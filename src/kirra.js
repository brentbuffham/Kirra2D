//=================================================
// IMPORTS
//=================================================
import { Delaunay } from "d3-delaunay";
import Delaunator from "delaunator";
import Triangle from "triangle-wasm";
import earcut from "earcut";
import Constrainautor from "@kninnug/constrainautor";
import DxfParser from "dxf-data-parser";
import Swal from "sweetalert2";
window.Swal = Swal; // Expose to window for dialog modules
import Plotly from "plotly.js-dist";
import Papa from "papaparse";
import CryptoJS from "crypto-js";
import * as turf from "@turf/turf";
import { polygonCentroid } from "d3-polygon";
import ClipperLib from "clipper-lib";
import { fromUrl, fromArrayBuffer } from "geotiff";
import proj4 from "proj4";
import printJS from "print-js";
import { jsPDF } from "jspdf";
import html2canvas from "html2canvas";
import pdfMake from "pdfmake/build/pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";
import { evaluate } from "mathjs";
//=================================================
// Three.js Rendering System
//=================================================
import * as THREE from "three";
import { ThreeRenderer } from "./three/ThreeRenderer.js";
import { CameraControls } from "./three/CameraControls.js";
import { GeometryFactory, clearTextCache } from "./three/GeometryFactory.js";
import { InteractionManager } from "./three/InteractionManager.js";
import { PolygonSelection3D } from "./three/PolygonSelection3D.js";
// Troika text optimization - configure builder and preload font for optimal performance
// import { configureTextBuilder, preloadFont } from "troika-three-text";
// import { Text } from "troika-three-text";
// OBJ/MTL Loaders for textured mesh import
import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
//=================================================
// Drawing Modules
//=================================================
import {
	clearThreeJS,
	renderThreeJS,
	drawHoleThreeJS,
	drawHoleToeThreeJS,
	drawHoleTextThreeJS,
	drawHoleTextsAndConnectorsThreeJS,
	drawKADPointThreeJS,
	drawKADLineSegmentThreeJS,
	drawKADPolygonSegmentThreeJS,
	drawKADBatchedPolylineThreeJS,
	drawKADSuperBatchedPointsThreeJS,
	drawKADSuperBatchedCirclesThreeJS,
	drawKADCircleThreeJS,
	drawKADTextThreeJS,
	drawSurfaceThreeJS,
	drawContoursThreeJS,
	drawDirectionArrowsThreeJS,
	drawBackgroundImageThreeJS,
	drawConnectorThreeJS,
	highlightSelectedHoleThreeJS,
	highlightSelectedKADPointThreeJS,
	drawToolPromptThreeJS,
	drawConnectStadiumZoneThreeJS,
	drawMousePositionIndicatorThreeJS,
	drawSlopeMapThreeJS,
	drawBurdenReliefMapThreeJS,
	drawVoronoiCellsThreeJS,
	drawKADLeadingLineThreeJS,
	clearKADLeadingLineThreeJS,
	drawRulerThreeJS,
	clearRulerThreeJS,
	drawProtractorThreeJS,
	clearProtractorThreeJS,
} from "./draw/canvas3DDrawing.js";
import { clearCanvas, drawText, drawRightAlignedText, drawMultilineText, drawTrack, drawHoleToe, drawHole, drawDummy, drawNoDiameterHole, drawHiHole, drawExplosion, drawHexagon, drawKADPoints, drawKADLines, drawKADPolys, drawKADCircles, drawKADTexts, drawDirectionArrow, drawArrow, drawArrowDelayText } from "./draw/canvas2DDrawing.js";
import { drawKADHighlightSelectionVisuals } from "./draw/canvas2DDrawSelection.js";
import { highlightSelectedKADThreeJS } from "./draw/canvas3DDrawSelection.js";
//=================================================
// BUG FIX 6: Uncommented FloatingDialog module import (duplicate code removed)
import { FloatingDialog, createFormContent, createEnhancedFormContent, getFormData, showConfirmationDialog, showConfirmationThreeDialog, showModalMessage } from "./dialog/FloatingDialog.js";
// TreeView Module
import { TreeView, initializeTreeView } from "./dialog/tree/TreeView.js";
//=================================================
// Dialog Modules - Converted to ES Modules for Vite bundling 2025-12-26
// These are imported as side-effect imports - the modules set window globals
// This avoids duplicate identifier errors with functions already in kirra.js
//=================================================
import "./dialog/contextMenu/HolesContextMenu.js";
import "./dialog/contextMenu/KADContextMenu.js";
import "./dialog/contextMenu/SurfacesContextMenu.js";
import "./dialog/contextMenu/ImagesContextMenu.js";
import "./dialog/contextMenu/ContextMenuManager.js";
import "./dialog/settings/ThreeDSettingsDialog.js";
import "./dialog/popups/confirm/ConfirmDialogs.js";
import "./dialog/popups/error/ErrorDialogs.js";
import "./dialog/popups/info/InfoDialogs.js";
import "./dialog/popups/generic/PatternGenerationDialogs.js";
import "./dialog/popups/generic/AddHoleDialog.js";
import "./dialog/popups/generic/HolePropertyDialogs.js";
import "./dialog/popups/generic/ExportDialogs.js";
import "./dialog/popups/generic/KADDialogs.js";
import "./dialog/popups/generic/SurfaceAssignmentDialogs.js";
//=================================================
// Overlay System - Unified UI overlay for status, selection, coordinates
//=================================================
import {
	initHUD,
	OverlayEventBus,
	OverlayEvents,
	// Status panel
	showStatusMessage,
	showSelectionMessage,
	clearStatus,
	// Stats panel
	emitStats,
	emitCoords,
	emitCentroid,
	emitRuler,
	emitProtractor,
	// Legend panels
	showSlopeLegend,
	showReliefLegend,
	showVoronoiLegend,
	showSurfaceLegend as showSurfaceElevationLegend,
	hideSlopeLegend,
	hideReliefLegend,
	hideSurfaceLegend as hideSurfaceElevationLegend,
	hideVoronoiLegend,
	hideLegend,
	// Ruler panel
	showRulerPanel,
	hideRulerPanel,
	// Protractor panel
	showProtractorPanel,
	hideProtractorPanel,
	// Drawing distance panel
	showDrawingDistance,
	hideDrawingDistance,
	// Pattern tool panel
	showPatternToolLabels,
	hidePatternToolLabels,
	// Tooltip panel
	showHoleTooltip,
	showPointTooltip,
	hideTooltipPanel
} from "./overlay/index.js";
//=================================================
import ToolbarPanel, { showToolbar } from "./toolbar/ToolbarPanel.js";
//=================================================
// Print and Statistics Modules
//=================================================
import { getBlastStatisticsPerEntity } from "./helpers/BlastStatistics.js";
import { printMode, printOrientation, printPaperSize, isPrinting, paperRatios, printCanvas, printCtx, togglePrintMode, getPrintBoundary, drawPrintBoundary, printCanvasHiRes, printToPDF, setupPrintEventHandlers, remove3DPrintBoundaryOverlay } from "./print/PrintSystem.js";
import {
	drawDataForPrinting,
	drawCompleteBlastDataForPrint,
	printData,
	printVoronoiMetric,
	printBlastBoundary,
	printKADPoints,
	printKADLines,
	printKADPolys,
	printKADCircles,
	printKADTexts,
	printTrack,
	printHoleToe,
	printHole,
	printDummy,
	printNoDiameterHole,
	printHiHole,
	printText,
	printRightAlignedText,
	printMultilineText,
	printDirectionArrow,
	printArrow,
	printArrowDelayText,
	printDelauanySlopeMap,
	printDelauanyBurdenRelief,
	printReliefLegend,
	printTriangleAngleText,
	printTriangleBurdenReliefText,
	printLegend,
	printVoronoiLegendAndCells,
	printHoleTextsAndConnectors,
	printHoleMainShape,
	printSurface,
	printSurfaceLegend,
	printTriangleWithGradient,
	printBackgroundImage,
} from "./print/PrintRendering.js";
import { printHeader, printFooter, printBlastStats, printBlastStatsSimple } from "./print/PrintStats.js";

//=================================================
// END IMPORTS
//=================================================

// Description: This file contains the main functions for the Kirra App
// Author: Brent Buffham
// Last Modified: "20250816.0140AWST"
const buildVersion = "202601023.0000AWST"; //Backwards Compatible Date Format AWST = Australian Western Standard Time
window.buildVersion = buildVersion; // Expose to window for dialog modules

//=================================================
// SETUP JSCOLOR
// Set up jscolor configuration
jscolor.presets = jscolor.presets || {};
jscolor.presets.default = {
	format: "rgb",
	palette: [
		"#770000",
		"#FF0000",
		"#FF9900",
		"#FFFF00",
		"#00ff00",
		"#009900",
		"#00ffFF",
		"#0099ff",
		"#0000FF",
		"#FF00FF", //10 per row
		"#550000",
		"#AA0000",
		"#883300",
		"#bbbb00",
		"#33AA00",
		"#006600",
		"#007F7F",
		"#002288",
		"#000099",
		"#7F007F", //10 per row
		"#010101",
		"#222222",
		"#333333",
		"#444444",
		"#555555",
		"#777777",
		"#888888",
		"#AAAAAA",
		"#cccccc",
		"#FEFEFE",
	],
};

// Initialize jscolor after DOM is loaded
document.addEventListener("DOMContentLoaded", function () {
	jscolor.install();
});

// END SETUP JSCOLOR
//==============================================


// Separate function for Voronoi initialization
function initializeVoronoiControls() {
	const voronoiBoundarySwitch = document.getElementById("voronoiBoundarySwitch");
	if (voronoiBoundarySwitch) {
		voronoiBoundarySwitch.addEventListener("change", function () {
			useToeLocation = voronoiBoundarySwitch.checked;
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiMetricDropdown = document.getElementById("voronoiSelect");
	if (voronoiMetricDropdown) {
		voronoiMetricDropdown.addEventListener("change", function () {
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiLegendDropdown = document.getElementById("voronoiLegendSelect");
	if (voronoiLegendDropdown) {
		voronoiLegendDropdown.addEventListener("change", function () {
			isVoronoiLegendFixed = voronoiLegendDropdown.value === "fixed";
			drawData(allBlastHoles, selectedHole);
		});
	}
}

// Separate function for preferences initialization
function initializePreferences() {
	try {
		loadViewControlsSliderValues();
		fontSlider.value = 14; // force the font size.
		setupAutoSavePreferences();
		console.log("‚úÖ Preferences loaded successfully");
		debugPreferences();
	} catch (error) {
		console.error("? Error loading preferences:", error);
	}
}
// Add this temporarily to debug
function debugPreferences() {
	console.log("Checking preference controls:");
	console.log("fontSlider:", document.getElementById("fontSlider"));
	console.log("snapToleranceSlider:", document.getElementById("snapToleranceSlider"));
	console.log("elevation:", document.getElementById("elevation"));

	// Test localStorage
	console.log("LocalStorage test:", localStorage.getItem("fontSize"));
}

// Call this in your consolidated DOMContentLoaded
//------------------------------------------
const canvas = document.getElementById("canvas");
const padding = 10; // add 10 pixels of padding

const uiVersionElement = document.getElementById("htmlUIVersion");
const htmlUIVersion = uiVersionElement ? uiVersionElement.value : "1"; // Default to "1" if not found

//get the menu bar --var from the css
const menubarSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--menubar-size"));
const canvasBorderWidth2X = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-border")) * 2;
const canvasContainerMargin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-container-margin"));

// Existing canvas setup logic that you want to make conditional
if (htmlUIVersion === "1") {
	// Get the screen size and calculate the dimensions based on the desired ratio
	const screenWidth = window.innerWidth;
	const screenHeight = window.innerHeight;
	const canvasWidth = Math.round(screenWidth);
	const canvasHeight = Math.round(screenHeight);

	const canvasAdjustWidth = 40; //was 40 for kirra.html and styles.css;
	const canvasAdjustHeight = 0.12; //was 0.12 for kirra.html and styles.css;
	// Set the dimensions of the canvas and its container
	canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
	canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
} else {
	//Do nothing
}

const timeChartObject = document.getElementById("timeChart");
let statusMessage = "";
const resizeRight = document.getElementById("resizeHandleRight");
let isResizingRight = false;
const resizeLeft = document.getElementById("resizeHandleLeft");
let isResizingLeft = false;

//=================================================
// Step 1) Initialize Three.js Rendering System
//=================================================
let threeRenderer = null;
let cameraControls = null;
let interactionManager = null; // 3D raycasting and interaction manager
let threeInitialized = false;
let threeInitializationFailed = false; // Step 0a) Prevent retry storm if initialization fails
let onlyShowThreeJS = false; // Toggle to show only Three.js rendering
// let troikaFontBaked = false; // Step 0b) Track if Troika font SDF texture has been baked

// Step 1) Local coordinate offset for precision with large UTM coordinates
// Three.js uses these local coordinates (offset from origin) to avoid floating-point errors
let threeLocalOriginX = 0;
let threeLocalOriginY = 0;

// Step 1b) Track current rotation state (in radians)
let currentRotation = 0;

// Step 1c) Track Z centroid of all data for orbit center
let dataCentroidZ = 0;

// Step 2) Helper to convert world coordinates to local Three.js coordinates
function worldToThreeLocal(worldX, worldY) {
	return {
		x: worldX - threeLocalOriginX,
		y: worldY - threeLocalOriginY,
	};
}

// Step 2a) Helper to project 3D world position to 2D screen pixels (for selection and raycasting)
function worldToScreen(worldX, worldY, worldZ) {
	// Step 2a.1) Early return if Three.js not initialized
	if (!threeRenderer || !threeRenderer.camera || !threeRenderer.getCanvas()) {
		return null;
	}

	// Step 2a.2) Get canvas dimensions
	const canvas = threeRenderer.getCanvas();
	const rect = canvas.getBoundingClientRect();
	const canvasWidth = rect.width;
	const canvasHeight = rect.height;

	// Step 2a.3) Convert world to Three.js local coordinates
	const local = worldToThreeLocal(worldX, worldY);

	// Step 2a.4) Create vector and project to normalized device coordinates
	const vector = new THREE.Vector3(local.x, local.y, worldZ);
	vector.project(threeRenderer.camera);

	// Step 2a.5) Convert NDC (-1 to +1) to screen pixels (0 to width/height)
	const screenX = ((vector.x + 1) * canvasWidth) / 2;
	const screenY = ((-vector.y + 1) * canvasHeight) / 2; // Invert Y for screen coordinates

	return { x: screenX, y: screenY };
}

// Expose globals for canvas3DDrawing.js module
window.worldToThreeLocal = worldToThreeLocal;
window.worldToScreen = worldToScreen;
// Note: getSnapRadiusInWorldUnits3D exposed near its definition (line ~36617)

// Function to sync globals to window for module access
// Called before rendering to ensure all values are current
function exposeGlobalsToWindow() {
	// Step 1) Three.js globals
	window.threeInitialized = threeInitialized;
	window.threeRenderer = threeRenderer;
	window.dataCentroidZ = dataCentroidZ;
	window.threeLocalOriginX = threeLocalOriginX;
	window.threeLocalOriginY = threeLocalOriginY;

	// Step 2) 2D Canvas globals (ctx and canvas exposed at initialization)
	window.strokeColor = strokeColor;
	window.fillColor = fillColor;
	window.firstMovementSize = firstMovementSize;
	window.connScale = connScale;

	// Step 3) Shared globals
	window.holeScale = holeScale;
	window.currentScale = currentScale;
	window.darkModeEnabled = darkModeEnabled;
	window.currentFontSize = currentFontSize;
	window.textFillColor = textFillColor;
	window.depthColor = depthColor;
	window.angleDipColor = angleDipColor;
	window.snapRadiusPixels = snapRadiusPixels;

	// Step 4) Connector state (for stadium zone tracking)
	window.fromHoleStore = fromHoleStore;
	window.isAddingMultiConnector = isAddingMultiConnector;
	window.connectAmount = connectAmount;

	// Step 5) Helper functions
	window.elevationToColor = elevationToColor;
	window.rgbStringToThreeColor = rgbStringToThreeColor;
	window.worldToCanvas = worldToCanvas;

	// Step 6) Selection state for KAD and holes (for selection highlighting modules)
	// FIX: Preserve window.selectedKADObject if local variable is null but window already has a value
	// This prevents pattern tool selections from being cleared when exposeGlobalsToWindow() runs
	if (selectedKADObject !== null && selectedKADObject !== undefined) {
		window.selectedKADObject = selectedKADObject;
	} else if (window.selectedKADObject && (window.isPatternInPolygonActive || window.isHolesAlongPolyLineActive)) {
		// Preserve window.selectedKADObject for pattern tools even if local variable is null
		// This handles the case where drawData() calls exposeGlobalsToWindow() before the local variable is set
		// The local variable will be set by the click handler, but exposeGlobalsToWindow() runs first
	} else {
		window.selectedKADObject = selectedKADObject;
	}
	window.selectedKADPolygon = selectedKADPolygon;
	window.selectedMultipleKADObjects = selectedMultipleKADObjects;
	window.selectedHole = selectedHole;
	window.selectedMultipleHoles = selectedMultipleHoles;
	window.selectedPoint = selectedPoint; // CRITICAL: Expose selectedPoint for vertex highlighting
	window.selectedMultiplePoints = selectedMultiplePoints; // CRITICAL: Expose for multi-vertex highlighting
	window.isSelectionPointerActive = isSelectionPointerActive;
	window.allKADDrawingsMap = allKADDrawingsMap;
	window.isPatternInPolygonActive = isPatternInPolygonActive;
	window.isHolesAlongPolyLineActive = isHolesAlongPolyLineActive;
	window.getEntityFromKADObject = getEntityFromKADObject;
	window.developerModeEnabled = developerModeEnabled;
	// Step 6a) Expose radio buttons and helper functions for 3D polygon selection
	window.selectHolesRadio = selectHolesRadio;
	window.selectKADRadio = selectKADRadio;
	window.isHoleVisible = isHoleVisible;
	window.isEntityVisible = isEntityVisible;
	window.allBlastHoles = allBlastHoles;

	// Step 6b) Expose drawing functions for 3D polygon selection
	window.drawData = drawData;
	window.renderThreeJS = renderThreeJS;
	window.updateStatusMessage = updateStatusMessage;
	window.updateSelectionAveragesAndSliders = updateSelectionAveragesAndSliders;

	// Step 6c) Expose context menu functions for tree view and 3D interactions
	window.showSurfaceContextMenu = showSurfaceContextMenu;
	window.showImageContextMenu = showImageContextMenu;

	// Step 6d) Expose additional functions needed by ContextMenuManager
	window.getClickedHole = getClickedHole;
	window.getClickedKADObject = getClickedKADObject;
	window.getClickedKADObject3D = getClickedKADObject3D;
	window.getSnapToleranceInWorldUnits = getSnapToleranceInWorldUnits;
	window.canvasToWorld = canvasToWorld;
	window.isKADObjectSelected = isKADObjectSelected;
	window.isPointInSurface = isPointInSurface;
	window.isPointInBackgroundImage = isPointInBackgroundImage;
	window.loadedImages = loadedImages;
	window.loadedSurfaces = loadedSurfaces;
	window.debouncedUpdateTreeView = debouncedUpdateTreeView;
	window.clearCurrentDrawingEntity = clearCurrentDrawingEntity;
	window.addPointDraw = addPointDraw;
	window.addLineDraw = addLineDraw;
	window.addCircleDraw = addCircleDraw;
	window.addPolyDraw = addPolyDraw;
	window.addTextDraw = addTextDraw;
	window.onlyShowThreeJS = onlyShowThreeJS;
	window.cameraControls = cameraControls;
	window.interactionManager = interactionManager;
	window.isPolygonSelectionActive = isPolygonSelectionActive;

	// Step 6e) Expose state variables needed by context menus
	window.isDragging = isDragging;
	window.longPressTimeout = longPressTimeout;
	window.createNewEntity = createNewEntity;
	window.lastKADDrawPoint = lastKADDrawPoint;

	// Step 6f) ONLY expose functions that actually exist in kirra.js
	window.calculateHoleGeometry = calculateHoleGeometry;
	window.debouncedSaveHoles = debouncedSaveHoles;
	window.debouncedSaveKAD = debouncedSaveKAD;
	window.clearAllSelectionState = clearAllSelectionState;
	window.setSelectionFromTreeView = setSelectionFromTreeView; // CRITICAL: For TreeView to update selection
	window.openColorPickerForElement = openColorPickerForElement; // CRITICAL: For TreeView color swatch clicks
	window.setKADEntityVisibility = setKADEntityVisibility;
	window.endKadTools = endKadTools; // CRITICAL: Expose for ContextMenuManager right-click handling
	window.setSurfaceVisibility = setSurfaceVisibility;
	window.showSurfaceLegend = showSurfaceLegend;
	window.deleteSurfaceFromDB = deleteSurfaceFromDB;
	window.deleteAllSurfacesFromDB = deleteAllSurfacesFromDB;
	window.saveSurfaceToDB = saveSurfaceToDB;
	window.deleteImageFromDB = deleteImageFromDB;
	window.deleteAllImagesFromDB = deleteAllImagesFromDB;
}

// Step 3) Set local origin from first hole, surface, or current centroid
function updateThreeLocalOrigin() {
	// Priority 1: Use first hole if available
	if (allBlastHoles && allBlastHoles.length > 0) {
		threeLocalOriginX = allBlastHoles[0].startXLocation;
		threeLocalOriginY = allBlastHoles[0].startYLocation;
		console.log("üìç Three.js local origin set from first hole:", threeLocalOriginX, threeLocalOriginY);
		return;
	}

	// Priority 2: Use first surface point if available (including textured meshes)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			// Check for standard surface points
			if (surface.points && surface.points.length > 0) {
				threeLocalOriginX = surface.points[0].x;
				threeLocalOriginY = surface.points[0].y;
				console.log("üìç Three.js local origin set from surface points:", surfaceId, "->", threeLocalOriginX, threeLocalOriginY);
				return;
			}
			// Check for textured mesh bounds (OBJ files)
			if (surface.isTexturedMesh && surface.meshBounds) {
				threeLocalOriginX = (surface.meshBounds.minX + surface.meshBounds.maxX) / 2;
				threeLocalOriginY = (surface.meshBounds.minY + surface.meshBounds.maxY) / 2;
				console.log("üìç Three.js local origin set from textured mesh center:", surfaceId, "->", threeLocalOriginX, threeLocalOriginY);
				return;
			}
		}
	}

	// Priority 3: Fallback to current centroid
	if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined") {
		threeLocalOriginX = centroidX;
		threeLocalOriginY = centroidY;
		console.log("üìç Three.js local origin set to centroid:", threeLocalOriginX, threeLocalOriginY);
	}
}

// Step 4) Calculate XYZ centroid of all data for orbit center and grid positioning
// Note: X/Y and Z are calculated with separate counts to avoid Z values (small elevation numbers)
// diluting the X/Y centroid calculation
function calculateDataCentroid() {
	let sumX = 0,
		sumY = 0,
		sumZ = 0;
	let countXY = 0;
	let countZ = 0;

	// Step 4a) Add hole values - X/Y from collar only, Z from collar/grade/toe
	// Note: parseFloat ensures string values are converted to numbers
	if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
		for (const hole of allBlastHoles) {
			if (hole && typeof hole === "object") {
				// X/Y: Only use collar position (startX/Y) to avoid zeros from grade/toe
				sumX += parseFloat(hole.startXLocation) || 0;
				sumY += parseFloat(hole.startYLocation) || 0;
				countXY++;

				// Z: Use all three elevations (collar, grade, toe) for better Z average
				sumZ += parseFloat(hole.startZLocation) || 0;
				countZ++;
				if (hole.gradeZLocation) {
					sumZ += parseFloat(hole.gradeZLocation) || 0;
					countZ++;
				}
				if (hole.endZLocation) {
					sumZ += parseFloat(hole.endZLocation) || 0;
					countZ++;
				}
			}
		}
	}

	// Step 4b) Add surface XYZ values if available
	if (typeof loadedSurfaces !== "undefined" && loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface && surface.triangles && Array.isArray(surface.triangles) && surface.triangles.length > 0) {
				// Step 4b.1) Standard surface with triangles - Z only
				for (const tri of surface.triangles) {
					if (tri) {
						sumZ += parseFloat(tri.minZ) || 0;
						sumZ += parseFloat(tri.maxZ) || 0;
						countZ += 2;
					}
				}
			} else if (surface && surface.isTexturedMesh && surface.meshBounds) {
				// Step 4b.2) Textured mesh (OBJ) - use mesh center for XY, bounds for Z
				sumX += (parseFloat(surface.meshBounds.minX) || 0) + (parseFloat(surface.meshBounds.maxX) || 0);
				sumY += (parseFloat(surface.meshBounds.minY) || 0) + (parseFloat(surface.meshBounds.maxY) || 0);
				countXY += 2;
				sumZ += parseFloat(surface.meshBounds.minZ) || 0;
				sumZ += parseFloat(surface.meshBounds.maxZ) || 0;
				countZ += 2;
			}
		}
	}
	// Step 4c) Add KAD drawing XYZ values if available
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			if (entity && entity.data && Array.isArray(entity.data) && entity.data.length > 0) {
				for (const point of entity.data) {
					if (point && typeof point === "object") {
						sumX += parseFloat(point.pointXLocation) || 0;
						sumY += parseFloat(point.pointYLocation) || 0;
						countXY++;
						if (point.pointZLocation) {
							sumZ += parseFloat(point.pointZLocation) || 0;
							countZ++;
						}
					}
				}
			}
		}
	}
	return {
		x: countXY > 0 ? sumX / countXY : 0,
		y: countXY > 0 ? sumY / countXY : 0,
		z: countZ > 0 ? sumZ / countZ : 0,
	};
}

// Step 5) Calculate Z centroid only (for backward compatibility)
function calculateDataZCentroid() {
	const centroid = calculateDataCentroid();
	return centroid.z;
}

function initializeThreeJS() {
	if (threeInitialized) return;

	// Step 0a) Prevent retry storm - if initialization failed once, don't retry on every mouse move
	if (threeInitializationFailed) {
		return;
	}

	// Step 1) Check if canvas exists
	if (!canvas) {
		console.warn("‚ö†Ô∏è Canvas not ready yet, deferring Three.js initialization");
		return;
	}

	try {
		console.log("üé¨ Initializing Three.js rendering system...");

		// Step 1a) Load 3D settings (guard against function not being defined yet)
		const settings = typeof load3DSettings === "function" ? load3DSettings() : {};

		// Step 2) Create Three.js renderer
		const canvasContainer = canvas.parentElement;

		if (!canvasContainer) {
			console.error("‚ùå Canvas container not found");
			return;
		}
		threeRenderer = new ThreeRenderer(canvasContainer, canvas.clientWidth, canvas.clientHeight);

		// Step 2a) Optimize Troika font rendering for optimal performance (one-time, shared by all text)
		// This configures optimal SDF settings and preloads all glyphs into Troika's shared atlas.
		// This must happen before creating any Text instances
		//await optimizeTroikaFont();//Didn't work well enough

		// Step 2b) Apply lighting settings
		if (settings.lightBearing !== undefined && settings.lightElevation !== undefined) {
			threeRenderer.updateLighting(settings.lightBearing, settings.lightElevation);
		}
		if (settings.ambientLightIntensity !== undefined) {
			threeRenderer.updateAmbientLightIntensity(settings.ambientLightIntensity);
		}
		if (settings.directionalLightIntensity !== undefined) {
			threeRenderer.updateDirectionalLightIntensity(settings.directionalLightIntensity);
		}
		if (settings.shadowIntensity !== undefined) {
			threeRenderer.updateShadowIntensity(settings.shadowIntensity);
		}

		// Step 2b) Apply clipping plane settings
		if (settings.clippingNear !== undefined && settings.clippingFar !== undefined) {
			threeRenderer.updateClippingPlanes(settings.clippingNear, settings.clippingFar);
		}
		if (settings.showClippingPlane !== undefined) {
			threeRenderer.setClippingPlaneVisualization(settings.showClippingPlane);
		}

		// Step 2c) Apply grid settings
		if (settings.showGrid !== undefined) {
			threeRenderer.setGridVisible(settings.showGrid);
		}
		if (settings.gridSize !== undefined) {
			threeRenderer.updateGridSize(settings.gridSize);
		}
		if (settings.gridOpacity !== undefined) {
			threeRenderer.updateGridOpacity(settings.gridOpacity);
		}

		// Step 2d) Apply cursor opacity
		if (settings.cursorOpacity !== undefined) {
			window.cursorOpacity3D = settings.cursorOpacity;
		}

		// Step 2a) Create base canvas for background color (bottom layer)
		const baseCanvas = document.createElement("canvas");
		baseCanvas.id = "baseCanvas";
		baseCanvas.width = canvas.clientWidth;
		baseCanvas.height = canvas.clientHeight;
		baseCanvas.style.position = "absolute";
		baseCanvas.style.top = "0";
		baseCanvas.style.left = "0";
		baseCanvas.style.width = "100%";
		baseCanvas.style.height = "100%";
		baseCanvas.style.pointerEvents = "none"; // No interaction, just background
		baseCanvas.style.zIndex = "0"; // Bottom layer

		// Step 2b) Set base canvas color based on dark mode
		const baseCtx = baseCanvas.getContext("2d");
		baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
		baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

		// Step 2c) Insert base canvas first
		canvasContainer.insertBefore(baseCanvas, canvas);

		// Step 2d) Store reference for later updates
		window.baseCanvas = baseCanvas;
		window.baseCtx = baseCtx;

		// Step 3) Insert Three.js canvas after base canvas
		const threeCanvas = threeRenderer.getCanvas();
		threeCanvas.id = "threeCanvas";
		threeCanvas.style.position = "absolute";
		threeCanvas.style.top = "0";
		threeCanvas.style.left = "0";
		threeCanvas.style.width = "100%";
		threeCanvas.style.height = "100%";
		threeCanvas.style.pointerEvents = "auto";
		threeCanvas.style.zIndex = "1";

		// Step 4) Insert before 2D canvas (but after base canvas)
		canvasContainer.insertBefore(threeCanvas, canvas);

		// Step 5) Update 2D canvas to be transparent overlay
		canvas.style.zIndex = "2";
		// IMPORTANT: Keep pointer-events AUTO so 2D canvas still works!
		// Three.js will render behind, 2D canvas renders on top
		canvas.style.pointerEvents = "auto";
		canvas.style.setProperty("background-color", "transparent", "important"); // Override CSS
		canvas.style.border = "none"; // Remove border for cleaner look

		// Step 5b) Ensure toggle buttons are above both canvases
		const toggleButtonsContainer = document.querySelector(".toggle-buttons-container");
		if (toggleButtonsContainer) {
			toggleButtonsContainer.style.zIndex = "10"; // Above both canvases
			console.log("üìç Set toggle buttons z-index to 10");
		}

		// Step 6) Create unified camera controls
		cameraControls = new CameraControls(threeRenderer, canvas);

		// Step 6a) Apply unified camera settings
		const cameraSettings = {
			gizmoDisplay: settings.gizmoDisplay || "only_when_orbit_or_rotate",
			axisLock: settings.axisLock || "none",
			dampingFactor: settings.dampingFactor || 0.05,
		};
		cameraControls.updateSettings(cameraSettings);

		// Step 6a.1) START ANIMATION LOOP IMMEDIATELY for smooth 3D rendering
		// This ensures the scene renders continuously even without user interaction
		// Fixes QUIRK 1: Jerkiness on startup until user drags 2D then returns to 3D
		if (cameraControls.animationFrameId === null) {
			cameraControls.animationFrameId = requestAnimationFrame(cameraControls.animate);
			console.log("üì∑ Started CameraControls animation loop for smooth 3D rendering");
		}

		// Step 6b) Set gizmo display mode
		if (settings.gizmoDisplay !== undefined) {
			cameraControls.setGizmoDisplayMode(settings.gizmoDisplay);
		}

		// Step 6c) Set axis lock mode
		if (settings.axisLock !== undefined) {
			cameraControls.setAxisLock(settings.axisLock);
		}

		cameraControls.attachEvents();

		// Step 6d) Set callback for camera changes to update pattern tool labels
		cameraControls.onCameraChange = function() {
			if (isPatternInPolygonActive) {
				drawPatternInPolygon3DVisual(); // Updates HUD label positions via worldToScreen()
			}
			if (isHolesAlongLineActive) {
				drawHolesAlongLine3DVisual();
			}
			if (isHolesAlongPolyLineActive) {
				drawHolesAlongPolyline3DVisual();
			}
		};

		// Step 6a) Create interaction manager for 3D raycasting
		interactionManager = new InteractionManager(threeRenderer, threeRenderer.camera);
		window.interactionManager = interactionManager; // Expose globally

		// Step 6b) Expose globals to window immediately after initialization
		// This ensures mouse tracking works from the start
		exposeGlobalsToWindow();

		// Step 7) Override camera controls to sync with 2D overlay
		const originalHandleWheel = cameraControls.handleWheel.bind(cameraControls);
		cameraControls.handleWheel = function (event) {
			const result = originalHandleWheel(event);
			if (result) {
				syncCameraFromThreeJS(result);
			}
			return result;
		};

		const originalHandleMouseMove = cameraControls.handleMouseMove.bind(cameraControls);
		cameraControls.handleMouseMove = function (event) {
			const result = originalHandleMouseMove(event);
			if (result) {
				syncCameraFromThreeJS(cameraControls.getCameraState());
			}
			return result;
		};

		// Step 8) Test square removed - Three.js is working!

		// Step 8b) Initialize camera with current state (use local coordinates)
		if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && typeof currentScale !== "undefined") {
			const localCentroid = worldToThreeLocal(centroidX, centroidY);
			// Initialize with default top-down view (rotation=0, orbitX=0, orbitY=0)
			cameraControls.setCameraState(localCentroid.x, localCentroid.y, currentScale, 0, 0, 0);
			console.log("üì∑ Camera initialized - World:", centroidX.toFixed(2), centroidY.toFixed(2), "Local:", localCentroid.x.toFixed(2), localCentroid.y.toFixed(2), "Scale:", currentScale);
		}

		// Step 9) Start render loop
		threeRenderer.startRenderLoop();

		// Step 10) Set initial background color based on current dark mode
		threeRenderer.setBackgroundColor(darkModeEnabled);
		console.log("üé® Three.js background set to", darkModeEnabled ? "black" : "white");

		// Step 10a) Also update base canvas background on initialization
		if (window.baseCanvas && window.baseCtx) {
			window.baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
			window.baseCtx.fillRect(0, 0, window.baseCanvas.width, window.baseCanvas.height);
			console.log("üé® Base canvas background set to", darkModeEnabled ? "black" : "white");
		}

		// Step 10b) Set threeInitialized to true BEFORE setting up event handlers
		threeInitialized = true;

		// Step 10b) Setup 3D mouse event handlers for independent 3D selection
		setup3DMouseEvents();

		console.log("‚úÖ Three.js rendering system initialized");

		// Step 10c) Update LineMaterial resolution for any fat lines on initial render
		if (typeof updateAllLineMaterialResolution === "function") {
			updateAllLineMaterialResolution();
		}

		// Step 10d) If data was already loaded, redraw it now that 3D is ready
		if (allBlastHoles && allBlastHoles.length > 0) {
			console.log("üé® Redrawing existing data in 3D...");
			drawData(allBlastHoles, selectedHole);
		}
	} catch (error) {
		console.error("‚ùå Failed to initialize Three.js:", error);
		threeInitialized = false;
		threeInitializationFailed = true; // Step 0b) Mark failure to prevent retry storm

		// Step 0c) Use centralized cleanup function to ensure all resources are cleaned up
		cleanupAllResources();

		// Step 0c.1) CRITICAL: Restore failure flag after cleanup (cleanup resets it, but we need to prevent retry storm)
		threeInitializationFailed = true;

		// Step 0d) Show user-friendly error message
		console.error("‚ùå WebGL initialization failed. This may be caused by:");
		console.error("  - Browser WebGL context limit exhausted (refresh page)");
		console.error("  - GPU/graphics driver issues");
		console.error("  - Too many browser tabs with WebGL content");
		console.error("  - Outdated graphics drivers");
	}
}

// Step 9) Sync camera state FROM Three.js TO 2D variables
// This updates 2D variables when user interacts with Three.js camera
function syncCameraFromThreeJS(cameraState) {
	if (cameraState) {
		// Convert local coordinates back to world
		centroidX = cameraState.centroidX + threeLocalOriginX;
		centroidY = cameraState.centroidY + threeLocalOriginY;
		currentScale = cameraState.scale;

		// Preserve rotation state
		if (cameraState.rotation !== undefined) {
			currentRotation = cameraState.rotation;
		}

		// Note: orbitX and orbitY are not synced to 2D (2D doesn't support orbit)
		// They remain in CameraControls state only
	}
}

// Step 9b) Sync camera state FROM 2D TO Three.js
// This is used only for initialization and fit-to-view operations (not ongoing updates)
function syncCameraToThreeJS() {
	if (threeInitialized && cameraControls) {
		const localCentroid = worldToThreeLocal(centroidX, centroidY);
		cameraControls.setCameraState(localCentroid.x, localCentroid.y, currentScale, currentRotation || 0, cameraControls.orbitX || 0, cameraControls.orbitY || 0);
		console.log("üì∑ Synced camera TO Three.js - World:", centroidX.toFixed(2), centroidY.toFixed(2), "Local:", localCentroid.x.toFixed(2), localCentroid.y.toFixed(2), "Scale:", currentScale);

		// After camera sync, redraw mouse indicator at current position (or camera center)
		// This ensures the grey torus stays visible after camera changes
		if (onlyShowThreeJS && threeRenderer && interactionManager) {
			setTimeout(() => {
				const threeCanvas = threeRenderer.getCanvas();
				if (threeCanvas) {
					// Get current mouse position or canvas center
					const rect = threeCanvas.getBoundingClientRect();
					const centerX = rect.left + rect.width / 2;
					const centerY = rect.top + rect.height / 2;

					// Trigger mousemove event to recalculate and redraw mouse indicator
					const syntheticEvent = new MouseEvent("mousemove", {
						bubbles: true,
						cancelable: true,
						clientX: centerX,
						clientY: centerY,
						button: 0,
						buttons: 0,
					});

					document.dispatchEvent(syntheticEvent);
				}
			}, 50); // Small delay to ensure camera state is fully updated
		}
	}
}

//=================================================
// End Three.js Initialization
// Note: initializeThreeJS() is called from drawData() when canvas is ready
//=================================================

// Step 11) Setup 3D mouse event handlers for independent 3D selection
function setup3DMouseEvents() {
	if (!threeRenderer) {
		if (developerModeEnabled) {
			console.warn("üö® [3D EVENTS] threeRenderer not ready");
		}
		return;
	}

	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) {
		if (developerModeEnabled) {
			console.warn("üö® [3D EVENTS] No 3D canvas found");
		}
		return;
	}

	// Step 11a) Get container (same as camera controls) to ensure events are received
	const container = threeCanvas.parentElement;
	if (!container) {
		console.warn("üö® [3D EVENTS] Could not find container for 3D mouse events");
		return;
	}

	if (developerModeEnabled) {
		console.log("üëÇ [3D EVENTS] Setting up event listeners on container:", container);
	}

	// Step 11b) Attach event handlers
	// IMPORTANT: Use capture phase for click to run before camera controls
	// IMPORTANT: Use DOCUMENT for mousemove to track mouse even when it leaves canvas (for stadium zone)
	container.addEventListener("click", handle3DClick, true); // Capture phase for selection priority
	container.addEventListener("contextmenu", window.handle3DContextMenu, true); // Capture phase for context menu
	document.addEventListener("mousemove", handle3DMouseMove, false); // Document-wide to track all mouse movement
	container.addEventListener("touchstart", handle3DTouchStart, { passive: false, capture: true });
	container.addEventListener("touchend", handle3DTouchEnd, { passive: false, capture: true });
	container.addEventListener("touchmove", handle3DTouchMove, { passive: false, capture: true });

	if (developerModeEnabled) {
		console.log("üëã [3D EVENTS] 3D mouse event handlers attached", {
			container: container.tagName,
			containerId: container.id,
			containerClass: container.className,
			mouseMoveTarget: "document (for full tracking)",
		});
	}
}

// Step 12) Handle 3D click - independent 3D selection using raycasting
// Using click instead of mousedown ensures it only fires after a full click (not during drag)
// Simplified pattern matching Three.js examples - works at any camera orientation
function handle3DClick(event) {
	if (developerModeEnabled) {
		console.log("üî´ [3D CLICK] Event fired", {
			onlyShowThreeJS,
			threeInitialized: !!threeInitialized,
			threeRenderer: !!threeRenderer,
			allBlastHoles: !!allBlastHoles,
			allBlastHolesLength: allBlastHoles ? allBlastHoles.length : 0,
			clientX: event.clientX,
			clientY: event.clientY,
			button: event.button,
			altKey: event.altKey,
			ctrlKey: event.ctrlKey,
			metaKey: event.metaKey,
		});
	}

	// Step 12a) Only handle if in 3D mode (onlyShowThreeJS flag determines mode)
	if (!onlyShowThreeJS) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] Not in 3D mode - onlyShowThreeJS =", onlyShowThreeJS);
		}
		// 2D mode is active, don't handle 3D selection
		return;
	}

	// Step 12a.0) Skip if we just finished dragging (prevents re-selection after mouseup)
	if (justFinishedDragging) {
		console.log("üèÅ [3D CLICK] Just finished dragging - skipping selection to prevent re-highlight");
		return;
	}

	// Step 12a.1) Skip if polygon selection tool is active
	const polygonToolCheckbox = document.getElementById("selectByPolygon");
	if (polygonToolCheckbox && polygonToolCheckbox.checked) {
		console.log("üî∂ [3D CLICK] Polygon selection tool active - skipping raycast selection");
		return;
	}

	// Step 12b) Skip if modifier keys are held (let camera controls handle orbit/rotate)
	// Alt = orbit, Ctrl/Cmd = rotate, Right-click = rotate
	if (event.altKey || event.metaKey || event.ctrlKey || event.button === 2) {
		console.log("ü§å [3D CLICK] Modifier keys held - skipping selection (3D arrow icon)");
		// Let camera controls handle these
		return;
	}

	// Step 12c) Early return if dependencies not ready
	// Note: allBlastHoles is NOT required - KAD objects can be selected without holes
	if (!threeInitialized || !threeRenderer) {
		console.log("üö® [3D CLICK] Dependencies not ready", {
			threeInitialized: !!threeInitialized,
			threeRenderer: !!threeRenderer,
		});
		return;
	}

	// Step 12c.1) Handle KAD drawing tools AND hole creation tools in 3D mode
	// Check if any drawing tool or hole creation tool is active and forward to appropriate handler
	// BUG FIX 2025-12-28: Added all hole/pattern creation tools to enable in 3D
	const isAnyDrawingToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole || isAddingPattern || isPatternInPolygonActive || isHolesAlongLineActive || isHolesAlongPolyLineActive;
	if (isAnyDrawingToolActive) {
		console.log("‚¨áÔ∏è [3D CLICK] Drawing/creation tool active, forwarding to handler");

		// Step 12c.1a) Get world coordinates using 3D cylindrical snap
		let snapResult;

		// Calculate snap radius in world units based on camera view
		const snapRadiusPixels = window.snapRadiusPixels || 15; // 15 pixels on screen
		const snapRadiusWorld = getSnapRadiusInWorldUnits3D(snapRadiusPixels);

		// Step 12c.1a.0) Get drawing elevation Z value
		var clickWorldZ = parseFloat(drawingZValue) || parseFloat(document.getElementById("drawingElevation").value) || 0;

		// Step 12c.1a.1) Calculate world coordinates using plane intersection at drawing elevation
		// This works correctly regardless of camera angle
		var clickWorldX = currentMouseWorldX;
		var clickWorldY = currentMouseWorldY;

		if (interactionManager && threeRenderer) {
			// Update raycaster to click position
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Step 12c.1a.2) Intersect ray with horizontal plane at drawing elevation
			// Use getMouseWorldPositionOnPlane which handles all camera angles correctly
			var planeWorldPos = interactionManager.getMouseWorldPositionOnPlane(clickWorldZ);
			if (planeWorldPos && isFinite(planeWorldPos.x) && isFinite(planeWorldPos.y)) {
				clickWorldX = planeWorldPos.x;
				clickWorldY = planeWorldPos.y;
				console.log("‚¨áÔ∏è [3D CLICK] Plane intersection at Z=" + clickWorldZ + ": X=" + clickWorldX.toFixed(2) + ", Y=" + clickWorldY.toFixed(2));
			} else {
				console.warn("‚¨áÔ∏è [3D CLICK] Plane intersection failed, using currentMouseWorld");
			}
		}

		// Step 12c.1a.3) Try cylindrical snap to nearby points
		if (interactionManager && interactionManager.raycaster) {
			// Get ray from raycaster (already set above)
			const ray = interactionManager.raycaster.ray;
			snapResult = snapToNearestPointWithRay(ray.origin, ray.direction, snapRadiusWorld);
		} else {
			// Fallback to 2D snap (shouldn't happen in 3D mode, but safe fallback)
			snapResult = snapToNearestPoint(clickWorldX, clickWorldY, snapRadiusWorld);
		}

		// Use snap result if available, otherwise use plane intersection coordinates
		worldX = snapResult.snapped && snapResult.worldX !== undefined ? snapResult.worldX : clickWorldX;
		worldY = snapResult.snapped && snapResult.worldY !== undefined ? snapResult.worldY : clickWorldY;
		worldZ = snapResult.snapped && snapResult.worldZ !== undefined ? snapResult.worldZ : clickWorldZ;

		// Step 12c.1b) Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(function () {
				updateStatusMessage("");
			}, 1500);
		}

		// Step 12c.1c) Call appropriate KAD drawing function based on active tool
		if (isDrawingPoint) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Point at:", worldX, worldY, worldZ);
			}
			addKADPoint();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingLine) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Line point at:", worldX, worldY, worldZ);
			}
			addKADLine();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingPoly) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Polygon point at:", worldX, worldY, worldZ);
			}
			addKADPoly();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingCircle) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Circle at:", worldX, worldY, worldZ);
			}
			addKADCircle();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingText) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Text at:", worldX, worldY, worldZ);
			}
			addKADText();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isAddingHole) {
			// Step 12c.1c.1) Handle Add Hole tool in 3D mode (BUG FIX 2025-12-28, 2025-12-29)
			console.log("‚¨áÔ∏è [3D CLICK] Adding Hole at:", worldX, worldY, worldZ);
			// Set world coordinates for AddHoleDialog to access
			window.worldX = worldX;
			window.worldY = worldY;
			window.worldZ = worldZ;
			// Step 12c.1c.1a) Check if we're in multiple mode (have stored form data)
			// This matches the 2D behavior at line ~17954
			if (window.isAddingSingleHole && window.multipleAddHoleFormData) {
				// Multiple mode: Reuse stored form data, don't show dialog
				console.log("üìçüìç [3D] Multiple mode: Reusing stored form data");
				if (typeof window.addHoleMultipleMode === "function") {
					window.addHoleMultipleMode(worldX, worldY);
				} else {
					console.error("addHoleMultipleMode function not found");
					// Fallback to showing dialog
					if (typeof window.showAddHoleDialog === "function") {
						window.showAddHoleDialog();
					}
				}
			} else {
				// Single mode or first click: Show dialog
				if (typeof window.showAddHoleDialog === "function") {
					window.showAddHoleDialog();
				} else {
					console.error("showAddHoleDialog not found - ensure AddHoleDialog.js is loaded");
				}
			}
		} else if (isAddingPattern) {
			// Step 12c.1c.2) Handle Add Pattern tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Adding Pattern at:", worldX, worldY, worldZ);
			// Set world coordinates for pattern creation
			window.worldX = worldX;
			window.worldY = worldY;
			window.worldZ = worldZ;
			// Show the pattern dialog using showPatternDialog from PatternGenerationDialogs.js
			if (typeof window.showPatternDialog === "function") {
				window.showPatternDialog("add_pattern", worldX, worldY);
			} else {
				console.error("showPatternDialog not found - ensure PatternGenerationDialogs.js is loaded");
			}
		} else if (isPatternInPolygonActive) {
			// Step 12c.1c.3) Handle Pattern in Polygon tool in 3D mode
			console.log("‚¨áÔ∏è [3D CLICK] Pattern in Polygon click at:", worldX, worldY, worldZ);
			
			// Step 12c.1c.3a) For polygon selection (step 0), use 3D raycast to find KAD polygon
			if (patternPolygonStep === 0) {
				// Perform raycast to find KAD objects
				const threeCanvas = threeRenderer.getCanvas();
				if (!threeCanvas || !interactionManager) {
					console.warn("‚¨áÔ∏è [3D CLICK] Pattern tool: Missing threeCanvas or interactionManager");
					return;
				}
				interactionManager.updateMousePosition(event, threeCanvas);
				const intersects = interactionManager.raycast();
				
				let clickedKADObject = null;
				// Search intersects for KAD polygon objects
				for (const intersect of intersects) {
					let object = intersect.object;
					
					// Skip selection highlights
					let isHighlight = false;
					let checkObj = object;
					let depth = 0;
					while (checkObj && depth < 10) {
						if (checkObj.userData && checkObj.userData.type === "kadSelectionHighlight") {
							isHighlight = true;
							break;
						}
						checkObj = checkObj.parent;
						depth++;
					}
					if (isHighlight) continue;
					
					// Traverse up to find KAD polygon
					depth = 0;
					while (object && depth < 10) {
						if (object.userData && object.userData.kadId && object.userData.type === "kadPolygon") {
							const entity = allKADDrawingsMap.get(object.userData.kadId);
							if (entity && entity.entityType === "poly") {
								// Found polygon - create KAD object descriptor
								clickedKADObject = {
									entityName: object.userData.kadId,
									entity: entity,
									entityType: "poly"
								};
								break;
							}
						}
						object = object.parent;
						depth++;
					}
					if (clickedKADObject) break;
				}
				
				// If polygon found, set selection state
				if (clickedKADObject) {
					selectedPolygon = clickedKADObject.entity;
					// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
					selectedKADObject = clickedKADObject;
					window.selectedKADObject = clickedKADObject;
					patternPolygonStep = 1;
					updateStatusMessage("Step 2: Click to select pattern start point");

					// FIX: Ensure highlight is drawn by calling drawData and then explicitly calling highlight function
					drawData(allBlastHoles, selectedHole);
					// Explicitly trigger highlight after drawData to ensure it runs
					if (window.selectedKADObject && window.selectedKADObject.entityType === "poly") {
						highlightSelectedKADThreeJS();
					}
					event.preventDefault();
					event.stopPropagation();
					return;
				} else {
					updateStatusMessage("No polygon found.\nStep 1: Click on a polygon to select it");
					drawData(allBlastHoles, selectedHole);
					event.preventDefault();
					event.stopPropagation();
					return;
				}
			} else {
				// For steps 1-3 (point selection), use snapping same as 2D
				var rect = canvas.getBoundingClientRect();
				var canvasCoords = worldToCanvas(worldX, worldY);
				var clickX = canvasCoords[0];
				var clickY = canvasCoords[1];

				// Step 1) Apply same snapping as 2D tools (snaps to KAD entities, holes, grid, etc.)
				var patternSnapResult = canvasToWorldWithSnap(clickX, clickY);
				var snappedWorldX = patternSnapResult.worldX;
				var snappedWorldY = patternSnapResult.worldY;

				// Step 2) Show snap feedback if snapped (same as 2D)
				if (patternSnapResult.snapped) {
					updateStatusMessage("Snapped to " + patternSnapResult.snapTarget.description);
					setTimeout(() => updateStatusMessage(""), 1500);
				}

				// Step 3) Set snapped coordinates for handler
				window.worldX = snappedWorldX;
				window.worldY = snappedWorldY;
				window.worldZ = worldZ;

				// Step 4) Create synthetic event with canvas coordinates (handler will re-apply snap, but coordinates already snapped)
				var syntheticEvent = {
					clientX: rect.left + clickX,
					clientY: rect.top + clickY,
					preventDefault: function () { },
					stopPropagation: function () { }
				};
				if (typeof handlePatternInPolygonClick === "function") {
					handlePatternInPolygonClick(syntheticEvent);
				}
			}
		} else if (isHolesAlongLineActive) {
			// Step 12c.1c.4) Handle Holes Along Line tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Holes Along Line click at:", worldX, worldY, worldZ);
			// Use snapping same as 2D
			var rect = canvas.getBoundingClientRect();
			var canvasCoords = worldToCanvas(worldX, worldY);
			var clickX = canvasCoords[0];
			var clickY = canvasCoords[1];

			// Step 1) Apply same snapping as 2D tools (snaps to KAD entities, holes, grid, etc.)
			const snapResult = canvasToWorldWithSnap(clickX, clickY);
			var snappedWorldX = snapResult.worldX;
			var snappedWorldY = snapResult.worldY;

			// Step 2) Show snap feedback if snapped (same as 2D)
			if (snapResult.snapped) {
				updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
				setTimeout(() => updateStatusMessage(""), 1500);
			}

			// Step 3) Set snapped coordinates for handler
			window.worldX = snappedWorldX;
			window.worldY = snappedWorldY;
			window.worldZ = worldZ;

			// Step 4) Create synthetic event with canvas coordinates for the 2D handler
			var syntheticEvent = {
				clientX: rect.left + clickX,
				clientY: rect.top + clickY,
				preventDefault: function () { },
				stopPropagation: function () { }
			};
			// Call the existing handler
			if (typeof handleHolesAlongLineClick === "function") {
				handleHolesAlongLineClick(syntheticEvent);
			}
		} else if (isHolesAlongPolyLineActive) {
			// Step 12c.1c.5) Handle Holes Along Polyline tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Holes Along Polyline click at:", worldX, worldY, worldZ);
			// Use snapping same as 2D
			var rect = canvas.getBoundingClientRect();
			var canvasCoords = worldToCanvas(worldX, worldY);
			var clickX = canvasCoords[0];
			var clickY = canvasCoords[1];

			// Step 1) Apply same snapping as 2D tools (snaps to KAD entities, holes, grid, etc.)
			const snapResult = canvasToWorldWithSnap(clickX, clickY);
			var snappedWorldX = snapResult.worldX;
			var snappedWorldY = snapResult.worldY;

			// Step 2) Show snap feedback if snapped (same as 2D)
			if (snapResult.snapped) {
				updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
				setTimeout(() => updateStatusMessage(""), 1500);
			}

			// Step 3) Set snapped coordinates for handler
			window.worldX = snappedWorldX;
			window.worldY = snappedWorldY;
			window.worldZ = worldZ;

			// Step 4) Create synthetic event with canvas coordinates for the 2D handler
			var syntheticEvent = {
				clientX: rect.left + clickX,
				clientY: rect.top + clickY,
				preventDefault: function () { },
				stopPropagation: function () { }
			};
			// Call the existing handler
			if (typeof handleHolesAlongPolyLineClick === "function") {
				handleHolesAlongPolyLineClick(syntheticEvent);
			}
		}

		// Step 12c.1d) Prevent default and stop propagation
		event.preventDefault();
		event.stopPropagation();

		// Step 12c.1e) Redraw to show new KAD object
		drawData(allBlastHoles, selectedHole);
		return; // Don't process as selection click
	}

	// Step 12c.2) Handle Ruler tool in 3D mode
	if (isRulerActive) {
		console.log("üìè [3D CLICK] Ruler tool active, handling 3D ruler click");

		// Step 12c.2a) Get world coordinates from click using plane intersection
		var rulerClickX = currentMouseWorldX;
		var rulerClickY = currentMouseWorldY;
		var rulerClickZ = currentMouseWorldZ || window.dataCentroidZ || 0;

		// Step 12c.2b) Calculate coordinates using plane intersection (works at any camera angle)
		if (interactionManager && threeRenderer) {
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Intersect with horizontal plane at data centroid Z
			var rulerPlanePos = interactionManager.getMouseWorldPositionOnPlane(rulerClickZ);
			if (rulerPlanePos && isFinite(rulerPlanePos.x) && isFinite(rulerPlanePos.y)) {
				rulerClickX = rulerPlanePos.x;
				rulerClickY = rulerPlanePos.y;
			}
		}

		// Step 12c.2c) Apply 3D snap if available
		if (interactionManager && interactionManager.raycaster) {
			var rulerSnapRadius = getSnapRadiusInWorldUnits3D(window.snapRadiusPixels || 15);
			var rulerSnapResult = snapToNearestPointWithRay(interactionManager.raycaster.ray.origin, interactionManager.raycaster.ray.direction, rulerSnapRadius);
			if (rulerSnapResult.snapped) {
				rulerClickX = rulerSnapResult.worldX;
				rulerClickY = rulerSnapResult.worldY;
				rulerClickZ = rulerSnapResult.worldZ || rulerClickZ;
				updateStatusMessage("Snapped to " + rulerSnapResult.snapTarget.description);
				setTimeout(function () { updateStatusMessage(""); }, 1500);
			}
		}

		// Step 12c.2d) Handle ruler click logic (same as 2D)
		if (!rulerStartPoint) {
			rulerStartPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
			rulerEndPoint = null;
		} else if (!rulerEndPoint) {
			rulerEndPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
		} else {
			rulerStartPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
			rulerEndPoint = null;
		}

		event.preventDefault();
		event.stopPropagation();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Step 12c.3) Handle Protractor tool in 3D mode
	if (isRulerProtractorActive) {
		console.log("üìê [3D CLICK] Protractor tool active, handling 3D protractor click");

		// Step 12c.3a) Get world coordinates from click using plane intersection
		var protClickX = currentMouseWorldX;
		var protClickY = currentMouseWorldY;
		var protClickZ = currentMouseWorldZ || window.dataCentroidZ || 0;

		// Step 12c.3b) Calculate coordinates using plane intersection (works at any camera angle)
		if (interactionManager && threeRenderer) {
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Intersect with horizontal plane at data centroid Z
			var protPlanePos = interactionManager.getMouseWorldPositionOnPlane(protClickZ);
			if (protPlanePos && isFinite(protPlanePos.x) && isFinite(protPlanePos.y)) {
				protClickX = protPlanePos.x;
				protClickY = protPlanePos.y;
			}
		}

		// Step 12c.3c) Apply 3D snap if available
		if (interactionManager && interactionManager.raycaster) {
			var protSnapRadius = getSnapRadiusInWorldUnits3D(window.snapRadiusPixels || 15);
			var protSnapResult = snapToNearestPointWithRay(interactionManager.raycaster.ray.origin, interactionManager.raycaster.ray.direction, protSnapRadius);
			if (protSnapResult.snapped) {
				protClickX = protSnapResult.worldX;
				protClickY = protSnapResult.worldY;
				protClickZ = protSnapResult.worldZ || protClickZ;
				updateStatusMessage("Snapped to " + protSnapResult.snapTarget.description);
				setTimeout(function () { updateStatusMessage(""); }, 1500);
			}
		}

		// Step 12c.3d) Handle protractor click logic (same as 2D)
		rulerProtractorPoints.push({ x: protClickX, y: protClickY, z: protClickZ });
		if (rulerProtractorPoints.length > 3) {
			rulerProtractorPoints = [{ x: protClickX, y: protClickY, z: protClickZ }];
		}

		event.preventDefault();
		event.stopPropagation();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Step 12d) Get 3D canvas for coordinate conversion
	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] No 3D canvas found");
		}
		return;
	}

	// Step 12e) Update mouse position in interaction manager and perform raycast
	// Use interactionManager which has the proper logic for finding holes
	if (!interactionManager) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] interactionManager not available");
		}
		return;
	}

	interactionManager.updateMousePosition(event, threeCanvas);

	// Step 12f) Perform raycast
	const intersects = interactionManager.raycast();

	if (developerModeEnabled) {
		console.log("üîç [3D CLICK] Raycast results:", {
			intersectsCount: intersects.length,
			firstIntersect:
				intersects.length > 0
					? {
						object: intersects[0].object.type,
						userData: intersects[0].object.userData,
						distance: intersects[0].distance.toFixed(2),
					}
					: null,
		});
	}

	// Step 12g) Find clicked hole from intersects using interactionManager's method
	// This has proper logic for traversing parent chains and finding the correct hole
	// But let's also log what we're checking to debug why it always finds hole 1
	if (developerModeEnabled) {
		console.log("üîç [3D CLICK] Checking", intersects.length, "intersections for holes...");
	}
	for (let i = 0; i < Math.min(intersects.length, 5); i++) {
		const intersect = intersects[i];
		let object = intersect.object;
		let userData = object.userData;
		let depth = 0;

		// Traverse up to find userData
		while (object && (!userData || !userData.holeId)) {
			object = object.parent;
			if (object) {
				userData = object.userData;
				depth++;
				if (depth > 5) break;
			} else {
				break;
			}
		}
	}

	// Step 12h.5) Check radio button selection mode (Holes vs KAD) - matching 2D behavior
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	// Step 12h.5a) Only allow selection if SelectPointer tool, Move tool, or connector tool is active
	// Fixes QUIRK 2: Prevent selection when no tool is active
	const isConnectorToolActive = isAddingConnector || isAddingMultiConnector;
	if (!isSelectionPointerActive && !isConnectorToolActive && !isMultiHoleSelectionEnabled && !isMoveToolActive) {
		if (developerModeEnabled) {
			console.log("üö´ [3D CLICK] Select Pointer tool not active - skipping selection");
		}
		return;
	}

	const clickedHole = selectingHoles ? interactionManager.findClickedHole(intersects, allBlastHoles || []) : null;

	if (clickedHole) {
		if (developerModeEnabled) {
			console.log("üîç [3D CLICK] Found hole:", clickedHole.holeID, "in", clickedHole.entityName);
		}
	} else if (selectingHoles) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] No hole found in intersections");
		}
	}

	// Step 12i) Handle selection based on current tool mode
	if (clickedHole && selectingHoles) {
		if (developerModeEnabled) {
			console.log("‚¨áÔ∏è [3D CLICK] Processing selection for hole:", clickedHole.holeID);
		}
		console.log("üîç [3D CLICK] Current tool state:", {
			isAddingConnector,
			isAddingMultiConnector,
			isMultiHoleSelectionEnabled,
			selectedHoleBefore: selectedHole ? selectedHole.holeID : null,
			selectedMultipleHolesBefore: selectedMultipleHoles.length,
		});

		// Prevent camera controls from handling this event
		event.stopPropagation();
		event.preventDefault();

		if (isAddingConnector) {
			// Step 12i.1) Single connector tool logic in 3D (matching 2D handleConnectorClick)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Single connector tool mode");
			}
			if (!fromHoleStore) {
				// Step 12i.1a) First hole selection
				fromHoleStore = clickedHole;
				firstSelectedHole = clickedHole;
				selectedHole = clickedHole;
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set first connector hole:", clickedHole.holeID);
				}
				// Step 12i.1a.1) Immediately render to show green highlight
				drawData(allBlastHoles, selectedHole);
				//renderThreeJS();
			} else {
				// Step 12i.1b) Second hole selection - create connector
				selectedHole = clickedHole; // Set selected hole to second hole for yellow highlight
				secondSelectedHole = clickedHole; // IMPORTANT: Set this for highlighting
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set second connector hole:", clickedHole.holeID);
				}

				// Step 12i.1c) Get delay and color values
				const delay = getDelayValue();
				const color = getJSColorHex();

				// Step 12i.1d) Find clicked hole in allBlastHoles array
				const clickedHoleIndex = allBlastHoles.findIndex((h) => h === clickedHole);

				if (clickedHoleIndex !== -1) {
					// Step 12i.1e) Set connector data (matching 2D format)
					allBlastHoles[clickedHoleIndex].fromHoleID = fromHoleStore.entityName + ":::" + fromHoleStore.holeID;
					allBlastHoles[clickedHoleIndex].timingDelayMilliseconds = delay;
					allBlastHoles[clickedHoleIndex].colorHexDecimal = color;
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Created connector:", fromHoleStore.holeID, "?", clickedHole.holeID, "delay:", delay, "color:", color);
					}
				}

				// Step 12i.1f) Reset connector state - green disappears, only yellow persists from selectedHole
				fromHoleStore = null;
				firstSelectedHole = null;
				// NOTE: secondSelectedHole and selectedHole remain set to show yellow highlight

				// Step 12i.1g) Recalculate timing and contours
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step 12i.1g.1) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Step 12i.1g.2) Save connector changes to IndexedDB
				debouncedSaveHoles();

				// Step 12i.1h) Update time chart
				timeChart();

				// Step 12i.1i) Draw - only yellow highlight visible now
				drawData(allBlastHoles, selectedHole);
			}
		} else if (isAddingMultiConnector) {
			// Step 12i.2) Multi-connector tool logic in 3D (matching 2D handleConnectorClick)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Multi-connector tool mode");
			}
			if (!fromHoleStore) {
				// Step 12i.2a) First hole selection - clear previous yellow highlight
				secondSelectedHole = null; // Clear old yellow
				fromHoleStore = clickedHole;
				firstSelectedHole = clickedHole;
				selectedHole = clickedHole;
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set first multi-connector hole:", clickedHole.holeID);
				}

				// Step 12i.2a.1) Ensure globals are exposed and trigger redraw
				exposeGlobalsToWindow();
				drawData(allBlastHoles, selectedHole);
			} else {
				// Step 12i.2b) Second hole selection - create connectors
				selectedHole = clickedHole; // Set selected hole to second hole for yellow highlight
				secondSelectedHole = clickedHole; // IMPORTANT: Set this for highlighting
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set second multi-connector hole:", clickedHole.holeID);
				}

				// Step 12i.2c) Get all holes in stadium zone (line with tolerance)
				const pointsInLine = getPointsInLine(fromHoleStore, clickedHole);

				if (pointsInLine.length > 0) {
					// Step 12i.2d) Connect all holes in sequence
					connectHolesInLine(pointsInLine);
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Connected " + pointsInLine.length + " holes in line");
					}
				}

				// Step 12i.2e) Reset connector state - green disappears, only yellow persists from selectedHole
				// Step 12i.2e) Reset connector state - green disappears, only yellow persists from selectedHole
				fromHoleStore = null;
				firstSelectedHole = null;
				// NOTE: secondSelectedHole and selectedHole remain set to show yellow highlight

				// Step 12i.2f) Recalculate timing and contours
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step 12i.2f.1) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Step 12i.2f.2) Save multi-connector changes to IndexedDB
				debouncedSaveHoles();

				// Step 12i.2g) Update time chart
				timeChart();

				// Step 12i.2h) Draw - only yellow highlight visible now
				drawData(allBlastHoles, selectedHole);
			}
		} else if (isMultiHoleSelectionEnabled) {
			// Multi-selection mode
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Multi-selection mode");
			}
			const index = selectedMultipleHoles.findIndex((h) => h.entityName === clickedHole.entityName && h.holeID === clickedHole.holeID);
			if (index >= 0) {
				selectedMultipleHoles.splice(index, 1);
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Removed from multi-selection. New count:", selectedMultipleHoles.length);
				}
			} else {
				selectedMultipleHoles.push(clickedHole);
				if (developerModeEnabled) {
					console.log(
						"‚¨áÔ∏è [3D CLICK] Added to multi-selection. New count:",
						selectedMultipleHoles.length,
						"Holes:",
						selectedMultipleHoles.map((h) => h.holeID)
					);
				}
			}
			selectedHole = null; // Clear single selection
		} else {
			// Single selection mode (SelectionPointer tool)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Single selection mode (SelectionPointer)");
			}
			const previousSelectedHole = selectedHole ? selectedHole.holeID : null;
			selectedHole = clickedHole;
			selectedMultipleHoles = [];
			// Step 12i.3a) Clear KAD selections when hole is selected (matching 2D behavior)
			selectedKADObject = null;
			selectedKADPolygon = null;
			selectedMultipleKADObjects = [];
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] SELECTED HOLE:", {
					previous: previousSelectedHole,
					current: selectedHole.holeID,
					entityName: selectedHole.entityName,
					selectedHoleObject: selectedHole,
				});
			}
		}

		// Redraw to show selection (ONLY for non-connector modes)
		// Connector modes handle their own drawData calls with proper timing
		if (!isAddingConnector && !isAddingMultiConnector) {
			console.log("‚¨áÔ∏è [3D CLICK] Calling drawData with selectedHole:", selectedHole ? selectedHole.holeID : null);
			drawData(allBlastHoles, selectedHole);
			syncCanvasToTreeView(); // Sync selection to TreeView
		}
	} else {
		if (developerModeEnabled) {
			// Step 12j) No hole clicked - check for KAD objects in 3D
			console.log("‚¨áÔ∏è [3D CLICK] No hole found, checking for KAD objects...");
			console.log("‚¨áÔ∏è [3D CLICK] Total intersects:", intersects.length);
			console.log("‚¨áÔ∏è [3D CLICK] Selection pointer active?", isSelectionPointerActive);
			console.log("‚¨áÔ∏è [3D CLICK] KAD entities in map:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
		}
		if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
			const entityTypes = [];
			allKADDrawingsMap.forEach((entity, name) => {
				entityTypes.push(name + " (" + entity.entityType + ")");
			});
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Entity list:", entityTypes.join(", "));
			}
		}

		// Step 12j.0) Debug: Log all intersect types
		intersects.forEach((intersect, index) => {
			let obj = intersect.object;
			let types = [];
			let depth = 0;
			while (obj && depth < 5) {
				if (obj.userData && obj.userData.type) {
					types.push(obj.userData.type);
				}
				obj = obj.parent;
				depth++;
			}
			if (developerModeEnabled) {
				console.log("  Intersect " + index + ":", intersect.object.type, "types in chain:", types.join(" -> "));
			}
		});

		// Step 12j.1) Check if selection pointer is active and KAD radio is selected
		if (isSelectionPointerActive && selectingKAD) {
			let clickedKADObject = null;

			// Step 12j.2) Search intersects for KAD objects (they have userData.kadId)
			// Skip selection highlights and look for actual KAD geometry
			for (const intersect of intersects) {
				let object = intersect.object;

				// Step 12j.3) Skip if this intersect is a selection highlight
				// Check immediate object and parents
				let isHighlight = false;
				let checkObj = object;
				let depth = 0;
				while (checkObj && depth < 10) {
					if (checkObj.userData && checkObj.userData.type === "kadSelectionHighlight") {
						isHighlight = true;
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Skipping selection highlight at depth", depth);
						}
						break;
					}
					checkObj = checkObj.parent;
					depth++;
				}

				// Step 12j.4) If this was a highlight, skip to next intersect
				if (isHighlight) {
					continue;
				}

				// Step 12j.5) Now traverse up to find actual KAD object
				depth = 0;
				while (object && depth < 10) {
					// Step 12j.5a) Check for actual KAD objects (kadPoint, kadLine, kadPolygon, kadCircle, kadText)
					if (object.userData && object.userData.kadId && object.userData.type && (object.userData.type === "kadPoint" || object.userData.type === "kadLine" || object.userData.type === "kadPolygon" || object.userData.type === "kadCircle" || object.userData.type === "kadText")) {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Found KAD object:", object.userData.kadId, "type:", object.userData.type);
						}

						// Step 12j.4) Get the KAD entity from the map
						const entity = allKADDrawingsMap.get(object.userData.kadId);
						if (entity) {
							// Step 12j.5) Find which specific element was clicked
							// Use intersection point to determine closest element
							let closestElementIndex = 0;
							let minDistance = Infinity;

							if (entity.data && entity.data.length > 1 && intersect.point) {
								// Convert intersection point from local to world coordinates
								const intersectWorldX = intersect.point.x + (window.threeLocalOriginX || 0);
								const intersectWorldY = intersect.point.y + (window.threeLocalOriginY || 0);

								// Find closest element by distance
								entity.data.forEach((element, index) => {
									const elemX = element.pointXLocation || element.centerX;
									const elemY = element.pointYLocation || element.centerY;
									const dx = elemX - intersectWorldX;
									const dy = elemY - intersectWorldY;
									const distance = Math.sqrt(dx * dx + dy * dy);

									if (distance < minDistance) {
										minDistance = distance;
										closestElementIndex = index;
									}
								});

								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Found closest element:", closestElementIndex, "at distance:", minDistance.toFixed(2) + "m");
								}
							}

							// Step 12j.6) Create KAD object descriptor (similar to 2D getClickedKADObject)
							// Step 12j.6a) Determine selectionType based on entity type and distance to vertex
							// Points are always "vertex", lines/polys are "vertex" if close enough, else "segment"
							var selectionType = "entity";
							var vertexSnapDistance = 5; // meters - threshold for vertex vs segment selection

							if (entity.entityType === "point") {
								selectionType = "vertex"; // Points are always vertex selection
							} else if ((entity.entityType === "line" || entity.entityType === "poly") && minDistance < vertexSnapDistance) {
								selectionType = "vertex"; // Close to a vertex
							} else if (entity.entityType === "line" || entity.entityType === "poly") {
								selectionType = "segment"; // On a segment between vertices
							}

							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] selectionType:", selectionType, "(minDistance:", minDistance.toFixed(2) + "m, threshold:", vertexSnapDistance + "m)");
							}

							clickedKADObject = {
								entityName: object.userData.kadId,
								entityType: entity.entityType,
								elementIndex: closestElementIndex, // Use calculated closest element
								selectionType: selectionType, // vertex, segment, or entity based on distance
							};

							// Step 12j.7) Add type-specific properties from the clicked element
							if (entity.data && entity.data[closestElementIndex]) {
								const clickedElement = entity.data[closestElementIndex];
								if (entity.entityType === "circle") {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation || clickedElement.centerX;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation || clickedElement.centerY;
									clickedKADObject.radius = clickedElement.radius;
								} else if (entity.entityType === "text") {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation;
									clickedKADObject.text = clickedElement.text;
								} else {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation;
								}
							}
							break;
						}
					}
					object = object.parent;
					depth++;
				}

				if (clickedKADObject) break;
			}

			// Step 12j.6.5) If no raycast hit, try screen-space distance-based selection (fallback)
			if (!clickedKADObject && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] No raycast hit, trying screen-space distance selection...");
				}

				// Step 12j.6.5a) Get camera and canvas for screen-space projection
				const camera = threeRenderer.camera;
				const canvas = threeRenderer.getCanvas();
				if (!camera || !canvas) {
					if (developerModeEnabled) {
						console.log("üì∑ [3D CLICK] Missing camera or canvas for screen-space selection");
					}
				} else {
					// Step 12j.6.5b) Get mouse position in screen pixels
					const rect = canvas.getBoundingClientRect();
					const mouseScreenX = event.clientX - rect.left;
					const mouseScreenY = event.clientY - rect.top;
					const canvasWidth = rect.width;
					const canvasHeight = rect.height;

					// Step 12j.6.5c) Snap tolerance in pixels (use snapRadiusPixels directly)
					const snapTolerancePixels = snapRadiusPixels || 20;
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Mouse at (" + mouseScreenX.toFixed(0) + "px, " + mouseScreenY.toFixed(0) + "px), tolerance: " + snapTolerancePixels + "px");
					}
					// Step 12j.6.5d) Helper function to project 3D world position to 2D screen pixels
					const worldToScreen = function (worldX, worldY, worldZ) {
						// Step 12j.6.5d.1) Convert world to Three.js local coordinates
						const local = worldToThreeLocal(worldX, worldY);

						// Step 12j.6.5d.2) Create vector and project to normalized device coordinates
						const vector = new THREE.Vector3(local.x, local.y, worldZ);
						vector.project(camera);

						// Step 12j.6.5d.3) Convert NDC (-1 to +1) to screen pixels (0 to width/height)
						const screenX = ((vector.x + 1) * canvasWidth) / 2;
						const screenY = ((-vector.y + 1) * canvasHeight) / 2; // Invert Y for screen coordinates

						return { x: screenX, y: screenY };
					};

					// Step 12j.6.5e) Helper function to calculate distance from point to line segment in 2D screen space
					const screenPointToSegmentDistance = function (px, py, x1, y1, x2, y2) {
						const A = px - x1;
						const B = py - y1;
						const C = x2 - x1;
						const D = y2 - y1;
						const dot = A * C + B * D;
						const lenSq = C * C + D * D;

						if (lenSq === 0) {
							return Math.sqrt(A * A + B * B);
						}

						let t = dot / lenSq;
						t = Math.max(0, Math.min(1, t));

						const projX = x1 + t * C;
						const projY = y1 + t * D;
						const dx = px - projX;
						const dy = py - projY;

						return Math.sqrt(dx * dx + dy * dy);
					};

					// Step 12j.6.5f) Search all KAD entities for closest one within tolerance
					let closestEntity = null;
					let closestEntityName = null;
					let closestDistance = Infinity;
					let closestElementIndex = 0;

					allKADDrawingsMap.forEach((entity, entityName) => {
						if (!entity.data || entity.data.length === 0) return;

						// Step 12j.6.5g) Calculate screen-space distance based on entity type
						if (entity.entityType === "point") {
							// Step 12j.6.5g.1) Points: screen distance to each point
							entity.data.forEach((point, index) => {
								const screenPos = worldToScreen(point.pointXLocation, point.pointYLocation, point.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
								}
							});
						} else if (entity.entityType === "line" || entity.entityType === "poly") {
							// Step 12j.6.5g.2) Lines/Polys: screen distance to closest segment
							const points = entity.data;
							if (points.length >= 2) {
								const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D LINE SELECT] Checking " + entity.entityType + " '" + entity.entityName + "' with " + numSegments + " segments");
								}

								// Step 12j.6.5g.2a) Store segment info for proper highlighting
								let closestSegmentIndex = 0;
								let closestSegmentDistance = Infinity;

								for (let i = 0; i < numSegments; i++) {
									const p1 = points[i];
									const p2 = points[(i + 1) % points.length];

									// Project both endpoints to screen space
									const screen1 = worldToScreen(p1.pointXLocation, p1.pointYLocation, p1.pointZLocation || dataCentroidZ || 0);
									const screen2 = worldToScreen(p2.pointXLocation, p2.pointYLocation, p2.pointZLocation || dataCentroidZ || 0);

									// Calculate screen-space distance to segment
									const segmentDist = screenPointToSegmentDistance(mouseScreenX, mouseScreenY, screen1.x, screen1.y, screen2.x, screen2.y);

									if (developerModeEnabled) {
										console.log("  Segment " + i + ": p1=(" + screen1.x.toFixed(0) + "," + screen1.y.toFixed(0) + ") p2=(" + screen2.x.toFixed(0) + "," + screen2.y.toFixed(0) + ") dist=" + segmentDist.toFixed(1) + "px");
									}

									if (segmentDist < closestSegmentDistance) {
										closestSegmentDistance = segmentDist;
										closestSegmentIndex = i;
									}
								}

								// Step 12j.6.5g.2b) If closest segment is within tolerance, update closestEntity
								if (closestSegmentDistance < closestDistance) {
									closestDistance = closestSegmentDistance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = closestSegmentIndex; // Which segment was clicked
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D LINE SELECT] Closest segment:", closestSegmentIndex, "at distance:", closestSegmentDistance.toFixed(2) + "px");
									}
								}
							}
						} else if (entity.entityType === "circle") {
							// Step 12j.6.5g.3) Circles: screen distance to circle outline (approximate - use center for now)
							entity.data.forEach((circle, index) => {
								const centerX = circle.pointXLocation || circle.centerX;
								const centerY = circle.pointYLocation || circle.centerY;
								const centerZ = circle.pointZLocation || dataCentroidZ || 0;

								const screenCenter = worldToScreen(centerX, centerY, centerZ);
								const dx = screenCenter.x - mouseScreenX;
								const dy = screenCenter.y - mouseScreenY;
								const distToCenter = Math.sqrt(dx * dx + dy * dy);

								// Approximate: just use distance to center (could improve by projecting radius)
								const distance = distToCenter;

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D CIRCLE SELECT] Closest circle:", closestElementIndex, "at distance:", closestDistance.toFixed(2) + "px");
									}
								}
							});
						} else if (entity.entityType === "text") {
							// Step 12j.6.5g.4) Text: screen distance to text anchor point
							entity.data.forEach((text, index) => {
								const screenPos = worldToScreen(text.pointXLocation, text.pointYLocation, text.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D TEXT SELECT] Closest text:", closestElementIndex, "at distance:", closestDistance.toFixed(2) + "px");
									}
								}
							});
						}
					});

					// Step 12j.6.5h) Check if closest entity is within tolerance
					if (closestEntity && closestDistance <= snapTolerancePixels) {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Found entity by screen distance:", closestEntityName, "type:", closestEntity.entityType, "distance:", closestDistance.toFixed(1) + "px");
						}

						// Step 12j.6.5h.1) For lines/polys, check if we're closer to a vertex than the segment
						let closestVertexDistance = Infinity;
						let closestVertexIndex = -1;
						if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
							// Check each vertex to see if mouse is closer to it than to the segment
							closestEntity.data.forEach(function (point, index) {
								const screenPos = worldToScreen(point.pointXLocation, point.pointYLocation, point.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestVertexDistance) {
									closestVertexDistance = distance;
									closestVertexIndex = index;
								}
							});
						}

						// Step 12j.6.5i) Determine selection type (match 2D behavior)
						let selectionType = "entity";
						if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
							// Step 12j.6.5i.1) If vertex is significantly closer than segment, use vertex selection
							if (closestVertexDistance < closestDistance && closestVertexDistance <= snapTolerancePixels) {
								selectionType = "vertex";
								closestElementIndex = closestVertexIndex; // Update to use vertex index
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Vertex selection - closest vertex at distance:", closestVertexDistance.toFixed(1) + "px");
								}
							} else {
								selectionType = "segment"; // Lines/polys use segment selection
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Segment selection - distance:", closestDistance.toFixed(1) + "px");
								}
							}
						} else if (closestEntity.entityType === "point") {
							selectionType = "point";
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Point selection - distance:", closestDistance.toFixed(1) + "px");
							}
						}

						// Step 12j.6.5j) Create KAD object descriptor (match 2D structure)
						clickedKADObject = {
							entityName: closestEntityName,
							entityType: closestEntity.entityType,
							elementIndex: closestElementIndex,
							segmentIndex: closestElementIndex, // For lines/polys, this is the clicked segment
							selectionType: selectionType,
						};

						// Step 12j.6.5k) Add type-specific properties
						if (closestEntity.data && closestEntity.data[closestElementIndex]) {
							const clickedElement = closestEntity.data[closestElementIndex];
							if (closestEntity.entityType === "circle") {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation || clickedElement.centerX;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation || clickedElement.centerY;
								clickedKADObject.radius = clickedElement.radius;
							} else if (closestEntity.entityType === "text") {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
								clickedKADObject.text = clickedElement.text;
							} else if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
								// For lines/polys, use first point of segment as base
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
							} else {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
							}
						}
					} else {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Closest entity at " + closestDistance.toFixed(1) + "px (outside tolerance " + snapTolerancePixels + "px)");
						}
					}
				}
			}

			// Step 12j.7) Handle KAD object selection (matching 2D handleSelection logic)
			if (clickedKADObject) {
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Processing KAD selection:", clickedKADObject.entityName);
				}

				// Step 12j.8) Check for Shift key (multiple selection)
				const isShiftPressed = event.shiftKey;

				if (isShiftPressed) {
					// Step 12j.9) Multiple selection mode
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Multiple KAD selection mode (Shift pressed)");
					}
					const existingIndex = selectedMultipleKADObjects.findIndex((obj) => {
						return obj.entityName === clickedKADObject.entityName && obj.entityType === clickedKADObject.entityType;
					});

					if (existingIndex === -1) {
						// Add to multiple selection
						selectedMultipleKADObjects.push(clickedKADObject);
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Added to selection, total:", selectedMultipleKADObjects.length);
						}
					} else {
						// Remove from multiple selection
						selectedMultipleKADObjects.splice(existingIndex, 1);
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Removed from selection, total:", selectedMultipleKADObjects.length);
						}
					}

					// Clear single selection
					selectedKADObject = null;
					selectedKADPolygon = null;
					selectedPoint = null; // Clear selectedPoint in multi-selection mode
				} else {
					// Step 12j.10) Single selection mode
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Single KAD selection mode");
					}
					selectedKADObject = clickedKADObject;
					selectedKADPolygon = clickedKADObject; // Backward compatibility
					selectedMultipleKADObjects = [];

					// Step 12j.10a) Set selectedPoint - for segments, highlight the endpoint that will be deleted
					if (clickedKADObject.selectionType === "vertex") {
						const entity = allKADDrawingsMap.get(clickedKADObject.entityName);
						if (entity && entity.data && entity.data[clickedKADObject.elementIndex]) {
							selectedPoint = entity.data[clickedKADObject.elementIndex];
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Set selectedPoint:", selectedPoint.pointID);
							}
						}
					} else if (clickedKADObject.selectionType === "segment" && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
						const entity = allKADDrawingsMap.get(clickedKADObject.entityName);
						if (entity && entity.data) {
							const isPoly = clickedKADObject.entityType === "poly";
							const numPoints = entity.data.length;
							const endpointIndex = isPoly ? (clickedKADObject.elementIndex + 1) % numPoints : clickedKADObject.elementIndex + 1;
							selectedPoint = entity.data[endpointIndex];
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Set selectedPoint for segment endpoint:", selectedPoint.pointID);
							}
						}
					} else {
						selectedPoint = null;
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Cleared selectedPoint (entity selection)");
						}
					}
				}

				// Step 12j.11) Clear hole selections
				selectedHole = null;
				selectedMultipleHoles = [];

				// Step 12j.12) Expose globals and redraw
				exposeGlobalsToWindow();
				drawData(allBlastHoles || [], selectedHole);
				syncCanvasToTreeView(); // Sync KAD selection to TreeView

				// Prevent camera controls from handling this event
				event.stopPropagation();
				event.preventDefault();
			} else {
				// Step 12j.13) No KAD object clicked - clear KAD selections only if KAD radio is selected
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Clicked on empty space - clearing selections");
				}
				if (!isAddingConnector && !isAddingMultiConnector) {
					const previousSelectedHole = selectedHole ? selectedHole.holeID : null;
					const previousMultiCount = selectedMultipleHoles.length;
					const previousKADCount = selectedMultipleKADObjects.length;

					// Step 12j.13a) Clear selections based on radio button state (matching 2D behavior)
					if (selectingKAD) {
						selectedKADObject = null;
						selectedKADPolygon = null;
						selectedMultipleKADObjects = [];
					}
					if (selectingHoles && !isMultiHoleSelectionEnabled) {
						selectedHole = null;
						selectedMultipleHoles = [];
					}
					if (developerModeEnabled) {
						console.log("üßπ [3D CLICK] Cleared selections:", {
							selectingHoles,
							selectingKAD,
							previousSelectedHole,
							previousMultiCount,
							previousKADCount,
						});
					}

					exposeGlobalsToWindow();
					drawData(allBlastHoles || [], selectedHole);
					syncCanvasToTreeView(); // Sync cleared selection to TreeView
				}
			}
		} else if (isSelectionPointerActive && selectingHoles && !clickedHole) {
			// Step 12j.14) Selection pointer active with Holes radio, but no hole clicked - clear hole selections
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Selection pointer active (Holes mode), no hole clicked");
			}
			if (!isAddingConnector && !isAddingMultiConnector) {
				if (!isMultiHoleSelectionEnabled) {
					selectedHole = null;
					selectedMultipleHoles = [];
					exposeGlobalsToWindow();
					drawData(allBlastHoles || [], selectedHole);
				}
			}
		}
	}
}

// handle3DContextMenu now loaded from ContextMenuManager.js

// Step 13) Handle 3D mouse move - hover effects and stadium zone tracking
function handle3DMouseMove(event) {
	// Step 13a) Only handle if in 3D mode
	if (!onlyShowThreeJS) return;

	// Step 13b) Early return if dependencies not ready
	if (!threeInitialized || !threeRenderer || !interactionManager) {
		// Try to get interactionManager from window if not set locally
		if (!interactionManager && window.interactionManager) {
			interactionManager = window.interactionManager;
		}
		// Ensure globals are exposed (in case they weren't set up yet)
		if (threeInitialized && threeRenderer) {
			exposeGlobalsToWindow();
		}
		if (!threeInitialized || !threeRenderer || !interactionManager) return;
	}

	// Step 13c) Get 3D canvas
	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) return;

	// Step 13d) Update mouse position for raycasting
	interactionManager.updateMousePosition(event, threeCanvas);

	// Step 13e) Update hover state and get raytrace intersection for 3D tracking
	// Always raycast to get 3D position (even if no blast holes, we might hit surfaces/other objects)
	const intersects = interactionManager.raycast();

	// Only update hover state if we have blast holes
	if (allBlastHoles && allBlastHoles.length > 0) {
		interactionManager.updateHover(intersects, allBlastHoles);
	}

	// Step 13f) Calculate world coordinates for stadium zone tracking
	// Try to get 3D world position from raytrace intersection first
	let mouseWorldPos = null;
	if (intersects && intersects.length > 0) {
		// Step 13f.1) Use raytrace intersection to get full 3D world position
		mouseWorldPos = interactionManager.getWorldPosition(intersects);
		// Validate the result - if it has NaN values, treat as null
		if (mouseWorldPos && (!isFinite(mouseWorldPos.x) || !isFinite(mouseWorldPos.y) || !isFinite(mouseWorldPos.z))) {
			mouseWorldPos = null;
		}
	}

	// Step 13f.2) If no object intersection, use ground plane intersection for interaction
	if (!mouseWorldPos && interactionManager && typeof interactionManager.getMouseWorldPositionOnPlane === "function") {
		// Use plane intersection at fromHoleStore Z level, or dataCentroidZ, or 0
		const zLevel = fromHoleStore ? fromHoleStore.startZLocation || window.dataCentroidZ || 0 : window.dataCentroidZ || 0;
		mouseWorldPos = interactionManager.getMouseWorldPositionOnPlane(zLevel);
	}

	//=============================================================================
	// AGENT NOTE - DO NOT REVERT THIS TO getMouseWorldPositionOnPlane()
	//=============================================================================
	// The torus/cursor indicator MUST use getMouseWorldPositionOnViewPlane() which
	// calculates position on a plane PERPENDICULAR to the camera direction.
	// This allows the cursor to follow the view angle in 3D, not be stuck on XY.
	//
	// WRONG: getMouseWorldPositionOnPlane() - horizontal XY plane, cursor stuck
	// CORRECT: getMouseWorldPositionOnViewPlane() - perpendicular to camera view
	//
	// This has been incorrectly reverted multiple times. DO NOT CHANGE.
	//=============================================================================
	// Step 13f.2a) Calculate mouse position on view plane for torus indicator
	// This ensures torus is always visible at cursor location in 3D view
	let torusWorldPos = null;
	if (interactionManager && typeof interactionManager.getMouseWorldPositionOnViewPlane === "function") {
		torusWorldPos = interactionManager.getMouseWorldPositionOnViewPlane();
	}

	// Step 13f.3) Final fallback to camera projection if plane intersection fails
	if (!mouseWorldPos) {
		// Get mouse position in canvas coordinates
		const rect = threeCanvas.getBoundingClientRect();
		const mouseX = event.clientX - rect.left;
		const mouseY = event.clientY - rect.top;

		// Validate canvas dimensions
		if (!rect.width || !rect.height || rect.width <= 0 || rect.height <= 0) {
			console.warn("handle3DMouseMove: Invalid canvas dimensions", rect);
			return; // Can't calculate position without valid canvas
		}

		// Convert canvas coordinates to world coordinates using current camera state
		const camera = threeRenderer.camera;
		if (camera && camera.isOrthographicCamera) {
			// Step 13f.3.1) Get normalized device coordinates (-1 to +1)
			const ndcX = (mouseX / rect.width) * 2 - 1;
			const ndcY = -(mouseY / rect.height) * 2 + 1;

			// Step 13f.3.2) Calculate world position at Z=0 plane
			// Try to get camera state from CameraControls first, fallback to global centroidX/Y
			let worldCentroidX = null;
			let worldCentroidY = null;

			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				// CameraControls.centroidX/Y are in LOCAL coordinates (relative to threeLocalOrigin)
				// Need to convert to world coordinates
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				worldCentroidX = cameraState.centroidX + originX;
				worldCentroidY = cameraState.centroidY + originY;
			} else {
				// Fallback to global centroidX/Y variables (already in world coordinates)
				if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
					// Use global variables directly (they're already in world coordinates)
					worldCentroidX = centroidX;
					worldCentroidY = centroidY;
				} else {
					console.warn("handle3DMouseMove: No valid camera state or centroid available", {
						cameraState: cameraState,
						globalCentroidX: typeof centroidX !== "undefined" ? centroidX : "undefined",
						globalCentroidY: typeof centroidY !== "undefined" ? centroidY : "undefined",
					});
					return; // Can't calculate position without centroid
				}
			}

			// Step 13f.3.3) Calculate viewport dimensions and offsets
			const viewportWidth = camera.right - camera.left;
			const viewportHeight = camera.top - camera.bottom;

			// Validate viewport dimensions
			if (isFinite(viewportWidth) && isFinite(viewportHeight) && viewportWidth > 0 && viewportHeight > 0) {
				const offsetX = ndcX * (viewportWidth / 2);
				const offsetY = ndcY * (viewportHeight / 2);

				// Step 13f.3.4) Calculate world mouse position
				// worldCentroidX/Y are in WORLD coordinates, just add viewport offsets
				const worldX = worldCentroidX + offsetX;
				const worldY = worldCentroidY + offsetY;

				// Validate calculated coordinates
				if (isFinite(worldX) && isFinite(worldY)) {
					// Use fromHoleStore Z as fallback when no intersection
					const worldZ = fromHoleStore ? fromHoleStore.startZLocation || window.dataCentroidZ || 0 : window.dataCentroidZ || 0;

					mouseWorldPos = { x: worldX, y: worldY, z: worldZ };
				} else {
					console.warn("handle3DMouseMove: Calculated world coordinates are NaN", {
						worldCentroidX: worldCentroidX,
						worldCentroidY: worldCentroidY,
						offsetX: offsetX,
						offsetY: offsetY,
						worldX: worldX,
						worldY: worldY,
					});
				}
			} else {
				console.warn("handle3DMouseMove: Invalid viewport dimensions", {
					viewportWidth: viewportWidth,
					viewportHeight: viewportHeight,
				});
			}
		} else {
			console.warn("handle3DMouseMove: Camera not available or not orthographic", camera);
		}
	}

	// Step 13f.4) Apply 3D cylindrical snap if snapping enabled
	// This ensures cursor sphere and leading lines show snapped position during mouse move
	let snapResult = {
		snapped: false,
		snapTarget: null,
		worldX: mouseWorldPos ? mouseWorldPos.x : currentMouseWorldX,
		worldY: mouseWorldPos ? mouseWorldPos.y : currentMouseWorldY,
		worldZ: mouseWorldPos ? mouseWorldPos.z : currentMouseWorldZ,
	};

	if (snapEnabled && interactionManager && interactionManager.raycaster) {
		// Step 13f.4a) Calculate snap radius in world units
		const snapRadiusPixels = window.snapRadiusPixels || 15; // 15 pixels on screen
		const snapRadiusWorld = getSnapRadiusInWorldUnits3D(snapRadiusPixels);

		// Step 13f.4b) Get ray from raycaster
		interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);
		const ray = interactionManager.raycaster.ray;

		// Step 13f.4c) Perform cylindrical snap along view ray
		snapResult = snapToNearestPointWithRay(ray.origin, ray.direction, snapRadiusWorld);

		// Step 13f.4d) If snapped, use snap position; otherwise use mouseWorldPos
		if (snapResult.snapped && snapResult.snapTarget) {
			// Use snapped position
			if (mouseWorldPos) {
				mouseWorldPos.x = snapResult.worldX;
				mouseWorldPos.y = snapResult.worldY;
				mouseWorldPos.z = snapResult.worldZ;
			} else {
				mouseWorldPos = {
					x: snapResult.worldX,
					y: snapResult.worldY,
					z: snapResult.worldZ,
				};
			}

			// Also update torusWorldPos so cursor sphere shows at snap point
			if (torusWorldPos) {
				torusWorldPos.x = snapResult.worldX;
				torusWorldPos.y = snapResult.worldY;
				torusWorldPos.z = snapResult.worldZ;
			} else {
				torusWorldPos = {
					x: snapResult.worldX,
					y: snapResult.worldY,
					z: snapResult.worldZ,
				};
			}
		}
	}

	// Step 13f.5) Update current mouse world coordinates and HUD
	if (mouseWorldPos) {
		currentMouseWorldX = mouseWorldPos.x;
		currentMouseWorldY = mouseWorldPos.y;
		currentMouseWorldZ = mouseWorldPos.z || document.getElementById("drawingElevation").value;

		// Step 13f.5a) Update snapHighlight for HUD magnet icon
		snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;

		// Step 13f.5b) Get canvas mouse coordinates for HUD
		const rect = threeCanvas.getBoundingClientRect();
		const canvasMouseX = event.clientX - rect.left;
		const canvasMouseY = event.clientY - rect.top;
		currentMouseCanvasX = canvasMouseX;
		currentMouseCanvasY = canvasMouseY;

		// Step 13f.5c) Emit coordinates to HUD (same as 2D path)
		var isCurrentlySnapped = snapHighlight !== null && snapEnabled;
		emitCoords(
			{ x: canvasMouseX, y: canvasMouseY },
			{ x: currentMouseWorldX, y: currentMouseWorldY, z: parseFloat(currentMouseWorldZ) || 0 },
			currentScale,
			isCurrentlySnapped
		);

		// Step 13f.6) Draw stadium zone if in multi-connector mode
		// Check fromHoleStore by entityName and holeID to ensure it matches
		const hasFromHole = fromHoleStore && fromHoleStore.entityName && fromHoleStore.holeID;
		if (isAddingMultiConnector && hasFromHole && threeRenderer && threeRenderer.connectorsGroup) {
			const toRemove = [];
			threeRenderer.connectorsGroup.children.forEach((child) => {
				if (child.userData && child.userData.type === "stadiumZone") {
					toRemove.push(child);
				}
			});
			toRemove.forEach((obj) => {
				threeRenderer.connectorsGroup.remove(obj);
				if (obj.geometry) obj.geometry.dispose();
				if (obj.material) {
					if (Array.isArray(obj.material)) {
						obj.material.forEach((mat) => mat.dispose());
					} else {
						obj.material.dispose();
					}
				}
			});

			// Only draw stadium zone if we have valid mouse position
			if (mouseWorldPos && isFinite(mouseWorldPos.x) && isFinite(mouseWorldPos.y)) {
				drawConnectStadiumZoneThreeJS(fromHoleStore, mouseWorldPos, connectAmount);
			}
		}
	}

	// Step 13f.7) Always draw mouse position indicator on view plane (so it's always visible)
	// Special case: During orbit mode, lock torus to orbit focal point to prevent jumping
	// Use view plane position for torus, ground plane position for interactions
	// Priority: 1) Orbit focal point (if orbiting), 2) Snapped position (if snapping), 3) Hit object, 4) View plane, 5) Camera centroid
	let indicatorPos = null;

	// Step 13f.7a) Check if we have a snap target - highest priority for cursor display
	if (snapResult && snapResult.snapped && snapResult.snapTarget) {
		// Show cursor at snap target position
		indicatorPos = {
			x: snapResult.worldX,
			y: snapResult.worldY,
			z: snapResult.worldZ,
		};
	} else {
		// Step 13f.7b) Check if orbit mode is active via CameraControls
		const isOrbitingNow = window.cameraControls && window.cameraControls.isOrbiting;

		if (isOrbitingNow) {
			// Step 13f.7c) During orbit: Lock torus to orbit focal point (centroid + orbitCenterZ)
			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				const orbitZ = window.threeRenderer ? window.threeRenderer.orbitCenterZ || 0 : window.dataCentroidZ || 0;
				indicatorPos = {
					x: cameraState.centroidX + originX,
					y: cameraState.centroidY + originY,
					z: orbitZ,
				};
			}
		} else if (intersects && intersects.length > 0 && mouseWorldPos && isFinite(mouseWorldPos.x) && isFinite(mouseWorldPos.y)) {
			// Step 13f.7d) If we hit an object, use that position
			indicatorPos = mouseWorldPos;
		} else if (torusWorldPos && isFinite(torusWorldPos.x) && isFinite(torusWorldPos.y)) {
			// Step 13f.7e) Otherwise use view plane position (always visible at cursor)
			indicatorPos = torusWorldPos;
		} else {
			// Step 13f.7f) Fallback: camera centroid if view plane calc failed
			const fallbackZ = window.dataCentroidZ || 0;
			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				indicatorPos = {
					x: cameraState.centroidX + originX,
					y: cameraState.centroidY + originY,
					z: fallbackZ,
				};
			} else if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
				indicatorPos = {
					x: centroidX,
					y: centroidY,
					z: fallbackZ,
				};
			}
		}
	}

	if (indicatorPos && isFinite(indicatorPos.x) && isFinite(indicatorPos.y)) {
		// Step 13f.7g) Determine torus color based on active tool or snap state
		var torusColor = "rgba(128, 128, 128, 0.4)"; // Default grey

		// Step 13f.7h) If snapped, change color to indicate snap (bright green)
		// MUST use rgba() format - parseRGBA only handles rgba/rgb, not hex colors!
		if (snapResult && snapResult.snapped && snapResult.snapTarget) {
			torusColor = "rgba(0, 255, 0, 0.8)";
		} else {
			// Otherwise use tool-specific colors
			var isAnyDrawingToolActiveForTorus = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole;
			if (isAnyDrawingToolActiveForTorus) {
				if (isDrawingPoint || isAddingHole) {
					torusColor = "rgba(209, 0, 0, 0.5)"; // Red for points and holes
				} else if (isDrawingLine) {
					torusColor = "rgba(0, 255, 255, 0.5)"; // Cyan for lines
				} else if (isDrawingPoly) {
					torusColor = "rgba(255, 0, 255, 0.5)"; // Magenta for polygons
				} else if (isDrawingCircle) {
					torusColor = "rgba(255, 165, 0, 0.5)"; // Orange for circles
				} else if (isDrawingText) {
					torusColor = "rgba(0, 150, 50, 0.5)"; // Green for text
				}
			}
		}
		drawMousePositionIndicatorThreeJS(indicatorPos.x, indicatorPos.y, indicatorPos.z, torusColor);
	}

	// Step 13f.8) Draw KAD leading line preview if drawing tool is active
	const isAnyDrawingToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole;
	if (isAnyDrawingToolActive && lastKADDrawPoint && createNewEntity === false) {
		// Get drawing Z value
		const drawZ = drawingZValue || document.getElementById("drawingElevation").value || 0;

		// Determine color based on active tool
		var leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan default
		if (isDrawingPoint || isAddingHole) {
			leadingLineColor = "rgba(209, 0, 0, 0.8)"; // Red for points and holes
		} else if (isDrawingLine) {
			leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan for lines
		} else if (isDrawingPoly) {
			leadingLineColor = "rgba(255, 0, 255, 0.8)"; // Magenta for polygons
		} else if (isDrawingCircle) {
			leadingLineColor = "rgba(255, 165, 0, 0.8)"; // Orange for circles
		} else if (isDrawingText) {
			leadingLineColor = "rgba(0, 255, 0, 0.8)"; // Green for text
		}

		drawKADLeadingLineThreeJS(
			lastKADDrawPoint.x,
			lastKADDrawPoint.y,
			lastKADDrawPoint.z || parseFloat(drawZ),
			currentMouseWorldX,
			currentMouseWorldY,
			currentMouseWorldZ || parseFloat(drawZ), // Use raycast Z, fallback to drawZ
			leadingLineColor
		);

		// Step 13f.8b) Show distance overlay for drawing tools with tool-specific color
		var drawDx = currentMouseWorldX - lastKADDrawPoint.x;
		var drawDy = currentMouseWorldY - lastKADDrawPoint.y;
		var drawDistance = Math.sqrt(drawDx * drawDx + drawDy * drawDy);
		var drawBearing = (90 - (Math.atan2(drawDy, drawDx) * 180) / Math.PI + 360) % 360;

		// Determine tool type for color
		var drawToolType = "line";
		if (isDrawingPoint || isAddingHole) {
			drawToolType = "point";
		} else if (isDrawingLine) {
			drawToolType = "line";
		} else if (isDrawingPoly) {
			drawToolType = "poly";
		} else if (isDrawingCircle) {
			drawToolType = "circle";
		} else if (isDrawingText) {
			drawToolType = "text";
		}

		showDrawingDistance(drawDistance, drawBearing, drawToolType, event.clientX, event.clientY);
	} else {
		// Clear leading line if no drawing tool active or no last point
		clearKADLeadingLineThreeJS();
		hideDrawingDistance();
	}

	// Step 13f.9) Draw ruler in 3D mode if active
	if (isRulerActive && rulerStartPoint) {
		var rulerEndX = currentMouseWorldX;
		var rulerEndY = currentMouseWorldY;
		var rulerEndZ = currentMouseWorldZ || rulerStartPoint.z || 0;

		if (rulerEndPoint) {
			rulerEndX = rulerEndPoint.x;
			rulerEndY = rulerEndPoint.y;
			rulerEndZ = rulerEndPoint.z || 0;
		}

		drawRulerThreeJS(
			rulerStartPoint.x,
			rulerStartPoint.y,
			rulerStartPoint.z || 0,
			rulerEndX,
			rulerEndY,
			rulerEndZ
		);

		// Step 13f.9a) Update CSS ruler panel with measurements (same as 2D drawRuler)
		var ruler3DStartZ = rulerStartPoint.z || 0;
		var ruler3DEndZ = rulerEndZ || 0;
		var ruler3DDeltaX = rulerEndX - rulerStartPoint.x;
		var ruler3DDeltaY = rulerEndY - rulerStartPoint.y;
		var ruler3DDeltaZ = ruler3DEndZ - ruler3DStartZ;
		var ruler3DPlanDistance = Math.sqrt(ruler3DDeltaX * ruler3DDeltaX + ruler3DDeltaY * ruler3DDeltaY);
		var ruler3DTotalDistance = Math.sqrt(ruler3DDeltaX * ruler3DDeltaX + ruler3DDeltaY * ruler3DDeltaY + ruler3DDeltaZ * ruler3DDeltaZ);
		var ruler3DElevationAngle = ruler3DPlanDistance > 0 ? (Math.atan(Math.abs(ruler3DDeltaZ) / ruler3DPlanDistance) * 180) / Math.PI : 0;
		var ruler3DSlopePercent = ruler3DPlanDistance > 0 ? (Math.abs(ruler3DDeltaZ) / ruler3DPlanDistance) * 100 : 0;

		showRulerPanel({
			z1: ruler3DStartZ,
			z2: ruler3DEndZ,
			planDistance: ruler3DPlanDistance,
			totalDistance: ruler3DTotalDistance,
			deltaZ: ruler3DDeltaZ,
			elevationAngle: ruler3DElevationAngle,
			slopePercent: ruler3DSlopePercent,
			mouseX: currentMouseCanvasX,
			mouseY: currentMouseCanvasY
		});
	} else {
		clearRulerThreeJS();
		hideRulerPanel();
	}

	// Step 13f.9.5) Draw Pattern In Polygon leading line if active
	if (isPatternInPolygonActive && patternStartPoint && !patternEndPoint) {
		// Step 13f.9.5a) Get snapped mouse coordinates (same as 2D)
		var mouseCanvasCoords = worldToCanvas(currentMouseWorldX, currentMouseWorldY);
		var patternSnapResult = canvasToWorldWithSnap(mouseCanvasCoords[0], mouseCanvasCoords[1]);
		var snappedMouseX = patternSnapResult.worldX;
		var snappedMouseY = patternSnapResult.worldY;
		
		// Step 13f.9.5b) Reuse existing drawKADLeadingLineThreeJS for cheap dashed line
		var startZ = patternStartPoint.z || dataCentroidZ || 0;
		var mouseZ = currentMouseWorldZ || startZ;
		drawKADLeadingLineThreeJS(
			patternStartPoint.x, patternStartPoint.y, startZ,
			snappedMouseX, snappedMouseY, mouseZ,
			"rgba(0, 255, 0, 0.5)" // Green to match 2D
		);
		// Also redraw markers via the visual function
		drawPatternInPolygon3DVisual();
	}

	// Step 13f.9.6) Draw Holes Along Line leading line if active
	if (isHolesAlongLineActive && lineStartPoint && !lineEndPoint) {
		var mouseCanvasCoords = worldToCanvas(currentMouseWorldX, currentMouseWorldY);
		var holesLineSnapResult = canvasToWorldWithSnap(mouseCanvasCoords[0], mouseCanvasCoords[1]);
		var snappedMouseX = holesLineSnapResult.worldX;
		var snappedMouseY = holesLineSnapResult.worldY;
		
		var startZ = lineStartPoint.z || dataCentroidZ || 0;
		var mouseZ = currentMouseWorldZ || startZ;
		drawKADLeadingLineThreeJS(
			lineStartPoint.x, lineStartPoint.y, startZ,
			snappedMouseX, snappedMouseY, mouseZ,
			"rgba(0, 255, 0, 0.5)"
		);
		drawHolesAlongLine3DVisual();
	}

	// Step 13f.9.7) Draw Holes Along Polyline leading line if active - REMOVED per user request
	// Leading line removed for holesAlongPolyline tool

	// Step 13f.10) Draw protractor in 3D mode if active
	if (isRulerProtractorActive && rulerProtractorPoints.length > 0) {
		var p1 = rulerProtractorPoints[0];
		var p2 = rulerProtractorPoints.length > 1 ? rulerProtractorPoints[1] : { x: currentMouseWorldX, y: currentMouseWorldY, z: currentMouseWorldZ || p1.z || 0 };
		var p3 = { x: currentMouseWorldX, y: currentMouseWorldY, z: currentMouseWorldZ || p1.z || 0 };

		if (rulerProtractorPoints.length === 2) {
			p2 = rulerProtractorPoints[1];
		}
		if (rulerProtractorPoints.length === 3) {
			p3 = rulerProtractorPoints[2];
		}

		drawProtractorThreeJS(
			p1.x, p1.y, p1.z || 0,
			p2.x, p2.y, p2.z || 0,
			p3.x, p3.y, p3.z || 0
		);

		// Step 13f.10a) Update CSS protractor panel with measurements (same as 2D drawProtractor)
		var prot3DDeltaX1 = p2.x - p1.x;
		var prot3DDeltaY1 = p2.y - p1.y;
		var prot3DD1 = Math.sqrt(prot3DDeltaX1 * prot3DDeltaX1 + prot3DDeltaY1 * prot3DDeltaY1);
		var prot3DBearing1 = ((90 - Math.atan2(prot3DDeltaY1, prot3DDeltaX1) * 180 / Math.PI) + 360) % 360;

		var prot3DDeltaX2 = p3.x - p1.x;
		var prot3DDeltaY2 = p3.y - p1.y;
		var prot3DD2 = Math.sqrt(prot3DDeltaX2 * prot3DDeltaX2 + prot3DDeltaY2 * prot3DDeltaY2);
		var prot3DBearing2 = ((90 - Math.atan2(prot3DDeltaY2, prot3DDeltaX2) * 180 / Math.PI) + 360) % 360;

		// Calculate inner angle between the two legs
		var prot3DAngle1Rad = Math.atan2(prot3DDeltaY1, prot3DDeltaX1);
		var prot3DAngle2Rad = Math.atan2(prot3DDeltaY2, prot3DDeltaX2);
		var prot3DInnerAngle = Math.abs(prot3DAngle2Rad - prot3DAngle1Rad) * 180 / Math.PI;
		if (prot3DInnerAngle > 180) prot3DInnerAngle = 360 - prot3DInnerAngle;
		var prot3DOuterAngle = 360 - prot3DInnerAngle;

		showProtractorPanel({
			d1: prot3DD1,
			d2: prot3DD2,
			bearing1: prot3DBearing1,
			bearing2: prot3DBearing2,
			innerAngle: prot3DInnerAngle,
			outerAngle: prot3DOuterAngle,
			mouseX: currentMouseCanvasX,
			mouseY: currentMouseCanvasY
		});
	} else {
		clearProtractorThreeJS();
		hideProtractorPanel();
	}

	// Step 13f.11) Draw Pattern In Polygon leading line and visuals if active
	if (isPatternInPolygonActive && patternStartPoint && !patternEndPoint) {
		// Reuse existing drawKADLeadingLineThreeJS for cheap dashed line to mouse
		var patternStartZ = patternStartPoint.z || dataCentroidZ || 0;
		var patternMouseZ = currentMouseWorldZ || patternStartZ;
		drawKADLeadingLineThreeJS(
			patternStartPoint.x, patternStartPoint.y, patternStartZ,
			currentMouseWorldX, currentMouseWorldY, patternMouseZ,
			"rgba(0, 255, 0, 0.5)" // Green to match 2D
		);
		// Redraw markers and arrow via the visual function
		drawPatternInPolygon3DVisual();
	} else if (isPatternInPolygonActive) {
		// Still active but no leading line needed - just update visuals (markers, direction line, arrow)
		drawPatternInPolygon3DVisual();
	}

	if (threeRenderer.renderer) {
		threeRenderer.render();
	}
}

// Step 15) Handle 3D touch events
function handle3DTouchStart(event) {
	if (event.touches.length === 1) {
		const touch = event.touches[0];
		const mouseEvent = new MouseEvent("mousedown", {
			clientX: touch.clientX,
			clientY: touch.clientY,
			button: 0,
		});
		handle3DMouseDown(mouseEvent);
	}
	event.preventDefault();
}

function handle3DTouchEnd(event) {
	if (event.changedTouches.length === 1) {
		const touch = event.changedTouches[0];
		const mouseEvent = new MouseEvent("mouseup", {
			clientX: touch.clientX,
			clientY: touch.clientY,
			button: 0,
		});
		handle3DMouseUp(mouseEvent);
	}
	event.preventDefault();
}

function handle3DTouchMove(event) {
	if (event.touches.length === 1) {
		const touch = event.touches[0];
		const mouseEvent = new MouseEvent("mousemove", {
			clientX: touch.clientX,
			clientY: touch.clientY,
		});
		handle3DMouseMove(mouseEvent);
	}
	event.preventDefault();
}

// Step 10) Setup onlyShowThreeJS checkbox listener
document.addEventListener("DOMContentLoaded", function () {
	const onlyThreeJSCheckbox = document.getElementById("onlyShowThreeJS");
	if (onlyThreeJSCheckbox) {
		onlyThreeJSCheckbox.addEventListener("change", function () {
			onlyShowThreeJS = this.checked;
			console.log(onlyShowThreeJS ? "üé® Showing only Three.js rendering" : "üé® Showing both 2D canvas and Three.js");

			const threeCanvas = document.getElementById("threeCanvas");

			if (onlyShowThreeJS) {
				// Step 1a) Show only 3D canvas - hide 2D canvas completely
				canvas.style.zIndex = "0"; // 2D canvas behind
				canvas.style.opacity = "0"; // Hide 2D canvas
				canvas.style.pointerEvents = "none"; // Don't block events

				if (threeCanvas) {
					threeCanvas.style.zIndex = "2"; // Three.js on top
					threeCanvas.style.opacity = "1"; // Show 3D canvas
					threeCanvas.style.pointerEvents = "auto"; // Receive events
				}
				console.log("üîç Layers: Three.js (z:2, visible), 2D canvas (z:0, hidden)");
			} else {
				// Step 1b) Show only 2D canvas - hide 3D canvas completely
				canvas.style.zIndex = "2"; // 2D canvas on top
				canvas.style.opacity = "1"; // Show 2D canvas
				canvas.style.pointerEvents = "auto"; // Receive events

				if (threeCanvas) {
					threeCanvas.style.zIndex = "0"; // Three.js behind
					threeCanvas.style.opacity = "0"; // Hide 3D canvas
					threeCanvas.style.pointerEvents = "none"; // Don't block events
				}

				// Reset pan state to prevent stuck dragging
				if (window.cameraControls) {
					window.cameraControls.resetPanState();
					console.log("üîÑ Reset camera controls pan state on switch to 2D");
				}

				console.log("üîç Layers: 2D canvas (z:2, visible), Three.js (z:0, hidden)");
			}

			// Redraw to apply changes
			drawData(allBlastHoles);

			// If switching to 3D mode, trigger mouse indicator initialization
			if (show3D && threeInitialized && interactionManager && threeRenderer) {
				// Use setTimeout to ensure canvas is visible and ready
				setTimeout(() => {
					const threeCanvas = threeRenderer.getCanvas();
					if (threeCanvas) {
						const rect = threeCanvas.getBoundingClientRect();
						const centerX = rect.left + rect.width / 2;
						const centerY = rect.top + rect.height / 2;

						const syntheticEvent = new MouseEvent("mousemove", {
							bubbles: true,
							cancelable: true,
							clientX: centerX,
							clientY: centerY,
							button: 0,
							buttons: 0,
						});

						document.dispatchEvent(syntheticEvent);
					}
				}, 100);
			}
		});
	}

	// Step 11) Setup 2D-3D dimension toggle button
	const dimension2D3DBtn = document.getElementById("dimension2D-3DBtn");
	if (dimension2D3DBtn) {
		dimension2D3DBtn.addEventListener("change", function () {
			const show3D = this.checked;
			const threeCanvas = document.getElementById("threeCanvas");
			const iconImg = this.nextElementSibling.querySelector("img");

			if (show3D) {
				// Step 1c) 3D-only mode - show only 3D canvas, hide 2D canvas
				onlyShowThreeJS = true;
				// Reset mouse indicator flag so it initializes when switching to 3D mode
				mouseIndicatorInitialized = false;
				// Step 1ca) Reset initialization failure flag to allow retry
				threeInitializationFailed = false;
				// Step 1cb) Reset camera pan state to prevent stuck drag
				if (cameraControls && cameraControls.resetPanState) {
					cameraControls.resetPanState();
				}
				console.log("üßä 3D-ONLY Mode: ON (cube icon active, 2D canvas hidden)");

				// Step 1cc.0) SYNC CAMERA: Match 3D camera position/zoom to current 2D view
				syncCameraToThreeJS();

				// Step 1cc.0a) Clear text cache to ensure text renders at correct scale
				clearTextCache();

				// Step 1cc.1) Force geometry rebuild when entering 3D mode
				window.threeDataNeedsRebuild = true;

				// Step 1cc) Update Move Tool if active - switch to 3D canvas
				if (isMoveToolActive) {
					const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
					if (threeCanvas) {
						// Remove listeners from 2D canvas
						canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
						canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
						canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
						canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
						canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
						canvas.removeEventListener("touchend", handleMoveToolMouseUp);

						// Add listeners to 3D canvas
						threeCanvas.addEventListener("mousedown", handleMoveToolMouseDown);
						threeCanvas.addEventListener("touchstart", handleMoveToolMouseDown);

						// Update mode flag
						moveToolIn3DMode = true;
						console.log("üëã Move Tool switched to 3D canvas");
					}
				}

				// Step 1cc.1) Handle KAD drawing tools when switching to 3D
				const anyKADToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText;
				if (anyKADToolActive) {
					// Remove event listeners from 2D canvas (drawing doesn't work in 3D)
					canvas.removeEventListener("click", handleKADPointClick);
					canvas.removeEventListener("touchstart", handleKADPointClick);
					canvas.removeEventListener("click", handleKADLineClick);
					canvas.removeEventListener("touchstart", handleKADLineClick);
					canvas.removeEventListener("click", handleKADPolyClick);
					canvas.removeEventListener("touchstart", handleKADPolyClick);
					canvas.removeEventListener("click", handleKADCircleClick);
					canvas.removeEventListener("touchstart", handleKADCircleClick);
					canvas.removeEventListener("click", handleKADTextClick);
					canvas.removeEventListener("touchstart", handleKADTextClick);

					// Clear drawing state to prevent stale preview lines
					lastKADDrawPoint = null;

					// Keep the tool active but inform user about 3D limitations
					updateStatusMessage("KAD drawing: Right-click to end entities in 3D mode");
					setTimeout(() => updateStatusMessage(""), 3000);

					console.log("üîÑ KAD drawing tools switched to 3D mode (right-click only)");
				}

				if (threeCanvas) {
					threeCanvas.style.zIndex = "2"; // Three.js on top
					threeCanvas.style.opacity = "1"; // Show 3D canvas
					threeCanvas.style.pointerEvents = "auto"; // Receive events
				}
				// Hide 2D canvas completely
				if (canvas) {
					canvas.style.zIndex = "0"; // 2D canvas behind
					canvas.style.opacity = "0"; // Hide 2D canvas
					canvas.style.pointerEvents = "none"; // Don't block events
				}
				// Step 1cc) Hide contour overlay canvas in 3D mode (labels render as 3D text)
				if (typeof contourOverlayCanvas !== "undefined" && contourOverlayCanvas) {
					contourOverlayCanvas.style.display = "none";
				}
				// Swap icon to 3D badge
				if (iconImg) {
					iconImg.src = "icons/badge-3d-v2.png";
					iconImg.alt = "3D View Active (3D Only)";
				}
				// Step 1cd) CRITICAL: Trigger contour recalculation and drawData to populate 3D scene
				// Without this, the 3D scene remains empty until user interaction
				if (allBlastHoles && allBlastHoles.length > 0) {
					// Step 1cd.1) Recalculate contours if contour OR direction arrows display is enabled
					// This ensures both contourLinesArray and directionArrows are populated for 3D rendering
					var needsContourRecalc = (displayContours && displayContours.checked) ||
						(displayFirstMovements && displayFirstMovements.checked);
					if (needsContourRecalc) {
						var result = recalculateContours(allBlastHoles, 0, 0);
						if (result) {
							contourLinesArray = result.contourLinesArray;
							directionArrows = result.directionArrows;
						}
					}
					// Step 1cd.2) Now draw the data with populated contours/arrows
					drawData(allBlastHoles, selectedHole);
				}
			} else {
				// Step 1d) 2D-only mode - show only 2D canvas, hide 3D canvas
				onlyShowThreeJS = false;
				// Step 1da) SYNC CAMERA: Get 3D camera state and apply to 2D view
				if (cameraControls) {
					var cameraState = cameraControls.getCameraState();
					if (cameraState) {
						syncCameraFromThreeJS(cameraState);
						console.log("üì∑ Synced camera FROM Three.js - centroidX:", centroidX.toFixed(2), "centroidY:", centroidY.toFixed(2), "scale:", currentScale);
					}
					// Reset camera pan state to prevent stuck drag
					if (cameraControls.resetPanState) {
						cameraControls.resetPanState();
					}
				}
				console.log("üé® 2D-ONLY Mode: ON (3D canvas hidden)");

				// Step 1db) Update Move Tool if active - switch to 2D canvas
				if (isMoveToolActive) {
					const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
					if (threeCanvas) {
						// Remove listeners from 3D canvas
						threeCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
						threeCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
						threeCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
						threeCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
						threeCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
						threeCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
					}

					// Add listeners to 2D canvas
					canvas.addEventListener("mousedown", handleMoveToolMouseDown);
					canvas.addEventListener("touchstart", handleMoveToolMouseDown);

					// Update mode flag
					moveToolIn3DMode = false;
					dragPlaneZ = 0;
					console.log("üîÑ Move Tool switched to 2D canvas");
				}

				// Step 1db.1) Update KAD drawing tools if active - ensure event listeners are on 2D canvas
				const anyKADToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText;
				if (anyKADToolActive) {
					// Remove any existing listeners (just in case)
					canvas.removeEventListener("click", handleKADPointClick);
					canvas.removeEventListener("touchstart", handleKADPointClick);
					canvas.removeEventListener("click", handleKADLineClick);
					canvas.removeEventListener("touchstart", handleKADLineClick);
					canvas.removeEventListener("click", handleKADPolyClick);
					canvas.removeEventListener("touchstart", handleKADPolyClick);
					canvas.removeEventListener("click", handleKADCircleClick);
					canvas.removeEventListener("touchstart", handleKADCircleClick);
					canvas.removeEventListener("click", handleKADTextClick);
					canvas.removeEventListener("touchstart", handleKADTextClick);

					// Add listeners to 2D canvas based on active tool
					if (isDrawingPoint) {
						canvas.addEventListener("click", handleKADPointClick);
						canvas.addEventListener("touchstart", handleKADPointClick);
					} else if (isDrawingLine) {
						canvas.addEventListener("click", handleKADLineClick);
						canvas.addEventListener("touchstart", handleKADLineClick);
					} else if (isDrawingPoly) {
						canvas.addEventListener("click", handleKADPolyClick);
						canvas.addEventListener("touchstart", handleKADPolyClick);
					} else if (isDrawingCircle) {
						canvas.addEventListener("click", handleKADCircleClick);
						canvas.addEventListener("touchstart", handleKADCircleClick);
					} else if (isDrawingText) {
						canvas.addEventListener("click", handleKADTextClick);
						canvas.addEventListener("touchstart", handleKADTextClick);
					}

					// Inform user that full drawing functionality is restored
					updateStatusMessage("KAD drawing: Full functionality restored in 2D mode");
					setTimeout(() => updateStatusMessage(""), 2000);

					console.log("üîÑ KAD drawing tool event listeners switched to 2D canvas");
				}

				// Step 1dc) Clear all Three.js geometry when switching to 2D mode
				if (typeof clearThreeJS === "function") {
					clearThreeJS();
					console.log("üé® Cleared Three.js geometry on switch to 2D mode");
				}

				// Step 1dc.1) Remove 3D print preview overlay if present
				remove3DPrintBoundaryOverlay();
				console.log("üñ®Ô∏è Removed 3D print boundary overlay on switch to 2D mode");

				if (threeCanvas) {
					threeCanvas.style.zIndex = "0"; // Three.js behind
					threeCanvas.style.opacity = "0"; // Hide 3D canvas
					threeCanvas.style.pointerEvents = "none"; // Don't block events
				}
				if (canvas) {
					canvas.style.zIndex = "2"; // 2D canvas on top
					canvas.style.opacity = "1"; // Show 2D canvas
					canvas.style.pointerEvents = "auto"; // Receive events
				}

				// Step 1dc) Reset 2D canvas transform state to prevent 3D rotation artifacts
				// This fixes the quirk where surfaces render above KAD and Holes after 3D rotation
				if (ctx) {
					ctx.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
					console.log("üîÑ Reset 2D canvas transform state on switch to 2D mode");
				}

				// Step 1dd) Show contour overlay canvas in 2D mode
				if (typeof contourOverlayCanvas !== "undefined" && contourOverlayCanvas) {
					contourOverlayCanvas.style.display = "block";
				}
				// Swap icon to 2D badge
				if (iconImg) {
					iconImg.src = "icons/badge-2d-v2.png";
					iconImg.alt = "2D View Active (2D Only)";
				}
				// Step 1de) CRITICAL: Recalculate contours and redraw for 2D mode
				// This ensures contours display correctly after switching from 3D
				if (allBlastHoles && allBlastHoles.length > 0) {
					if (displayContours && displayContours.checked) {
						var result = recalculateContours(allBlastHoles, 0, 0);
						if (result) {
							contourLinesArray = result.contourLinesArray;
							directionArrows = result.directionArrows;
						}
					}
					drawData(allBlastHoles, selectedHole);
				}
			}

			// Redraw to apply changes
			drawData(allBlastHoles);
		});

		// Step 12) Set initial state (2D visible by default for faster startup and smoother UX)
		// Starting in 2D mode avoids choppy 3D navigation on initial load
		dimension2D3DBtn.checked = false;
		dimension2D3DBtn.dispatchEvent(new Event("change"));
	}

	// Step 13) Setup 3D Settings button
	const dimension2D3DSettingsBtn = document.getElementById("dimension2D-3D-SettingsBtn");
	if (dimension2D3DSettingsBtn) {
		dimension2D3DSettingsBtn.addEventListener("change", function () {
			if (this.checked) {
				// Step 13a) Show settings dialog
				if (window.show3DSettingsDialog) {
					window.show3DSettingsDialog();
				} else {
					console.warn("üö® 3D Settings Dialog not loaded");
				}
				// Step 13b) Uncheck button after dialog is shown (dialog handles its own state)
				setTimeout(() => {
					this.checked = false;
				}, 100);
			}
		});
	}
});

const ctx = canvas.getContext("2d");
// Expose ctx and canvas globally for canvas2DDrawing.js module
window.ctx = ctx;
window.canvas = canvas;

let scale = 5; // adjust the scale to fit the allBlastHoles in the canvas
let fontSize = document.getElementById("fontSlider").value;
//TODO Eventually use this class for all holes.
class BlastHole {
	constructor(data = {}) {
		this.entityName = data.entityName || "";
		this.entityType = data.entityType || "hole";
		this.holeID = data.holeID || null;
		this.startXLocation = data.startXLocation || 0;
		this.startYLocation = data.startYLocation || 0;
		this.startZLocation = data.startZLocation || 0;
		this.endXLocation = data.endXLocation || 0;
		this.endYLocation = data.endYLocation || 0;
		this.endZLocation = data.endZLocation || 0;
		this.gradeXLocation = data.gradeXLocation || 0;
		this.gradeYLocation = data.gradeYLocation || 0;
		this.gradeZLocation = data.gradeZLocation || 0;
		this.subdrillAmount = data.subdrillAmount || 0; //deltaZ of gradeZ to toeZ -> downhole =+ve uphole =-ve
		this.subdrillLength = data.subdrillLength || 0; //distance of subdrill from gradeXYZ to toeXYZ -> downhole =+ve uphole =-ve
		this.benchHeight = data.benchHeight || 0; //deltaZ of collarZ to gradeZ -> always Absolute
		this.holeDiameter = data.holeDiameter || 115;
		this.holeType = data.holeType || "Undefined";
		this.fromHoleID = data.fromHoleID || "";
		this.timingDelayMilliseconds = data.timingDelayMilliseconds || 0;
		this.colorHexDecimal = data.colorHexDecimal || "red";
		this.holeLengthCalculated = data.holeLengthCalculated || 0; //Distance from the collarXYZ to the ToeXYZ
		this.holeAngle = data.holeAngle || 0; //Angle of the blast hole from Collar to Toe --> 0¬∞ = Vertical
		this.holeBearing = data.holeBearing || 0;
		this.measuredLength = data.measuredLength || 0;
		this.measuredLengthTimeStamp = data.measuredLengthTimeStamp || "09/05/1975 00:00:00";
		this.measuredMass = data.measuredMass || 0;
		this.measuredMassTimeStamp = data.measuredMassTimeStamp || "09/05/1975 00:00:00";
		this.measuredComment = data.measuredComment || "None";
		this.measuredCommentTimeStamp = data.measuredCommentTimeStamp || "09/05/1975 00:00:00";
		this.rowID = data.rowID || null;
		this.posID = data.posID || null;
		this.visible = data.visible !== false;
		this.burden = data.burden || 1;
		this.spacing = data.spacing || 1;
		this.connectorCurve = data.connectorCurve || 0;
	}
}

let allBlastHoles = [];
let dxfEntities = [];
let countAllBlastHoles = allBlastHoles.length;
let sumMeters = 0;
let currentScale = scale; // declare a variable to store the current scale
let currentFontSize = fontSize; // declare a variable to store the current font size
let toeScale = document.getElementById("toeSlider").value;
let holeScale = document.getElementById("holeSlider").value;
let deltaX = 0;
let deltaY = 0;
let centroidX = 0;
let centroidY = 0;
let centroidZ = 0;
let firstPointInLine = null;
let blastNameValue = "";
let currentEntityName = "";

// Group visibility flags
let blastGroupVisible = true;
let drawingsGroupVisible = true;
let surfacesGroupVisible = true;
let imagesGroupVisible = true;
// Drawing sub-group visibility flags
let pointsGroupVisible = true;
let linesGroupVisible = true;
let polygonsGroupVisible = true;
let circlesGroupVisible = true;
let textsGroupVisible = true;

// Forward declarations for functions/variables defined later in the file
// These prevent "not defined" errors when used early
let contourOverlayCanvas = null;
let contourOverlayCtx = null;
// debouncedUpdateTreeView is defined later at line ~41322 with proper debouncing
let debouncedUpdateTreeView;

// Function to update TreeView when holes are added
window.updateTreeFromBlastHoles = function() {
	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}
};

// Variable to store the "fromHole" ID during connector mode
let fromHoleStore = null;
let mouseIndicatorInitialized = false; // Track if mouse indicator has been initialized on startup
let isAddingConnector = false;
let isAddingMultiConnector = false;

let isAddingPoint = false;
let isAddingLine = false;
let isAddingPoly = false;
let isAddingCircle = false;
let isAddingText = false;
let isAssignSurfaceActive = false;
let isAssignGradeActive = false;
let isOffsetKADActive = false;
let isRadiiHolesOrKADActive = false;
let isRulerToolActive = false;
let isRulerProtractorToolActive = false;
let startPanX, startPanY;

let isAddingHole = false;
let isAddingPattern = false;
let isDeletingHole = false;
let isDeletingPattern = false;
let isMovingCanvas = false;
let isDragging = false;
let isModifyingKAD = false;
let entityName; // Define entityName outside the function to persist between calls
let createNewEntity = true; // Flag to create a new entity
// Variables to store the initial mouse position during canvas movement
let lastMouseX = 0;
let lastMouseY = 0;
let initialMouseX = 0;
let initialMouseY = 0;
let touchStartX,
	touchStartY = 0;
// Add current mouse tracking for interactive previews
let currentMouseCanvasX = 0;
let currentMouseCanvasY = 0;
let currentMouseCanvasZ = document.getElementById("drawingElevation").value;
let currentMouseWorldX = 0;
let currentMouseWorldY = 0;
let currentMouseWorldZ = document.getElementById("drawingElevation").value;
// Surfaces
let allAvailableSurfaces = [];
let intervalAmount = document.getElementById("intervalSlider").value;
let firstMovementSize = document.getElementById("firstMovementSlider").value;
let connectAmount = document.getElementById("connectSlider").value;
let contourLevel = 0;
let contourUpdatePending = false;
let clipperUnionWarned = false; // Flag to prevent console spam for Clipper union warnings
let minX;
let minY;
let worldX = null;
let worldY = null;
let worldZ = null;
let contourLines = [];
let contourLinesArray = [];
let directionArrows = [];
let epsilon = 1;

// Contour caching - only recalculate when hole positions/times change
let cachedContourHash = null;
let cachedContourLinesArray = [];
let cachedDirectionArrows = [];
let holeTimes = {};
let deleteRenumberStart = document.getElementById("deleteRenumberStart").value;
let firstSelectedHole = null;
let secondSelectedHole = null;
let selectedHole = null;
let isBlastNameEditing = false;
let isHoleEditing = false;
let isSelectionPointerActive = false;
let polyPointsX = [];
let polyPointsY = [];
let isPolygonSelectionActive = false;
let useToeLocation = false;
let selectedVoronoiMetric = "powderFactor"; // default
// Add these variables near the top (around line 190)
let lastKADDrawPoint = null; // Store the last drawn point from any KAD tool
let isVoronoiLegendFixed = false;
let isBearingToolActive = false;

// Add this declaration around line 99 (after bearingToolSelectedHole declaration)
let bearingToolSelectedHole = null;
let moveToolSelectedHole = null; // Add this declaration
let bearingToolStartAngle = 0;
let bearingToolStartMouseAngle = 0;
let isDraggingBearing = false;
let rulerStartPoint = null;
let rulerEndPoint = null;
let rulerProtractorPoints = []; // For 3-point bearing measurement
let isRulerActive = false;
let isRulerProtractorActive = false;
let isLengthPopupEditing = false;
let isDisplayingContours = false;
let isDisplayingSlopeTriangles = false;
let isDisplayingReliefTriangles = false;
let isDisplayingDirectionArrows = false;
let isTypeEditing = false;
let fixToeLocation = false;
// Add these missing global variable declarations
let imageVisible = false;
let surfaceVisible = false;
//drawing tool booleans
let isDrawingPoint = false;
let isDrawingLine = false;
let isDrawingCircle = false;
let isDrawingPoly = false;
let isDrawingText = false;

let selectedKADObject = null;
let selectedKADPolygon = null;
let selectedKADPoint = null;
let selectedKADLine = null;
let selectedKADCircle = null;
let selectedKADText = null;

let isAddKADLineToolActive = false;
let isAddKADPolygonToolActive = false;
let isAddKADPointsToolActive = false;
let isAddKADCircleToolActive = false;
let isAddKADTextToolActive = false;
let isTriangulateToolActive = false;

//delete tool booleans
let isDeletingKAD = false;
//modify tool booleans
let isModifyingPoint = false;
//offset tool booleans
let isOffsetLinePoly = false;
//offset kad tool booleans
let isOffsetKAD = false;
//radii holes or kads tool booleans
let isRadiiHolesOrKADs = false;
//Record Measurements booleans
let isMeasureRecording = false;
// PolyLine select for use in tools
let selectedVertices = [];
let isSelectingPolyline = false;
//has selected multiple holes
let hasSelectedMultipleHoles = false;
let isMultiHoleSelectionEnabled = false; // Selection mode is false if single ONLY hole selection on each click and true when each click adds a hole to the selection.  It does not indicate that selection is active or inactive.
let isMoveToolActive = false;
let isMovingHole = false;
let holeToMove = null;
// Step 1) Move Tool 3D mode tracking variables
let moveToolIn3DMode = false; // Track if move tool is in 3D mode
let dragPlaneZ = 0; // Z elevation of plane for 3D raycasting
let justFinishedDragging = false; // Flag to prevent click event after drag
let dragInitialKADPositions = null; // Initial positions for multiple KAD points

let maxEdgeLength = 15;
let clickedHole; // Declare clickedHole outside the event listener
let timingWindowHolesSelected = [];
let selectedMultipleHoles = [];
let selectedPoint = null; // Global selectedPoint declaration
let selectedMultiplePoints = [];
let selectedMultipleKADObjects = []; // Array to store multiple selected KAD objects
let isMultiKADSelectionEnabled = false; // Flag for multi-KAD selection mode
// Add this global flag at the top of your file (near other globals like snapEnabled)
let isSelfSnapEnabled = false; // Tracks if 'S' is held down
// Step 4) Move tool state for KAD vertices
let moveToolSelectedKAD = null;
let moveToolKADOriginalZ = 0;
let toeSizeInMeters = 1;
let connScale = 1;
let isPlaying = false; // To track whether the animation is playing
let animationInterval; // To store the interval ID for the animation
let animationFrameId = null; // To store the requestAnimationFrame ID for smooth animation
let playSpeed = 1; // Default play speed
//COLOURS
let noneColor = "rgba(0, 0, 0, 0)";
// Step 1) Initialize darkModeEnabled from localStorage BEFORE setting colors
let darkModeEnabled = localStorage.getItem("darkMode") === "true" || document.body.classList.contains("dark-mode");
console.log("üåô Dark mode detected on init:", darkModeEnabled, "from localStorage:", localStorage.getItem("darkMode"));
// Step 2) Set colors correctly based on dark mode
let transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
let fillColor = darkModeEnabled ? "darkgrey" : "lightgrey"; // FIXED: was backwards
let strokeColor = darkModeEnabled ? "white" : "black";
let textFillColor = darkModeEnabled ? "white" : "black";
let depthColor = darkModeEnabled ? "cyan" : "blue"; // FIXED: was backwards
let angleDipColor = darkModeEnabled ? "orange" : "darkorange"; // FIXED: was backwards

///////////////////////////
//DEVELOPER MODE BUTTON
const developerModeCheckbox = document.getElementById("developerMode");
let developerModeEnabled = false;
developerModeCheckbox.addEventListener("change", function () {
	developerModeEnabled = developerModeCheckbox.checked;
	console.log("Developer mode enabled:", developerModeEnabled);
});
///////////////////////////

///////////////////////////
// 3D OPTIMIZATION FLAGS
// Step 1) Get checkbox elements for 3D optimization options
var use3DSimplificationCheckbox = document.getElementById("use3DSimplification");
var useInstancedHolesCheckbox = document.getElementById("useInstancedHoles");

// Step 2) Initialize global flags (default values match HTML checked states)
var use3DSimplification = use3DSimplificationCheckbox ? use3DSimplificationCheckbox.checked : true;
var useInstancedHoles = useInstancedHolesCheckbox ? useInstancedHolesCheckbox.checked : false;

// Step 3) Expose to window for access from other modules
window.use3DSimplification = use3DSimplification;
window.useInstancedHoles = useInstancedHoles;

// Step 4) Add event listeners to sync checkbox changes
if (use3DSimplificationCheckbox) {
	use3DSimplificationCheckbox.addEventListener("change", function () {
		use3DSimplification = this.checked;
		window.use3DSimplification = use3DSimplification;
		console.log("3D Simplification " + (use3DSimplification ? "enabled" : "disabled"));
		// Trigger redraw to apply change
		if (typeof redraw === "function") {
			redraw();
		}
	});
}

if (useInstancedHolesCheckbox) {
	useInstancedHolesCheckbox.addEventListener("change", function () {
		useInstancedHoles = this.checked;
		window.useInstancedHoles = useInstancedHoles;
		console.log("Instanced Holes " + (useInstancedHoles ? "enabled" : "disabled"));
		// Trigger redraw to apply change
		if (typeof redraw === "function") {
			redraw();
		}
	});
}
///////////////////////////

//Switches
const addConnectorButton = document.getElementById("addConnectorButton");
const addMultiConnectorButton = document.getElementById("addMultiConnectorButton");
const addPatternSwitch = document.getElementById("addPatternSwitch");
const addHoleSwitch = document.getElementById("addHoleSwitch");

const editLengthPopupSwitch = document.getElementById("editLengthPopupButton");
const editHoleTypePopupSwitch = document.getElementById("editHoleTypePopupButton");

const editBlastNameSwitch = document.getElementById("editBlastNameButton");
// const editDiameterSwitch = document.getElementById("editDiameterButton");
const deleteHoleSwitch = document.getElementById("deleteHoleSwitch");
const modifyKADSwitch = document.getElementById("modifyKADDraw");
const offsetKADButton = document.getElementById("offsetKADTool");
const radiiHolesOrKADsButton = document.getElementById("radiiHolesOrKADsTool");
const selectionModeButton = document.getElementById("selectionModeButton");
const editHolesToggle = document.getElementById("editHolesToggle"); //required to be true if holes are to be fine tuned

// Drawing Switch Event Listeners
const addPointDraw = document.getElementById("addPointDraw");
const addLineDraw = document.getElementById("addLineDraw");
const addCircleDraw = document.getElementById("addCircleDraw");
const addPolyDraw = document.getElementById("addPolyDraw");
const addTextDraw = document.getElementById("addTextDraw");
// Delete Drawing Switch Event Listeners
const deleteKADDraw = document.getElementById("deleteKADDraw");
//Record Measurements Switch Event Listeners
const measuredLengthSwitch = document.getElementById("measuredLengthSwitch");
const measuredMassSwitch = document.getElementById("measuredMassSwitch");
const measuredCommentSwitch = document.getElementById("measuredCommentSwitch");

//switch Options - Do not include in switches array
const renumberStartListener = document.getElementById("deleteRenumberStart");
const renumberHoles = document.getElementById("renumberHoles");
let isRenumberingHoles = false;

const switches = [addConnectorButton, addMultiConnectorButton, addPatternSwitch, addHoleSwitch, editLengthPopupSwitch, editBlastNameSwitch, deleteHoleSwitch, modifyKADSwitch, editHoleTypePopupSwitch, addPointDraw, addLineDraw, addCircleDraw, addPolyDraw, addTextDraw, deleteKADDraw, measuredLengthSwitch, measuredMassSwitch, measuredCommentSwitch, selectionModeButton, editHolesToggle];

const booleans = [
	isAddingConnector,
	isAddingMultiConnector,
	isAddingHole,
	isAddingPattern,
	isDeletingHole,
	isMovingCanvas,
	isDragging,
	isBlastNameEditing,
	isHoleEditing,
	isLengthPopupEditing,
	isDisplayingContours,
	isDisplayingSlopeTriangles,
	isDisplayingReliefTriangles,
	isDisplayingDirectionArrows,
	isTypeEditing,
	isDrawingPoint,
	isDrawingLine,
	isDrawingCircle,
	isDrawingPoly,
	isDrawingText,
	isDeletingKAD,
	isPlaying,
	isModifyingPoint,
	isOffsetLinePoly,
	isMeasureRecording,
	isMultiHoleSelectionEnabled, //check this
];

// Boolean set to False
function setAllBoolsToFalse() {
	isAddingConnector = false;
	isAddingMultiConnector = false;
	isAddingHole = false;
	isAddingPattern = false;
	isDeletingHole = false;
	isMovingCanvas = false;
	isDragging = false;
	isBlastNameEditing = false;
	isHoleEditing = false;
	isLengthPopupEditing = false;
	isDisplayingContours = false;
	isDisplayingSlopeTriangles = false;
	isDisplayingReliefTriangles = false;
	isDisplayingDirectionArrows = false;
	isTypeEditing = false;
	isDrawingPoint = false;
	isDrawingLine = false;
	isDrawingCircle = false;
	isDrawingPoly = false;
	isDrawingText = false;
	isDeletingKAD = false;
	isPlaying = false;
	isModifyingPoint = false;
	isOffsetLinePoly = false;
	isMeasureRecording = false;
	isMultiHoleSelectionEnabled = false;
	isMoveToolActive = false;
	window.isMoveToolActive = false;
	isMovingHole = false;

	// CRITICAL FIX: Remove move tool event listeners when deactivating
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Also clear move tool state variables
	moveToolSelectedHole = null;

	// Hide drawing distance panel when tools are deactivated
	hideDrawingDistance();
	isDraggingHole = false;

	// Remove bearing tool listeners too
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);

	// Clear bearing tool state
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
}

// Function 2: Reset all switches and toggles
function resetSwitchesTogglesOptionalDisplay(resetDisplayOptions) {
	// Reset all switches
	const allSwitches = [
		"addConnectorSwitch",
		"addMultiConnectorSwitch",
		"addHoleSwitch",
		"addPatternSwitch",
		"deleteHoleSwitch",
		"renumberHoles",
		"editBlastNameSwitch",
		"editHoleSwitch",
		"editLengthPopupSwitch",
		"editTypePopupSwitch",
		"selectionModeSwitch",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"addPointDraw",
		"addLineDraw",
		"addCircleDraw",
		"addPolyDraw",
		"addTextDraw",
		"deleteKADDraw",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"selectionModeButton",
		"editHolesToggle",
	];

	allSwitches.forEach((switchId) => {
		const switchElement = document.getElementById(switchId);
		if (switchElement) {
			switchElement.checked = false;
		}
	});

	if (resetDisplayOptions) {
		// Reset display options toggles
		allToggles.forEach((toggle) => {
			if (toggle) {
				toggle.checked = false;
			}
		});
	}
}

// Function 3: Reset all selected stores and state variables
function resetAllSelectedStores() {
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	firstSelectedHole = null;
	secondSelectedHole = null;
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	clickedHole = null;
	timingWindowHolesSelected = [];

	// Reset pattern tool variables
	selectedPolygon = null;
	selectedPolyline = null;
	patternStartPoint = null;
	patternEndPoint = null;
	patternReferencePoint = null;

	// Reset line tool variables
	lineStartPoint = null;
	lineEndPoint = null;

	// Reset poly line tool variables
	polylineStartPoint = null;
	polylineEndPoint = null;

	// Reset any other state variables
	blastNameValue = "";
	currentEntityName = "";

	console.log("üßπ All selected stores and pattern states reset");
}

/**
 * Removes event listeners for various tools, with option to exclude specific tools
 *
 * @param {string|string[]} [excluding=[]] - Tool(s) to exclude from listener removal
 * Possible exclusion values include:
 * - "moveToTool", "bearingTool", "tieConnectTool", "tieConnectMultiTool", "lineDrawing", "polygonDrawing", "pointDrawing", "textDrawing", "circleDrawing", "rulerTool", "rulerProtractorTool", "selectPointerTool", "selectByPolygonTool", "addingHoleSwitch", "addingPatternSwitch", "patternInPolygonTool", "holesAlongLineTool", "holesAlongPolyLineTool", "measuredLengthClick", "measuredMassClick", "measuredCommentClick", "editBlastNameClick", "editLengthWithPopupClick", "editHoleTypeClick", "defaultListeners"
 */
function removeEventListenersExcluding(excluding = []) {
	console.log("Removing event listeners excluding: ", excluding);
	// Convert single string to array for consistency
	if (typeof excluding === "string") {
		excluding = [excluding];
	}

	// Remove move tool listeners
	if (!excluding.includes("moveToTool")) {
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		document.removeEventListener("mousemove", handleMoveToolMouseMove);
		document.removeEventListener("touchmove", handleMoveToolMouseMove);
		moveToolSelectedHole = null;
		isDraggingHole = false;
	}

	// Remove bearing tool listeners
	if (!excluding.includes("bearingTool")) {
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		document.removeEventListener("mousemove", handleBearingToolMouseMove);
		document.removeEventListener("touchmove", handleBearingToolMouseMove);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}

	// Remove connector tool listeners
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Remove drawing tool listeners
	if (!excluding.includes("lineDrawing")) {
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		isDrawingLine = false;
		createNewEntity = true;
	}

	// Remove polygon drawing listeners
	if (!excluding.includes("polygonDrawing")) {
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		isDrawingPoly = false;
		createNewEntity = true;
	}

	// Remove point drawing listeners
	if (!excluding.includes("pointDrawing")) {
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		isDrawingPoint = false;
		createNewEntity = true;
	}

	// Remove text drawing listeners
	if (!excluding.includes("textDrawing")) {
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		isDrawingText = false;
		createNewEntity = true;
	}

	// Remove circle drawing listeners
	if (!excluding.includes("circleDrawing")) {
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		isDrawingCircle = false;
		createNewEntity = true;
	}

	// Remove ruler tool listeners
	if (!excluding.includes("rulerTool")) {
		canvas.removeEventListener("click", handleRulerClick);
		canvas.removeEventListener("touchstart", handleRulerClick);
		rulerStartPoint = null;
		rulerEndPoint = null;
		hideRulerPanel(); // Step #) Hide CSS ruler panel when tool is removed
	}

	// Remove ruler protractor listeners
	if (!excluding.includes("rulerProtractorTool")) {
		canvas.removeEventListener("click", handleRulerProtractorClick);
		canvas.removeEventListener("touchstart", handleRulerProtractorClick);
		rulerProtractorPoints = [];
		hideProtractorPanel(); // Step #) Hide CSS protractor panel when tool is removed
	}

	// Remove selection tool listeners
	if (!excluding.includes("selectPointerTool")) {
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		isSelectionPointerActive = false;
	}

	// Remove polygon selection listeners
	if (!excluding.includes("selectByPolygonTool")) {
		// Remove polygon listeners
		canvas.removeEventListener("click", selectInsidePolygon);
		canvas.removeEventListener("dblclick", completePolygonSelection);
		canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
		canvas.removeEventListener("mousemove", handlePolygonMouseMove);
		document.removeEventListener("mousemove", handlePolygonMouseMove);
		isPolygonSelectionActive = false;
	}

	// Remove the adding Pattern Listener
	if (!excluding.includes("addingPatternSwitch")) {
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		isAddingPattern = false;
	}

	// Remove the adding hole listener
	if (!excluding.includes("addingHoleSwitch")) {
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		isAddingHole = false;
	}

	// Remove pattern in polygon listeners
	if (!excluding.includes("patternInPolygonTool")) {
		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);
		isPatternInPolygonActive = false;
	}

	// Remove holes along line listeners
	if (!excluding.includes("holesAlongLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);
		isHolesAlongLineActive = false;
	}

	// Remove holes along poly line listeners
	if (!excluding.includes("holesAlongPolyLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);
		isHolesAlongPolyLineActive = false;
	}
	
	// Hide pattern tool HUD labels when any pattern tool is deactivated
	if (!excluding.includes("patternInPolygonTool") || !excluding.includes("holesAlongLineTool") || !excluding.includes("holesAlongPolyLineTool")) {
		hidePatternToolLabels();
	}

	// Remove measured length click listeners
	if (!excluding.includes("measuredLengthClick")) {
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
	}

	// Remove measured mass click listeners
	if (!excluding.includes("measuredMassClick")) {
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
	}

	// Remove measured comment click listeners
	if (!excluding.includes("measuredCommentClick")) {
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
	}

	// Remove edit blast name click listeners
	if (!excluding.includes("editBlastNameClick")) {
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
	}

	// Remove edit length with popup click listeners
	if (!excluding.includes("editLengthWithPopupClick")) {
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
	}

	// Remove edit hole type click listeners
	if (!excluding.includes("editHoleTypeClick")) {
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
	}

	// ? IMPORTANT: NEVER remove handleMouseMove or handleTouchMove here
	// These are intended to be persistent for basic mouse/touch tracking.
	if (!excluding.includes("defaultListeners")) {
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Do NOT remove handleMouseMove or handleTouchMove here!
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// document.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		// document.removeEventListener("touchmove", handleTouchMove);
	}

	// Reset tool-specific state variables that aren't excluded
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		isAddingConnector = false;
		isAddingMultiConnector = false;
		firstSelectedHole = null;
		secondSelectedHole = null;
	}

	// Reset drawing states if not excluded
	if (!excluding.includes("lineDrawing") && !excluding.includes("polygonDrawing") && !excluding.includes("pointDrawing") && !excluding.includes("textDrawing") && !excluding.includes("circleDrawing")) {
		createNewEntity = true;
	}
}

// Add a centralized function to clear all selection state
function clearAllSelectionState() {
	// Clear individual selections
	selectedPoint = null;
	selectedHole = null;
	selectedKADObject = null;
	selectedKADPolygon = null;
	selectedMultipleKADObjects = []; // Add this line
	// Clear multiple selections (with null safety)
	if (selectedMultipleHoles) {
		selectedMultipleHoles.length = 0; // Clear array but keep reference?
	} else {
		selectedMultipleHoles = [];
	}

	// Clear selected multiple KAD objects
	if (selectedMultipleKADObjects) {
		selectedMultipleKADObjects.length = 0;
	} else {
		selectedMultipleKADObjects = [];
	}

	// Clear timing window holes selected
	if (timingWindowHolesSelected) {
		timingWindowHolesSelected.length = 0;
	} else {
		timingWindowHolesSelected = [];
	}

	console.log("üßπ All selection state cleared");
}

// Step 7a) Function for TreeView to set selection state (bypasses window.* overwrite issue)
function setSelectionFromTreeView(selectionState) {
	// TreeView calls this instead of setting window.* directly
	// This ensures the local module variables are updated before exposeGlobalsToWindow() runs
	if (selectionState.selectedHole !== undefined) {
		selectedHole = selectionState.selectedHole;
	}
	if (selectionState.selectedMultipleHoles !== undefined) {
		selectedMultipleHoles = selectionState.selectedMultipleHoles;
	}
	if (selectionState.selectedKADObject !== undefined) {
		selectedKADObject = selectionState.selectedKADObject;
	}
	if (selectionState.selectedMultipleKADObjects !== undefined) {
		selectedMultipleKADObjects = selectionState.selectedMultipleKADObjects;
	}
	if (selectionState.selectedPoint !== undefined) {
		selectedPoint = selectionState.selectedPoint;
	}
	if (selectionState.selectedMultiplePoints !== undefined) {
		selectedMultiplePoints = selectionState.selectedMultiplePoints;
	}

	console.log("üìä [TreeView] Selection state updated:", {
		selectedKADObject: selectedKADObject ? selectedKADObject.entityName : null,
		selectedPoint: selectedPoint ? selectedPoint.pointID : null
	});
}

// Update resetFloatingToolbarButtons to only clear floating toolbar related booleans
function resetFloatingToolbarButtons(excluding) {
	// Clear only floating toolbar tool states
	isSelectionPointerActive = false;
	isPolygonSelectionActive = false;
	isHolesAlongPolyLineActive = false;
	isHolesAlongLineActive = false;
	isMoveToolActive = false;
	window.isMoveToolActive = false;
	isBearingToolActive = false;
	isRulerActive = false;
	isRulerProtractorActive = false;

	// ALSO clear connector tool states when switching floating toolbar tools
	isAddingConnector = false;
	isAddingMultiConnector = false;

	// CRITICAL: Remove move and bearing tool listeners when switching away
	if (excluding !== "moveToTool") {
		// Remove the 2D move tool listeners
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);

		//ALSO Remove from 3Dcanvas if it exists
		const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
		if (threeCanvas) {
			threeCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
			threeCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
			threeCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			threeCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			threeCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			threeCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		//clear move tool state
		moveToolSelectedHole = null;
		moveToolSelectedKAD = null;
		isDraggingHole = false;
		window.isdraggingHole = false;
		moveToolIn3DMode = false;
		dragPlaneZ = 0;
	}

	if (excluding !== "bearingTool") {
		// Remove the 2D bearing tool listeners
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}
	// Set all tool checkboxes to false except the excluded one
	selectPointerTool.checked = excluding === "selectPointerTool";
	selectByPolygonTool.checked = excluding === "selectByPolygonTool";
	moveToTool.checked = excluding === "moveToTool";
	tieConnectTool.checked = excluding === "tieConnectTool";
	tieConnectMultiTool.checked = excluding === "tieConnectMultiTool";
	addKADPointsTool.checked = excluding === "addKADPointsTool";
	addKADLineTool.checked = excluding === "addKADLineTool";
	addKADPolygonTool.checked = excluding === "addKADPolygonTool";
	addKADCircleTool.checked = excluding === "addKADCircleTool";
	addKADTextTool.checked = excluding === "addKADTextTool";
	triangulateTool.checked = excluding === "triangulateTool";
	bearingTool.checked = excluding === "bearingTool";
	rulerTool.checked = excluding === "rulerTool";
	rulerProtractorTool.checked = excluding === "rulerProtractorTool";
	patternInPolygonTool.checked = excluding === "patternInPolygonTool";
	holesAlongLineTool.checked = excluding === "holesAlongLineTool";
	holesAlongPolyLineTool.checked = excluding === "holesAlongPolyLineTool";
	// Step #) Sync holesAddingTool with null check (declared later in code)
	var holesAddingToolRef = document.getElementById("holesAddingTool");
	if (holesAddingToolRef) holesAddingToolRef.checked = excluding === "holesAddingTool";

	// ALSO uncheck connector buttons when switching floating toolbar tools
	if (excluding !== "tieConnectTool") {
		addConnectorButton.checked = false;
	}
	if (excluding !== "tieConnectMultiTool") {
		addMultiConnectorButton.checked = false;
	}
	// Step #) ALSO uncheck addHoleSwitch when switching away from holesAddingTool
	if (excluding !== "holesAddingTool") {
		addHoleSwitch.checked = false;
		isAddingHole = false;
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
	}

	// Set only the excluded tool's active state to true
	isSelectionPointerActive = excluding === "selectPointerTool";
	isPolygonSelectionActive = excluding === "selectByPolygonTool";
	isPatternInPolygonActive = excluding === "patternInPolygonTool";
	isHolesAlongLineActive = excluding === "holesAlongLineTool";
	isHolesAlongPolyLineActive = excluding === "holesAlongPolyLineTool";
	isMoveToolActive = excluding === "moveToTool";
	isBearingToolActive = excluding === "bearingTool";
	isRulerActive = excluding === "rulerTool";
	isRulerProtractorActive = excluding === "rulerProtractorTool";
	isAddKADPointsToolActive = excluding === "addKADPointsTool";
	isAddKADLineToolActive = excluding === "addKADLineTool";
	isAddKADPolygonToolActive = excluding === "addKADPolygonTool";
	isAddKADCircleToolActive = excluding === "addKADCircleTool";
	isAddKADTextToolActive = excluding === "addKADTextTool";
	isTriangulateToolActive = excluding === "triangulateTool";

	// Reset floating toolbar tool-specific state variables
	rulerStartPoint = null;
	rulerEndPoint = null;
	rulerProtractorPoints = [];
	hideRulerPanel(); // Step #) Hide CSS ruler panel when switching tools
	hideProtractorPanel(); // Step #) Hide CSS protractor panel when switching tools
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
	isDraggingHole = false;

	// Reset selection-related variables for floating toolbar tools
	firstSelectedHole = null;
	secondSelectedHole = null;

	// Remove connector event listeners when switching away from connector tools
	if (excluding !== "tieConnectTool" && excluding !== "tieConnectMultiTool") {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Force redraw to update button states
	drawData(allBlastHoles, selectedHole);
}

// Step 1) Function to clear all pending timers to prevent memory leaks
function clearAllPendingTimers() {
	// Step 1a) Clear debounced update tree view timer
	if (updateTreeViewTimeout) {
		clearTimeout(updateTreeViewTimeout);
		updateTreeViewTimeout = null;
	}
	// Step 1b) Clear debounced save KAD timer
	if (saveTimeout) {
		clearTimeout(saveTimeout);
		saveTimeout = null;
	}
	// Step 1c) Clear debounced save holes timer
	if (holesSaveTimeout) {
		clearTimeout(holesSaveTimeout);
		holesSaveTimeout = null;
	}
	// Step 1d) Clear animation interval if exists
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}
	// Step 1e) Clear animation frame if exists
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
		animationFrameId = null;
	}
}

// Step 2) Function to clear all data structures to prevent memory leaks
function clearAllDataStructures() {
	// Step 2a) Clear KAD drawings map
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap) {
		allKADDrawingsMap.clear();
	}
	// Step 2b) Clear loaded surfaces map
	if (typeof loadedSurfaces !== "undefined" && loadedSurfaces) {
		loadedSurfaces.clear();
	}
	// Step 2c) Clear loaded images map
	if (typeof loadedImages !== "undefined" && loadedImages) {
		loadedImages.clear();
	}
	// Step 2d) Clear blast holes array
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.length = 0;
	}
}

// Step 3) Centralized cleanup function to prevent memory leaks
// Call this on page unload, data clear, and error recovery
function cleanupAllResources() {
	console.log("üßπ Starting comprehensive resource cleanup...");

	// Step 3a) Clear all pending timers
	clearAllPendingTimers();

	// Step 3b) Clear all data structures
	clearAllDataStructures();

	// Step 3c) Dispose CameraControls if it exists
	if (cameraControls) {
		try {
			cameraControls.dispose();
		} catch (disposeError) {
			console.warn("üö® Failed to dispose cameraControls:", disposeError);
		}
		cameraControls = null;
	}

	// Step 3d) Dispose Three.js renderer if it exists
	if (threeRenderer) {
		try {
			threeRenderer.dispose();
		} catch (disposeError) {
			console.warn("üö® Failed to dispose threeRenderer:", disposeError);
		}
		threeRenderer = null;
	}

	// Step 3e) Dispose interaction manager if it exists
	if (interactionManager) {
		try {
			if (typeof interactionManager.dispose === "function") {
				interactionManager.dispose();
			}
		} catch (disposeError) {
			console.warn("‚ùå Failed to dispose interactionManager:", disposeError);
		}
		interactionManager = null;
	}

	// Step 3f) Reset initialization flags
	threeInitialized = false;
	threeInitializationFailed = false;

	console.log("üßπ Resource cleanup completed");
}
// Step 3h) Force Three.js re-initialization (call after cleanupAllResources)
function forceThreeJSReset() {
	console.log("üîÑ Forcing Three.js reset and re-initialization...");

	// Step 1) Clean up all resources first
	cleanupAllResources();

	// Step 2) Wait for cleanup to complete (browser needs time to release contexts)
	setTimeout(function () {
		console.log("üßπ Cleanup complete, attempting re-initialization...");

		// Step 3) Try to initialize again
		initializeThreeJS()
			.then(function () {
				console.log("üîÑ Three.js re-initialized successfully!");
				// Step 4) Redraw existing data
				if (allBlastHoles && allBlastHoles.length > 0) {
					drawData();
				}
			})
			.catch(function (error) {
				console.error("‚ùå Re-initialization failed:", error);
				alert("WebGL initialization failed. Try:\n\n1. Refresh the page (F5)\n2. Close other browser tabs\n3. Close and reopen browser\n4. Update graphics drivers");
			});
	}, 500); // Wait 500ms for browser to release contexts
}

// Step 3i) Expose to window for console access
window.forceThreeJSReset = forceThreeJSReset;
// Master function to reset everything
function resetAppToDefaults() {
	// Step 3) Clear all pending timers before reset
	clearAllPendingTimers();
	// Step 4) Clear all data structures before reset
	clearAllDataStructures();
	setAllBoolsToFalse();
	resetSwitchesTogglesOptionalDisplay(true);
	resetAllSelectedStores();
	resetFloatingToolbarButtons("none");
	console.log("App reset to defaults: booleans, switches, toggles, stores, and data structures cleared");
}

// Buttons
document.getElementById("deletePointButton").addEventListener("click", deleteSelectedPoint);
document.getElementById("deleteObjectButton").addEventListener("click", deleteSelectedObject);
document.getElementById("deleteAllButton").addEventListener("click", deleteSelectedAll);
document.getElementById("fileInput").addEventListener("change", handleFileUpload);
document.getElementById("fileInputDXF").addEventListener("change", handleDXFUpload);
document.getElementById("fileInputMeasured").addEventListener("change", handleMeasuredUpload);
document.getElementById("fileInputSurface").addEventListener("change", handleSurfaceUpload);
document.getElementById("fileInputGeotiff").addEventListener("change", handleGeotiffUpload);
document.getElementById("helpButton").addEventListener("click", openHelp);
document.getElementById("zoomInButton").addEventListener("click", zoomIn);
document.getElementById("zoomOutButton").addEventListener("click", zoomOut);
// document.getElementById("resetZoomButton").addEventListener("click", resetZoom);
document.getElementById("deleteHoleButton").addEventListener("click", deleteSelectedHoles);

// Print event listeners
document.addEventListener("DOMContentLoaded", function () {
	// Setup print event handlers - pass a function that returns fresh context
	// This ensures we always get current data values when printing
	setupPrintEventHandlers(() => ({
		updateStatusMessage: updateStatusMessage,
		drawData: () => drawData(allBlastHoles, selectedHole),
		allBlastHoles: allBlastHoles,
		allKADDrawingsMap: allKADDrawingsMap,
		allAvailableSurfaces: allAvailableSurfaces,
		selectedHole: selectedHole,
		canvas: canvas,
		currentScale: currentScale,
		centroidX: centroidX,
		centroidY: centroidY,
		imageVisible: imageVisible,
		surfaceVisible: surfaceVisible,
		getDisplayOptions: getDisplayOptions,
		buildHoleMap: buildHoleMap,
		developerModeEnabled: developerModeEnabled,
		simplifyByPxDist: simplifyByPxDist,
		worldToCanvas: worldToCanvas,
		delaunayTriangles: delaunayTriangles,
		maxEdgeLength: maxEdgeLength,
		createBlastBoundaryPolygon: createBlastBoundaryPolygon,
		offsetPolygonClipper: offsetPolygonClipper,
		getAverageDistance: getAverageDistance,
		selectedVoronoiMetric: selectedVoronoiMetric,
		isVoronoiLegendFixed: isVoronoiLegendFixed,
		getVoronoiMetrics: getVoronoiMetrics,
		useToeLocation: useToeLocation,
		clipVoronoiCells: clipVoronoiCells,
		getPFColor: getPFColor,
		getMassColor: getMassColor,
		getVolumeColor: getVolumeColor,
		getAreaColor: getAreaColor,
		getLengthColor: getLengthColor,
		getHoleFiringTimeColor: getHoleFiringTimeColor,
		strokeColor: strokeColor,
		directionArrows: directionArrows,
		contourLinesArray: contourLinesArray,
		firstMovementSize: firstMovementSize,
		currentFontSize: currentFontSize,
		holeScale: holeScale,
		transparentFillColor: transparentFillColor,
		textFillColor: textFillColor,
		fillColor: fillColor,
		depthColor: depthColor,
		angleDipColor: angleDipColor,
		isAddingConnector: isAddingConnector,
		isAddingMultiConnector: isAddingMultiConnector,
		fromHoleStore: fromHoleStore,
		firstSelectedHole: firstSelectedHole,
		secondSelectedHole: secondSelectedHole,
		selectedMultipleHoles: selectedMultipleHoles,
		loadedSurfaces: loadedSurfaces,
		showSurfaceLegend: showSurfaceLegend,
		elevationToColor: elevationToColor,
		currentGradient: currentGradient,
		surfaceTextureData: surfaceTextureData,
		loadedImages: loadedImages,
		buildVersion: buildVersion,
		showModalMessage: showModalMessage,
		FloatingDialog: FloatingDialog,
		getDipAngle: getDipAngle,
		currentRotation: currentRotation,
		// Step) 3D printing support - ThreeJS renderer and camera controls
		threeRenderer: threeRenderer,
		cameraControls: cameraControls,
		darkModeEnabled: darkModeEnabled,
	}));
});
document.getElementById("deletePatternButton").addEventListener("click", deleteSelectedPattern);
document.getElementById("deleteAllPatternsButton").addEventListener("click", deleteSelectedAllPatterns);

const displayHoleId = document.getElementById("display1"); //holeID
const displayHoleLength = document.getElementById("display2"); //holeLength
const displayHoleDiameter = document.getElementById("display2A"); //holeDiameter
const displayHoleAngle = document.getElementById("display3"); //holeAngle
const displayHoleDip = document.getElementById("display4"); //holeDip
const displayHoleBearing = document.getElementById("display5"); //holeBearing
const displayHoleSubdrill = document.getElementById("display5B"); //subdrill
const displayConnectors = document.getElementById("display5A"); //connectors
const displayDelays = document.getElementById("display6"); //delays
const displayTimes = document.getElementById("display6A"); //times only
const displayContours = document.getElementById("display8"); //contours
const displaySlope = document.getElementById("display8A"); //slope
const displayRelief = document.getElementById("display8B"); //relief
const displayFirstMovements = document.getElementById("display8C"); //direction
const displayXLocation = document.getElementById("display9"); //xlocation
const displayYLocation = document.getElementById("display10"); //ylocation
const displayElevation = document.getElementById("display11"); //zlocation
const displayHoleType = document.getElementById("display12"); //holeType
const displayMLength = document.getElementById("display13"); //holeLength
const displayMMass = document.getElementById("display14"); //holeMass
const displayMComment = document.getElementById("display15"); //holeComment
const displayVoronoiCells = document.getElementById("display16"); //voronoi
const displayRowAndPosId = document.getElementById("rowAndPosDisplay"); //Developer mode Row and Position Display

// after const option16 = ?
const allToggles = [displayHoleId, displayHoleLength, displayHoleDiameter, displayHoleAngle, displayHoleDip, displayHoleBearing, displayHoleSubdrill, displayConnectors, displayDelays, displayTimes, displayContours, displaySlope, displayRelief, displayFirstMovements, displayXLocation, displayYLocation, displayElevation, displayHoleType, displayMLength, displayMMass, displayMComment, displayVoronoiCells, displayRowAndPosId];

allToggles.forEach((opt) => {
	if (opt)
		opt.addEventListener("change", () => {
			// assuming drawData is your main render function
			drawData(allBlastHoles, selectedHole);
		});
});

const holeCountRadio = document.getElementById("holeCountRadio");
const measuredMassRadio = document.getElementById("measuredMassRadio");

//create holeCountRadio and measureMassRadio Listener
document.getElementById("measuredMassRadio")?.addEventListener("change", timeChart);
document.getElementById("holeCountRadio")?.addEventListener("change", timeChart);

// Add event listeners for mouse down, move, and up events
canvas.addEventListener("mousedown", handleMouseDown);
// canvas.addEventListener("mousemove", handleMouseMove);
canvas.addEventListener("mouseup", handleMouseUp);
// Add event listeners for touch start, move, and end events
canvas.addEventListener("touchstart", handleTouchStart, {
	passive: false,
});
// canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd, {
	passive: false,
});

// Event listener for the language dropdown
document.getElementById("languageSelect").addEventListener("change", function () {
	const selectedLanguage = this.value;
	updateTranslations(selectedLanguage);
});

// Function to update translations
function updateTranslations(language) {
	// Use the inline translations object
	const langTranslations = translations[language]?.translation;

	if (langTranslations) {
		// Update the text content of elements in the DOM with null checks
		const titleElement = document.querySelector("title");
		if (titleElement) titleElement.textContent = langTranslations.title;

		const helpButton = document.querySelector("#helpButton");
		if (helpButton) helpButton.title = langTranslations.help_button;

		const zoomInButton = document.querySelector("#zoomInButton");
		if (zoomInButton) zoomInButton.title = langTranslations.zoom_in_button;

		const zoomOutButton = document.querySelector("#zoomOutButton");
		if (zoomOutButton) zoomOutButton.title = langTranslations.zoom_out_button;

		const buttonGoBack = document.querySelector("#buttonGoBack");
		if (buttonGoBack) buttonGoBack.title = langTranslations.go_back_button;

		const languageSelect = document.querySelector("#languageSelect");
		if (languageSelect) languageSelect.title = langTranslations.select_language;

		const darkModeToggle = document.querySelector("#dark-mode-toggle");
		if (darkModeToggle) darkModeToggle.placeholder = langTranslations.dark_mode;

		// Display option tooltips
		const display1Label = document.querySelector("label[for='display1']");
		if (display1Label) display1Label.title = langTranslations.display_hole_id_title;

		const display2Label = document.querySelector("label[for='display2']");
		if (display2Label) display2Label.title = langTranslations.display_hole_length_title;

		const display2ALabel = document.querySelector("label[for='display2A']");
		if (display2ALabel) display2ALabel.title = langTranslations.display_hole_diameter_title;

		const display3Label = document.querySelector("label[for='display3']");
		if (display3Label) display3Label.title = langTranslations.display_angle_title;

		const display4Label = document.querySelector("label[for='display4']");
		if (display4Label) display4Label.title = langTranslations.display_dip_title;

		const display5Label = document.querySelector("label[for='display5']");
		if (display5Label) display5Label.title = langTranslations.display_bearing_title;

		const display5BLabel = document.querySelector("label[for='display5B']");
		if (display5BLabel) display5BLabel.title = langTranslations.display_subdrill_title;

		const display5ALabel = document.querySelector("label[for='display5A']");
		if (display5ALabel) display5ALabel.title = langTranslations.display_ties_title;

		const display6Label = document.querySelector("label[for='display6']");
		if (display6Label) display6Label.title = langTranslations.display_connectors_title;

		const display6ALabel = document.querySelector("label[for='display6A']");
		if (display6ALabel) display6ALabel.title = langTranslations.display_times_only_title;

		const display8Label = document.querySelector("label[for='display8']");
		if (display8Label) display8Label.title = langTranslations.display_contours_title;

		const display8ALabel = document.querySelector("label[for='display8A']");
		if (display8ALabel) display8ALabel.title = langTranslations.display_slope_title;

		const display8BLabel = document.querySelector("label[for='display8B']");
		if (display8BLabel) display8BLabel.title = langTranslations.display_relief_title;

		const display8CLabel = document.querySelector("label[for='display8C']");
		if (display8CLabel) display8CLabel.title = langTranslations.display_direction_title;

		const display9Label = document.querySelector("label[for='display9']");
		if (display9Label) display9Label.title = langTranslations.display_xlocation_title;

		const display10Label = document.querySelector("label[for='display10']");
		if (display10Label) display10Label.title = langTranslations.display_ylocation_title;

		const display11Label = document.querySelector("label[for='display11']");
		if (display11Label) display11Label.title = langTranslations.display_zlocation_title;

		const display12Label = document.querySelector("label[for='display12']");
		if (display12Label) display12Label.title = langTranslations.display_hole_type_title;

		const display13Label = document.querySelector("label[for='display13']");
		if (display13Label) display13Label.title = langTranslations.display_measure_title;

		const display14Label = document.querySelector("label[for='display14']");
		if (display14Label) display14Label.title = langTranslations.display_mass_title;

		const display15Label = document.querySelector("label[for='display15']");
		if (display15Label) display15Label.title = langTranslations.display_comment_title;

		const display16Label = document.querySelector("label[for='display16']");
		if (display16Label) display16Label.title = langTranslations.display_voronoi_title;

		// Left panel sections
		const openOrImportAcc = document.querySelector("#openOrImportAcc span");
		if (openOrImportAcc) openOrImportAcc.textContent = langTranslations.open_import;

		// File input icon button titles
		const fileInputBtns = document.querySelectorAll(".file-import-btn");
		fileInputBtns.forEach((btn) => {
			const target = btn.getAttribute("data-target");
			if (target === "fileInput") btn.title = langTranslations.file_holes_kad_title;
			if (target === "fileInputCustomCSV") btn.title = langTranslations.custom_csv_title;
			if (target === "fileInputDXF") btn.title = langTranslations.file_dxf_title;
			if (target === "fileInputMeasured") btn.title = langTranslations.measured_values_title;
			if (target === "fileInputSurface") btn.title = langTranslations.file_surface_title;
			if (target === "fileInputGeotiff") btn.title = langTranslations.file_geotiff_title;
		});

		// File input alt text
		const fileInputImgs = document.querySelectorAll(".file-import-btn img");
		fileInputImgs.forEach((img) => {
			const alt = img.getAttribute("alt");
			if (alt === "Load Holes & KAD") img.alt = langTranslations.load_holes_kad_alt;
			if (alt === "Load CSV") img.alt = langTranslations.load_csv_alt;
			if (alt === "Load DXF") img.alt = langTranslations.load_dxf_alt;
			if (alt === "Load Measured Values") img.alt = langTranslations.load_measured_alt;
			if (alt === "Load Surface") img.alt = langTranslations.load_surface_alt;
			if (alt === "Load Geotiff") img.alt = langTranslations.load_geotiff_alt;
		});

		const plusorminusHolesAcc = document.querySelector("#plusorminusHolesAcc span");
		if (plusorminusHolesAcc) plusorminusHolesAcc.textContent = langTranslations.plus_minus_holes;

		const addPatternLabel = document.querySelector("#addPatternLabel");
		if (addPatternLabel) addPatternLabel.textContent = langTranslations.add_pattern_label;

		const addHoleLabel = document.querySelector("#addHoleLabel");
		if (addHoleLabel) addHoleLabel.textContent = langTranslations.add_hole_label;

		const deleteHoleLabel = document.querySelector("#deleteHoleLabel");
		if (deleteHoleLabel) deleteHoleLabel.textContent = langTranslations.delete_label;

		const deleteHoleButton = document.querySelector("#deleteHoleButton");
		if (deleteHoleButton) deleteHoleButton.textContent = langTranslations.delete_hole_button;

		const deletePatternButton = document.querySelector("#deletePatternButton");
		if (deletePatternButton) deletePatternButton.textContent = langTranslations.delete_pattern_button;

		const deleteAllPatternsButton = document.querySelector("#deleteAllPatternsButton");
		if (deleteAllPatternsButton) deleteAllPatternsButton.textContent = langTranslations.delete_all_patterns_button;

		const renumberHolesLabel = document.querySelector("label[for='renumberHoles']");
		if (renumberHolesLabel) renumberHolesLabel.textContent = langTranslations.renumber_holes_label;

		const deleteRenumberStartLabel = document.querySelector("label[for='deleteRenumberStart']");
		if (deleteRenumberStartLabel) deleteRenumberStartLabel.textContent = langTranslations.delete_renumber_start_label;

		const editHolesAcc = document.querySelector("#editHolesAcc span");
		if (editHolesAcc) editHolesAcc.textContent = langTranslations.edit_holes;

		const editBlastNameLabel = document.querySelector("#editBlastNameLabel");
		if (editBlastNameLabel) editBlastNameLabel.textContent = langTranslations.edit_blast_name_label;

		const editLengthPopupLabel = document.querySelector("#editLengthPopupLabel");
		if (editLengthPopupLabel) editLengthPopupLabel.textContent = langTranslations.edit_length_popup_label;

		const editHoleTypePopupLabel = document.querySelector("#editHoleTypePopupLabel");
		if (editHoleTypePopupLabel) editHoleTypePopupLabel.textContent = langTranslations.edit_hole_type_popup_label;

		const selectionModeLabels = document.querySelectorAll("#selectionModeLabel");
		selectionModeLabels.forEach((label, index) => {
			if (index === 0) label.textContent = langTranslations.allow_holes_edited;
			if (index === 1) label.textContent = langTranslations.selection_mode_label;
		});

		const holeEastingLabel = document.querySelector("#holeEastingLabel");
		if (holeEastingLabel) holeEastingLabel.textContent = langTranslations.hole_easting_label;

		const holeNorthingLabel = document.querySelector("#holeNorthingLabel");
		if (holeNorthingLabel) holeNorthingLabel.textContent = langTranslations.hole_northing_label;

		const holeElevationLabel = document.querySelector("#holeElevationLabel");
		if (holeElevationLabel) holeElevationLabel.textContent = langTranslations.hole_elevation_label;

		const holeDiameterLabel = document.querySelector("#holeDiameterLabel");
		if (holeDiameterLabel) holeDiameterLabel.textContent = langTranslations.hole_diameter_label;

		const holeLengthLabel = document.querySelector("#holeLengthLabel");
		if (holeLengthLabel) holeLengthLabel.textContent = langTranslations.hole_length_label;

		const holeAngleLabel = document.querySelector("#holeAngleLabel");
		if (holeAngleLabel) holeAngleLabel.textContent = langTranslations.hole_angle_label;

		const holeBearingLabel = document.querySelector("#holeBearingLabel");
		if (holeBearingLabel) holeBearingLabel.textContent = langTranslations.hole_bearing_label;

		const holeSubdrillLabel = document.querySelector("#holeSubdrillLabel");
		if (holeSubdrillLabel) holeSubdrillLabel.textContent = langTranslations.hole_subdrill_label;

		const recordActualsAcc = document.querySelector("#recordActualsAcc span");
		if (recordActualsAcc) recordActualsAcc.textContent = langTranslations.record_actuals;

		const recordLengthPopupLabel = document.querySelector("#recordLengthPopupLabel");
		if (recordLengthPopupLabel) recordLengthPopupLabel.textContent = langTranslations.record_length_popup_label;

		const editMassPopupLabel = document.querySelector("#editMassPopupLabel");
		if (editMassPopupLabel) editMassPopupLabel.textContent = langTranslations.record_mass_popup_label;

		const recordCommentPopupLabel = document.querySelector("#recordCommentPopupLabel");
		if (recordCommentPopupLabel) recordCommentPopupLabel.textContent = langTranslations.record_comment_popup_label;

		const viewControlsAcc = document.querySelector("#viewControlsAcc span");
		if (viewControlsAcc) viewControlsAcc.textContent = langTranslations.view_controls;

		const fontLabel = document.querySelector("#fontLabel");
		if (fontLabel) fontLabel.textContent = langTranslations.font_size_label;

		const connLabel = document.querySelector("#connLabel");
		if (connLabel) connLabel.textContent = langTranslations.tie_size_label;

		const toeLabel = document.querySelector("#toeLabel");
		if (toeLabel) toeLabel.textContent = langTranslations.toe_size_label;

		const holeLabel = document.querySelector("#holeLabel");
		if (holeLabel) holeLabel.textContent = langTranslations.hole_adjust_label;

		const intervalLabel = document.querySelector("#intervalLabel");
		if (intervalLabel) intervalLabel.textContent = langTranslations.interval_label;

		const firstMovementLabel = document.querySelector("#firstMovementLabel");
		if (firstMovementLabel) firstMovementLabel.textContent = langTranslations.first_movement_label;

		const snapToleranceLabel = document.querySelector("#snapToleranceLabel");
		if (snapToleranceLabel) snapToleranceLabel.textContent = langTranslations.snap_tolerance_label;

		const outputfilesAcc = document.querySelector("#outputfilesAcc span");
		if (outputfilesAcc) outputfilesAcc.textContent = langTranslations.output_files;

		const label_saveHoles = document.querySelector("#label_saveHoles");
		if (label_saveHoles) label_saveHoles.textContent = langTranslations.save_holes_label;

		const saveHoles = document.querySelector("#saveHoles");
		if (saveHoles) saveHoles.textContent = langTranslations.save_holes_button;

		const label_saveKAD = document.querySelector("#label_saveKAD");
		if (label_saveKAD) label_saveKAD.textContent = langTranslations.save_kad_label;

		const saveKAD = document.querySelector("#saveKAD");
		if (saveKAD) saveKAD.textContent = langTranslations.save_kad_button;

		const label_saveAll = document.querySelector("#label_saveAll");
		if (label_saveAll) label_saveAll.textContent = langTranslations.save_all_label;

		const saveAll = document.querySelector("#saveAll");
		if (saveAll) saveAll.textContent = langTranslations.save_all_button;

		const label_saveMeasures = document.querySelector("#label_saveMeasures");
		if (label_saveMeasures) label_saveMeasures.textContent = langTranslations.save_measures_label;

		const saveMeasures = document.querySelector("#saveMeasures");
		if (saveMeasures) saveMeasures.textContent = langTranslations.save_measures_button;

		const label_exportHolesDXF = document.querySelector("#label_exportHolesDXF");
		if (label_exportHolesDXF) label_exportHolesDXF.textContent = langTranslations.export_holes_dxf_label;

		const exportHolesDXF = document.querySelector("#exportHolesDXF");
		if (exportHolesDXF) exportHolesDXF.textContent = langTranslations.export_holes_dxf_button;

		const label_exportDrawingDXF = document.querySelector("#label_exportDrawingDXF");
		if (label_exportDrawingDXF) label_exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_label;

		const exportDrawingDXF = document.querySelector("#exportDrawingDXF");
		if (exportDrawingDXF) exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_button;

		const label_saveIREDES = document.querySelector("#label_saveIREDES");
		if (label_saveIREDES) label_saveIREDES.textContent = langTranslations.export_epiroc_label;

		const saveIREDES = document.querySelector("#saveIREDES");
		if (saveIREDES) saveIREDES.textContent = langTranslations.export_epiroc_button;

		const label_saveAQM = document.querySelector("#label_saveAQM");
		if (label_saveAQM) label_saveAQM.textContent = langTranslations.export_minestar_label;

		const saveAQM = document.querySelector("#saveAQM");
		if (saveAQM) saveAQM.textContent = langTranslations.export_minestar_button;

		const aboutAcc = document.querySelector("#aboutAcc span");
		if (aboutAcc) aboutAcc.textContent = langTranslations.about_title;

		const developerModeLabel = document.querySelector("label[for='developerMode']");
		if (developerModeLabel) developerModeLabel.textContent = langTranslations.developer_mode;

		const connectorsAcc = document.querySelector("#connectorsAcc span");
		if (connectorsAcc) connectorsAcc.textContent = langTranslations.connectors;

		const singleTie = document.querySelector("#singleTie");
		if (singleTie) singleTie.textContent = langTranslations.single_tie_label;

		const multiTie = document.querySelector("#multiTie");
		if (multiTie) multiTie.textContent = langTranslations.multi_tie_label;

		const delayLabel = document.querySelector("#delayLabel");
		if (delayLabel) delayLabel.textContent = langTranslations.delay_label;

		jscolor.install();
		const connectorColor = document.querySelector("#connectorColor");
		if (connectorColor) connectorColor.textContent = langTranslations.color_label;
		if (connectorColor.jscolor) {
			// Step #) Set the color programmatically
			connectorColor.jscolor.fromString("#00FF00");

			// Step #) Get the current color as hex
			var currentColor = connectorColor.jscolor.toHEXString();

			// Step #) Set jscolor options (optional)
			connectorColor.jscolor.option("width", 80);
			connectorColor.jscolor.option("height", 30);

			// Step #) You can also add event handlers if needed
			connectorColor.jscolor.option("onInput", function () {
				// Do something when the color changes
				// Example: update a preview or save to localStorage
			});
		}

		const connectLabel = document.querySelector("#connectLabel");
		if (connectLabel) connectLabel.textContent = langTranslations.connect_distance_label;

		const animateAcc = document.querySelector("#animateAcc span");
		if (animateAcc) animateAcc.textContent = langTranslations.animate_firing;

		const play = document.querySelector("#play");
		if (play) play.textContent = langTranslations.play_button;

		const stop = document.querySelector("#stop");
		if (stop) stop.textContent = langTranslations.stop_button;

		const timeWindowAcc = document.querySelector("#timeWindowAcc span");
		if (timeWindowAcc) timeWindowAcc.textContent = langTranslations.time_window;

		const timeRangeLabel = document.querySelector("#timeRangeLabel");
		if (timeRangeLabel) timeRangeLabel.textContent = langTranslations.time_range_label;

		const timeOffsetLabel = document.querySelector("#timeOffsetLabel");
		if (timeOffsetLabel) timeOffsetLabel.textContent = langTranslations.time_offset_label;

		const holeCountLabel = document.querySelector("#holeCountLabel");
		if (holeCountLabel) holeCountLabel.textContent = langTranslations.hole_count_label;

		const measuredMassLabel = document.querySelector("#measuredMassLabel");
		if (measuredMassLabel) measuredMassLabel.textContent = langTranslations.measured_mass_label;

		const drawingTools = document.querySelector("#drawingTools span");
		if (drawingTools) drawingTools.textContent = langTranslations.drawing_tools;

		const elevationName = document.querySelector("#elevationName");
		if (elevationName) elevationName.textContent = langTranslations.elevation_label;

		const colorLabel = document.querySelector("#colorLabel");
		if (colorLabel) colorLabel.textContent = langTranslations.drawing_color_label;

		const lineWidthLabel = document.querySelector("#lineWidthLabel");
		if (lineWidthLabel) lineWidthLabel.textContent = langTranslations.line_width_label;

		const pointDraw = document.querySelector("#pointDraw");
		if (pointDraw) pointDraw.textContent = langTranslations.point_draw_label;

		const lineDraw = document.querySelector("#lineDraw");
		if (lineDraw) lineDraw.textContent = langTranslations.line_draw_label;

		const polyDraw = document.querySelector("#polyDraw");
		if (polyDraw) polyDraw.textContent = langTranslations.poly_draw_label;

		const circleDraw = document.querySelector("#circleDraw");
		if (circleDraw) circleDraw.textContent = langTranslations.circle_draw_label;

		const drawingRadiusLabel = document.querySelector("#drawingRadiusLabel");
		if (drawingRadiusLabel) drawingRadiusLabel.textContent = langTranslations.drawing_radius_label;

		const textDraw = document.querySelector("#textDraw");
		if (textDraw) textDraw.textContent = langTranslations.text_draw_label;

		const textLabel = document.querySelector("#textLabel");
		if (textLabel) textLabel.textContent = langTranslations.text_label;

		const commonMath1 = document.querySelector("#commonMath1");
		if (commonMath1) commonMath1.textContent = langTranslations.common_math_label;

		const commonMath2 = document.querySelector("#commonMath2");
		if (commonMath2) commonMath2.innerHTML = langTranslations.common_math_examples;

		const createRadiiFromBlastHoles = document.querySelector("#createRadiiFromBlastHoles");
		if (createRadiiFromBlastHoles) createRadiiFromBlastHoles.textContent = langTranslations.create_radii_button;

		const radiiStepsLabel = document.querySelector("#radiiStepsLabel");
		if (radiiStepsLabel) radiiStepsLabel.textContent = langTranslations.radii_steps_label;

		const drawingPolygonRadiusLabel = document.querySelector("#drawingPolygonRadiusLabel");
		if (drawingPolygonRadiusLabel) drawingPolygonRadiusLabel.textContent = langTranslations.drawing_polygon_radius_label;

		const drawingRemovalAcc = document.querySelector("#drawingRemovalAcc span");
		if (drawingRemovalAcc) drawingRemovalAcc.textContent = langTranslations.drawing_removal;

		const pointDeleteLabel = document.querySelector("#pointDeleteLabel");
		if (pointDeleteLabel) pointDeleteLabel.textContent = langTranslations.drawing_delete_label;

		const deletePointButton = document.querySelector("#deletePointButton");
		if (deletePointButton) deletePointButton.textContent = langTranslations.delete_point_button;

		const deleteObjectButton = document.querySelector("#deleteObjectButton");
		if (deleteObjectButton) deleteObjectButton.textContent = langTranslations.delete_object_button;

		const deleteAllButton = document.querySelector("#deleteAllButton");
		if (deleteAllButton) deleteAllButton.textContent = langTranslations.delete_all_button;

		const voronoiOptionsAcc = document.querySelector("#voronoiOptionsAcc span");
		if (voronoiOptionsAcc) voronoiOptionsAcc.textContent = langTranslations.voronoi_options;

		const voronoiLabel = document.querySelector("#voronoiLabel");
		if (voronoiLabel) voronoiLabel.textContent = langTranslations.voronoi_display_label;

		const voronoiLegendLabel = document.querySelector("#voronoiLegendLabel");
		if (voronoiLegendLabel) voronoiLegendLabel.textContent = langTranslations.voronoi_legend_label;

		const voronoiBoundaryLabel = document.querySelector("#voronoiBoundaryLabel");
		if (voronoiBoundaryLabel) voronoiBoundaryLabel.textContent = langTranslations.voronoi_boundary_label;

		// Update select options
		const voronoiSelect = document.querySelector("#voronoiSelect");
		if (voronoiSelect) {
			const options = voronoiSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "powderFactor":
						option.textContent = langTranslations.powder_factor;
						break;
					case "mass":
						option.textContent = langTranslations.mass;
						break;
					case "volume":
						option.textContent = langTranslations.volume;
						break;
					case "area":
						option.textContent = langTranslations.area;
						break;
					case "measuredLength":
						option.textContent = langTranslations.measured_length;
						break;
					case "designedLength":
						option.textContent = langTranslations.designed_length;
						break;
					case "holeFiringTime":
						option.textContent = langTranslations.hole_firing_time;
						break;
					case "heelanVibration":
						option.textContent = langTranslations.heelan_vibration;
						break;
					case "unknown":
						option.textContent = langTranslations.unknown;
						break;
				}
			});
		}

		// Update legend select options
		const voronoiLegendSelect = document.querySelector("#voronoiLegendSelect");
		if (voronoiLegendSelect) {
			const options = voronoiLegendSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "minmax":
						option.textContent = langTranslations.min_max;
						break;
					case "fixed":
						option.textContent = langTranslations.fixed;
						break;
				}
			});
		}

		const buymeaCoffeeLabel = document.querySelector("#buymeacoffeelabel");
		if (buymeaCoffeeLabel) buymeaCoffeeLabel.textContent = langTranslations.buy_coffee_alt;

		const bugButton = document.querySelector("#bugButton");
		if (bugButton) bugButton.textContent = langTranslations.report_bug_button;

		// Floating toolbar
		const dragLabel = document.querySelector("#dragLabel");
		if (dragLabel) dragLabel.textContent = langTranslations.drag_label;

		const selectLabel = document.querySelector("#selectLabel");
		if (selectLabel) selectLabel.textContent = langTranslations.select_label;

		const selectPointerLabel = document.querySelector("label[for='selectPointer']");
		if (selectPointerLabel) selectPointerLabel.title = langTranslations.select_pointer;

		const selectByPolygonLabel = document.querySelector("label[for='selectByPolygon']");
		if (selectByPolygonLabel) selectByPolygonLabel.title = langTranslations.select_by_polygon;

		const createLabel = document.querySelector("#createLabel");
		if (createLabel) createLabel.textContent = langTranslations.create_label;

		const patternInPolygonLabel = document.querySelector("label[for='patternInPolygonTool']");
		if (patternInPolygonLabel) patternInPolygonLabel.title = langTranslations.pattern_in_polygon;

		const holesAlongLineLabel = document.querySelector("label[for='holesAlongLineTool']");
		if (holesAlongLineLabel) holesAlongLineLabel.title = langTranslations.holes_along_line;

		const holesAlongPolyLineLabel = document.querySelector("label[for='holesAlongPolyLineTool']");
		if (holesAlongPolyLineLabel) holesAlongPolyLineLabel.title = langTranslations.holes_along_polyline;

		// Triangulation tool translations
		const triangulateLabel = document.querySelector("#triangulateLabel");
		if (triangulateLabel) triangulateLabel.textContent = langTranslations.triangulate_label;

		const triangulateTool = document.querySelector("label[for='triangulateTool']");
		if (triangulateTool) triangulateTool.title = langTranslations.triangulate_tooltip;

		// drawing tool translations
		const drawLabel = document.querySelector("#addKADLabel");
		if (drawLabel) drawLabel.textContent = langTranslations.draw_label;

		const addKADPointsTool = document.querySelector("label[for='addKADPointsTool']");
		if (addKADPointsTool) addKADPointsTool.title = langTranslations.add_kad_points_tooltip;

		const addKADLineTool = document.querySelector("label[for='addKADLineTool']");
		if (addKADLineTool) addKADLineTool.title = langTranslations.add_kad_line_tooltip;

		const addKADPolygonTool = document.querySelector("label[for='addKADPolygonTool']");
		if (addKADPolygonTool) addKADPolygonTool.title = langTranslations.add_kad_polygon_tooltip;

		const addKADCircleTool = document.querySelector("label[for='addKADCircleTool']");
		if (addKADCircleTool) addKADCircleTool.title = langTranslations.add_kad_circle_tooltip;

		const addKADTextTool = document.querySelector("label[for='addKADTextTool']");
		if (addKADTextTool) addKADTextTool.title = langTranslations.add_kad_text_tooltip;

		// Modify Section
		const modifyLabel = document.querySelector("#modifyLabel");
		if (modifyLabel) modifyLabel.textContent = langTranslations.modify_label;

		const moveToLabel = document.querySelector("label[for='moveToTool']");
		if (moveToLabel) moveToLabel.title = langTranslations.move_to;

		const bearingToolLabel = document.querySelector("label[for='bearingTool']");
		if (bearingToolLabel) bearingToolLabel.title = langTranslations.hole_bearing;

		const assignSurfaceLabel = document.querySelector("label[for='assignSurfaceTool']");
		if (assignSurfaceLabel) assignSurfaceLabel.title = langTranslations.assign_surface;

		const assignGradeLabel = document.querySelector("label[for='assignGradeTool']");
		if (assignGradeLabel) assignGradeLabel.title = langTranslations.assign_grade;

		const offsetKADTool = document.querySelector("label[for='offsetKADTool']");
		if (offsetKADTool) offsetKADTool.title = langTranslations.offset_kad_tooltip;

		const radiiHolesOrKADTool = document.querySelector("label[for='radiiHolesOrKADTool']");
		if (radiiHolesOrKADTool) radiiHolesOrKADTool.title = langTranslations.radii_holes_or_kad_tooltip;

		// Connectors Section
		const connectLabelFloating = document.querySelector("#toolbarPanel #connectLabel");
		if (connectLabelFloating) connectLabelFloating.textContent = langTranslations.connect_label;

		const tieConnectLabel = document.querySelector("label[for='tieConnectTool']");
		if (tieConnectLabel) tieConnectLabel.title = langTranslations.tie_connect;

		const tieConnectMultiLabel = document.querySelector("label[for='tieConnectMultiTool']");
		if (tieConnectMultiLabel) tieConnectMultiLabel.title = langTranslations.tie_connect_multi;

		const floatingConnectorColor = document.querySelector("#floatingConnectorColor");
		if (floatingConnectorColor) floatingConnectorColor.title = langTranslations.connector_color;

		// Measure Section
		const measureLabel = document.querySelector("#measureLabel");
		if (measureLabel) measureLabel.textContent = langTranslations.measure_label;

		const rulerLabel = document.querySelector("label[for='rulerTool']");
		if (rulerLabel) rulerLabel.title = langTranslations.ruler;

		const rulerProtractorLabel = document.querySelector("label[for='rulerProtractorTool']");
		if (rulerProtractorLabel) rulerProtractorLabel.title = langTranslations.ruler_protractor;

		const viewLabel = document.querySelector("#viewLabel");
		if (viewLabel) viewLabel.textContent = langTranslations.view_label;

		const resetViewLabel = document.querySelector("label[for='resetViewTool']");
		if (resetViewLabel) resetViewLabel.title = langTranslations.reset_view;
	} else {
		console.error("Translations for language ", language, " not found.");
	}
}

function getDarkModeSettings() {
	// Add safety checks for all elements
	const darkModeToggle = document.getElementById("darkModeToggle");
	const body = document.body;
	const sidenavLeft = document.getElementById("sidenavLeft");
	const canvas = document.getElementById("canvas");

	// Check if all required elements exist
	if (!darkModeToggle || !body || !sidenavLeft || !canvas) {
		console.warn("üö® Dark mode elements not ready yet, skipping...");
		return;
	}

	darkModeEnabled = localStorage.getItem("darkMode") === "true";

	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}
	// Update color variables based on dark mode
	updateColorsForDarkMode();
}

document.getElementById("buttonGoBack").addEventListener("click", function () {
	// Step 1) Create detailed message content
	const message = "You might lose unsaved data." + "<br><br>Make sure to save any important work before leaving." + '<br><br><div class="labelWhite15" style="text-align: left;">' + "<strong>Consider saving your work first:</strong>" + '<ul style="margin: 20px 0; padding-left: 20px;">' + "<li>Save holes to CSV file</li>" + "<li>Save drawing to KAD file</li>" + "<li>Export your current work</li>" + "</ul></div>";

	// Step 2) Show confirmation dialog
	showConfirmationDialog(
		"Leave Kirra?",
		message,
		"Leave",
		"Stay",
		() => {
			// Step 3) Handle leave confirmation
			window.location.href = "index.html";
		},
		() => {
			// Step 4) Handle stay (cancel) - nothing needed
			console.log("User chose to stay in Kirra");
		}
	);
});

// Tie Connect Tool event listener
const tieConnectTool = document.getElementById("tieConnectTool");
tieConnectTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		// Activate the right side nav "tie in one by one" switch
		addConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

// Tie Connect Multi Tool event listener
const tieConnectMultiTool = document.getElementById("tieConnectMultiTool");
tieConnectMultiTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addMultiConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addMultiConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

const addKADPointsTool = document.getElementById("addKADPointsTool");
addKADPointsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPointsTool");
		addPointDraw.checked = true;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPointDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPointDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADLineTool = document.getElementById("addKADLineTool");
addKADLineTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADLineTool");
		addPointDraw.checked = false;
		addLineDraw.checked = true;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addLineDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addLineDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADPolygonTool = document.getElementById("addKADPolygonTool");
addKADPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPolygonTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = true;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPolyDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPolyDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADCircleTool = document.getElementById("addKADCircleTool");
addKADCircleTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADCircleTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = true;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addCircleDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addCircleDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADTextTool = document.getElementById("addKADTextTool");
addKADTextTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADTextTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = true;
		// Trigger the change event to activate the functionality
		addTextDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addTextDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

// Step #) Floating Toolbar holesAddingTool - syncs with sidenav addHoleSwitch
const holesAddingTool = document.getElementById("holesAddingTool");
holesAddingTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("holesAddingTool");
		// Activate the sidenav addHoleSwitch
		addHoleSwitch.checked = true;
		// Trigger the change event to activate the functionality
		addHoleSwitch.dispatchEvent(new Event("change"));
	} else {
		// Handle unchecked state
		resetFloatingToolbarButtons("none");
		addHoleSwitch.checked = false;
		addHoleSwitch.dispatchEvent(new Event("change"));
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

//Selection Mode
selectionModeButton.addEventListener("change", function () {
	if (this.checked) {
		//set all the other switches to false
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== editHolesToggle) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning on: " + switchElement.id);
			}
		});
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		selectionModeButton.checked = true;
		isMultiHoleSelectionEnabled = true;

		if (selectedHole && !selectedMultipleHoles.includes(selectedHole)) {
			selectedMultipleHoles.push(selectedHole);
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		console.log("selectionModeButton.addEventListener checked");
	} else {
		console.log("selectionModeButton.addEventListener unchecked");
		isMultiHoleSelectionEnabled = false;
		selectionModeButton.checked = false;
		selectedMultipleHoles = [];
		switches.forEach((switchElement) => {
			if (switchElement) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning off: " + switchElement.id);
			}
		});

		drawData(allBlastHoles, selectedHole);
	}
});

function setMultipleSelectionModeToFalse() {
	// resetFloatingToolbarButtons("none");
	isMultiHoleSelectionEnabled = false;
	selectedMultipleHoles = [];
	timingWindowHolesSelected = [];
	console.log("selectionModeSettings set to false");
}

//Resizing the Navbar on the right
resizeRight.addEventListener("mousedown", function () {
	isResizingRight = true;

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", handleMouseUp);
});
//Resizing the Navbar on the left
resizeLeft.addEventListener("mousedown", function () {
	isResizingLeft = true;

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", handleMouseUp);
});
renumberHoles.addEventListener("click", function () {
	isRenumberingHoles = this.checked;
});
renumberStartListener.addEventListener("change", function () {
	//Allow Alpha numeric values
	deleteRenumberStart = this.value;
});

measuredLengthSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		// Remove all listeners except move tool
		isMeasureRecording = true;
		measuredLengthSwitch.checked = true;
		displayHoleId.checked = true;
		displayMLength.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredLengthClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredLengthClick);
		canvas.addEventListener("touchstart", handleMeasuredLengthClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
		measuredMassSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredMassSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredMassSwitch.checked = true;
		displayHoleId.checked = true;
		displayMMass.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredMassClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredMassClick);
		canvas.addEventListener("touchstart", handleMeasuredMassClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
		measuredLengthSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredCommentSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredCommentSwitch.checked = true;
		displayHoleId.checked = true; // Set display mode to hole Id
		displayMComment.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredCommentClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredCommentClick);
		canvas.addEventListener("touchstart", handleMeasuredCommentClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
		measuredMassSwitch.checked = false;
		measuredLengthSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

addPointDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPointsTool");
		isDrawingPoint = true;
		addPointDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["pointDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		//Add event listeners
		canvas.addEventListener("click", handleKADPointClick);
		canvas.addEventListener("touchstart", handleKADPointClick);
	} else {
		isDrawingPoint = false;
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADPointsTool when sidenav is turned off
		var addKADPointsToolRef = document.getElementById("addKADPointsTool");
		if (addKADPointsToolRef) addKADPointsToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addLineDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADLineTool");
		isDrawingLine = true;
		addLineDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["lineDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADLineClick);
		canvas.addEventListener("touchstart", handleKADLineClick);
	} else {
		isDrawingLine = false;
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADLineTool when sidenav is turned off
		var addKADLineToolRef = document.getElementById("addKADLineTool");
		if (addKADLineToolRef) addKADLineToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addPolyDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPolygonTool");
		isDrawingPoly = true;
		addPolyDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["polygonDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADPolyClick);
		canvas.addEventListener("touchstart", handleKADPolyClick);
	} else {
		isDrawingPoly = false;
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADPolygonTool when sidenav is turned off
		var addKADPolygonToolRef = document.getElementById("addKADPolygonTool");
		if (addKADPolygonToolRef) addKADPolygonToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addCircleDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADCircleTool");
		isDrawingCircle = true;
		addCircleDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["circleDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADCircleClick);
		canvas.addEventListener("touchstart", handleKADCircleClick);
	} else {
		isDrawingCircle = false;
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADCircleTool when sidenav is turned off
		var addKADCircleToolRef = document.getElementById("addKADCircleTool");
		if (addKADCircleToolRef) addKADCircleToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addTextDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADTextTool");
		//If font is less than 20pt set the Font size slider to 20pt and and update
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		isDrawingText = true;
		addTextDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["textDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADTextClick);
		canvas.addEventListener("touchstart", handleKADTextClick);
	} else {
		isDrawingText = false;
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADTextTool when sidenav is turned off
		var addKADTextToolRef = document.getElementById("addKADTextTool");
		if (addKADTextToolRef) addKADTextToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteKADDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("selectPointer", "selectByPolyhon");
		isDeletingKAD = true;
		deleteKADDraw.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", getClickedPoint);
		canvas.addEventListener("touchstart", getClickedPoint);
	} else {
		isDeletingKAD = false;
		canvas.removeEventListener("click", getClickedPoint);
		canvas.removeEventListener("touchstart", getClickedPoint);
		drawData(allBlastHoles, selectedHole);
	}
});

addConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectTool");
		isAddingConnector = true;
		addConnectorButton.checked = true;
		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;

		// Step: Force Holes radio to be selected for connector tools
		if (selectHolesRadio) {
			selectHolesRadio.checked = true;
			selectHolesRadio.dispatchEvent(new Event("change"));
		}

		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		// Step #) Uncheck floating toolbar tieConnectTool when sidenav is turned off
		var tieConnectToolRef = document.getElementById("tieConnectTool");
		if (tieConnectToolRef) tieConnectToolRef.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
addMultiConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		isAddingMultiConnector = true;

		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;

		// Step: Force Holes radio to be selected for connector tools
		if (selectHolesRadio) {
			selectHolesRadio.checked = true;
			selectHolesRadio.dispatchEvent(new Event("change"));
		}

		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConectMultiTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingMultiConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		// Step #) Uncheck floating toolbar tieConnectMultiTool when sidenav is turned off
		var tieConnectMultiToolRef = document.getElementById("tieConnectMultiTool");
		if (tieConnectMultiToolRef) tieConnectMultiToolRef.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		deleteHoleSwitch.checked = true;
		isDeletingHole = true;
		isAddingPattern = false;
		isAddingHole = false;
		displayHoleId.checked = true;
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		canvas.addEventListener("click", handleHoleDeletingClick);
		canvas.addEventListener("touchstart", handleHoleDeletingClick);
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isDeletingHole = false;
		canvas.removeEventListener("click", handleHoleDeletingClick);
		canvas.removeEventListener("touchstart", handleHoleDeletingClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("holesAddingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}

		addHoleSwitch.checked = true;

		isAddingHole = true;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handleHoleAddingClick);
		canvas.addEventListener("touchstart", handleHoleAddingClick);
		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingHole = false;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);

		// Step #) Uncheck floating toolbar holesAddingTool when sidenav is turned off
		var holesAddingToolRef = document.getElementById("holesAddingTool");
		if (holesAddingToolRef) holesAddingToolRef.checked = false;

		// Clear multiple mode data when tool is turned off
		if (window.isAddingSingleHole !== undefined) {
			window.isAddingSingleHole = false;
		}
		if (window.multipleAddHoleFormData !== undefined) {
			window.multipleAddHoleFormData = null;
		}

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY); //TODO: check if this is correct
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addPatternSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		addPatternSwitch.checked = true;
		isAddingPattern = true;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handlePatternAddingClick);
		canvas.addEventListener("touchstart", handlePatternAddingClick);
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingPattern = false;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		// ensure the Adding Pattern and adding a hole are off and their switches are off
		addHoleSwitch.checked = false;
		addPatternSwitch.checked = false;
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});

editHoleTypePopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		//setSelectionModeToFalse();
		isTypeEditing = true;
		editHoleTypePopupSwitch.checked = true;
		displayHoleId.checked = true;
		displayHoleType.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editHoleTypeSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleTypeEditClick);
		canvas.addEventListener("touchstart", handleHoleTypeEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isTypeEditing = false;
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editBlastNameSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		editBlastNameSwitch.checked = true;
		isBlastNameEditing = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editBlastNameSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleBlastNameClick);
		canvas.addEventListener("touchstart", handleBlastNameClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isBlastNameEditing = false;
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editLengthPopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//setSelectionModeToFalse();
		editLengthPopupSwitch.checked = true;
		isLengthPopupEditing = true;
		displayHoleLength.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editLengthPopupSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleLengthEditClick);
		canvas.addEventListener("touchstart", handleHoleLengthEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isLengthPopupEditing = false;
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

/// Event listener for the edit hole Easting switch
// All previous slider enabling toggles/switches will be grouped into one switch
// isHoleEditing will be used to determine if the hole is being edited
editHolesToggle.addEventListener("change", function () {
	if (this.checked) {
		console.log("editHolesToggle checked");
		isHoleEditing = true;
		//use the set all switches to false function
		booleans.forEach((bool) => {
			if (bool !== isHoleEditing || bool != isMultiHoleSelectionEnabled) bool = false;
		});
		//turn all the switches off
		switches.forEach((switchElement) => {
			if (switchElement && (switchElement !== selectionModeButton || switchElement !== editHolesToggle)) switchElement.checked = false;
		});
		//turn on the edit holes toggle
		editHolesToggle.checked = true;
		//attach all the event listeners to the canvas
		canvas.addEventListener("click", handleHoleEditingSelection);
		canvas.addEventListener("touchstart", handleHoleEditingSelection);

		//draw the canvas
		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("editHolesToggle unchecked");
		isHoleEditing = false;
		//remove all the event listeners from the canvas
		canvas.removeEventListener("click", handleHoleEditingSelection);
		canvas.removeEventListener("touchstart", handleHoleEditingSelection);
		//turn off the edit holes toggle
		editHolesToggle.checked = false;
		//reset the selected hole
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
		drawData(allBlastHoles, selectedHole);
	}
});

const holeEastingSlider = document.getElementById("holeEastingSlider");
holeEastingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleEasting = parseFloat(holeEastingSlider.value);
		holeEastingLabel.textContent = "Hole Easting (X): " + newHoleEasting.toFixed(2) + "mE";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 4 (easting)
				calculateHoleGeometry(clickedHole, newHoleEasting, 4);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average easting of all selected holes
			let sumEasting = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startXLocation, 0);
			let averageEasting = sumEasting / selectedMultipleHoles.length;
			let eastingDelta = newHoleEasting - averageEasting;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleX = hole.startXLocation + eastingDelta;
				calculateHoleGeometry(hole, newHoleX, 4);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

const holeNorthingSlider = document.getElementById("holeNorthingSlider");
holeNorthingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleNorthing = parseFloat(holeNorthingSlider.value);
		holeNorthingLabel.textContent = "Hole Northing (Y): " + newHoleNorthing.toFixed(2) + "mN";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 5 (northing)
				calculateHoleGeometry(clickedHole, newHoleNorthing, 5);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average northing of all selected holes
			let sumNorthing = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startYLocation, 0);
			let averageNorthing = sumNorthing / selectedMultipleHoles.length;
			let northingDelta = newHoleNorthing - averageNorthing;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleY = hole.startYLocation + northingDelta;
				calculateHoleGeometry(hole, newHoleY, 5);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

// Access the slider element and add an event listener to track changes
const holeElevationSlider = document.getElementById("holeElevationSlider");
holeElevationSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleElevation = parseFloat(holeElevationSlider.value);
		holeElevationLabel.textContent = "Hole Elevation (Z): " + newHoleElevation.toFixed(2) + "m";

		if (selectedHole) {
			// Update the easting of the individual selected hole
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (fixToeLocation == true) {
				if (index !== -1) {
					allBlastHoles[index].startZLocation = newHoleElevation;
					// Assuming endZLocation should also be updated based on the new easting
					allBlastHoles[index].endZLocation += newHoleElevation - allBlastHoles[index].startZLocation;
					calculateHoleGeometry(allBlastHoles[index], allBlastHoles[index].length, 1);
					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			} else {
				if (index !== -1) {
					// Calculate the original delta between startZLocation and endZLocation
					let originalDeltaZ = allBlastHoles[index].endZLocation - allBlastHoles[index].startZLocation;

					// Update startZLocation
					allBlastHoles[index].startZLocation = newHoleElevation;

					// Update endZLocation based on the new startZLocation and original delta
					allBlastHoles[index].endZLocation = newHoleElevation + originalDeltaZ;

					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			}
		} else if (selectedMultipleHoles) {
			// Update the elevation of multiple selected holes
			let sumElevation = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startZLocation, 0);
			let averageElevation = sumElevation / selectedMultipleHoles.length;
			let elevationDelta = newHoleElevation - averageElevation;

			selectedMultipleHoles.forEach((hole) => {
				hole.startZLocation += elevationDelta;
				// Assuming endZLocation should also be updated based on the new elevation
				hole.endZLocation += elevationDelta;
			});

			// Redraw the updated data for multiple holes
			drawData(allBlastHoles, null); // Pass null as the selected hole might not be relevant
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
	}
});

const holeLengthSlider = document.getElementById("holeLengthSlider");
holeLengthSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleLength = parseFloat(holeLengthSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeAngleSlider = document.getElementById("holeAngleSlider");
holeAngleSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleAngle = parseFloat(holeAngleSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(clickedHole, newHoleAngle, 2);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(hole, newHoleAngle, 2);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
		}
	}
});

const holeDiameterSlider = document.getElementById("holeDiameterSlider");
holeDiameterSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleDiameter = parseFloat(holeDiameterSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(clickedHole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(hole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeBearingSlider = document.getElementById("holeBearingSlider");
holeBearingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleBearing = parseFloat(holeBearingSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(clickedHole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(hole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
			});
		}
	}
});

const holeSubdrillSlider = document.getElementById("holeSubdrillSlider");
holeSubdrillSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleSubdrill = parseFloat(holeSubdrillSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleSubdrill, 8);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleSubdrill, 8);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
		}
	}
});

function resizeChart() {
	if (Array.isArray(holeTimes) && timeChartObject) {
		// Check if the chart has been created by Plotly
		const chart = document.getElementById("timeChart");
		if (chart && chart._fullLayout) {
			const newWidth = document.documentElement.clientWidth;
			// Use the string ID instead of the DOM element
			Plotly.relayout("timeChart", {
				width: newWidth,
			});
		} else {
			console.warn("resizeChart skipped: timeChart not yet initialized by Plotly");
		}
	} else {
		console.warn("resizeChart skipped: invalid holeTimes or timeChartObject");
	}
}

// Add event listener for window resize
function handleThreeJSResize() {
	if (threeInitialized && threeRenderer && canvas) {
		const width = canvas.clientWidth;
		const height = canvas.clientHeight;
		threeRenderer.resize(width, height);
		console.log("üîÑ Three.js canvas resized:", width, height);
	}
}

// Handle base canvas resize
function handleBaseCanvasResize() {
	if (window.baseCanvas && window.baseCtx && canvas) {
		const width = canvas.clientWidth;
		const height = canvas.clientHeight;

		// Step 1) Resize base canvas to match main canvas
		window.baseCanvas.width = width;
		window.baseCanvas.height = height;

		// Step 2) Redraw background color
		const isDark = document.body.classList.contains("dark-mode");
		window.baseCtx.fillStyle = isDark ? "#000000" : "#FFFFFF";
		window.baseCtx.fillRect(0, 0, width, height);
	}
}

window.addEventListener("resize", resizeChart);
window.addEventListener("resize", handleThreeJSResize);
window.addEventListener("resize", handleBaseCanvasResize);

// Step A5) Reusable function to update LineMaterial resolution for all fat lines
// This traverses the ENTIRE scene to catch pattern tool fat lines, not just kadGroup
// CRITICAL: Must use canvas dimensions, NOT window dimensions, for LineMaterial resolution
function updateAllLineMaterialResolution() {
	if (!window.threeRenderer) return;
	
	// Step A5.0) Use window dimensions for LineMaterial resolution
	// LineMaterial expects CSS pixel dimensions matching the DOM viewport
	var res = new THREE.Vector2(window.innerWidth, window.innerHeight);
	
	console.log("üîß Updating LineMaterial resolution to:", window.innerWidth, "x", window.innerHeight);
	
	// Step A5.1) Traverse kadGroup if it exists
	if (window.threeRenderer.kadGroup) {
		window.threeRenderer.kadGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
			}
		});
	}
	
	// Step A5.2) Traverse entire scene for pattern tool fat lines
	if (window.threeRenderer.scene) {
		window.threeRenderer.scene.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
			}
		});
	}
	
	// Step A5.3) Also update any pattern tool 3D groups
	if (window.patternTool3DGroup) {
		window.patternTool3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
			}
		});
	}
	if (window.holesAlongLine3DGroup) {
		window.holesAlongLine3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
			}
		});
	}
	if (window.holesAlongPolyline3DGroup) {
		window.holesAlongPolyline3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
			}
		});
	}
}

// Expose globally for use in other modules
window.updateAllLineMaterialResolution = updateAllLineMaterialResolution;

// Step A5.4) Update LineMaterial resolution on resize
window.addEventListener("resize", updateAllLineMaterialResolution);
var acc = document.getElementsByClassName("accordion");
var i;
for (i = 0; i < acc.length; i++) {
	acc[i].addEventListener("click", function () {
		/* Toggle between adding and removing the "active" class,
	to highlight the button that controls the panel */
		this.classList.toggle("active");
		/* Toggle between hiding and showing the active panel */
		var panel = this.nextElementSibling;
		if (panel.style.display === "block") {
			panel.style.display = "none";
		} else {
			panel.style.display = "block";
			resizeChart(); // Call the resizeChart function to adjust the chart layout
			timeChart();
			//Plotly.relayout("timeChart", {
			//	width: newWidthRight - 50
			//});
		}
	});
}

const voronoiMetricDropdown = document.getElementById("voronoiSelect");
if (voronoiMetricDropdown) {
	voronoiMetricDropdown.addEventListener("change", function (e) {
		selectedVoronoiMetric = e.target.value;
		drawData(allBlastHoles, selectedHole); // Redraw with the new metric
	});
}

function isIOS() {
	const userAgent = navigator.userAgent.toLowerCase();
	return /iphone|ipad|ipod/.test(userAgent);
}
document.getElementById("saveKAD").addEventListener("click", function () {
	exportKADFile(mapData);
});
document.getElementById("saveHoles").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsTo14ColumnCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 1) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsTo14ColumnCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});

document.getElementById("saveAll").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToAllDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 2) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsToAllDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
document.getElementById("saveIREDES").addEventListener("click", function () {
	saveIREDESPopup();
});
document.getElementById("saveAQM").addEventListener("click", function () {
	saveAQMPopup();
});
document.getElementById("saveMeasures").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToActualDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 3) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsToActualDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
// Update the event listener to filter visible holes first
document.getElementById("exportHolesDXF").addEventListener("click", function () {
	// ? Filter allBlastHoles to only include visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

	if (visibleBlastHoles.length === 0) {
		alert("No visible holes to export.");
		return;
	}

	console.log(`Exporting ${visibleBlastHoles.length} visible holes out of ${allBlastHoles.length} total holes`);

	const dxf = exportHolesDXF(visibleBlastHoles);
	const filename = "KIRRA_HOLES_DXF_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_") + ".dxf";
	downloadDXF(dxf, filename);
});

document.getElementById("exportDrawingDXF").addEventListener("click", function () {
	const dxf = exportKADDXF();
	const filename = "KIRRA_DRAWING_DXF_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_") + ".dxf";
	downloadDXF(dxf, filename);
});

function downloadDXF(content, filename) {
	if (isIOS()) {
		const blob = new Blob([content], {
			type: "text/dxf;charset=utf-8",
		});
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		// Step 4) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const link = document.createElement("a");
		link.style.display = "none";
		link.href = "data:text/dxf;charset=utf-8," + encodeURIComponent(content);
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

// Function to check if the mouse is inside the canvas
function isMouseInside(mouseX, mouseY, canvas) {
	const rect = canvas.getBoundingClientRect(); // Get the bounding rectangle of the canvas
	return mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom;
}
const canvasContainer = document.querySelector(".canvas-container");

canvasContainer.addEventListener(
	"wheel",
	function (event) {
		const mouseX = event.clientX;
		const mouseY = event.clientY;
		const isMouseInsideCanvas = isMouseInside(mouseX, mouseY, canvas);

		if (isMouseInsideCanvas) {
			event.preventDefault();
			const wheelDelta = event.deltaY;

			const zoomFactor = wheelDelta > 0 ? 0.95 : 1.05;

			// Calculate the mouse position in canvas coordinates
			const canvasRect = canvas.getBoundingClientRect();
			const canvasX = mouseX - canvasRect.left;
			const canvasY = mouseY - canvasRect.top;

			// Calculate the center of the canvas
			const centerX = canvasRect.width / 2;
			const centerY = canvasRect.height / 2;
			//make the canvas center the value of 0,0
			//const canvasCenterX = centerX - canvasX;
			//const canvasCenterY = centerY - canvasY;

			// Calculate the delta between the mouse position and the canvas center
			const deltaX = canvasX - centerX;
			const deltaY = canvasY - centerY;
			// Calculate the delta between the mouse position and the canvas center in negative on the left and positive on the right
			// and negative on the top and positive on the bottom
			//const deltaX = canvasCenterX - centerX;
			//const deltaY = canvasCenterY - centerY;

			// Calculate the position offsets from the center of the canvas
			const offsetX = canvasX - canvasRect.width / 2;
			const offsetY = canvasY - canvasRect.height / 2;

			// Calculate the new scale
			// Calculate the new scale
			// Calculate the new scale
			currentScale *= zoomFactor;

			// Step #) Only adjust font size if font lock is not checked
			const fontLock = document.getElementById("fontLock");
			if (!fontLock.checked) {
				currentFontSize = Math.min(Math.max(currentFontSize * zoomFactor, 0), 100);
			}

			// Adjust the centroid position based on the offsets and zoom direction
			if (deltaX < 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Left Quadrant: Mouse is above and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX < 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Left Quadrant: Mouse is below and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Right Quadrant: Mouse is above and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Right Quadrant: Mouse is below and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Center: Mouse is in the center region of the canvas");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY -= (offsetY / currentScale) * (1 - zoomFactor);
			}

			// Ensure the currentScale does not go below a minimum value
			currentScale = Math.max(currentScale, 0.000001);

			// Recalculate contours when zoom changes to keep worker in sync
			if (allBlastHoles && allBlastHoles.length > 0) {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				if (result && result.contourLinesArray) {
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}
			}

			drawData(allBlastHoles, selectedHole);

			// Step #) Update contour overlay after zoom - this ensures contours redraw with new scale
			if (typeof updateOverlayColorsForTheme === "function") {
				updateOverlayColorsForTheme();
			}
		}
	},
	{
		passive: false,
	}
);

document.addEventListener("DOMContentLoaded", function () {
	// Access the slider element and add an event listener to track changes
	const toeSlider = document.getElementById("toeSlider");
	toeSlider.addEventListener("input", function () {
		// Calculate the toe size in meters by using the slider value directly
		const toeSizeInMeters = parseFloat(this.value);

		// Update the label with the calculated toe size
		toeLabel.textContent = "Toe Size: " + toeSizeInMeters.toFixed(2) + "m";

		// Call the drawData function with the updated toe size in meters
		drawData(allBlastHoles, selectedHole, toeSizeInMeters);
	});
	const holeSlider = document.getElementById("holeSlider");
	holeSlider.addEventListener("input", function () {
		////console.log('Slider value:', this.value);
		holeScale = document.getElementById("holeSlider").value;
		holeLabel.textContent = "Hole Adjust : " + parseFloat(holeScale).toFixed(1);
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const connSlider = document.getElementById("connSlider");
	connSlider.addEventListener("input", function () {
		////console.log('Connector value:', this.value);
		connScale = document.getElementById("connSlider").value;
		connLabel.textContent = "Tie Size : " + parseFloat(connScale).toFixed(1);
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	// Step #) Font lock checkbox event listener
	const fontLock = document.getElementById("fontLock");
	const fontSlider = document.getElementById("fontSlider");

	fontLock.addEventListener("change", function () {
		// Step #) Enable/disable slider based on checkbox state
		fontSlider.disabled = this.checked;
	});

	fontSlider.min = "0";
	fontSlider.max = "100";
	fontSlider.addEventListener("input", function () {
		currentFontSize = this.value;
		currentFontSize = document.getElementById("fontSlider").value;
		fontLabel.textContent = "Font Size : " + currentFontSize + "px";
		drawData(allBlastHoles, selectedHole);
	});

	// Access the slider element and add an event listener to track changes
	const intervalSlider = document.getElementById("intervalSlider");
	intervalSlider.addEventListener("input", function () {
		intervalAmount = document.getElementById("intervalSlider").value;
		intervalLabel.textContent = "Interval : " + intervalAmount + "ms";

		// Step 1) Invalidate cache by clearing cached data
		cachedContourLinesArray = null;
		cachedDirectionArrows = null;

		// Step 2) Recalculate contours with new interval
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// Step 3) Update overlay system if active
		if (useContourOverlay && typeof drawContoursOnOverlayFixed === "function") {
			drawContoursOnOverlayFixed();
		}

		// Step 4) Redraw main canvas
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const firstMovementSlider = document.getElementById("firstMovementSlider");
	firstMovementSlider.addEventListener("input", function () {
		firstMovementSize = document.getElementById("firstMovementSlider").value;
		firstMovementLabel.textContent = "First Movement Size : " + firstMovementSize;

		// Step 1) Update window global for 3D rendering
		window.firstMovementSize = firstMovementSize;

		// Step 2) Invalidate cache
		cachedContourLinesArray = null;
		cachedDirectionArrows = null;

		// Step 3) Recalculate contours/arrows
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// Step 4) Redraw
		drawData(allBlastHoles, selectedHole);
	});
	//snap tolerance - UPDATED TO USE PIXELS
	const snapToleranceSlider = document.getElementById("snapToleranceSlider");
	snapToleranceSlider.addEventListener("input", function () {
		snapRadiusPixels = parseFloat(this.value);
		document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

		// Save to localStorage
		localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
	});

	// Access the slider element and add an event listener to track changes
	const connectSlider = document.getElementById("connectSlider");
	connectSlider.addEventListener("input", function () {
		updateConnectDistance(); // Step 7) Use the new logarithmic update function
	});
});

// Connector Distance Log Helper Functions (Base 5)
function connectDistanceLogScale(sliderValue) {
	if (sliderValue <= 33.33) {
		// First third: 0.2m to 1.0m (5^0.43 to 5^0.86 approximately)
		const normalizedValue = sliderValue / 33.33;
		const minLog = Math.log(0.2) / Math.log(5); // log5(0.2)
		const maxLog = Math.log(1.0) / Math.log(5); // log5(1.0)
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else if (sliderValue <= 66.66) {
		// Second third: 1.0m to 5.0m (5^0 to 5^1)
		const normalizedValue = (sliderValue - 33.33) / 33.33;
		const minLog = Math.log(1.0) / Math.log(5); // log5(1.0) = 0
		const maxLog = Math.log(5.0) / Math.log(5); // log5(5.0) = 1
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else {
		// Last third: 5.0m to 25.0m (5^1 to 5^2)
		const normalizedValue = (sliderValue - 66.66) / 33.34;
		const minLog = Math.log(5.0) / Math.log(5); // log5(5.0) = 1
		const maxLog = Math.log(25.0) / Math.log(5); // log5(25.0) = 2
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	}
}

function updateConnectDistance() {
	const connectSlider = document.getElementById("connectSlider");
	const sliderValue = parseFloat(connectSlider.value);

	// Step 4) Use logarithmic scaling instead of direct value
	connectAmount = connectDistanceLogScale(sliderValue);

	// Step 5) Snap to 0.1m increments
	connectAmount = Math.round(connectAmount * 10) / 10;

	// Step 6) Update label with actual distance
	const connectLabel = document.getElementById("connectLabel");
	connectLabel.textContent = "Connect Distance : " + connectAmount.toFixed(1) + "m";
}

// Step 6) Optional: Add visual markers to show the scale divisions
function addConnectDistanceMarkers() {
	const slider = document.getElementById("connectSlider");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.2m</span><span>1m</span><span>5m</span><span>25m</span>";
	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}
const timeSlider = document.getElementById("timeRange");
timeSlider.addEventListener("input", function () {
	timeRange = document.getElementById("timeRange").value;
	timeRangeLabel.textContent = "Time window :" + timeRange + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true, // Adjust the y-axis range to fit the data
		},
	});
});

// Access the slider element and add an event listener to track changes
const timeOffsetSlider = document.getElementById("timeOffset");
timeOffsetSlider.addEventListener("input", function () {
	timeOffset = document.getElementById("timeOffset").value;
	timeOffsetLabel.textContent = "Time Offset : " + timeOffset + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true, // Adjust the y-axis range to fit the data
		},
	});
});

//floating connector color
const floatingConnectorColor = document.getElementById("floatingConnectorColor");
floatingConnectorColor.addEventListener("change", function () {
	floatingConnectorColor.jscolor.fromString(floatingConnectorColor.value);
});
//Color Wells not sliders but JScolor buttons
const connectorColor = document.getElementById("connectorColor");
connectorColor.addEventListener("change", function () {
	connectorColor.jscolor.fromString(connectorColor.value);
});
const drawingColor = document.getElementById("drawingColor");
drawingColor.addEventListener("change", function () {
	drawingColor.jscolor.fromString(drawingColor.value);
});

const connectorDelay = document.getElementById("delay");
connectorDelay.addEventListener("change", function () {
	connectorDelay.value = parseFloat(connectorDelay.value);
});
const floatingDelay = document.getElementById("floatingDelay");
floatingDelay.addEventListener("change", function () {
	floatingDelay.value = parseFloat(floatingDelay.value);
});

let drawingZValue = 0.0;
//Numbers like elevation and circle radius and polygon radius
const drawingElevation = document.getElementById("drawingElevation");
// Step #) Initialize drawingZValue to match the HTML input's initial value
drawingZValue = parseFloat(drawingElevation.value) || 0.0;
drawingElevation.addEventListener("change", function () {
	drawingZValue = parseFloat(drawingElevation.value);
});

const lineThickness = document.getElementById("drawingLineWidth");
lineThickness.addEventListener("input", function () {
	lineThickness.value = parseFloat(lineThickness.value);
	// Step #) Sync with floating toolbar
	const toolbarLineWidth = document.getElementById("drawingKADSizeToolbar");
	if (toolbarLineWidth) {
		toolbarLineWidth.value = lineThickness.value;
	}
});
lineThickness.addEventListener("change", function () {
	lineThickness.value = parseFloat(lineThickness.value);
	// Step #) Sync with floating toolbar
	const toolbarLineWidth = document.getElementById("drawingKADSizeToolbar");
	if (toolbarLineWidth) {
		toolbarLineWidth.value = lineThickness.value;
	}
});

// Step #) Sync floating toolbar line width back to sidebar
const drawingKADSizeToolbar = document.getElementById("drawingKADSizeToolbar");
if (drawingKADSizeToolbar) {
	drawingKADSizeToolbar.addEventListener("input", function () {
		const sidebarLineWidth = document.getElementById("drawingLineWidth");
		if (sidebarLineWidth) {
			sidebarLineWidth.value = drawingKADSizeToolbar.value;
		}
	});
	drawingKADSizeToolbar.addEventListener("change", function () {
		const sidebarLineWidth = document.getElementById("drawingLineWidth");
		if (sidebarLineWidth) {
			sidebarLineWidth.value = drawingKADSizeToolbar.value;
		}
	});

	// Step #) Initial sync to ensure values match on load
	const sidebarLineWidth = document.getElementById("drawingLineWidth");
	if (sidebarLineWidth && sidebarLineWidth.value !== drawingKADSizeToolbar.value) {
		sidebarLineWidth.value = drawingKADSizeToolbar.value;
	}
}

const circleRadius = document.getElementById("drawingRadius");
circleRadius.addEventListener("change", function () {
	circleRadius.value = parseFloat(circleRadius.value);
});
const polygonRadius = document.getElementById("drawingPolygonRadius");
polygonRadius.addEventListener("change", function () {
	polygonRadius.value = parseFloat(polygonRadius.value);
});
const radiiSteps = document.getElementById("radiiSteps");
radiiSteps.addEventListener("change", function () {
	radiiSteps.value = parseInt(radiiSteps.value);
});
const drawingText = document.getElementById("drawingText");
drawingText.addEventListener("change", function () {
	drawingText.value = String(drawingText.value);
});

// Create array of options and their corresponding flags
const optionConfigs = [
	{
		option: displayHoleId,
	},
	{
		option: displayHoleLength,
	},
	{
		option: displayHoleDiameter,
	},
	{
		option: displayHoleAngle,
	},
	{
		option: displayHoleDip,
	},
	{
		option: displayHoleBearing,
	},
	{
		option: displayHoleSubdrill,
	},
	{
		option: displayConnectors,
	},
	{
		option: displayDelays,
	},
	{
		option: displayTimes,
	},
	{
		option: displayContours,
		flag: "isDisplayingContours",
	},
	{
		option: displaySlope,
		flag: "isDisplayingSlopeTriangles",
	},
	{
		option: displayRelief,
		flag: "isDisplayingReliefTriangles",
	},
	{
		option: displayFirstMovements,
		flag: "isDisplayingDirectionArrows",
	},
	{
		option: displayXLocation,
	},
	{
		option: displayYLocation,
	},
	{
		option: displayElevation,
	},
	{
		option: displayHoleType,
	},
	{
		option: displayMLength,
	},
	{
		option: displayMMass,
	},
	{
		option: displayMComment,
	},
	{
		option: displayVoronoiCells,
	},
	{
		option: displayRowAndPosId,
	},
];

// Step 1: Add throttling variables at the top of your file (near other global variables)
//let contourUpdatePending = false;

// Step 2: Create throttled function
function throttledRecalculateContours() {
	if (contourUpdatePending) return;
	contourUpdatePending = true;

	requestAnimationFrame(function () {
		if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
			contourUpdatePending = false;
			// Step 2c) Redraw even when nothing is displayed to clear old data
			drawData(allBlastHoles, selectedHole);
			return;
		}

		// Step 2a) Check if we can use cache - need BOTH contours AND arrows if arrows are requested
		var needsArrows = displayFirstMovements && displayFirstMovements.checked;
		var hasValidCache = cachedContourLinesArray && cachedContourLinesArray.length > 0;
		var hasValidArrowCache = cachedDirectionArrows && cachedDirectionArrows.length > 0;

		// Step 2b) Use cache only if it has what we need, otherwise recalculate
		if (hasValidCache && (!needsArrows || hasValidArrowCache)) {
			contourLinesArray = cachedContourLinesArray;
			directionArrows = cachedDirectionArrows;
		} else {
			// Step 2c) Recalculate - cache is incomplete or doesn't have arrows when needed
			var result = recalculateContours(allBlastHoles, 0, 0);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		updateOverlayColorsForTheme();
		contourUpdatePending = false;

		// Step 2d) Redraw after contours/arrows are calculated to ensure immediate rendering
		drawData(allBlastHoles, selectedHole);
	});
}

// Step 3: Replace the calculation in your existing event listener
optionConfigs.forEach((config) => {
	if (config.option) {
		config.option.addEventListener("change", function () {
			if (config.flag) {
				window[config.flag] = true;
			}

			// REPLACE THIS SECTION:
			/*
			// Calculate contours when any of these displays are turned on
			if ((config.option === displayContours && displayContours.checked) || 
				(config.option === displayFirstMovements && displayFirstMovements.checked) || 
				(config.option === displayRelief && displayRelief.checked)) {
				const result = recalculateContours(allBlastHoles, 0, 0);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			}
			*/

			// WITH THIS THROTTLED VERSION:
			if ((config.option === displayContours && displayContours.checked) || (config.option === displayFirstMovements && displayFirstMovements.checked) || (config.option === displayRelief && displayRelief.checked)) {
				throttledRecalculateContours(); // Use throttled version
			}

			// Your existing overlay integration code...
			if (config.option === displayContours) {
				if (displayContours.checked) {
					if (!useContourOverlay) {
						toggleContourOverlayFixed();
					} else {
						updateOverlayColorsForTheme();
					}
				} else {
					if (contourOverlayCanvas) {
						contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
					}
				}
			}

			drawData(allBlastHoles, selectedHole);
		});
	}
});

let touchStartTime;
let touchDuration;
const longPressDuration = 200; // Adjust this duration as needed
let isTouchDragging = false;
let longPressTimeout;
let isUpdatingSelectionFromMove = false;
let newWidthRight = 350;
let newWidthLeft = 350;

function handleMouseDown(event) {
	// Debug log for 2D pan troubleshooting
	console.log("‚¨áÔ∏è [2D] handleMouseDown fired", {
		button: event.button,
		ctrlKey: event.ctrlKey,
		shiftKey: event.shiftKey,
		altKey: event.altKey,
		onlyShowThreeJS: onlyShowThreeJS,
	});

	if (onlyShowThreeJS) {
		// In 3D mode, let camera controls handle it (except for selection which is handled by click)
		return;
	}

	// Prevent context menu if we are panning or interacting
	if (event.button === 2) {
		// Right-click is for context menus only - don't set up any drag/pan behavior
		// The context menu handler will manage this
		return; // Exit early for right-clicks
	}

	// Step 1) Handle dragging functionality (Pan)
	// Only start pan if NOT clicking on a handle or control
	if (!isResizingRight && !isResizingLeft) {
		// Step 1a) Middle mouse button - immediate pan
		if (event.button === 1) {
			isDragging = true;
			startPanX = event.clientX;
			startPanY = event.clientY;
			// console.log("üëã 2D Pan started");
		}
		// Step 1b) Left mouse button - check tool state
		else if (event.button === 0) {
			// Step 1b.1) Tools that suspend dragging: Move and Bearing tools
			// These tools handle their own dragging behavior and should not trigger panning
			const toolsThatSuspendDragging = isMoveToolActive || isBearingToolActive;

			// Step 1b.2) Tools that allow immediate panning (no delay needed)
			const toolsThatAllowImmediatePan = !isAddingConnector && !isAddingMultiConnector && !isAddingPoint && !isAddingLine && !isAddingPoly && !isAddingCircle && !isAddingText && !isAssignSurfaceActive && !isAssignGradeActive && !isOffsetKADActive && !isRadiiHolesOrKADActive && !isRulerToolActive && !isRulerProtractorToolActive && !isPatternInPolygonActive && !isHolesAlongLineActive && !isHolesAlongPolyLineActive;

			// Step 1b.3) selectPointer allows panning after 300ms delay (single click = selection, long press = pan)
			if (isSelectionPointerActive && !toolsThatSuspendDragging) {
				// Store initial mouse position for drag detection
				startPanX = event.clientX;
				startPanY = event.clientY;
				// Delay panning for selectPointer - allows single clicks for selection
				// Pan will be enabled after 300ms if mouse is still down
				window.selectPointerPanTimeout = setTimeout(() => {
					if (!isDraggingBearing && !isDraggingHole) {
						isDragging = true;
						// console.log("üëã 2D Pan started (selectPointer delayed)");
					}
				}, 300); // 300ms delay for selectPointer panning
			}
			// Step 1b.4) Other tools - immediate panning if allowed
			else if (!isSelectionPointerActive && toolsThatAllowImmediatePan && !toolsThatSuspendDragging) {
				isDragging = true;
				startPanX = event.clientX;
				startPanY = event.clientY;
				// console.log("üëã 2D Pan started");
			}
		}
	}

	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	// BUT NOT for right-click (button 2) - that's for context menus
	if (event.button !== 2) {
		longPressTimeout = setTimeout(() => {
			isDragging = true; // Set isDragging to true after 500ms
		}, longPressDuration);
	}

	// Convert to canvas coordinates (consistent with handleMouseMove)
	const rect = canvas.getBoundingClientRect();
	lastMouseX = event.clientX - rect.left;
	lastMouseY = event.clientY - rect.top;
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
}

function handleMouseMove(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Update global mouse tracking for interactive previews
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;

	// Convert to world coordinates with snapping for HUD display
	const snapResult = canvasToWorldWithSnap(mouseX, mouseY);
	currentMouseWorldX = snapResult.worldX;
	currentMouseWorldY = snapResult.worldY;
	currentMouseWorldZ = snapResult.worldZ;

	// Update snapHighlight for HUD display (magnet icon)
	snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;

	// Step 1) For selectPointer, if mouse moves significantly before timeout, start panning immediately
	if (isSelectionPointerActive && window.selectPointerPanTimeout && !isDragging) {
		const deltaX = Math.abs(event.clientX - startPanX);
		const deltaY = Math.abs(event.clientY - startPanY);
		// If mouse moved more than 5 pixels, start panning immediately
		if (deltaX > 5 || deltaY > 5) {
			clearTimeout(window.selectPointerPanTimeout);
			window.selectPointerPanTimeout = null;
			if (!isDraggingBearing && !isDraggingHole) {
				isDragging = true;
				startPanX = event.clientX;
				startPanY = event.clientY;
			}
		}
	}

	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;

		// Recalculate contours during drag to keep them in sync
		if (allBlastHoles && allBlastHoles.length > 0 && (displayContours.checked || displayFirstMovements.checked)) {
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			if (result && result.contourLinesArray) {
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			}
		}
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	if (isResizingRight) {
		newWidthRight = window.innerWidth - event.clientX;
		Plotly.relayout("timeChart", {
			width: newWidthRight - 50,
		});
		document.getElementById("sidenavRight").style.width = newWidthRight + "px";
	}
	if (isResizingLeft) {
		newWidthLeft = event.clientX;
		document.getElementById("sidenavLeft").style.width = newWidthLeft + "px";
	}

	// If in selection mode and there's a selection, prevent getMultipleClickedHoles from re-evaluating during this move
	if (isMultiHoleSelectionEnabled && selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		isUpdatingSelectionFromMove = true; // Flag to prevent re-evaluating selection during mouse move
	}

	// Only redraw during active interactions to improve performance
	//if (isDragging || isAddingHole || isDeletingHole || isAddingConnector || isAddingMultiConnector || isDrawingText || isDrawingLine || isDrawingPoly || isDrawingCircle || isMeasureRecording) {
	drawData(allBlastHoles, selectedHole);
	//}

	// Step #) Update contour overlay when panning - ensures contours stay in sync with canvas position
	if (isDragging && typeof updateOverlayColorsForTheme === "function") {
		updateOverlayColorsForTheme();
	}

	isUpdatingSelectionFromMove = false; // Reset the flag after drawData
}

function handleMouseUp(event) {
	// Debug log for 2D pan troubleshooting
	if (isDragging) {
		console.log("üñêÔ∏è [2D] handleMouseUp fired - Releasing Pan");
	}

	if (onlyShowThreeJS) {
		return;
	}

	// Stop 2D Pan
	if (isDragging) {
		isDragging = false;
		canvas.style.cursor = "default";
	}

	// Stop resizing
	if (isResizingRight) {
		isResizingRight = false;
		document.removeEventListener("mousemove", handleMouseMove);
		document.removeEventListener("mouseup", handleMouseUp);
	}
	if (isResizingLeft) {
		isResizingLeft = false;
		document.removeEventListener("mousemove", handleMouseMove);
		document.removeEventListener("mouseup", handleMouseUp);
	}

	clearTimeout(longPressTimeout); // Clear the long press timeout
	// Step 2) Clear selectPointer pan timeout if it exists
	if (window.selectPointerPanTimeout) {
		clearTimeout(window.selectPointerPanTimeout);
		window.selectPointerPanTimeout = null;
	}
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
	//touchDuration = Date.now() - touchStartTime;

	// Note: Add hole dialog is now shown in handleHoleAddingClick, not here
	// This prevents duplicate dialogs
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	drawData(allBlastHoles, selectedHole);
	// Remove the Side Nav Accorian resize Listeners.
	isResizingRight = false;
	document.removeEventListener("mousemove", handleMouseMove);
	document.removeEventListener("mouseup", handleMouseUp);
	isResizingLeft = false;
	document.removeEventListener("mousemove", handleMouseMove);
	document.removeEventListener("mouseup", handleMouseUp);
}

// Rest of the code for touch events is unchanged

function handleTouchStart(event) {
	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	longPressTimeout = setTimeout(() => {
		isTouchDragging = true; // Set isTouchDragging to true after 500ms
	}, longPressDuration);

	// Continue handling the touch start event as before
	if (event.touches.length === 1) {
		if (!isDraggingBearing && !isDraggingHole) {
			isTouchDragging = true;
		}
		touchStartX = event.touches[0].clientX;
		touchStartY = event.touches[0].clientY;
	} else if (event.touches.length === 2) {
		// Pinch
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
}

function handleTouchEnd(event) {
	// Clear the long press timeout
	clearTimeout(longPressTimeout);

	// Only set isTouchDragging to false on touch end
	isTouchDragging = false;

	touchDuration = Date.now() - touchStartTime;
	// Block tool-specific behaviors if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;

	// Note: Add hole dialog is now shown in handleHoleAddingClick, not here
	// This prevents duplicate dialogs
	if (event.touches.length === 1) {
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
}

function handleTouchMove(event) {
	if (event.touches.length === 1 && isTouchDragging && !isDraggingBearing && !isDraggingHole) {
		// Only do canvas panning if tools aren't dragging
		event.preventDefault();
		let touchX = event.touches[0].clientX;
		let touchY = event.touches[0].clientY;
		deltaX = touchX - touchStartX;
		deltaY = touchY - touchStartY;
		touchStartX = touchX;
		touchStartY = touchY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		drawData(allBlastHoles, selectedHole);
	} else if (event.touches.length === 2) {
		event.preventDefault();

		deltaX = event.touches[0].clientX - event.touches[1].clientX;
		deltaY = event.touches[0].clientY - event.touches[1].clientY;
		const currentPinchDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

		if (initialPinchDistance === null) {
			initialPinchDistance = currentPinchDistance;
		} else {
			const pinchDelta = currentPinchDistance - initialPinchDistance;
			currentScale = initialScale + pinchDelta * 0.05;
			currentScale = Math.max(currentScale, 0.000001);
			currentFontSize = initialFontSize * (currentScale / initialScale);

			drawData(allBlastHoles, selectedHole);
		}
	}
}

async function handleFileUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();

	reader.onload = async function (event) {
		const data = event.target.result;

		if (file.name.endsWith(".kad") || file.name.endsWith(".KAD") || file.name.endsWith(".txt") || file.name.endsWith(".TXT")) {
			parseKADFile(data);
			// Step 1) Clear text cache when data changes
			if (window.threeRenderer && typeof window.threeRenderer.clearTextCacheOnDataChange === "function") {
				window.threeRenderer.clearTextCacheOnDataChange();
			}
			drawData(allBlastHoles, selectedHole);
		} else if (file.name.endsWith(".csv") || file.name.endsWith(".CSV")) {
			try {
				allBlastHoles = parseK2Dcsv(data);
				// Step 1) Save loaded file to IndexedDB
				debouncedSaveHoles();

				// Calculate centroid
				let sumX = 0;
				let sumY = 0;
				for (let i = 0; i < allBlastHoles.length; i++) {
					sumX += allBlastHoles[i].startXLocation;
					sumY += allBlastHoles[i].startYLocation;
				}
				centroidX = sumX / allBlastHoles.length;
				centroidY = sumY / allBlastHoles.length;

				// Step 1a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
				var fullCentroid = calculateDataCentroid();
				emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

				// Recalculate contours and triangles
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
				// Step 1) Clear text cache when data changes
				if (window.threeRenderer && typeof window.threeRenderer.clearTextCacheOnDataChange === "function") {
					window.threeRenderer.clearTextCacheOnDataChange();
				}
				drawData(allBlastHoles, selectedHole);
				countAllBlastHoles = allBlastHoles.length;
			} catch (error) {
				console.error("Error during CSV handling:", error);
				fileFormatPopup(error);
			}
		}
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

let randomHex = Math.floor(Math.random() * 16777215).toString(16);

// DUPLICATE ID DETECTION AND RESOLUTION SYSTEM
// Enhanced duplicate checking that handles all ID formats
async function checkAndResolveDuplicateHoleIDs(allBlastHoles, actionType = "import") {
	const duplicateReport = {
		hasDuplicates: false,
		duplicates: [],
		resolved: [],
		errors: [],
	};

	// Group holes by entity name
	const entitiesMap = new Map();

	allBlastHoles.forEach((hole, index) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, []);
		}
		entitiesMap.get(hole.entityName).push({
			hole,
			originalIndex: index,
		});
	});

	// Check each entity for duplicate IDs
	entitiesMap.forEach((holes, entityName) => {
		const idMap = new Map();

		holes.forEach(({ hole, originalIndex }) => {
			const holeID = hole.holeID.toString(); // Convert to string for comparison

			if (idMap.has(holeID)) {
				// Duplicate found!
				duplicateReport.hasDuplicates = true;

				const existingHole = idMap.get(holeID);
				const duplicateInfo = {
					entityName,
					holeID,
					existing: {
						hole: existingHole.hole,
						index: existingHole.originalIndex,
					},
					duplicate: {
						hole,
						index: originalIndex,
					},
				};

				duplicateReport.duplicates.push(duplicateInfo);
			} else {
				idMap.set(holeID, {
					hole,
					originalIndex,
				});
			}
		});
	});

	// If duplicates found, resolve them
	if (duplicateReport.hasDuplicates) {
		console.warn("‚ö†Ô∏è DUPLICATE HOLE IDs DETECTED:", duplicateReport.duplicates.length, "conflicts found");

		// Show user dialog for resolution strategy
		const resolution = await showDuplicateResolutionDialog(duplicateReport, actionType);

		switch (resolution.strategy) {
			case "auto-renumber":
				resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport);
				break;
			case "keep-first":
				resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport);
				break;
			case "keep-last":
				resolveDuplicatesKeepLast(allBlastHoles, duplicateReport);
				break;
			case "manual":
				// Let user manually resolve - return for manual handling
				return duplicateReport;
			case "abort":
				// Return special value indicating user cancelled
				console.log("‚úÖ User cancelled duplicate resolution");
				return { cancelled: true };
		}
	}

	return duplicateReport;
}

function showDuplicateResolutionDialog(duplicateReport, actionType) {
	const duplicateCount = duplicateReport.duplicates.length;
	const entitiesAffected = [...new Set(duplicateReport.duplicates.map((d) => d.entityName))];

	// Build content using CSS classes that handle dark/light mode automatically
	const contentDiv = document.createElement("div");
	contentDiv.className = "button-container-2col";
	contentDiv.style.padding = "10px";
	contentDiv.style.minHeight = "200px";

	// Warning header - uses labelWhite18 class
	const warningHeader = document.createElement("label");
	warningHeader.className = "labelWhite15"; // Using existing CSS class
	warningHeader.style.gridColumn = "1 / -1";
	warningHeader.style.textAlign = "center";
	warningHeader.style.marginBottom = "10px";
	warningHeader.style.fontSize = "14px";
	warningHeader.style.fontWeight = "bold";
	warningHeader.textContent = "‚ö†Ô∏è Duplicate Hole IDs Detected";
	contentDiv.appendChild(warningHeader);

	// Conflict count - uses labelWhite15 class
	const conflictLabel = document.createElement("label");
	conflictLabel.className = "labelWhite15";
	conflictLabel.style.gridColumn = "1 / -1";
	conflictLabel.style.marginBottom = "5px";
	conflictLabel.textContent = "Found: " + duplicateCount + " conflicts";
	contentDiv.appendChild(conflictLabel);

	// Affected blasts - uses labelWhite15 class
	const blastsLabel = document.createElement("label");
	blastsLabel.className = "labelWhite15";
	blastsLabel.style.gridColumn = "1 / -1";
	blastsLabel.style.marginBottom = "10px";
	blastsLabel.textContent = "Blasts: " + entitiesAffected.join(", ");
	contentDiv.appendChild(blastsLabel);

	// Examples header - uses labelWhite12 class
	const examplesHeader = document.createElement("label");
	examplesHeader.className = "labelWhite12";
	examplesHeader.style.gridColumn = "1 / -1";
	examplesHeader.style.marginTop = "10px";
	examplesHeader.style.marginBottom = "5px";
	examplesHeader.textContent = "Examples:";
	contentDiv.appendChild(examplesHeader);

	// Example entries - uses labelWhite12 class
	duplicateReport.duplicates.slice(0, 3).forEach((dup) => {
		const exampleLabel = document.createElement("label");
		exampleLabel.className = "labelWhite12";
		exampleLabel.style.gridColumn = "1 / -1";
		exampleLabel.style.marginBottom = "2px";
		exampleLabel.textContent = "? " + dup.entityName + " - ID: " + dup.holeID;
		contentDiv.appendChild(exampleLabel);
	});

	// More indicator - uses labelWhite12 class
	if (duplicateReport.duplicates.length > 3) {
		const moreLabel = document.createElement("label");
		moreLabel.className = "labelWhite12";
		moreLabel.style.gridColumn = "1 / -1";
		moreLabel.textContent = "... and " + (duplicateReport.duplicates.length - 3) + " more";
		contentDiv.appendChild(moreLabel);
	}

	// Return promise exactly like original Swal2 version
	return new Promise((resolve) => {
		const dialog = new FloatingDialog({
			title: "Duplicate Resolution",
			content: contentDiv,
			width: 450,
			height: 350,
			layoutType: "default",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false,
			showConfirm: true,
			showCancel: true,
			showOption1: true,
			showOption2: true,
			confirmText: "Renumber",
			option1Text: "Keep First",
			option2Text: "Keep Last",
			cancelText: "Cancel",
			onConfirm: () => {
				resolve({
					strategy: "auto-renumber",
				});
			},
			onOption1: () => {
				resolve({
					strategy: "keep-first",
				});
			},
			onOption2: () => {
				resolve({
					strategy: "keep-last",
				});
			},
			onCancel: () => {
				resolve({
					strategy: "abort",
				});
			},
		});

		dialog.show();
	});
}

// Enhanced auto-renumbering that handles all ID formats
function resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport) {
	// For each entity, analyze existing ID patterns and generate appropriate new IDs
	const entitiesMap = new Map();

	// Group allBlastHoles by entity and analyze ID patterns
	allBlastHoles.forEach((hole) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, {
				holes: [],
				numericIDs: [],
				alphaIDs: [],
				maxNumeric: 0,
				maxAlphaRow: "A",
				maxAlphaNum: 0,
			});
		}
		const entity = entitiesMap.get(hole.entityName);
		entity.holes.push(hole);

		const holeID = hole.holeID.toString();

		// Check if it's purely numeric
		const numericMatch = holeID.match(/^(\d+)$/);
		if (numericMatch) {
			const num = parseInt(numericMatch[1]);
			entity.numericIDs.push(num);
			entity.maxNumeric = Math.max(entity.maxNumeric, num);
		}
		// Check if it's alphanumeric (like A1, B2, AA1, etc.)
		else {
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);
				entity.alphaIDs.push({
					letters,
					number,
					full: holeID,
				});

				// Track highest letter combination and number
				if (letters.localeCompare(entity.maxAlphaRow) > 0) {
					entity.maxAlphaRow = letters;
					entity.maxAlphaNum = number;
				} else if (letters === entity.maxAlphaRow) {
					entity.maxAlphaNum = Math.max(entity.maxAlphaNum, number);
				}
			}
		}
	});

	// Renumber duplicates using appropriate format
	duplicateReport.duplicates.forEach((duplicate) => {
		const entity = entitiesMap.get(duplicate.entityName);
		const oldID = duplicate.duplicate.hole.holeID.toString();
		let newID;

		// Determine what format to use for the new ID
		const numericMatch = oldID.match(/^(\d+)$/);
		const alphaMatch = oldID.match(/^([A-Z]+)(\d+)$/);

		if (numericMatch) {
			// Generate new numeric ID
			newID = (++entity.maxNumeric).toString();
		} else if (alphaMatch) {
			// For true alphanumeric (A1, B2 style), maintain the letter prefix
			const letters = alphaMatch[1];

			// Find max number for this specific letter prefix
			let maxNumForPrefix = 0;
			entity.holes.forEach((h) => {
				const match = h.holeID.toString().match(/^([A-Z]+)(\d+)$/);
				if (match && match[1] === letters) {
					maxNumForPrefix = Math.max(maxNumForPrefix, parseInt(match[2]));
				}
			});

			newID = letters + (maxNumForPrefix + 1);
		} else {
			// Fallback: use numeric
			newID = (++entity.maxNumeric).toString();
		}

		// Update the hole ID
		duplicate.duplicate.hole.holeID = newID;

		// Update fromHoleID references if they point to this hole
		allBlastHoles.forEach((hole) => {
			if (hole.fromHoleID === duplicate.entityName + ":::" + oldID) {
				hole.fromHoleID = duplicate.entityName + ":::" + newID;
			}
		});

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			oldID: oldID,
			newID: newID,
			action: "renumbered",
		});

		console.log("üîß Renumbered duplicate hole:", duplicate.entityName + ":" + oldID, "‚Üí", newID);
	});
}

function resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport) {
	// Remove duplicate holes (keep the first occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.duplicate.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-duplicate",
		});

		console.log("üóëÔ∏è Removed duplicate hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

function resolveDuplicatesKeepLast(allBlastHoles, duplicateReport) {
	// Remove original holes (keep the duplicate/last occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.existing.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-original",
		});

		console.log("üóëÔ∏è Removed original hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

// Enhanced unique ID validation for any format
function validateUniqueHoleID(entityName, holeID, excludeHole = null) {
	const holeIDStr = holeID.toString();

	const existing = allBlastHoles.find((hole) => hole.entityName === entityName && hole.holeID.toString() === holeIDStr && hole !== excludeHole);

	if (existing) {
		const newID = generateUniqueHoleID(entityName, holeIDStr);
		console.warn("‚ö†Ô∏è Duplicate hole ID detected:", entityName + ":" + holeIDStr, "‚úÖ Auto-assigned:", newID);
		return newID;
	}

	return holeIDStr;
}
// Enhanced unique ID generation for any format
function generateUniqueHoleID(entityName, baseID) {
	const baseIDStr = baseID.toString();

	// Analyze existing IDs in this entity
	const existingIDs = new Set();
	let maxNumeric = 0;
	let maxAlphaRow = "A";
	let maxAlphaNum = 0;

	allBlastHoles.forEach((hole) => {
		if (hole.entityName === entityName) {
			const holeID = hole.holeID.toString();
			existingIDs.add(holeID);

			// Track numeric IDs
			const numericMatch = holeID.match(/^(\d+)$/);
			if (numericMatch) {
				maxNumeric = Math.max(maxNumeric, parseInt(numericMatch[1]));
			}

			// Track alphanumeric IDs
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);

				if (letters.localeCompare(maxAlphaRow) > 0) {
					maxAlphaRow = letters;
					maxAlphaNum = number;
				} else if (letters === maxAlphaRow) {
					maxAlphaNum = Math.max(maxAlphaNum, number);
				}
			}
		}
	});

	// Determine format of base ID and generate appropriate new ID
	const numericMatch = baseIDStr.match(/^(\d+)$/);
	const alphaMatch = baseIDStr.match(/^([A-Z]+)(\d+)$/);

	if (numericMatch) {
		// Generate next numeric ID
		return (maxNumeric + 1).toString();
	} else if (alphaMatch) {
		// Generate next alphanumeric ID in same pattern
		const letters = alphaMatch[1];
		let newID;

		// Try incrementing the number first
		for (let num = 1; num <= maxAlphaNum + 10; num++) {
			newID = letters + num;
			if (!existingIDs.has(newID)) {
				return newID;
			}
		}

		// If that fails, increment the letter
		const nextLetter = incrementLetter(letters);
		return nextLetter + "1";
	} else {
		// Fallback: generate numeric ID
		return (maxNumeric + 1).toString();
	}
}

function parseK2Dcsv(data) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles)) allBlastHoles = [];
	randomHex = Math.floor(Math.random() * 16777215).toString(16);

	const lines = data.split("\n");
	let minX = Infinity;
	let minY = Infinity;

	const supportedLengths = [4, 7, 9, 12, 14, 20, 25, 30, 32, 35];
	const warnings = [];
	const newHolesForRowDetection = []; // Track holes that need row detection

	let blastNameValue = "BLAST_" + randomHex;

	for (let i = 0; i < lines.length; i++) {
		const rawLine = lines[i].trim();
		if (rawLine === "") continue;

		const values = rawLine.split(",");
		const len = values.length;

		if (values.every((v) => v.trim() === "")) continue;
		if (!supportedLengths.includes(len)) {
			warnings.push("Line " + (i + 1) + " skipped: unsupported column count (" + len + ")");
			continue;
		}

		let entityName = blastNameValue;
		let holeID, startX, startY, startZ, endX, endY, endZ;
		let holeDiameter = 0,
			holeType = "Undefined",
			fromHoleID = "",
			delay = 0,
			color = "red";
		let measuredLength = 0,
			measuredLengthTimeStamp = "09/05/1975 00:00:00";
		let measuredMass = 0,
			measuredMassTimeStamp = "09/05/1975 00:00:00";
		let measuredComment = "None",
			measuredCommentTimeStamp = "09/05/1975 00:00:00";
		let subdrill = 0;
		let rowID = 0;
		let posID = 0;
		let burden = 0;
		let spacing = 0;
		let connectorCurve = 0;

		if (len === 35) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
			rowID = values[30] && values[30].trim() !== "" ? parseInt(values[30]) : null;
			posID = values[31] && values[31].trim() !== "" ? parseInt(values[31]) : null;
			burden = parseFloat(values[32]);
			spacing = parseFloat(values[33]);
			connectorCurve = parseInt(values[34]);
		} else if (len === 32) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
			rowID = values[30] && values[30].trim() !== "" ? parseInt(values[30]) : null;
			posID = values[31] && values[31].trim() !== "" ? parseInt(values[31]) : null;
		} else if (len === 30) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			// Note: We'll ignore the saved calculated values and recalculate using calculateHoleGeometry
			subdrill = parseFloat(values[12]);
			holeDiameter = parseFloat(values[15]);
			holeType = values[16];
			fromHoleID = values[17];
			delay = parseInt(values[18]);
			color = values[19].replace(/\r$/, "");
			measuredLength = parseFloat(values[24]);
			measuredLengthTimeStamp = values[25];
			measuredMass = parseFloat(values[26]);
			measuredMassTimeStamp = values[27];
			measuredComment = values[28];
			measuredCommentTimeStamp = values[29];
		} else if (len === 14) {
			entityName = values[0];
			holeID = values[2];
			startX = parseFloat(values[3]);
			startY = parseFloat(values[4]);
			startZ = parseFloat(values[5]);
			endX = parseFloat(values[6]);
			endY = parseFloat(values[7]);
			endZ = parseFloat(values[8]);
			holeDiameter = parseFloat(values[9]);
			holeType = values[10];
			fromHoleID = values[11];
			delay = parseInt(values[12]);
			color = values[13].replace(/\r$/, "");
		} else if (len === 12) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			holeDiameter = parseFloat(values[7]);
			holeType = values[8];
			fromHoleID = values[9].includes(":::") ? values[9] : blastNameValue + ":::" + values[9];
			delay = parseInt(values[10]);
			color = values[11].replace(/\r$/, "");
		} else if (len === 9) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			holeDiameter = parseFloat(values[7]);
			holeType = values[8];
			fromHoleID = blastNameValue + ":::" + holeID;
		} else if (len === 7) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = parseFloat(values[4]);
			endY = parseFloat(values[5]);
			endZ = parseFloat(values[6]);
			fromHoleID = blastNameValue + ":::" + holeID;
		} else if (len === 4) {
			holeID = values[0];
			startX = parseFloat(values[1]);
			startY = parseFloat(values[2]);
			startZ = parseFloat(values[3]);
			endX = startX;
			endY = startY;
			endZ = startZ;
			fromHoleID = blastNameValue + ":::" + holeID;
		}

		// Calculate basic hole properties using the same logic as calculateHoleGeometry
		const dx = endX - startX;
		const dy = endY - startY;
		const dz = endZ - startZ;
		const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

		const epsilon = 1e-10;
		const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
		const dotProduct = dz;
		const normalizedDotProduct = magnitude < epsilon ? 0 : dotProduct / magnitude;

		const angle = 180 - Math.acos(normalizedDotProduct) * (180 / Math.PI);
		const bearing = (450 - Math.atan2(dy, dx) * (180 / Math.PI)) % 360;

		if (!isNaN(startX) && !isNaN(startY) && !isNaN(startZ) && !isNaN(endX) && !isNaN(endY) && !isNaN(endZ)) {
			// Create the hole object with initial values
			const hole = {
				entityName,
				entityType: "hole",
				holeID,
				startXLocation: startX,
				startYLocation: startY,
				startZLocation: startZ,
				endXLocation: endX,
				endYLocation: endY,
				endZLocation: endZ,
				gradeXLocation: endX, // Will be recalculated
				gradeYLocation: endY, // Will be recalculated
				gradeZLocation: endZ, // Will be recalculated
				subdrillAmount: subdrill,
				subdrillLength: 0, // Will be recalculated
				benchHeight: 0, // Will be recalculated
				holeDiameter,
				holeType,
				fromHoleID,
				timingDelayMilliseconds: delay,
				colorHexDecimal: color,
				holeLengthCalculated: length,
				holeAngle: angle,
				holeBearing: bearing,
				measuredLength,
				measuredLengthTimeStamp,
				measuredMass,
				measuredMassTimeStamp,
				measuredComment,
				measuredCommentTimeStamp,
				rowID,
				posID,
				visible: true,
				burden: burden || 0,
				spacing: spacing || 0,
				connectorCurve: connectorCurve || 0,
			};

			// Add to allBlastHoles array first
			allBlastHoles.push(hole);
			// If this hole needs row detection, add to list
			if (rowID === null || rowID === 0 || posID === null || posID === 0) {
				newHolesForRowDetection.push(hole);
			}

			// Calculate proper benchHeight and grade positions for ALL holes (not just when subdrill !== 0)
			if (len !== 4) {
				// Only skip for 4-point holes (which are just collar coordinates)
				const cosAngle = Math.cos(angle * (Math.PI / 180));
				if (Math.abs(cosAngle) > 1e-9) {
					// Calculate benchHeight from the Z difference minus subdrill
					hole.benchHeight = Math.abs(startZ - endZ) - subdrill;

					// Use calculateHoleGeometry to recalculate all derived positions
					// First recalculate based on the existing length to set up grade positions
					calculateHoleGeometry(hole, length, 1); // Mode 1 = length recalculation

					// If there's subdrill, also update that
					if (subdrill !== 0) {
						calculateHoleGeometry(hole, subdrill, 8); // Mode 8 = subdrill recalculation
					}
				} else {
					// For horizontal holes, handle specially
					hole.benchHeight = Math.abs(startZ - endZ);
					hole.gradeXLocation = endX;
					hole.gradeYLocation = endY;
					hole.gradeZLocation = endZ - subdrill;
				}
			}

			minX = Math.min(minX, startX);
			minY = Math.min(minY, startY);
		}
	}
	// Group holes by entity for row detection
	const entitiesForRowDetection = new Map();
	newHolesForRowDetection.forEach((hole) => {
		if (!entitiesForRowDetection.has(hole.entityName)) {
			entitiesForRowDetection.set(hole.entityName, []);
		}
		entitiesForRowDetection.get(hole.entityName).push(hole);
	});

	// In parseCSV and processCsvData:
	entitiesForRowDetection.forEach((holes, entityName) => {
		improvedSmartRowDetection(holes, entityName); //
	});

	// Auto-assign rowID/posID for holes that still don't have them
	const unassignedHoles = allBlastHoles.filter((hole) => hole.rowID === null || hole.rowID === 0 || hole.posID === null || hole.posID === 0);
	unassignedHoles.forEach((hole) => {
		if (!hole.rowID || hole.rowID === 0) {
			hole.rowID = getNextRowID(hole.entityName);
		}
		if (!hole.posID || hole.posID === 0) {
			hole.posID = getNextPosID(hole.entityName, hole.rowID);
		}
	});

	if (warnings.length > 0) {
		console.warn("parseK2Dcsv warnings:\n" + warnings.join("\n"));
	}
	// CRITICAL: Check for duplicate hole IDs after parsing
	const duplicateCheck = checkAndResolveDuplicateHoleIDs(allBlastHoles, "CSV import");

	if (duplicateCheck.hasDuplicates) {
		console.log("Resolved", duplicateCheck.resolved.length, "duplicate hole ID conflicts");

		// Show summary to user
		let summary = "Duplicate hole IDs resolved:\n\n";
		duplicateCheck.resolved.forEach((resolution) => {
			if (resolution.action === "renumbered") {
				summary += "? " + resolution.entityName + ":" + resolution.oldID + " ? " + resolution.newID + "\n";
			} else {
				summary += "? " + resolution.entityName + ":" + resolution.holeID + " (" + resolution.action + ")\n";
			}
		});

		alert(summary);
	}
	holeTimes = calculateTimes(allBlastHoles);
	drawData(allBlastHoles, selectedHole);
	return allBlastHoles;
}

async function handleDXFUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = async function (e) {
		const dxfContent = e.target.result;
		try {
			const parser = new DxfParser();
			const dxf = parser.parseSync(dxfContent);
			await parseDXFtoKadMaps(dxf);
		} catch (error) {
			console.error("DXF parsing failed:", error);
			alert("Error parsing DXF file.");
		}
	};
	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}
// Add this helper function to generate unique entity names
function getUniqueEntityName(baseName, entityType) {
	// If baseName doesn't exist in the map, use it as-is
	if (!allKADDrawingsMap.has(baseName)) {
		return baseName;
	}

	// Otherwise, increment until we find a unique name
	let counter = 1;
	let uniqueName = baseName + "_" + counter;

	while (allKADDrawingsMap.has(uniqueName)) {
		counter++;
		uniqueName = baseName + "_" + counter;
	}

	console.log("‚ö†Ô∏è Entity name collision avoided: '" + baseName + "' ‚Üí '" + uniqueName + "'");
	return uniqueName;
}

async function parseDXFtoKadMaps(dxf) {
	// Step 1) Create progress dialog for DXF parsing
	var progressUpdateDXF = null;
	var progressDialog = null;
	var progressBar = null;
	var progressText = null;
	var totalEntities = dxf.entities ? dxf.entities.length : 0;

	if (totalEntities > 10) {
		var progressContent = "<p>Parsing DXF File</p>" + "<p>Please wait, this may take a moment...</p>" + '<div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;">' + '<div id="dxfProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div>' + "</div>" + '<p id="dxfProgressText">Initializing...</p>';

		progressDialog = new FloatingDialog({
			title: "DXF Import Progress",
			content: progressContent,
			layoutType: "standard",
			width: 400,
			height: 200,
			showConfirm: false,
			showCancel: false,
			draggable: true,
		});

		progressDialog.show();

		// Step 2) Wait for dialog to render, then get progress elements
		await new Promise(function (resolve) {
			setTimeout(resolve, 50);
		});

		progressBar = document.getElementById("dxfProgressBar");
		progressText = document.getElementById("dxfProgressText");

		// Step 3) Update progress function
		progressUpdateDXF = function (percent, message) {
			if (progressBar) progressBar.style.width = percent + "%";
			if (progressText) progressText.textContent = message;
		};
	}

	// Step 4) seed counters so we never collide with existing entries
	var counts = {
		point: 0,
		line: 0,
		poly: 0,
		circle: 0,
		text: 0,
	};

	// Step 5) kirra.js centroid offsets
	var offsetX = 0; //centroidX || 0;
	var offsetY = 0; //centroidY || 0;
	// Step 6) Collections for surface data
	var surfacePoints = [];
	var surfaceTriangles = [];

	// Step 7) raw DXF color or bright-red fallback, but return as "#RRGGBB"
	function getColor(idx) {
		// pick the DXF color (decimal) or default grey
		var dec = idx != null && idx >= 0 ? idx : 0x777777;
		// convert to hex, pad to 6 digits, uppercase if you like
		var hex = dec.toString(16).padStart(6, "0").toUpperCase();
		return "#" + hex;
	}

	// Step 8) iterate over every entity with progress updates
	for (var index = 0; index < dxf.entities.length; index++) {
		var ent = dxf.entities[index];

		// Step 9) Update progress every entity and yield to UI periodically
		if (progressUpdateDXF) {
			var percent = Math.round((index / totalEntities) * 100);
			var message = "Processing entity " + (index + 1) + " of " + totalEntities;
			progressUpdateDXF(percent, message);

			// Yield to UI every 50 entities to allow progress bar to update
			if (index % 50 === 0) {
				await new Promise(function (resolve) {
					setTimeout(resolve, 0);
				});
			}
		}
		var t = ent.type.toUpperCase();
		var color = getColor(ent.color);

		// POINT or VERTEX
		if (t === "POINT" || t === "VERTEX") {
			var x = (ent.position && ent.position.x != null ? ent.position.x : ent.x) - offsetX;
			var y = (ent.position && ent.position.y != null ? ent.position.y : ent.y) - offsetY;
			var z = (ent.position && ent.position.z != null ? ent.position.z : ent.z) || 0;
			if (x == null || y == null) {
				console.warn("POINT/VERTEX missing coords:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseName = ent.name || "pointEntity_" + ++counts.point;
				var name = getUniqueEntityName(baseName, "point");

				allKADDrawingsMap.set(name, {
					entityName: name,
					entityType: "point",
					data: [
						{
							entityName: name,
							entityType: "point",
							pointID: 1,
							pointXLocation: x,
							pointYLocation: y,
							pointZLocation: z,
							color: color,
						},
					],
				});
			}
		}
		// INSERT ? single point
		else if (t === "INSERT") {
			if (!ent.position) {
				console.warn("INSERT missing position:", ent);
			} else {
				var xi = ent.position.x - offsetX;
				var yi = ent.position.y - offsetY;
				var zi = ent.position.z || 0;

				// FIXED: Use unique name generation
				var baseNameI = ent.name || "pointEntity_" + ++counts.point;
				var nameI = getUniqueEntityName(baseNameI, "point");

				allKADDrawingsMap.set(nameI, {
					entityName: nameI,
					entityType: "point",
					data: [
						{
							entityName: nameI,
							entityType: "point",
							pointID: 1,
							pointXLocation: xi,
							pointYLocation: yi,
							pointZLocation: zi,
							color: color,
						},
					],
				});
			}
		} else if (t === "LINE") {
			var v = ent.vertices;
			if (!v || v.length < 2) {
				console.warn("LINE missing vertices:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameL = ent.name || "lineEntity_" + ++counts.line;
				var nameL = getUniqueEntityName(baseNameL, "line");

				allKADDrawingsMap.set(nameL, {
					entityName: nameL,
					entityType: "line",
					data: [
						{
							entityName: nameL,
							entityType: "line",
							pointID: 1,
							pointXLocation: v[0].x - offsetX,
							pointYLocation: v[0].y - offsetY,
							pointZLocation: v[0].z || 0,
							lineWidth: 1,
							color: color,
							closed: false,
						},
						{
							entityName: nameL,
							entityType: "line",
							pointID: 2,
							pointXLocation: v[1].x - offsetX,
							pointYLocation: v[1].y - offsetY,
							pointZLocation: v[1].z || 0,
							lineWidth: 1,
							color: color,
							closed: false,
						},
					],
				});
			}
		}
		// LWPOLYLINE or POLYLINE ? poly (closed) or line (open)
		else if (t === "LWPOLYLINE" || t === "POLYLINE") {
			var verts = ent.vertices || ent.controlPoints || [];
			if (!verts.length) {
				console.warn("POLYLINE missing vertices:", ent);
			} else {
				var isClosed = !!(ent.closed || ent.shape);
				var entityType = isClosed ? "poly" : "line";
				var nameP;
				if (isClosed) {
					// FIXED: Use unique name generation
					var baseNameP = ent.name || "polyEntity_" + ++counts.poly;
					nameP = getUniqueEntityName(baseNameP, "poly");
				} else {
					// FIXED: Use unique name generation
					var baseNameP = ent.name || "lineEntity_" + ++counts.line;
					nameP = getUniqueEntityName(baseNameP, "line");
				}

				allKADDrawingsMap.set(nameP, {
					entityName: nameP,
					entityType: entityType,
					data: [],
				});
				var dataP = allKADDrawingsMap.get(nameP).data;
				verts.forEach(function (v, i) {
					dataP.push({
						entityName: nameP,
						entityType: entityType,
						pointID: i + 1,
						pointXLocation: v.x - offsetX,
						pointYLocation: v.y - offsetY,
						pointZLocation: v.z || 0,
						lineWidth: 1,
						color: color,
						closed: false,
					});
				});
				// close if flagged
				if (isClosed) {
					var v0p = verts[0];
					dataP.push({
						entityName: nameP,
						entityType: entityType,
						pointID: dataP.length + 1,
						pointXLocation: v0p.x - offsetX,
						pointYLocation: v0p.y - offsetY,
						pointZLocation: v0p.z || 0,
						lineWidth: 1,
						color: color,
						closed: true,
					});
				}
			}
		}
		// CIRCLE
		else if (t === "CIRCLE") {
			if (!ent.center) {
				console.warn("CIRCLE missing center:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameC = ent.name || "circleEntity_" + ++counts.circle;
				var nameC = getUniqueEntityName(baseNameC, "circle");

				allKADDrawingsMap.set(nameC, {
					entityName: nameC,
					entityType: "circle",
					data: [
						{
							entityName: nameC,
							entityType: "circle",
							pointID: 1,
							pointXLocation: ent.center.x - offsetX,
							pointYLocation: ent.center.y - offsetY,
							pointZLocation: ent.center.z || 0,
							radius: ent.radius,
							lineWidth: 1,
							color: color,
						},
					],
				});
			}
		}
		// ELLIPSE sampled as closed polygon
		else if (t === "ELLIPSE") {
			if (!ent.center) {
				console.warn("ELLIPSE missing center:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameE = ent.name || "polyEntity_" + ++counts.poly;
				var nameE = getUniqueEntityName(baseNameE, "poly");

				allKADDrawingsMap.set(nameE, {
					entityName: nameE,
					entityType: "poly",
					data: [],
				});
				var dataE = allKADDrawingsMap.get(nameE).data;
				var segs = 64;
				for (var i = 0; i < segs; i++) {
					var angle = ent.startAngle + (ent.endAngle - ent.startAngle) * (i / (segs - 1));
					var px = ent.center.x + ent.xRadius * Math.cos(angle) - offsetX;
					var py = ent.center.y + ent.yRadius * Math.sin(angle) - offsetY;
					var closed = true;
					dataE.push({
						entityName: nameE,
						entityType: "poly",
						pointID: i + 1,
						pointXLocation: px,
						pointYLocation: py,
						pointZLocation: ent.center.z || 0,
						lineWidth: 1,
						color: color,
						closed: closed,
					});
				}
				// close loop
				dataE.push(
					Object.assign({}, dataE[0], {
						pointID: dataE.length + 1,
					})
				);
			}
		}
		// TEXT or MTEXT
		else if (t === "TEXT" || t === "MTEXT") {
			var pos = ent.startPoint || ent.position;
			if (!pos) {
				console.warn("TEXT missing position:", ent);
			} else {
				// FIXED: Use unique name generation
				var baseNameT = ent.name || "textEntity_" + ++counts.text;
				var nameT = getUniqueEntityName(baseNameT, "text");

				allKADDrawingsMap.set(nameT, {
					entityName: nameT,
					entityType: "text",
					data: [
						{
							entityName: nameT,
							entityType: "text",
							pointID: 1,
							pointXLocation: pos.x - offsetX,
							pointYLocation: pos.y - offsetY,
							pointZLocation: pos.z || 0,
							text: ent.text,
							color: color,
							fontHeight: ent.height || 12, // Step B1) Add fontHeight from DXF, default 12
						},
					],
				});
			}
		} // NEW: 3DFACE handling for surfaces
		else if (t === "3DFACE") {
			// 3DFACE entities have vertices property with 4 allBlastHoles (last one often duplicates first for triangles)
			var verts = ent.vertices;
			if (!verts || verts.length < 3) {
				console.warn("3DFACE missing vertices:", ent);
			} else {
				// Extract the three unique vertices for the triangle
				var p1 = {
					x: verts[0].x - offsetX,
					y: verts[0].y - offsetY,
					z: verts[0].z || 0,
				};
				var p2 = {
					x: verts[1].x - offsetX,
					y: verts[1].y - offsetY,
					z: verts[1].z || 0,
				};
				var p3 = {
					x: verts[2].x - offsetX,
					y: verts[2].y - offsetY,
					z: verts[2].z || 0,
				};

				// Add allBlastHoles to surface allBlastHoles collection (with deduplication)
				var p1Index = addUniquePoint(surfacePoints, p1);
				var p2Index = addUniquePoint(surfacePoints, p2);
				var p3Index = addUniquePoint(surfacePoints, p3);

				// Create triangle referencing the point indices
				surfaceTriangles.push({
					vertices: [surfacePoints[p1Index], surfacePoints[p2Index], surfacePoints[p3Index]],
					minZ: Math.min(p1.z, p2.z, p3.z),
					maxZ: Math.max(p1.z, p2.z, p3.z),
				});
			}
		}
		// anything else ? skip
		else {
			console.warn("Unsupported DXF entity:", ent.type);
		}
	}
	// NEW: Create and SAVE surface from 3DFACE data if any triangles were found
	if (surfaceTriangles.length > 0) {
		var surfaceName = "DXF_Surface_" + Date.now();
		var surfaceId = getUniqueEntityName(surfaceName, "surface");

		console.log("Creating surface from DXF 3DFACE entities: " + surfaceTriangles.length + " triangles, " + surfacePoints.length + " points");

		// Add to surfaces system (same as point cloud)
		loadedSurfaces.set(surfaceId, {
			id: surfaceId,
			name: surfaceId,
			points: surfacePoints,
			triangles: surfaceTriangles,
			visible: true,
			gradient: "hillshade", // Could be "hillshade" for your lighting effect
			transparency: 1.0,
			minLimit: null,
			maxLimit: null,
		});

		// Update display
		updateCentroids();
		drawData(allBlastHoles, selectedHole);

		// CRITICAL: Save to database using async pattern like point cloud loader
		setTimeout(async () => {
			try {
				await saveSurfaceToDB(surfaceId);
				console.log("‚úÖ DXF surface saved to database: " + surfaceId);
				debouncedUpdateTreeView();
			} catch (saveError) {
				console.error("? Failed to save DXF surface:", saveError);
			}
		}, 100);
	}

	// Step 10) Update progress to 100% and close dialog
	if (progressUpdateDXF) {
		progressUpdateDXF(100, "DXF import complete!");
		setTimeout(function () {
			if (progressDialog) {
				progressDialog.close();
			}
		}, 500);
	}

	console.log("Appended to KAD maps:", {
		drawings: allKADDrawingsMap,
	});
	// Trigger a debounced save to persist the newly loaded data
	debouncedSaveKAD();
	// Frame the newly loaded data correctly on the canvas
	zoomToFitAll();
}

function addUniquePoint(pointsArray, newPoint, tolerance = 0.001) {
	// Check if point already exists within tolerance
	for (let i = 0; i < pointsArray.length; i++) {
		const existingPoint = pointsArray[i];
		const dx = Math.abs(existingPoint.x - newPoint.x);
		const dy = Math.abs(existingPoint.y - newPoint.y);
		const dz = Math.abs(existingPoint.z - newPoint.z);

		if (dx < tolerance && dy < tolerance && dz < tolerance) {
			return i; // Return existing point index
		}
	}

	// Point doesn't exist, add it
	pointsArray.push({
		...newPoint,
	}); // Create a copy to avoid reference issues
	return pointsArray.length - 1; // Return new point index
}

function handleGeotiffUpload(event) {
	const file = event.target.files[0];
	if (file) {
		loadGeoTIFF(file);
		updateStatusMessage("Loading geotiff: " + file.name);
	}
	debouncedUpdateTreeView(); // Use debounced version
}

function handleSurfaceUpload(event) {
	var allFiles = event.target.files;
	if (!allFiles || allFiles.length === 0) return;

	// Step 1) Categorize selected files
	var objFiles = [];
	var pointCloudFiles = [];
	var companionFiles = []; // MTL, JPG, PNG, etc.
	var pointCloudExtensions = ["xyz", "csv", "txt", "asc", "ply", "pts"];
	var companionExtensions = ["mtl", "jpg", "jpeg", "png", "gif", "bmp"];

	for (var i = 0; i < allFiles.length; i++) {
		var file = allFiles[i];
		var ext = file.name.split(".").pop().toLowerCase();

		if (ext === "obj") {
			objFiles.push(file);
		} else if (pointCloudExtensions.indexOf(ext) !== -1) {
			pointCloudFiles.push(file);
		} else if (companionExtensions.indexOf(ext) !== -1) {
			companionFiles.push(file);
		}
	}

	// Step 2) OBJ file(s) selected - load with MTL/texture support
	if (objFiles.length > 0) {
		// Load each OBJ with all selected files (for MTL/texture matching)
		objFiles.forEach(function (objFile) {
			updateStatusMessage("Loading OBJ surface: " + objFile.name);
			loadOBJWithMTL(objFile, allFiles);
		});
	}
	// Step 3) No OBJ but point cloud files selected - load those
	else if (pointCloudFiles.length > 0) {
		pointCloudFiles.forEach(function (pcFile) {
			updateStatusMessage("Loading surface: " + pcFile.name);
			loadPointCloudFile(pcFile);
		});
	}
	// Step 4) Only MTL/JPG files without OBJ - ignore with message
	else if (companionFiles.length > 0) {
		updateStatusMessage("?? Please select an OBJ file along with MTL/texture files");
		console.warn(
			"MTL/texture files selected without OBJ - ignoring. Selected:",
			companionFiles
				.map(function (f) {
					return f.name;
				})
				.join(", ")
		);
	}
	// Step 5) No valid files
	else {
		updateStatusMessage("No valid surface files found");
	}

	debouncedUpdateTreeView();
}

// ENHANCED: Update OBJ loading to pass texture data
async function loadOBJWithMTL(objFile, allFiles) {
	try {
		// Step 1) Read OBJ file content
		var objContent = await readFileAsText(objFile);
		var baseName = objFile.name.replace(/\.obj$/i, "");

		// Step 2) Look for MTL file
		var mtlContent = null;
		var mtlFile = null;
		for (var i = 0; i < allFiles.length; i++) {
			var file = allFiles[i];
			if (file.name.toLowerCase() === baseName.toLowerCase() + ".mtl") {
				mtlContent = await readFileAsText(file);
				mtlFile = file;
				updateStatusMessage("Found material file: " + file.name);
				break;
			}
		}

		// Step 3) Look for texture files (JPG, PNG, etc.)
		var textureFiles = [];
		var textureBlobs = {};
		for (var j = 0; j < allFiles.length; j++) {
			var texFile = allFiles[j];
			var ext = texFile.name.split(".").pop().toLowerCase();
			if (ext === "jpg" || ext === "jpeg" || ext === "png" || ext === "gif" || ext === "bmp") {
				textureFiles.push(texFile);
				// Read texture as blob for storage
				textureBlobs[texFile.name] = await readFileAsBlob(texFile);
				updateStatusMessage("Found texture file: " + texFile.name);
			}
		}

		// Step 4) Parse OBJ to get points/triangles for Data Explorer
		var objData = parseOBJFile(objContent, mtlContent);

		// Step 5) Check if this is a textured mesh (has MTL + texture files)
		var hasTextures = mtlContent && textureFiles.length > 0;

		if (hasTextures) {
			console.log("üé® Loading textured OBJ mesh: " + objFile.name);
			// Step 6) Use Three.js loaders for textured mesh
			await loadOBJWithTextureThreeJS(objFile.name, objContent, mtlContent, textureBlobs, objData);
		} else {
			// Step 7) No textures - use existing point cloud/surface method
			if (objData.points && objData.points.length > 0) {
				if (objData.points.length > 10000) {
					showDecimationWarning(objData.points, objFile.name, objData);
				} else {
					processSurfacePoints(objData.points, objFile.name, objData);
				}
			}
		}
	} catch (error) {
		console.error("‚ùå Error loading OBJ with MTL:", error);
		// If anything fails, use normal OBJ loading
		loadPointCloudFile(objFile);
	}
}

// Step 1) Read file as Text helper function
async function readFileAsText(file) {
	return new Promise(function (resolve, reject) {
		var reader = new FileReader();
		reader.onload = function (e) {
			resolve(e.target.result);
		};
		reader.onerror = function (e) {
			reject(e);
		};
		reader.readAsText(file);
	});
}

// Step 2) Read file as Blob helper function
async function readFileAsBlob(file) {
	return new Promise(function (resolve, reject) {
		var reader = new FileReader();
		reader.onload = function (e) {
			resolve(new Blob([e.target.result], { type: file.type }));
		};
		reader.onerror = function (e) {
			reject(e);
		};
		reader.readAsArrayBuffer(file);
	});
}

// Step 3) Load OBJ with texture using Three.js loaders
async function loadOBJWithTextureThreeJS(fileName, objContent, mtlContent, textureBlobs, objData) {
	// Step 1) Create progress dialog
	const progressContent = document.createElement("div");
	progressContent.style.textAlign = "center";
	progressContent.innerHTML = "<p>Loading OBJ File: " + fileName + '</p><p>Please wait...</p><div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;"><div id="objProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div></div><p id="objProgressText">Initializing...</p>';

	const progressDialog = new FloatingDialog({
		title: "Loading OBJ",
		content: progressContent,
		layoutType: "standard",
		width: 350,
		height: 200,
		showConfirm: false,
		showCancel: false,
		allowOutsideClick: false,
	});

	progressDialog.show();

	const bar = document.getElementById("objProgressBar");
	const text = document.getElementById("objProgressText");

	return new Promise(function (resolve, reject) {
		try {
			// Step 3) Create texture URLs from blobs
			var textureURLs = {};
			var blobURLs = []; // Track for cleanup
			text.textContent = "Creating texture URLs...";
			bar.style.width = "10%";

			Object.keys(textureBlobs).forEach(function (texName) {
				var url = URL.createObjectURL(textureBlobs[texName]);
				textureURLs[texName] = url;
				blobURLs.push(url);
				console.log("üé® Created blob URL for texture: " + texName);
			});

			// Step 4) Extract texture references directly from MTL content
			// This is more reliable than depending on MTLLoader's internal structure
			var textureRefs = extractTextureRefsFromMTL(mtlContent);
			console.log("üé® Texture references from MTL: " + textureRefs.join(", "));
			text.textContent = "Loading textures (" + Object.keys(textureBlobs).length + ")...";
			bar.style.width = "20%";

			// Step 5) Pre-load all textures into a map
			var textureLoader = new THREE.TextureLoader();
			var loadedTextures = {};
			var texturePromises = [];

			// Step 5a) Load each texture blob we have
			Object.keys(textureBlobs).forEach(function (texName) {
				var texturePromise = new Promise(function (resolveTexture) {
					textureLoader.load(
						textureURLs[texName],
						function (texture) {
							// Step 5b) Texture loaded successfully
							texture.wrapS = THREE.RepeatWrapping;
							texture.wrapT = THREE.RepeatWrapping;
							texture.flipY = true; // Standard UV convention
							texture.needsUpdate = true;
							loadedTextures[texName] = texture;
							loadedTextures[texName.toLowerCase()] = texture; // Also store lowercase for matching
							console.log("üé® Texture pre-loaded: " + texName);
							// Update progress
							const loadedCount = Object.keys(loadedTextures).length / 2; // Divide by 2 (we store twice)
							const totalCount = Object.keys(textureBlobs).length;
							const progress = 20 + (loadedCount / totalCount) * 30; // 20% to 50%
							bar.style.width = progress + "%";
							text.textContent = "Loaded texture " + loadedCount + " of " + totalCount;
							resolveTexture();
						},
						undefined, // onProgress
						function (error) {
							console.warn("üö® Failed to pre-load texture: " + texName, error);
							resolveTexture();
						}
					);
				});
				texturePromises.push(texturePromise);
			});

			// Step 6) Wait for ALL textures to pre-load
			Promise.all(texturePromises).then(function () {
				console.log("üé® All " + Object.keys(loadedTextures).length + " textures pre-loaded for: " + fileName);
				text.textContent = "Parsing MTL materials...";
				bar.style.width = "55%";

				// Step 7) Parse MTL content
				var mtlLoader = new MTLLoader();
				mtlLoader.setResourcePath("");
				var materials = mtlLoader.parse(mtlContent);
				materials.preload();

				text.textContent = "Parsing OBJ geometry...";
				bar.style.width = "70%";

				// Step 8) Parse OBJ content with materials
				var objLoader = new OBJLoader();
				objLoader.setMaterials(materials);
				var object3D = objLoader.parse(objContent);
				object3D.name = fileName;

				text.textContent = "Applying textures to mesh...";
				bar.style.width = "85%";

				// Step 9) Extract material properties from MTL for storage
				var materialProperties = extractMaterialProperties(mtlContent);
				console.log("üé® Extracted material properties: " + Object.keys(materialProperties).length + " materials");

				// Step 9a) Apply textures to mesh materials by matching texture filenames
				// Also collect final material properties (after texture application) for storage
				var finalMaterialProperties = {};
				object3D.traverse(function (child) {
					if (child.isMesh) {
						child.material.side = THREE.DoubleSide;

						// Step 9a.1) Find matching texture for this material
						var appliedTexture = false;
						var appliedTextureName = null;

						// Try to find texture by checking each loaded texture
						Object.keys(loadedTextures).forEach(function (texKey) {
							if (!appliedTexture && loadedTextures[texKey]) {
								// Apply the first available texture
								child.material.map = loadedTextures[texKey];
								child.material.needsUpdate = true;
								appliedTexture = true;
								appliedTextureName = texKey;
								console.log("üé® Applied texture '" + texKey + "' to mesh: " + (child.name || "unnamed"));
							}
						});

						if (!appliedTexture) {
							console.warn("üö® No texture applied to mesh: " + (child.name || "unnamed"));
						}

						// Step 9a.2) Store final material properties (after texture application)
						var materialName = child.name || "default";
						var matProps = materialProperties[materialName] ||
							materialProperties[Object.keys(materialProperties)[0]] || {
							Kd: [1, 1, 1],
							Ns: 0,
							map_Kd: appliedTextureName,
						};

						finalMaterialProperties[materialName] = {
							name: materialName,
							Ka: matProps.Ka || [0, 0, 0],
							Kd: matProps.Kd || [1, 1, 1],
							Ks: matProps.Ks || [0, 0, 0],
							Ns: matProps.Ns || 0,
							map_Kd: appliedTextureName || matProps.map_Kd || null,
							illum: matProps.illum || 2,
						};
					}
				});

				// Step 12) Calculate mesh bounds for georeferencing
				// CRITICAL: Use objData.points (UTM world coordinates) NOT object3D (object-local coordinates)
				// OBJ vertices are in UTM world coordinates, but object3D is in object-local space
				var meshBounds = null;
				if (objData && objData.points && objData.points.length > 0) {
					// Calculate bounds from UTM world coordinates (objData.points)
					var minX = Infinity,
						maxX = -Infinity;
					var minY = Infinity,
						maxY = -Infinity;
					var minZ = Infinity,
						maxZ = -Infinity;
					for (var i = 0; i < objData.points.length; i++) {
						var pt = objData.points[i];
						if (pt.x < minX) minX = pt.x;
						if (pt.x > maxX) maxX = pt.x;
						if (pt.y < minY) minY = pt.y;
						if (pt.y > maxY) maxY = pt.y;
						if (pt.z < minZ) minZ = pt.z;
						if (pt.z > maxZ) maxZ = pt.z;
					}
					meshBounds = { minX: minX, maxX: maxX, minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ };
					console.log("üìê Calculated meshBounds from UTM points: " + minX.toFixed(2) + " " + maxX.toFixed(2) + " " + minY.toFixed(2) + " " + maxY.toFixed(2));
				} else {
					// Fallback: use object3D bounds (object-local) if points not available
					var bounds = new THREE.Box3().setFromObject(object3D);
					meshBounds = {
						minX: bounds.min.x,
						maxX: bounds.max.x,
						minY: bounds.min.y,
						maxY: bounds.max.y,
						minZ: bounds.min.z,
						maxZ: bounds.max.z,
					};
					console.warn("üö® Using object-local bounds (fallback) - meshBounds may be incorrect!");
				}

				// Step 13) Create surface ID
				var surfaceId = fileName;

				// Step 14) Store in loadedSurfaces with all necessary data
				loadedSurfaces.set(surfaceId, {
					// Standard surface fields for Data Explorer
					id: surfaceId,
					name: fileName,
					points: objData.points,
					triangles: objData.triangles,
					visible: true,
					gradient: "texture", // Default to "texture" to show JPG texture if available
					transparency: 1.0,

					// Textured mesh specific fields
					isTexturedMesh: true,
					threeJSMesh: object3D,
					meshBounds: meshBounds,

					// Raw data for IndexedDB persistence
					objContent: objContent,
					mtlContent: mtlContent,
					textureBlobs: textureBlobs,
					materialProperties: finalMaterialProperties, // Store serializable material properties
				});

				console.log("üé® Textured OBJ loaded: " + fileName + " (" + objData.points.length + " points, " + objData.triangles.length + " triangles)");

				// Step 15) Create flattened 2D image for canvas rendering
				// This is now called AFTER textures are loaded
				flattenTexturedMeshToImage(surfaceId, object3D, meshBounds, fileName);

				// Step 16) Save to database
				saveSurfaceToDB(surfaceId)
					.then(function () {
						console.log("üíæ Textured surface saved to database: " + surfaceId);
					})
					.catch(function (err) {
						console.error("‚ùå Failed to save textured surface:", err);
					});

				// Step 17) Update UI
				updateCentroids();
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				updateStatusMessage("Loaded textured surface: " + fileName);

				// Step 18) Cleanup blob URLs after a delay (textures are now loaded)
				setTimeout(function () {
					blobURLs.forEach(function (url) {
						URL.revokeObjectURL(url);
					});
				}, 5000);

				// Step 19) Close progress dialog
				text.textContent = "Complete!";
				bar.style.width = "100%";
				setTimeout(function () {
					progressDialog.close();
				}, 500);

				resolve(object3D);
			});
		} catch (error) {
			console.error("‚ùå Error in loadOBJWithTextureThreeJS:", error);
			// Close progress dialog on error
			if (progressDialog) {
				progressDialog.close();
			}
			reject(error);
		}
	});
}

// Step 1) Rebuild textured mesh from stored data (called on app reload)
function rebuildTexturedMesh(surfaceId) {
	var surface = loadedSurfaces.get(surfaceId);
	if (!surface || !surface.isTexturedMesh) {
		console.warn("üö® Cannot rebuild mesh - not a textured surface:", surfaceId);
		return;
	}

	if (!surface.objContent) {
		console.warn("üö® Cannot rebuild mesh - missing OBJ content:", surfaceId);
		return;
	}

	// Step 1a) Prevent multiple rebuilds - if mesh already exists, skip
	if (surface.threeJSMesh) {
		console.log("üé® Mesh already rebuilt for: " + surfaceId + ", skipping rebuild");
		return;
	}

	try {
		// Step 2) Create texture URLs from stored blobs
		var textureURLs = {};
		var blobURLs = [];

		if (surface.textureBlobs) {
			Object.keys(surface.textureBlobs).forEach(function (texName) {
				var blob = surface.textureBlobs[texName];
				if (blob) {
					var url = URL.createObjectURL(blob);
					textureURLs[texName] = url;
					blobURLs.push(url);
				}
			});
		}

		// Step 3) Pre-load all textures into a map (same approach as initial load)
		var textureLoader = new THREE.TextureLoader();
		var loadedTextures = {};
		var texturePromises = [];

		Object.keys(textureURLs).forEach(function (texName) {
			var texturePromise = new Promise(function (resolveTexture) {
				textureLoader.load(
					textureURLs[texName],
					function (texture) {
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.flipY = true;
						texture.needsUpdate = true;
						loadedTextures[texName] = texture;
						loadedTextures[texName.toLowerCase()] = texture;
						resolveTexture();
					},
					undefined,
					function (error) {
						console.warn("üö® Failed to pre-load texture during rebuild: " + texName, error);
						resolveTexture();
					}
				);
			});
			texturePromises.push(texturePromise);
		});

		// Step 4) Wait for ALL textures to pre-load before proceeding
		Promise.all(texturePromises).then(function () {
			// Step 5) Parse OBJ WITHOUT materials (we'll apply materials manually from stored properties)
			var objLoader = new OBJLoader();
			var object3D = objLoader.parse(surface.objContent);
			object3D.name = surface.name;

			// Step 5a) Create materials from stored properties + texture blobs
			// This is more reliable than MTLLoader which expects file URLs
			var materialMap = {};
			if (surface.materialProperties && Object.keys(surface.materialProperties).length > 0) {
				console.log("üé® Creating materials from stored properties");
				Object.keys(surface.materialProperties).forEach(function (matName) {
					var matProps = surface.materialProperties[matName];
					var textureName = matProps.map_Kd;
					// Find texture from already-loaded textures map (textures loaded from blobs above)
					var texture = null;
					if (textureName && loadedTextures[textureName]) {
						texture = loadedTextures[textureName];
					} else if (textureName && loadedTextures[textureName.toLowerCase()]) {
						texture = loadedTextures[textureName.toLowerCase()];
					} else {
						// Use first available texture
						var firstTexKey = Object.keys(loadedTextures)[0];
						if (firstTexKey) {
							texture = loadedTextures[firstTexKey];
							console.log("üé® Using first available loaded texture: " + firstTexKey);
						}
					}

					materialMap[matName] = createMaterialFromProperties(matProps, texture, textureName);
					console.log("üé® Created material '" + matName + "' with texture: " + (texture ? textureName : "none"));
				});
			} else {
				// Fallback: Create default material with first available loaded texture
				console.warn("üö® No material properties found, creating default material");
				var firstTexKey = Object.keys(loadedTextures)[0];
				var firstTexture = firstTexKey ? loadedTextures[firstTexKey] : null;
				materialMap["default"] = createMaterialFromProperties(null, firstTexture, firstTexKey);
			}

			// Step 7) Apply materials to mesh (from materialMap created from stored properties)
			var texturesApplied = 0;
			var texturesFailed = 0;
			object3D.traverse(function (child) {
				if (child.isMesh) {
					// Find matching material from materialMap
					var materialName = child.name || "default";
					var material = materialMap[materialName] || materialMap["default"] || materialMap[Object.keys(materialMap)[0]];

					if (material) {
						child.material = material.clone();
						child.material.side = THREE.DoubleSide;
						texturesApplied++;
					} else {
						// Fallback: use default material
						child.material = new THREE.MeshStandardMaterial({
							color: 0xffffff,
							side: THREE.DoubleSide,
						});
						texturesFailed++;
					}
				}
			});

			// Step 8) Remove old mesh from scene if it exists (ensures new mesh with textures replaces old one)
			if (window.threeRenderer && window.threeRenderer.surfaceMeshMap) {
				var oldMesh = window.threeRenderer.surfaceMeshMap.get(surfaceId);
				if (oldMesh) {
					// Remove old mesh from scene
					if (window.threeRenderer.surfacesGroup) {
						window.threeRenderer.surfacesGroup.remove(oldMesh);
					}
					// Dispose old mesh to free resources
					oldMesh.traverse(function (child) {
						if (child.geometry) child.geometry.dispose();
						if (child.material) {
							if (Array.isArray(child.material)) {
								child.material.forEach(function (mat) {
									mat.dispose();
								});
							} else {
								child.material.dispose();
							}
						}
					});
					// Remove from map
					window.threeRenderer.surfaceMeshMap.delete(surfaceId);
					console.log("üßπ Removed old mesh from scene - will be re-added with textures on next render");
				}
			}

			// Step 8a) Store rebuilt mesh
			surface.threeJSMesh = object3D;

			console.log("üé® Rebuilt textured mesh: " + surfaceId);

			// Step 8a) CRITICAL: Force gradient to "texture" for textured meshes (overrides any saved gradient)
			// Textured meshes MUST use "texture" gradient to show JPG textures, not color gradients
			var oldGradient = surface.gradient;
			if (surface.gradient !== "texture") {
				surface.gradient = "texture";
				console.log("üîª FORCED gradient to 'texture' for rebuilt textured mesh: " + surfaceId + " (was: " + (oldGradient || "default") + ")");
			}

			// Step 8b) Mesh is rebuilt - it will render automatically on next drawData call
			// Don't force redraw here to avoid excessive redraws - let natural rendering cycle handle it

			// Step 9) Cleanup blob URLs after delay
			setTimeout(function () {
				blobURLs.forEach(function (url) {
					URL.revokeObjectURL(url);
				});
			}, 5000);

			// Step 10) Recreate flattened image for 2D canvas
			// This is now called AFTER textures are loaded
			// Step 10a) Check if we have a saved flattened image first
			if (surface.flattenedImageDataURL && surface.flattenedImageBounds && surface.flattenedImageDimensions) {
				console.log("üèûÔ∏è Reusing saved flattened image for: " + surfaceId);
				loadFlattenedImageFromData(surfaceId, surface.flattenedImageDataURL, surface.flattenedImageBounds, surface.flattenedImageDimensions, surface.name);
			} else if (surface.meshBounds && threeInitialized && !threeInitializationFailed) {
				// Step 10b) Only flatten if ThreeJS is initialized and no saved image exists
				console.log("üèûÔ∏è  Creating new flattened image for: " + surfaceId);
				flattenTexturedMeshToImage(surfaceId, object3D, surface.meshBounds, surface.name);
			} else if (!threeInitialized || threeInitializationFailed) {
				console.warn("üö® Skipping texture flattening - ThreeJS not available, will retry when ThreeJS initializes");
			}
		});
	} catch (error) {
		console.error("‚ùå Error rebuilding textured mesh:", error);
	}
}

// Step 0) Load flattened image from saved data URL (avoids WebGL context creation)
function loadFlattenedImageFromData(surfaceId, imageDataURL, meshBounds, dimensions, fileName) {
	try {
		console.log("üèûÔ∏è Loading flattened image from saved data for: " + surfaceId);

		var imageId = "flattened_" + surfaceId;
		var imageCanvas = document.createElement("canvas");
		imageCanvas.width = dimensions.width;
		imageCanvas.height = dimensions.height;
		var imageCtx = imageCanvas.getContext("2d");

		var img = new Image();
		img.onload = function () {
			imageCtx.drawImage(img, 0, 0);

			var worldWidth = meshBounds.maxX - meshBounds.minX;
			var worldHeight = meshBounds.maxY - meshBounds.minY;

			var imageEntry = {
				id: imageId,
				name: fileName + "_flattened",
				canvas: imageCanvas,
				bbox: [meshBounds.minX, meshBounds.minY, meshBounds.maxX, meshBounds.maxY],
				width: dimensions.width,
				height: dimensions.height,
				visible: true,
				transparency: 1.0,
				zElevation: window.drawingZLevel || meshBounds.minZ || 0,
				isGeoReferenced: true,
				bounds: {
					minX: meshBounds.minX,
					maxX: meshBounds.maxX,
					minY: meshBounds.minY,
					maxY: meshBounds.maxY,
				},
				pixelWidth: worldWidth / dimensions.width,
				pixelHeight: worldHeight / dimensions.height,
				sourceType: "flattened_obj",
				sourceSurfaceId: surfaceId,
			};

			loadedImages.set(imageId, imageEntry);
			console.log("üèûÔ∏è Loaded flattened image from saved data: " + imageId);
			debouncedUpdateTreeView();
		};
		img.onerror = function () {
			console.error("‚ùå Failed to load flattened image from saved data");
		};
		img.src = imageDataURL;
	} catch (error) {
		console.error("‚ùå Error loading flattened image from data:", error);
	}
}

// Step 1) Flatten textured mesh to 2D image for canvas rendering
function flattenTexturedMeshToImage(surfaceId, mesh, meshBounds, fileName) {
	try {
		// Step 1a) Check WebGL availability before attempting to create offscreen renderer
		// This prevents context exhaustion errors on page reload when OBJ is in IndexedDB
		if (!threeInitialized) {
			console.warn("üö® Skipping texture flattening - ThreeJS not initialized yet for: " + surfaceId);
			return;
		}

		// Step 1b) Additional check - don't create offscreen renderer if main renderer failed
		if (threeInitializationFailed) {
			console.warn("üö® Skipping texture flattening - ThreeJS initialization previously failed for: " + surfaceId);
			return;
		}

		// Step 2) Calculate image dimensions based on mesh bounds
		var worldWidth = meshBounds.maxX - meshBounds.minX;
		var worldHeight = meshBounds.maxY - meshBounds.minY;

		// Step 3) Determine resolution for high quality (300 DPI equivalent)
		// For mine site data, assume coordinates are in meters
		// 300 DPI at 1:1000 scale = 300 * (1/1000) * 39.37 = ~11.8 pixels per meter
		// For better quality, use higher resolution: 4096px max, minimum 1024px
		var maxResolution = 4096; // Increased from 2048 for better quality
		var minResolution = 1024; // Minimum size for reasonable quality
		var targetPixelsPerMeter = 15; // Higher for better detail

		var aspectRatio = worldWidth / worldHeight;
		var imgWidth, imgHeight;

		// Calculate based on target pixels per meter, clamped to max/min
		if (aspectRatio > 1) {
			imgWidth = Math.min(maxResolution, Math.max(minResolution, Math.ceil(worldWidth * targetPixelsPerMeter)));
			imgHeight = Math.ceil(imgWidth / aspectRatio);
		} else {
			imgHeight = Math.min(maxResolution, Math.max(minResolution, Math.ceil(worldHeight * targetPixelsPerMeter)));
			imgWidth = Math.ceil(imgHeight * aspectRatio);
		}

		// Ensure minimum size for reasonable quality
		imgWidth = Math.max(minResolution, imgWidth);
		imgHeight = Math.max(minResolution, imgHeight);

		console.log("üèûÔ∏è Creating flattened image: " + imgWidth + "x" + imgHeight + " for mesh bounds: " + worldWidth.toFixed(2) + "x" + worldHeight.toFixed(2));

		// Step 4) Create offscreen renderer
		var offscreenRenderer = new THREE.WebGLRenderer({
			antialias: true,
			preserveDrawingBuffer: true,
		});
		offscreenRenderer.setSize(imgWidth, imgHeight);
		offscreenRenderer.setClearColor(0xffffff, 0); // Transparent background

		// Step 4a) Calculate mesh center as local origin for this specific render
		// CRITICAL: Use mesh's own center as origin, NOT threeLocalOriginX/Y
		// This makes the flattening self-contained and independent of external state
		// Centers the mesh at (0,0) for optimal GPU precision during rendering
		var meshCenterX = (meshBounds.minX + meshBounds.maxX) / 2;
		var meshCenterY = (meshBounds.minY + meshBounds.maxY) / 2;
		var halfWidth = worldWidth / 2;
		var halfHeight = worldHeight / 2;

		console.log("üéØ Mesh center for flattening: (" + meshCenterX.toFixed(2) + ", " + meshCenterY.toFixed(2) + "), half-extents: " + halfWidth.toFixed(2) + " x " + halfHeight.toFixed(2));

		// Step 5) Create orthographic camera looking down (top-down view)
		// Use SYMMETRIC frustum centered at 0 - mesh will be transformed to match
		var camera = new THREE.OrthographicCamera(
			-halfWidth, // left
			halfWidth, // right
			halfHeight, // top
			-halfHeight, // bottom
			-10000, // near
			10000 // far
		);
		// Camera at origin looking down
		camera.position.set(0, 0, meshBounds.maxZ + 1000);
		camera.lookAt(0, 0, 0);
		camera.up.set(0, 1, 0); // Y is North

		// Step 6) Create scene with the mesh
		var scene = new THREE.Scene();
		scene.background = null; // Transparent

		// Add ambient light
		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(ambientLight);

		// Clone mesh for rendering - ensure textures are preserved
		var meshClone = mesh.clone();

		// Step 6a) Deep copy materials and TRANSFORM VERTEX POSITIONS to be centered at origin
		// CRITICAL: Subtract mesh center from all vertices so mesh is centered at (0,0)
		meshClone.traverse(function (child) {
			if (child.isMesh) {
				// Clone material and ensure texture references are maintained
				if (child.material) {
					if (Array.isArray(child.material)) {
						child.material = child.material.map(function (mat) {
							var clonedMat = mat.clone();
							if (mat.map) {
								clonedMat.map = mat.map;
								clonedMat.needsUpdate = true;
							}
							return clonedMat;
						});
					} else {
						var originalMat = child.material;
						child.material = originalMat.clone();
						if (originalMat.map) {
							child.material.map = originalMat.map;
							child.material.needsUpdate = true;
						}
					}
					child.material.side = THREE.DoubleSide;
				}

				// Step 6b) Transform vertex positions to center mesh at origin
				if (child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
					var positions = child.geometry.attributes.position;
					var posArray = positions.array;

					for (var i = 0; i < posArray.length; i += 3) {
						posArray[i] -= meshCenterX; // X - subtract center
						posArray[i + 1] -= meshCenterY; // Y - subtract center
						// Z stays unchanged
					}

					positions.needsUpdate = true;
					child.geometry.computeBoundingBox();
					child.geometry.computeBoundingSphere();
				}
			}
		});

		scene.add(meshClone);

		// Step 7) Render the scene
		offscreenRenderer.render(scene, camera);

		// Step 8) Extract image data as dataURL for creating canvas
		var rendererCanvas = offscreenRenderer.domElement;
		var imageDataURL = rendererCanvas.toDataURL("image/png");

		// Step 9) Create an HTMLCanvasElement from the rendered image
		// NOTE: loadedImages entries MUST have a 'canvas' property (HTMLCanvasElement)
		// and 'bbox' in array format [minX, minY, maxX, maxY] for drawing functions
		var imageId = "flattened_" + surfaceId;
		var imageCanvas = document.createElement("canvas");
		imageCanvas.width = imgWidth;
		imageCanvas.height = imgHeight;
		var imageCtx = imageCanvas.getContext("2d");

		// Step 10) Load the rendered image into the canvas
		var img = new Image();
		img.onload = function () {
			imageCtx.drawImage(img, 0, 0);

			// Step 11) Create georeferenced image entry for loadedImages
			var imageEntry = {
				id: imageId,
				name: fileName + "_flattened",
				canvas: imageCanvas, // HTMLCanvasElement - required by drawBackgroundImageThreeJS
				bbox: [meshBounds.minX, meshBounds.minY, meshBounds.maxX, meshBounds.maxY], // Array format [minX, minY, maxX, maxY]
				width: imgWidth,
				height: imgHeight,
				visible: true,
				transparency: 1.0,
				zElevation: window.drawingZLevel || meshBounds.minZ || 0, // Z elevation for 3D positioning

				// Georeferencing data
				isGeoReferenced: true,
				bounds: {
					minX: meshBounds.minX,
					maxX: meshBounds.maxX,
					minY: meshBounds.minY,
					maxY: meshBounds.maxY,
				},

				// Pixel to world transformation
				pixelWidth: worldWidth / imgWidth,
				pixelHeight: worldHeight / imgHeight,

				// Source info
				sourceType: "flattened_obj",
				sourceSurfaceId: surfaceId,
			};

			// Step 12) Store in loadedImages
			loadedImages.set(imageId, imageEntry);

			console.log("üèûÔ∏è Created flattened image for 2D canvas: " + imageId);

			// Step 12a) Save flattened image data URL back to surface for IndexedDB persistence
			var surface = loadedSurfaces.get(surfaceId);
			if (surface) {
				surface.flattenedImageDataURL = imageDataURL;
				surface.flattenedImageBounds = meshBounds;
				surface.flattenedImageDimensions = { width: imgWidth, height: imgHeight };

				// Step 12b) Save to IndexedDB
				saveSurfaceToDB(surfaceId).catch(function (err) {
					console.warn("üö® Failed to save flattened image to DB:", err);
				});
			}

			// Step 13) Update tree view to show new image
			debouncedUpdateTreeView();
		};
		img.onerror = function () {
			console.error("‚ùå Failed to create canvas from flattened image");
		};
		img.src = imageDataURL;

		// Step 14) Cleanup offscreen renderer
		offscreenRenderer.dispose();
		scene.clear();
	} catch (error) {
		console.error("? Error flattening textured mesh:", error);
	}
}

async function handleMeasuredUpload(event) {
	// Measured data format: EntityName,EntityType,PointID,MeasuredLength,MeasuredLengthTimeStamp,MeasuredMass,MeasuredMassTimeStamp,MeasuredComment,MeasuredCommentTimeStamp

	if (!event.target.files[0].name.endsWith(".csv")) {
		fileFormatPopup("1");
		return;
	}
	if (allBlastHoles.length === 0) {
		fileFormatPopup("2");
		return;
	}

	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = function (e) {
		const fileContent = e.target.result;
		const lines = fileContent.split("\n").filter((line) => line.trim().length > 0);

		// Skip header if present
		const header = lines[0].toLowerCase();
		const startIndex = header.includes("entityname") ? 1 : 0;

		for (let i = startIndex; i < lines.length; i++) {
			const cols = lines[i].split(",");
			if (cols.length < 9) continue; // Skip malformed lines

			const entityName = cols[0].trim();
			const holeID = cols[2].trim();

			// Find matching point
			const point = allBlastHoles.find((p) => p.entityName === entityName && p.holeID === holeID);
			if (point) {
				point.measuredLength = parseFloat(cols[3]) || 0;
				point.measuredLengthTimeStamp = cols[4].trim() || "09/05/1975 00:00:00";
				point.measuredMass = parseFloat(cols[5]) || 0;
				point.measuredMassTimeStamp = cols[6].trim() || "09/05/1975 00:00:00";
				point.measuredComment = cols[7].trim();
				point.measuredCommentTimeStamp = cols[8].trim() || "09/05/1975 00:00:00";
			}
		}

		drawData(allBlastHoles, selectedHole); // Redraw to reflect updated values
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

function fileFormatPopup(error) {
	console.log("File format error");
	showModalMessage("Error " + error, "This could be related to the data structure or file.<br><br>" + "Or there are NO blasts or Holes yet, if so ignore.<br><br>" + "Only files with 4, 7, 9, 14, 30, 32 and 35 columns are Accepted<br><br>" + "Column Order and Types are important.", "error");
}
// Create a Map for each entity type to store entities by name

let allKADDrawingsMap = new Map();

// Step #) Convert CSS color names to hex for 3D compatibility
// Three.js batched rendering only handles hex colors, not named colors
function cssColorToHex(colorInput) {
	if (!colorInput) return "#FF0000"; // Default red

	var color = String(colorInput).trim();

	// Already a hex color
	if (color.charAt(0) === "#") return color;

	// RGB/RGBA format
	if (color.toLowerCase().startsWith("rgb")) return color;

	// CSS color name lookup table (common colors)
	var colorNames = {
		"red": "#FF0000",
		"green": "#008000",
		"blue": "#0000FF",
		"yellow": "#FFFF00",
		"orange": "#FFA500",
		"purple": "#800080",
		"pink": "#FFC0CB",
		"cyan": "#00FFFF",
		"magenta": "#FF00FF",
		"black": "#000000",
		"white": "#FFFFFF",
		"gray": "#808080",
		"grey": "#808080",
		"brown": "#A52A2A",
		"lime": "#00FF00",
		"limegreen": "#32CD32",
		"navy": "#000080",
		"teal": "#008080",
		"maroon": "#800000",
		"olive": "#808000",
		"aqua": "#00FFFF",
		"fuchsia": "#FF00FF",
		"silver": "#C0C0C0",
		"gold": "#FFD700",
		"coral": "#FF7F50",
		"crimson": "#DC143C",
		"darkblue": "#00008B",
		"darkgreen": "#006400",
		"darkred": "#8B0000",
		"lightblue": "#ADD8E6",
		"lightgreen": "#90EE90",
		"lightgray": "#D3D3D3",
		"lightgrey": "#D3D3D3",
		"darkgray": "#A9A9A9",
		"darkgrey": "#A9A9A9",
		"skyblue": "#87CEEB",
		"steelblue": "#4682B4",
		"turquoise": "#40E0D0",
		"violet": "#EE82EE",
		"indigo": "#4B0082",
		"tan": "#D2B48C",
		"beige": "#F5F5DC",
		"salmon": "#FA8072",
		"khaki": "#F0E68C"
	};

	var hex = colorNames[color.toLowerCase()];
	if (hex) return hex;

	// Fallback: try to use browser canvas to convert (handles any CSS color)
	try {
		var tempCanvas = document.createElement("canvas");
		tempCanvas.width = 1;
		tempCanvas.height = 1;
		var tempCtx = tempCanvas.getContext("2d");
		tempCtx.fillStyle = color;
		// Get the computed color (will be in rgb format)
		var computedColor = tempCtx.fillStyle;
		if (computedColor.charAt(0) === "#") return computedColor;
		// Parse rgb(r,g,b) format
		var match = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
		if (match) {
			var r = parseInt(match[1]).toString(16).padStart(2, "0");
			var g = parseInt(match[2]).toString(16).padStart(2, "0");
			var b = parseInt(match[3]).toString(16).padStart(2, "0");
			return "#" + r + g + b;
		}
	} catch (e) {
		console.warn("Could not convert color:", color, e);
	}

	return "#FF0000"; // Default to red if all else fails
}

function parseKADFile(fileData) {
	let minX = Infinity;
	let minY = Infinity;
	let pointID, pointXLocation, pointYLocation, pointZLocation, text, radius, color, closed, lineWidth;

	try {
		// ? Use PapaParse with error handling
		const parseResult = Papa.parse(fileData, {
			delimiter: "", // Auto-detect delimiter
			skipEmptyLines: true,
			trimHeaders: true,
			transform: (value) => value.trim(),
		});

		// ? Check for critical parsing errors
		const criticalErrors = parseResult.errors.filter((error) => error.type === "Delimiter" || error.type === "Quotes");

		if (criticalErrors.length > 0) {
			showModalMessage("File Parsing Error", "Failed to parse the file properly:<br><br>" + criticalErrors.map((error) => "<li>" + error.message + "</li>").join("") + "<br><br>" + "Common causes:<br><br>" + "<li>Mixed delimiters (commas and tabs in same file)</li>" + "<li>Unescaped quotes in text fields</li>" + "<li>Inconsistent number of columns</li>" + "<br><br>" + "Please check your file format and try again.", "error");
			return; // Exit early
		}

		// ? Warn about minor parsing issues but continue
		if (parseResult.errors.length > 0) {
			console.warn("CSV parsing warnings:", parseResult.errors);

			const additionalErrors = parseResult.errors.length > 5 ? "<li>... and " + (parseResult.errors.length - 5) + " more</li>" : "";
			showModalMessage(
				"File Import Warning",
				"The file was imported but there were " +
				parseResult.errors.length +
				" parsing warnings:<br><br>" +
				parseResult.errors
					.slice(0, 5)
					.map((error) => "<li>Row " + error.row + ": " + error.message + "</li>")
					.join("") +
				additionalErrors +
				"<br><br>" +
				"Some data may have been skipped. Check your results carefully.",
				"warning"
			);
		}

		const dataRows = parseResult.data;

		// ? Check if we got any data
		if (dataRows.length === 0) {
			showModalMessage("Empty File", "The file appears to be empty or contains no valid data.", "warning");
			return;
		}

		console.log("Parsed " + dataRows.length + " rows with delimiter: " + parseResult.meta.delimiter);

		let successCount = 0;
		let errorCount = 0;
		let errorDetails = [];

		// Parse each row with individual error handling
		for (let i = 0; i < dataRows.length; i++) {
			try {
				const row = dataRows[i];

				// Skip rows that don't have enough columns
				if (row.length < 3) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Too few columns (" + row.length + ")");
					continue;
				}

				const entityName = row[0];
				const entityType = row[1];

				// Skip if missing essential data
				if (!entityName || !entityType) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Missing entity name or type");
					continue;
				}

				// ? Validate entity type
				const validTypes = ["point", "line", "poly", "circle", "text"];
				if (!validTypes.includes(entityType)) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Invalid entity type '" + entityType + "'");
					continue;
				}

				// ? Your existing parsing logic here (same as before)
				switch (entityType) {
					case "point":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "point",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]) || 1;
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							connected: false,
							closed: false,
						});
						break;

					case "poly":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: entityType,
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));
						closed = String(row[8]).trim().toLowerCase() === "true";

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: closed,
						});
						break;

					case "line":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "line",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "line",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: false,
						});
						break;

					case "circle":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "circle",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						radius = parseFloat(row[6]);
						lineWidth = parseFloat(row[7]) || 1;
						color = cssColorToHex((row[8] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "circle",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							radius: radius,
							lineWidth: lineWidth,
							color: color,
						});
						break;

					case "text":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "text",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						text = row[6] || "";
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));
						// Step B1) Read fontHeight from column 8, default to 12 for backward compatibility
						var textFontHeight = row[8] ? parseFloat(row[8]) : 12;

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "text",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							text: text,
							color: color,
							fontHeight: textFontHeight,
						});
						break;
				}

				successCount++;
			} catch (rowError) {
				errorCount++;
				errorDetails.push("Row " + (i + 1) + ": " + rowError.message);
				console.error("Error parsing row " + (i + 1) + ":", rowError);
			}
		}

		// ? Show import results
		if (successCount > 0) {
			let message = "Successfully imported " + successCount + " items.";

			if (errorCount > 0) {
				message += "\n" + errorCount + " items failed to import.";
			}

			const errorDetailsHtml =
				errorCount > 0
					? "<details>" +
					"<summary>View Error Details (" +
					errorCount +
					" errors)</summary>" +
					'<ul style="max-height: 200px; overflow-y: auto; text-align: left;">' +
					errorDetails
						.slice(0, 10)
						.map((error) => "<li>" + error + "</li>")
						.join("") +
					(errorDetails.length > 10 ? "<li>... and " + (errorDetails.length - 10) + " more errors</li>" : "") +
					"</ul>" +
					"</details>"
					: "";

			showModalMessage(errorCount > 0 ? "Import Completed with Errors" : "Import Successful", message + errorDetailsHtml, errorCount > 0 ? "warning" : "success");
		} else {
			// ? Complete failure
			const errorDetailsHtml =
				'<div style="text-align: left;">' +
				"<p><strong>No items could be imported.</strong></p>" +
				"<p><strong>Common issues:</strong></p>" +
				"<ul>" +
				"<li>Wrong file format or column order</li>" +
				"<li>Missing required columns</li>" +
				"<li>Invalid data types</li>" +
				"</ul>" +
				"<details>" +
				"<summary>View Error Details</summary>" +
				'<ul style="max-height: 200px; overflow-y: auto;">' +
				errorDetails
					.slice(0, 10)
					.map((error) => "<li>" + error + "</li>")
					.join("") +
				"</ul>" +
				"</details>" +
				"</div>";

			showModalMessage("Import Failed", errorDetailsHtml, "error");
			return;
		}

		// Calculate centroid (existing logic)
		let sumX = 0;
		let sumY = 0;
		let count = 0;

		for (let [key, value] of allKADDrawingsMap) {
			for (let i = 0; i < value.data.length; i++) {
				sumX += value.data[i].pointXLocation;
				sumY += value.data[i].pointYLocation;
				count++;
			}
		}

		if (count > 0) {
			centroidX = sumX / count;
			centroidY = sumY / count;
		}

		console.log(allKADDrawingsMap);
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	} catch (error) {
		// ? Catch any unexpected errors
		console.error("Unexpected error during KAD file parsing:", error);

		showModalMessage("Unexpected Error", '<div style="text-align: left;">' + "<p><strong>An unexpected error occurred while importing the file:</strong></p>" + "<p><code>" + error.message + "</code></p>" + "<p>Please check the file format and try again. If the problem persists, contact support.</p>" + "</div>", "error");
	}
}

let mapData = [allKADDrawingsMap];

function exportKADFile() {
	// First, check if we have data to export
	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		alert("No data to export. Please add some drawings first.");
		return;
	}

	console.log("Exporting KAD data, map size:", allKADDrawingsMap.size);

	// Prepare the CSV content for .kad file
	let csvContentKAD = "";
	let csvContentTXT = "";

	try {
		// Directly iterate through the allKADDrawingsMap
		for (const [entityName, entityData] of allKADDrawingsMap.entries()) {
			// ? ONLY ADD THIS LINE - check visibility using your existing function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity:", entityName);
				continue;
			}
			// Log each entity we're processing
			console.log(`Processing entity: ${entityName}, type: ${entityData.entityType}`);

			if (!entityData || !entityData.entityType) {
				console.warn(`Skipping invalid entity: ${entityName}`);
				continue;
			}

			if (entityData.entityType.trim() === "point") {
				for (const point of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${point.pointID},${point.pointXLocation},${point.pointYLocation},${point.pointZLocation},${point.lineWidth || 1},${point.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "poly") {
				for (let i = 0; i < entityData.data.length; i++) {
					const polygon = entityData.data[i];
					const isLast = i === entityData.data.length - 1;
					const csvLine = `${entityName},${entityData.entityType},${polygon.pointID},${polygon.pointXLocation},${polygon.pointYLocation},${polygon.pointZLocation},${polygon.lineWidth},${polygon.color},${isLast ? "1" : "0"}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "line") {
				for (const entityLine of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${entityLine.pointID},${entityLine.pointXLocation},${entityLine.pointYLocation},${entityLine.pointZLocation},${entityLine.lineWidth},${entityLine.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "circle") {
				for (const circle of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${circle.pointID},${circle.pointXLocation},${circle.pointYLocation},${circle.pointZLocation},${circle.radius},${circle.lineWidth},${circle.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "text") {
				for (const text of entityData.data) {
					// Step B4) Include fontHeight in export (column 8), default to 12 for backward compatibility
					var exportFontHeight = text.fontHeight || 12;
					const csvLine = entityName + "," + entityData.entityType + "," + text.pointID + "," + text.pointXLocation + "," + text.pointYLocation + "," + text.pointZLocation + "," + text.text + "," + text.color + "," + exportFontHeight + "\n";
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			}
		}
	} catch (error) {
		console.error("Error generating KAD export:", error);
		alert("Error exporting KAD file: " + error.message);
		return;
	}

	// If we generated any content, create and download the files
	if (csvContentKAD) {
		// Create a Blob with the CSV content for .kad file
		const blobKAD = new Blob([csvContentKAD], {
			type: "text/csv",
		});

		// Create a Blob with the CSV content for .txt file
		const blobTXT = new Blob([csvContentTXT], {
			type: "text/plain",
		});

		// Create temporary anchor elements to trigger the download for both files
		const aKAD = document.createElement("a");
		const aTXT = document.createElement("a");

		// Set the content for the anchor elements
		aKAD.href = URL.createObjectURL(blobKAD);
		aKAD.download = "KAD_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".kad";

		aTXT.href = URL.createObjectURL(blobTXT);
		aTXT.download = "TXT_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".txt";

		// Simulate clicks on both anchor elements to trigger the downloads
		aKAD.click();
		aTXT.click();

		console.log("KAD export completed successfully");
	} else {
		alert("No data to export. Please add some drawings first.");
	}
}

function getNearestNeighborDistancesByAggregation(allBlastHoles, mode, useToeLocation) {
	// Step 1: Compute nearest neighbor distances for each point
	const nearestDistances = allBlastHoles.map((pt, idx) => {
		let minDist = Infinity;
		for (let j = 0; j < allBlastHoles.length; j++) {
			if (j === idx) continue;
			const otherPt = allBlastHoles[j];

			const dx = useToeLocation ? otherPt.endXLocation - pt.endXLocation : otherPt.startXLocation - pt.startXLocation;
			const dy = useToeLocation ? otherPt.endYLocation - pt.endYLocation : otherPt.startYLocation - pt.startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			if (dist < minDist) minDist = dist;
		}
		return minDist;
	});
	// Step 2: Determine the distance to use based on the mode
	let chosenDistance;
	if (mode === "min") {
		chosenDistance = Math.min(...nearestDistances);
	} else if (mode === "max") {
		chosenDistance = Math.max(...nearestDistances);
	} else if (mode === "average" || mode === "mean") {
		const sum = nearestDistances.reduce((a, b) => a + b, 0);
		chosenDistance = sum / nearestDistances.length;
	} else if (mode === "mode") {
		// Find the most common value (rounded to nearest cm for stability)
		const freq = {};
		let maxFreq = 0,
			modeValue = nearestDistances[0];
		nearestDistances.forEach((d) => {
			const rounded = Math.round(d * 100); // round to cm
			freq[rounded] = (freq[rounded] || 0) + 1;
			if (freq[rounded] > maxFreq) {
				maxFreq = freq[rounded];
				modeValue = rounded / 100;
			}
		});
		chosenDistance = modeValue;
	} else {
		console.warn("Unknown mode for getRadiiBlastHolesPolygon:", mode, "Defaulting to  min.");
		chosenDistance = Math.min(...nearestDistances);
	}
	return chosenDistance;
}

/**
 * Get the unioned polygon of circles around blast holes, with radius based on nearest neighbor distances.
 * @param {Array} allBlastHoles - Array of allBlastHoles, each with startXLocation, startYLocation, startZLocation, endXLocation, endYLocation, endZLocation.
 * @param {number} percentDistance - Percentage to scale the chosen distance metric.
 * @param {number} steps - Number of steps for circle polygon-isation.
 * @param {string} mode - One of "min", "max", "average", "mode" (statistical mode of distances).
 * @returns {Array} Array of {x, y, z} points representing the unioned polygon.
 */
function getRadiiBlastHolesPolygon(allBlastHoles, percentDistance, steps, mode = "min") {
	const scale = 100000; // Clipper uses integers; scale meters to avoid precision loss

	// Step 2: Use the helper function to determine distance
	const chosenDistance = getNearestNeighborDistancesByAggregation(allBlastHoles, mode);

	// Step 3: Calculate the radius to use
	const radius = chosenDistance * (percentDistance / 100);

	// Step 4: Build circle polygons for each point
	const circlePolygons = allBlastHoles.map((pt) => {
		const centerX = pt.endXLocation;
		const centerY = pt.endYLocation;
		const centerZ = pt.endZLocation;
		const path = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			const z = centerZ; // keep flat for now
			path.push({
				X: Math.round(x * scale),
				Y: Math.round(y * scale),
				Z: z,
			});
		}
		return path;
	});

	// Step 5: Perform union using clipper-lib
	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(circlePolygons, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		console.warn("Clipper union failed or returned empty result.");
		return [];
	}

	// Step 6: Return the unioned polygon as an array of {x, y, z}
	return solution[0].map((pt) => {
		const realX = pt.X / scale;
		const realY = pt.Y / scale;
		// Nearest Z from original centers
		let nearestZ = 0;
		let minDist = Infinity;
		allBlastHoles.forEach((p) => {
			const dx = p.startXLocation - realX;
			const dy = p.startYLocation - realY;
			const dist = dx * dx + dy * dy;
			if (dist < minDist) {
				minDist = dist;
				nearestZ = p.startZLocation;
			}
		});
		return {
			x: realX,
			y: realY,
			z: nearestZ,
		};
	});
}

document.getElementById("createRadiiFromBlastHoles").addEventListener("click", function () {
	// Get the values from the input fields
	const radius = parseFloat(document.getElementById("drawingPolygonRadius").value);
	const lineWidth = parseFloat(document.getElementById("drawingLineWidth").value);
	const color = getJSColorHexDrawing();
	const steps = parseInt(document.getElementById("radiiSteps").value);
	const union = true;
	const addToMaps = true;

	// Check if the radius is a valid number
	if (isNaN(radius) || radius <= 0) {
		alert("Please enter a valid radius.");
		return;
	}
	// Check if the line width is a valid number
	if (isNaN(lineWidth) || lineWidth <= 0) {
		alert("Please enter a valid line width.");
		return;
	}

	// Determine which holes to process
	let targetHoles = allBlastHoles;
	let datasetDescription = "all holes";

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		targetHoles = selectedMultipleHoles;
		datasetDescription = "selected holes";
	} else if (selectedHole) {
		targetHoles = [selectedHole];
		datasetDescription = "selected hole";
	}

	// Add performance warning for large number of holes
	if (targetHoles.length > 1000) {
		Swal.fire({
			title: "Performance Warning",
			html: `
				<div style="text-align: center;">
					<p><strong>?? Large Dataset Detected</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p style="color: #f39c12;"><strong>Warning:</strong><br>
					This may take significant time and could cause<br>
					the browser to become unresponsive.</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Recommendations:</strong></p>
					<p style="text-align: left; margin: 0 auto; display: inline-block;">
						? Reduce steps (current: ${steps})<br>
						? Process smaller sections<br>
						? Save work before continuing
					</p>
				</div>
			`,
			icon: "warning",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container",
			},
		}).then((result) => {
			if (result.isConfirmed) {
				// Show progress message
				updateStatusMessage("Processing radii polygons for " + targetHoles.length + " " + datasetDescription + "... This may take a while.");

				// Use setTimeout to allow UI to update before processing
				setTimeout(() => {
					try {
						const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
						drawData(allBlastHoles, selectedHole);
						updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
					} catch (error) {
						console.error("Error creating radii polygons:", error);
						updateStatusMessage("Error creating radii polygons. Please try with fewer holes or reduced steps.");
						Swal.fire({
							title: "Error",
							html: `
								<div style="text-align: center;">
									<p><strong>Failed to create radii polygons.</strong></p>
									<hr style="border-color: #555; margin: 15px 0;">
									<p><strong>Try:</strong></p>
									<p style="text-align: left; margin: 0 auto; display: inline-block;">
										? Reducing steps<br>
										? Processing fewer holes<br>
										? Refreshing browser
									</p>
								</div>
							`,
							icon: "error",
							customClass: {
								container: "custom-popup-container",
								confirmButton: "confirm",
							},
						});
					}
				}, 100);
			}
		});
	} else if (targetHoles.length > 500) {
		// Medium warning for 500-1000 holes
		Swal.fire({
			title: "Performance Notice",
			html: `
				<div style="text-align: center;">
					<p><strong>Medium Dataset</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Note:</strong><br>Processing may take a few moments.</p>
				</div>
			`,
			icon: "info",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container",
			},
		}).then((result) => {
			if (result.isConfirmed) {
				processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
				debouncedUpdateTreeView(); // Use debounced version
			}
		});
	} else {
		// Process normally for smaller datasets
		processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
		debouncedUpdateTreeView(); // Use debounced version
	}
});
// Helper function to check if an entity is effectively visible (including parent groups)
function isEntityEffectivelyVisible(entityName, entityType, entityVisible = true) {
	// Check blast holes
	if (entityType === "hole") {
		return blastGroupVisible && entityVisible !== false;
	}

	// Check drawings
	if (!drawingsGroupVisible) return false;

	// Check specific drawing type groups
	if (entityType === "points") return pointsGroupVisible && entityVisible !== false;
	if (entityType === "lines") return linesGroupVisible && entityVisible !== false;
	if (entityType === "polygons") return polygonsGroupVisible && entityVisible !== false;
	if (entityType === "circles") return circlesGroupVisible && entityVisible !== false;
	if (entityType === "texts") return textsGroupVisible && entityVisible !== false;

	return entityVisible !== false;
}
// Helper function to process radii polygons
function processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription) {
	try {
		updateStatusMessage("Creating radii polygons for " + targetHoles.length + " " + datasetDescription + "...");
		const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
		// Step 1) Create success message content
		const successContent = '<div style="text-align: center;">' + "<p><strong>Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".</strong></p>" + "<p><strong>Zoom or Scroll to see the results.</strong></p>" + "<p><strong>The radii is at " + radius + "m from the hole(s).</strong></p>" + "</div>";

		// Step 2) Show success modal and handle saving
		showModalMessage("Success", successContent, "success");

		// Step 3) Save the drawing and update tree view
		debouncedSaveKAD();
		debouncedUpdateTreeView(); // Use debounced version
	} catch (error) {
		console.error("Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");
		// Step 1) Create error message content
		const errorContent = '<div style="text-align: center;">' + "<p><strong>Failed to create radii polygons.</strong></p>" + '<hr style="border-color: #555; margin: 15px 0;">' + "<p><strong>Error:</strong><br>" + (error.message || "Unknown error occurred") + "</p>" + "</div>";

		// Step 2) Show error modal using showModalMessage
		showModalMessage("Error", errorContent, "error");
	}
}

// Convert hex color (e.g., #FF0000) to a DXF color index (1-255, never 0 or 256)
function getColorInteger(hex) {
	// Remove the '#' character if present
	if (hex.startsWith("#")) {
		hex = hex.slice(1);
	}
	// Parse the hex string as an integer
	const intValue = parseInt(hex, 16);
	const r = (intValue >> 16) & 0xff;
	const g = (intValue >> 8) & 0xff;
	const b = intValue & 0xff;

	// Basic mapping for common colors
	if (r === 255 && g === 0 && b === 0) return 1; // red
	if (r === 255 && g === 255 && b === 0) return 2; // yellow
	if (r === 0 && g === 255 && b === 0) return 3; // green
	if (r === 0 && g === 255 && g === 255) return 4; // cyan
	if (r === 0 && g === 0 && b === 255) return 5; // blue
	if (r === 255 && g === 0 && b === 255) return 6; // magenta
	if (r === 255 && g === 255 && g === 255) return 7; // white

	// For other colors, approximate to 8-255 (never 0 or 256)
	const gray = Math.round((r + g + b) / 3);
	const index = Math.max(8, Math.min(255, Math.round((gray / 255) * 247) + 8));
	console.log("Color index:", index);
	return index;
}

/**
 * Exports map data to a DXF (Drawing Exchange Format) string and creates a Blob for download.
 *
 * The function iterates through the provided map data and converts supported entities
 * (point, line, poly, circle, text) into their corresponding DXF representations.
 * Each entity is added to the DXF content string, which is then used to create a Blob.
 *
 * @param {Array<Map<string, Object>>} mapData - An array of Map objects, where each Map contains
 *   entity names as keys and entity data objects as values. Each entity data object should have:
 *   - {string} entityType - The type of the entity ("point", "line", "poly", "circle", "text").
 *   - {Array<Object>} data - An array of entity?specific data objects.
 *
 * Entity data object structure varies by entityType:
 *   - "point": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "line": { pointXLocation, pointYLocation, pointZLocation, pointXTarget, pointYTarget, pointZTarget, color }
 *   - "poly": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "circle": { pointXLocation, pointYLocation, pointZLocation, radius, color }
 *   - "text": { pointXLocation, pointYLocation, pointZLocation, text, color }
 *
 * @returns {void}
 */
function exportKADDXF() {
	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	const allMaps = [allKADDrawingsMap];

	for (const map of allMaps) {
		for (const [entityName, entityData] of map.entries()) {
			// ? ADD: Check if entity is visible using existing visibility function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity for DXF export:", entityName);
				continue;
			}

			const type = entityData.entityType.trim();
			const data = entityData.data;

			data.forEach((item, index) => {
				// ? ADD: Check individual element visibility
				if (item.visible === false) {
					return; // Skip hidden elements
				}

				//get the first color of the first point in the item
				let color = 1;
				color = typeof item.color === "string" ? getColorInteger(item.color) : 1; // default to red if no color is provided
				if (type === "point") {
					dxf += "0\nPOINT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "line") {
					if (index === 0 && data.length > 1) {
						// ? ADD: Filter visible points for polyline (open)
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n0\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "poly") {
					if (index === 0 && data.length > 1) {
						// ? ADD: Filter visible points for polyline
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n1\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "circle") {
					dxf += "0\nCIRCLE\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n" + item.radius + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "text") {
					dxf += "0\nTEXT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n0.5\n"; // text height
					dxf += "50\n0.0\n"; // rotation
					dxf += "1\n" + item.text + "\n";
					dxf += "62\n" + color + "\n";
				}
			});
		}
	}

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

/**
 * Exports visible holes as a structured DXF file with proper layer organization
 *
 * Structure:
 * - EntityName_HoleID_Collar: Green collar circle
 * - EntityName_HoleID_Track: Grey hole track line (full length)
 * - EntityName_HoleID_Grade: Orange grade circle
 * - EntityName_HoleID_Toe: Red toe circle
 * - EntityName_HoleID_Text: Grey hole ID text
 */
function exportHolesDXF(visibleBlastHoles) {
	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	visibleBlastHoles.forEach((hole) => {
		const entityName = hole.entityName || "Unknown";
		const holeID = hole.holeID || "Unknown";
		const baseLayerName = entityName + "_" + holeID;

		// Calculate hole geometry
		const startX = hole.startXLocation || 0;
		const startY = hole.startYLocation || 0;
		const startZ = hole.startZLocation || 0;

		// Calculate end point based on hole parameters
		const length = hole.holeLengthCalculated || 0;
		const angle = (hole.holeAngle || 0) * (Math.PI / 180); // Convert to radians
		const bearing = (hole.holeBearing || 0) * (Math.PI / 180); // Convert to radians
		const subdrill = hole.subdrillAmount || 0;

		// Calculate actual hole end (planned end without subdrill)
		const plannedLength = length - subdrill;
		const endX = startX + plannedLength * Math.sin(bearing) * Math.sin(angle);
		const endY = startY + plannedLength * Math.cos(bearing) * Math.sin(angle);
		const endZ = startZ - plannedLength * Math.cos(angle);

		// Calculate toe point (actual end with subdrill)
		const toeX = startX + length * Math.sin(bearing) * Math.sin(angle);
		const toeY = startY + length * Math.cos(bearing) * Math.sin(angle);
		const toeZ = startZ - length * Math.cos(angle);

		// Circle sizes
		const collarRadius = hole.holeDiameter ? hole.holeDiameter / 1000 / 2 : 0.1; // Convert mm to meters or default 0.1m
		const gradeRadius = 0.08; // 8cm radius for grade circle
		const toeRadius = 0.06; // 6cm radius for toe circle

		// 1. COLLAR CIRCLE (Green)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Collar\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n" + collarRadius + "\n";
		dxf += "420\n65280\n"; // Green (0,255,0)

		// 2. HOLE TRACK LINE (Grey - full length from collar to toe)
		dxf += "0\nLINE\n8\n" + baseLayerName + "_Track\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n"; // Start (collar)
		dxf += "11\n" + toeX + "\n21\n" + toeY + "\n31\n" + toeZ + "\n"; // End (toe)
		dxf += "420\n9868950\n"; // Grey (150,150,150)

		// 3. GRADE CIRCLE (Orange - end of planned hole)
		if (plannedLength > 0) {
			dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Grade\n";
			dxf += "10\n" + endX + "\n20\n" + endY + "\n30\n" + endZ + "\n";
			dxf += "40\n" + gradeRadius + "\n";
			dxf += "420\n16753920\n"; // Orange (255,165,0)
		}

		// 4. TOE CIRCLE (Red)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Toe\n";
		dxf += "10\n" + toeX + "\n20\n" + toeY + "\n30\n" + toeZ + "\n";
		dxf += "40\n" + toeRadius + "\n";
		dxf += "420\n16711680\n"; // Red (255,0,0)

		// 5. HOLE ID TEXT (Grey)
		dxf += "0\nTEXT\n8\n" + baseLayerName + "_Text\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n0.5\n"; // Text height (0.5m)
		dxf += "50\n0.0\n"; // Text rotation (0?)
		dxf += "1\n" + holeID + "\n";
		dxf += "420\n9868950\n"; // Grey (150,150,150)
	});

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

function convertPointsTo14ColumnCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	// Iterate over the visible allBlastHoles array
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsTo12ColumnCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToAllDataCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	const header =
		"entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID, burden, spacing, connectorCurve";
	csv += header + "\n";
	const decimalPlaces = 4;

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation.toFixed(decimalPlaces)},${hole.startYLocation.toFixed(decimalPlaces)},${hole.startZLocation},${hole.endXLocation.toFixed(decimalPlaces)},${hole.endYLocation.toFixed(decimalPlaces)},${hole.endZLocation.toFixed(decimalPlaces)},${hole.gradeXLocation.toFixed(decimalPlaces)},${hole.gradeYLocation.toFixed(decimalPlaces)},${hole.gradeZLocation.toFixed(decimalPlaces)},${hole.subdrillAmount.toFixed(
			decimalPlaces
		)},${hole.subdrillLength.toFixed(decimalPlaces)},${hole.benchHeight.toFixed(decimalPlaces)},${hole.holeDiameter.toFixed(decimalPlaces)},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated.toFixed(decimalPlaces)},${hole.holeAngle.toFixed(decimalPlaces)},${hole.holeBearing.toFixed(decimalPlaces)},${hole.holeTime},${hole.measuredLength.toFixed(decimalPlaces)},${hole.measuredLengthTimeStamp},${hole.measuredMass.toFixed(
			decimalPlaces
		)},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToActualDataCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return;

	let csv = "";
	const header = "entityName,entityType,holeID,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp";
	csv += header + "\n";

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToAQMCSV(allBlastHoles, fileNameValue, blastName, patternName, materialType, instructionValue, useHoleTypeAsInstruction, writeIngoreColumn, columnOrderArray) {
	// ? Filter input allBlastHoles to only visible ones
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return;

	let aqm = "";
	let material = materialType;
	let pattern = patternName;
	let blast = blastName;
	let instruction = instructionValue;
	let fileName = fileNameValue;
	let columns = columnOrderArray; // 11 possible columns

	// Iterate over the allBlastHoles array and convert each object to an AQM row
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];

		let columnOrder = []; // Initialize the column order for each row

		let toeX = parseFloat(hole.endXLocation.toFixed(4));
		let toeY = parseFloat(hole.endYLocation.toFixed(4));
		let toeZ = parseFloat(hole.endZLocation.toFixed(4));
		// Iterate over the columns and map them to their corresponding values
		for (let j = 0; j < columns.length; j++) {
			if (columns[j] === "Pattern") {
				columnOrder.push(pattern);
			} else if (columns[j] === "Blast") {
				columnOrder.push(blast);
			} else if (columns[j] === "Name") {
				columnOrder.push(hole.holeID);
			} else if (columns[j] === "Easting") {
				columnOrder.push(toeX); // Assuming 'toeX' holds the Easting value
			} else if (columns[j] === "Northing") {
				columnOrder.push(toeY); // Assuming 'toeY' holds the Northing value
			} else if (columns[j] === "Elevation") {
				columnOrder.push(toeZ); // Assuming 'toeZ' holds the Elevation value
			} else if (columns[j] === "Angle") {
				columnOrder.push(hole.holeAngle);
			} else if (columns[j] === "Azimuth") {
				let azimuth = parseFloat(((hole.holeBearing - 180) % 360).toFixed(1));
				if (azimuth < 0) {
					azimuth += 360;
				}
				columnOrder.push(azimuth);
			} else if (columns[j] === "Diameter") {
				columnOrder.push(hole.holeDiameter);
			} else if (columns[j] === "Material Type") {
				columnOrder.push(material);
			} else if (columns[j] === "Instruction") {
				if (useHoleTypeAsInstruction) {
					columnOrder.push(hole.holeType);
				} else {
					columnOrder.push(instruction);
				}
			} else if (columns[j] === "Ignore") {
				if (writeIngoreColumn) {
					columnOrder.push("ignored");
				} else {
					//do nothing
				}

				// Default to an empty string for unknown columns
			}
		}

		// Join the column values to create a row and add it to the AQM string
		const row = columnOrder.join(",");
		aqm += row + "\n";
	}

	return aqm;
}

//-----------------------------------------------------------------------------//
// ----------------------// START IREDES EPIROC SECTION //---------------------//
//#region  --------------------------------------------------------------------//

/**
 * Using SweetAlert Library Create a popup that gets input from the user.
 * @param {object[]} allBlastHoles - The allBlastHoles to convert
 * @param {string} filename - The filename to use
 * @param {string} planID - The plan ID to use
 * @param {string} siteID - The site ID to use
 * @param {boolean} holeOptions - Whether the hole options are on
 * @param {boolean} mwd - Whether the mwd is on
 * @param {string} chksumType - The type of checksum to calculate
 * @returns {void}
 */
// ‚úÖ VERBOSE REMOVAL COMMENT - IREDES export functions removed
// Step 1) 10 functions (717 lines, lines 10237-10953) were extracted to src/dialog/popups/generic/ExportDialogs.js
// Step 2) Reason: Part of Phase 2.5 export dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Functions extracted:
//        - saveIREDESPopup() - 358 lines - Main IREDES export dialog
//        - convertPointsToIREDESXML() - 190 lines - XML generation
//        - crc32() - 34 lines - CRC32 checksum calculation
//        - validateIREDESXML() - 46 lines - XML validation
//        - testIREDESChecksumDebug() - 46 lines - Checksum debug test
//        - testEpirocCRC() - 16 lines - Epiroc CRC test
//        - decimalChecksum() - 8 lines - Decimal checksum
//        - calculateMD5Checksum() - 5 lines - MD5 hash
//        - calculateSHA1Checksum() - 5 lines - SHA1 hash
//        - calculateSHA256Checksum() - 9 lines - SHA256 hash
// Step 5) All functions are exposed globally via window.functionName in ExportDialogs.js

function calculateTimes(allBlastHoles) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;

	//console.log("Calculating times...");
	try {
		const surfaces = {};
		holeTimes = {};

		// Build initial structures for surfaces and hole times
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			if (hole.entityName && hole.holeID && !isNaN(hole.timingDelayMilliseconds)) {
				const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
				const combinedFromHoleID = hole.fromHoleID;
				surfaces[combinedFromHoleID + ">=|=<" + combinedHoleID] = {
					time: 0,
					delay: hole.timingDelayMilliseconds,
				};

				holeTimes[combinedHoleID] = null;
			} else {
				console.log("Invalid hole data:", hole);
			}
		}

		// Calculate times for each surface
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
			const combinedFromHoleID = hole.fromHoleID;
			if (combinedFromHoleID === combinedHoleID) {
				if (holeTimes[combinedHoleID] === null || hole.timingDelayMilliseconds < holeTimes[combinedHoleID]) {
					holeTimes[combinedHoleID] = hole.timingDelayMilliseconds;
				}
				updateSurfaceTimes(combinedHoleID, hole.timingDelayMilliseconds, surfaces, holeTimes);
			}
		}

		// Log the final state of surfaces and holeTimes for debugging
		//console.log("Final Surfaces:", surfaces);
		//console.log("Final Hole Times:", holeTimes);

		// Create a result array from the holeTimes object
		const result = [];
		for (const combinedHoleID in holeTimes) {
			result.push([combinedHoleID, holeTimes[combinedHoleID]]);
		}

		// Update allBlastHoles with hole times
		for (const [combinedHoleID, time] of result) {
			const [entityName, holeID] = combinedHoleID.split(":::");
			const holeIndex = allBlastHoles.findIndex((h) => h.entityName === entityName && h.holeID === holeID);
			if (holeIndex !== -1) {
				allBlastHoles[holeIndex].holeTime = time;
			}
		}

		return result;
	} catch (err) {
		console.log("Error in calculateTimes:", err);
	}
}

function updateSurfaceTimes(combinedHoleID, time, surfaces, holeTimes, visited = new Set()) {
	visited.add(combinedHoleID);
	for (const id in surfaces) {
		const [fromHoleID, toHoleID] = id.split(">=|=<");
		if (fromHoleID === combinedHoleID) {
			const surface = surfaces[id];
			const delay = surface.delay;
			if (!isNaN(delay)) {
				const toTime = parseInt(time) + parseInt(delay);
				if (!visited.has(toHoleID) && (toTime < surface.time || surface.time === 0)) {
					surface.time = toTime;
					holeTimes[toHoleID] = toTime;
					updateSurfaceTimes(toHoleID, toTime, surfaces, holeTimes, visited);
				}
			} else {
				console.log("Invalid delay:", delay, "for surface:", id);
			}
		}
	}
	visited.delete(combinedHoleID);
}

// Note: Old delaunayContoursSync function removed - replaced by calculateContoursSync at end of file
// Note: Old interpolate function removed - replaced by interpolateContourPoint at end of file

function simplifyLine(line, epsilon) {
	if (line.length <= 2) return line;

	const firstPoint = line[0];
	const lastPoint = line[line.length - 1];
	const lineDistSq = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

	const { maxDist, maxDistPoint } = line.slice(1, -1).reduce(
		(result, point, i) => {
			const distSq = pointToLineDistanceSq(point, firstPoint, lastPoint, lineDistSq);
			if (distSq > result.maxDist) {
				return {
					maxDist: distSq,
					maxDistPoint: {
						index: i + 1,
						point,
					},
				};
			}
			return result;
		},
		{
			maxDist: 0,
			maxDistPoint: {
				index: 0,
				point: null,
			},
		}
	);

	if (Math.sqrt(maxDist) > epsilon) {
		const left = simplifyLine(line.slice(0, maxDistPoint.index + 1), epsilon);
		const right = simplifyLine(line.slice(maxDistPoint.index), epsilon);

		return left.slice(0, left.length - 1).concat(right);
	} else {
		return [firstPoint, lastPoint];
	}
}
// NEW: Pixel distance simplification function
function simplifyByPxDist(points, pxThreshold = 10) {
	if (!points || points.length < 2) return points;

	const pxThresholdSq = pxThreshold * pxThreshold;
	const simplified = [points[0]]; // Always keep first point

	let lastKeptPoint = points[0];
	let [lastKeptX, lastKeptY] = worldToCanvas(lastKeptPoint.pointXLocation, lastKeptPoint.pointYLocation);

	for (let i = 1; i < points.length; i++) {
		const currentPoint = points[i];
		const [currentX, currentY] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);

		const dx = currentX - lastKeptX;
		const dy = currentY - lastKeptY;

		// Keep point if distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxThresholdSq || i === points.length - 1) {
			simplified.push(currentPoint);
			lastKeptPoint = currentPoint;
			lastKeptX = currentX;
			lastKeptY = currentY;
		}
	}

	return simplified;
}

// Step 1) 3D simplification using WORLD-SPACE distance based on camera zoom
// This is MUCH faster than screen projections - just simple distance math
// At scale 1:1000, a 0.5m segment is ~0.5px - not visible, so skip it
function simplifyByWorldDist3D(points, minWorldDistMeters) {
	// Step 1a) Early return if not enough points
	if (!points || points.length < 2) return points;

	var minDistSq = minWorldDistMeters * minWorldDistMeters;
	var simplified = [points[0]]; // Always keep first point

	var lastKeptPoint = points[0];
	var lastX = lastKeptPoint.pointXLocation;
	var lastY = lastKeptPoint.pointYLocation;
	var lastZ = lastKeptPoint.pointZLocation || 0;

	// Step 1b) Simple distance-based filtering - no expensive projections!
	for (var i = 1; i < points.length; i++) {
		var currentPoint = points[i];
		var currX = currentPoint.pointXLocation;
		var currY = currentPoint.pointYLocation;
		var currZ = currentPoint.pointZLocation || 0;

		// Step 1c) 3D distance calculation (XYZ)
		var dx = currX - lastX;
		var dy = currY - lastY;
		var dz = currZ - lastZ;
		var distSq = dx * dx + dy * dy + dz * dz;

		// Step 1d) Keep point if distance is significant OR if it's the last point
		if (distSq >= minDistSq || i === points.length - 1) {
			simplified.push(currentPoint);
			lastKeptPoint = currentPoint;
			lastX = currX;
			lastY = currY;
			lastZ = currZ;
		}
	}

	return simplified;
}

// Step 2) Calculate minimum visible world distance based on camera zoom
// Returns the world distance (meters) that would appear as ~1-2 pixels on screen
function getMinVisibleWorldDist() {
	if (!threeRenderer || !threeRenderer.camera) return 0.5; // Default fallback

	var camera = threeRenderer.camera;
	var threeCanvas = document.getElementById("threeCanvas");
	if (!threeCanvas) return 0.5;

	// Step 2a) For orthographic camera, calculate world units per pixel
	// camera.right - camera.left = total world width visible
	// canvas.width = total pixels
	var visibleWorldWidth = camera.right - camera.left;
	var canvasWidth = threeCanvas.width || 1920;

	// Step 2b) World meters per pixel (for 2 pixel threshold)
	var metersPerPixel = visibleWorldWidth / canvasWidth;
	var minVisibleDist = metersPerPixel * 2; // 2 pixel threshold

	// Step 2c) Clamp to reasonable bounds (0.1m to 50m)
	// At very zoomed out view, we don't want to skip more than 50m segments
	// At very zoomed in view, we still want at least 0.1m resolution
	if (minVisibleDist < 0.1) minVisibleDist = 0.1;
	if (minVisibleDist > 50) minVisibleDist = 50;

	return minVisibleDist;
}

// Step 3) Check if entity bounding box is visible and significant on screen
// Returns false if entity should be culled (too small or outside view)
function isEntityVisibleIn3D(points) {
	if (!points || points.length < 2) return false;
	if (!threeRenderer || !threeRenderer.camera) return true; // Draw if can't check

	var camera = threeRenderer.camera;

	// Step 3a) Calculate entity bounding box
	var minX = Infinity, maxX = -Infinity;
	var minY = Infinity, maxY = -Infinity;
	for (var i = 0; i < points.length; i++) {
		var p = points[i];
		if (p.pointXLocation < minX) minX = p.pointXLocation;
		if (p.pointXLocation > maxX) maxX = p.pointXLocation;
		if (p.pointYLocation < minY) minY = p.pointYLocation;
		if (p.pointYLocation > maxY) maxY = p.pointYLocation;
	}

	// Step 3b) Get camera view bounds (in local coordinates)
	var camLeft = camera.left + centroidX;
	var camRight = camera.right + centroidX;
	var camBottom = camera.bottom + centroidY;
	var camTop = camera.top + centroidY;

	// Step 3c) Check if entity is completely outside camera view (frustum culling)
	if (maxX < camLeft || minX > camRight || maxY < camBottom || minY > camTop) {
		return false; // Entity is outside view
	}

	// Step 3d) Check if entity is too small on screen (size culling)
	var entityWidth = maxX - minX;
	var entityHeight = maxY - minY;
	var entitySize = Math.max(entityWidth, entityHeight);

	// Get visible world width to calculate screen size
	var visibleWorldWidth = camera.right - camera.left;
	var threeCanvas = document.getElementById("threeCanvas");
	var canvasWidth = threeCanvas ? threeCanvas.width : 1920;

	// Entity size in pixels
	var entityScreenSize = (entitySize / visibleWorldWidth) * canvasWidth;

	// Step 3e) Skip entities smaller than 5 pixels on screen
	if (entityScreenSize < 5) {
		return false;
	}

	return true;
}

// Step 2) Helper: Project 3D world point to screen coordinates using camera projection
function worldToScreen3D(worldX, worldY, worldZ, camera, canvas) {
	// Step 2a) Convert world coordinates to local Three.js coordinates
	var local = worldToThreeLocal(worldX, worldY);

	// Step 2b) Create 3D vector and project to normalized device coordinates (NDC)
	var vector = new THREE.Vector3(local.x, local.y, worldZ);
	vector.project(camera);

	// Step 2c) Convert NDC (-1 to +1) to screen pixels
	return {
		x: (vector.x * 0.5 + 0.5) * canvas.width,
		y: (-vector.y * 0.5 + 0.5) * canvas.height
	};
}

//NEW: Add this hybrid simplification function that is WAY TOO AGGRESSIVE. - DO NOT USE.
function hybridSimplify(points, currentScale, isPolygon = false) {
	if (!points || points.length < 3) return points;

	const pxDistThresholdSq = 5 * 5; // pixel threshold squared
	const epsilon = 0.05 / currentScale; // RDP simplification tolerance

	// Convert to canvas coordinates for pixel distance calculations
	const canvasPoints = points.map((p) => {
		const [x, y] = worldToCanvas(p.pointXLocation, p.pointYLocation);
		return {
			...p,
			_cx: x,
			_cy: y,
		};
	});

	// Detect closed & small polygon/shape - preserve important small features
	const isClosed = isPolygon && points.length > 2;

	if (isClosed) {
		// Calculate approximate area in world coordinates
		let area = 0;
		for (let i = 0; i < points.length - 1; i++) {
			const p1 = points[i];
			const p2 = points[i + 1];
			area += p1.pointXLocation * p2.pointYLocation - p2.pointXLocation * p1.pointYLocation;
		}
		// If area is very small, preserve the shape without simplification
		if (Math.abs(area / 2) < 5 / currentScale) {
			return points;
		}
	}

	// Step 1: Pixel distance pre-filter - but keep consecutive points
	const pxFiltered = [canvasPoints[0]];
	for (let i = 1; i < canvasPoints.length; i++) {
		const current = canvasPoints[i];
		const previous = pxFiltered[pxFiltered.length - 1];
		const dx = current._cx - previous._cx;
		const dy = current._cy - previous._cy;

		// Keep point if pixel distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxDistThresholdSq || i === canvasPoints.length - 1) {
			pxFiltered.push(current);
		}
	}

	// Step 2: Apply RDP only if we have enough points and they're not too simplified already
	if (pxFiltered.length < 3) {
		return points; // Return original if too few points
	}

	// Remove canvas coordinates before RDP
	const worldFiltered = pxFiltered.map((p) => {
		const { _cx, _cy, ...worldPoint } = p;
		return worldPoint;
	});

	const rdpSimplified = simplifyLine(worldFiltered, epsilon);
	return rdpSimplified;
}

function pointToLineDistanceSq(point, lineStart, lineEnd, lineDistSq) {
	const t = ((point.x - lineStart.x) * (lineEnd.x - lineStart.x) + (point.y - lineStart.y) * (lineEnd.y - lineStart.y)) / lineDistSq;

	if (t < 0) {
		return (lineStart.x - point.x) ** 2 + (lineStart.y - point.y) ** 2;
	} else if (t > 1) {
		return (lineEnd.x - point.x) ** 2 + (lineEnd.y - point.y) ** 2;
	} else {
		const projX = lineStart.x + t * (lineEnd.x - lineStart.x);
		const projY = lineStart.y + t * (lineEnd.y - lineStart.y);
		return (point.x - projX) ** 2 + (point.y - projY) ** 2;
	}
}

function getVisibleHolesAndKADDrawings(allBlastHoles, allKADDrawings) {
	try {
		const visibleHoles = allBlastHoles.filter((hole) => hole.visible);

		// Fix KAD drawings filtering - check if entity is visible using isEntityVisible
		const visibleKADDrawings = allKADDrawings.filter((drawing) => {
			// Check if the drawing has a visible property, or use isEntityVisible function
			if (drawing.visible !== undefined) {
				return drawing.visible;
			} else if (drawing.entityName) {
				return isEntityVisible(drawing.entityName);
			}
			// If no visibility info, assume it's visible
			return true;
		});

		console.log("üëÄ getVisibleHolesAndKADDrawings - allBlastHoles:", allBlastHoles.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - allKADDrawings:", allKADDrawings.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - visibleHoles:", visibleHoles.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - visibleKADDrawings:", visibleKADDrawings.length);

		return {
			visibleHoles,
			visibleKADDrawings,
		};
	} catch (err) {
		console.log("‚ùå Error in getVisibleHolesAndKADDrawings:", err);
		return {
			visibleHoles: [],
			visibleKADDrawings: [],
		};
	}
}

// make a global Earcut
const useEarcut = getEarcut();

// üîç ROBUST: Check how earcut is available
function getEarcut() {
	if (typeof earcut !== "undefined") {
		// Check if it's the direct function or has .default
		return typeof earcut === "function" ? earcut : earcut.default;
	}
	throw new Error("Earcut library not found");
}

// Unified point-in-polygon function that handles all data formats
// FIX FOR THE TRIANGULATION TOOL
function isPointInPolygonObject(x, y, polygon) {
	let inside = false;
	let vertices = [];

	// Handle different polygon formats
	if (Array.isArray(polygon)) {
		// Handle array of points (most common case)
		vertices = polygon.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	} else if (polygon.data) {
		// Handle KAD polygon with data property
		vertices = polygon.data.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	} else if (polygon.points) {
		// Handle polygon with points property
		vertices = polygon.points.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	}

	// Ray casting algorithm
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		const xi = vertices[i].x;
		const yi = vertices[i].y;
		const xj = vertices[j].x;
		const yj = vertices[j].y;

		if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {
			inside = !inside;
		}
	}

	return inside;
}

//===========================
//#region DELAUNAY TRIANGULATION  - SURFACE TOOL - START
//===========================

const triangulateTool = document.getElementById("triangulateTool");

// Tool event listener
triangulateTool.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("triangulateTool");

		isTriangulateToolActive = true;
		triangulateTool.checked = true;

		//handleContourTriangulationAction();
		handleTriangulationAction();

		isTriangulateToolActive = false;
		triangulateTool.checked = false;
	}
});
// Check each entity individually
if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
	allKADDrawingsMap.forEach((entity, entityName) => {
		const isVisible = isEntityVisible(entityName);
		console.log(`üìã Entity "${entityName}": type=${entity.entityType}, points=${entity.data ? entity.data.length : 0}, visible=${isVisible}`);
		if (!isVisible) {
			console.log(`‚ùå Why not visible: drawingsGroupVisible=${drawingsGroupVisible}, entity.visible=${entity.visible}, typeGroupVisible=${getTypeGroupVisible(entity.entityType)}`);
		}
	});
}
function getTypeGroupVisible(entityType) {
	switch (entityType) {
		case "point":
			return pointsGroupVisible;
		case "line":
			return linesGroupVisible;
		case "poly":
			return polygonsGroupVisible;
		case "circle":
			return circlesGroupVisible;
		default:
			return true;
	}
}
function handleTriangulationAction() {
	console.log("üî∫ Delaunay triangulation action triggered");

	// Step 1) Debug visibility flags
	console.log("üîç Debugging triangulation visibility:");
	console.log("üìä allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
	console.log("üåç drawingsGroupVisible:", drawingsGroupVisible);
	console.log("üîò pointsGroupVisible:", pointsGroupVisible);
	console.log("üìè linesGroupVisible:", linesGroupVisible);
	console.log("üî∏ polygonsGroupVisible:", polygonsGroupVisible);
	console.log("üí• blastGroupVisible:", blastGroupVisible);

	// Check for any visible data
	let hasVisibleData = false;
	let visibleEntities = [];

	// Step 2) Check KAD drawings with detailed logging
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("üîç Checking KAD drawings for visibility:");
		allKADDrawingsMap.forEach((entity, key) => {
			// Use the map key instead of entity.entityName since some entityNames are corrupted
			const isVisible = isEntityVisible(key);
			console.log("  - Key: '" + key + "', entityName: '" + entity.entityName + "' (" + entity.entityType + "): " + (isVisible ? "? Visible" : "? Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(key);
			}
		});
	}

	// Step 3) Check blast holes with detailed logging
	if (!hasVisibleData && allBlastHoles && allBlastHoles.length > 0) {
		console.log("üîç Checking blast holes for visibility:");
		allBlastHoles.forEach((hole) => {
			const isVisible = isHoleVisible(hole);
			// Step 1) Fix the logging to use the correct property name
			const holeIdentifier = hole.entityName + ":" + hole.holeID || "Unknown";
			console.log("  - " + holeIdentifier + ": " + (isVisible ? "? Visible" : "? Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(holeIdentifier);
			}
		});
	}

	if (!hasVisibleData) {
		console.log("‚ùå No visible data found for triangulation");
		console.log("üìã Visible entities found:", visibleEntities);
		updateStatusMessage("No visible data found for triangulation");
		return;
	}

	console.log("‚úÖ Found visible data for triangulation:", visibleEntities);
	updateStatusMessage("Ready for triangulation ?");
	showTriangulationPopup();
}

//Take the visible veritces and filter any points the are within a 3D tolerance
// PERFORMANCE FIX 2025-12-28: Optimized from O(n¬≤) to O(n) using spatial hashing
// The original O(n¬≤) algorithm was impossibly slow for 310k+ points
// Now async with progress updates for large datasets
async function getUniqueElementVerticesAsync(xyzVertices, tolerance = 0.001, progressCallback = null) {
	// Step 1) Use spatial hash map for O(n) performance
	// Grid cell size slightly larger than tolerance to catch neighbors
	var cellSize = tolerance * 2;
	var spatialHash = new Map();
	var uniqueVertices = [];
	var totalVertices = xyzVertices.length;
	var lastProgressUpdate = Date.now();
	var BATCH_SIZE = 10000; // Process in batches to yield to UI

	// Step 2) Helper to get grid cell key
	function getCellKey(x, y) {
		var cellX = Math.floor(x / cellSize);
		var cellY = Math.floor(y / cellSize);
		return cellX + "," + cellY;
	}

	// Step 3) Helper to check if vertex is duplicate in neighboring cells
	function isDuplicateInNeighbors(vertex) {
		var cellX = Math.floor(vertex.x / cellSize);
		var cellY = Math.floor(vertex.y / cellSize);

		// Check 3x3 neighborhood of cells
		for (var dx = -1; dx <= 1; dx++) {
			for (var dy = -1; dy <= 1; dy++) {
				var neighborKey = (cellX + dx) + "," + (cellY + dy);
				var cellVertices = spatialHash.get(neighborKey);
				if (cellVertices) {
					for (var j = 0; j < cellVertices.length; j++) {
						var existing = cellVertices[j];
						var distX = vertex.x - existing.x;
						var distY = vertex.y - existing.y;
						var distSquared = distX * distX + distY * distY;
						if (distSquared <= tolerance * tolerance) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	// Step 4) Process all vertices in batches
	for (var i = 0; i < totalVertices; i++) {
		var vertex = xyzVertices[i];

		// Check if duplicate
		if (!isDuplicateInNeighbors(vertex)) {
			// Add to unique list
			uniqueVertices.push(vertex);

			// Add to spatial hash
			var cellKey = getCellKey(vertex.x, vertex.y);
			if (!spatialHash.has(cellKey)) {
				spatialHash.set(cellKey, []);
			}
			spatialHash.get(cellKey).push(vertex);
		}

		// Step 5) Yield to UI periodically
		if (i > 0 && i % BATCH_SIZE === 0) {
			var now = Date.now();
			if (now - lastProgressUpdate > 50 || progressCallback) { // Update every 50ms or if callback provided
				var progressPercent = Math.floor((i / totalVertices) * 100);
				if (progressCallback) {
					await progressCallback(progressPercent, "Deduplicating: " + i.toLocaleString() + " / " + totalVertices.toLocaleString() + " (" + uniqueVertices.length.toLocaleString() + " unique)");
				}
				lastProgressUpdate = now;
				// Yield to event loop
				await new Promise(function (resolve) { setTimeout(resolve, 0); });
			}
		}
	}

	return uniqueVertices;
}

// Synchronous version for backward compatibility (small datasets)
function getUniqueElementVertices(xyzVertices, tolerance = 0.001) {
	// For small datasets, use synchronous version
	var cellSize = tolerance * 2;
	var spatialHash = new Map();
	var uniqueVertices = [];

	function getCellKey(x, y) {
		var cellX = Math.floor(x / cellSize);
		var cellY = Math.floor(y / cellSize);
		return cellX + "," + cellY;
	}

	function isDuplicateInNeighbors(vertex) {
		var cellX = Math.floor(vertex.x / cellSize);
		var cellY = Math.floor(vertex.y / cellSize);

		for (var dx = -1; dx <= 1; dx++) {
			for (var dy = -1; dy <= 1; dy++) {
				var neighborKey = (cellX + dx) + "," + (cellY + dy);
				var cellVertices = spatialHash.get(neighborKey);
				if (cellVertices) {
					for (var j = 0; j < cellVertices.length; j++) {
						var existing = cellVertices[j];
						var distX = vertex.x - existing.x;
						var distY = vertex.y - existing.y;
						var distSquared = distX * distX + distY * distY;
						if (distSquared <= tolerance * tolerance) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	for (var i = 0; i < xyzVertices.length; i++) {
		var vertex = xyzVertices[i];
		if (!isDuplicateInNeighbors(vertex)) {
			uniqueVertices.push(vertex);
			var cellKey = getCellKey(vertex.x, vertex.y);
			if (!spatialHash.has(cellKey)) {
				spatialHash.set(cellKey, []);
			}
			spatialHash.get(cellKey).push(vertex);
		}
	}

	return uniqueVertices;
}

async function createDelaunayTriangulation(params, updateProgress = null) {
	// Add the getX and getY functions at the top of the function
	const getX = (point) => parseFloat(point.x);
	const getY = (point) => parseFloat(point.y);

	// Helper to update progress and yield to event loop
	async function reportProgress(percent, message) {
		if (updateProgress) {
			await updateProgress(percent, message);
		}
		// Always yield to event loop for large operations
		await new Promise(function (resolve) { setTimeout(resolve, 0); });
	}

	try {
		await reportProgress(5, "Collecting visible elements...");

		// Fix the function call by passing the required parameters
		let visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("üîç Debug - visibleElements:", visibleElements);
		console.log("üîç Debug - allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
		console.log("üîç Debug - visibleKADDrawings count:", visibleElements.visibleKADDrawings ? visibleElements.visibleKADDrawings.length : 0);

		// Extract parameters
		const minAngleTolerance = params.minAngle || 0;
		const maxEdgeLength = params.maxEdgeLength || 0;
		const tolerance = params.tolerance || 0.001;

		await reportProgress(10, "Collecting vertices...");

		// Collect all vertices from visible elements
		let elementVertices = [];

		// Add blast hole vertices based on parameters
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			// Step 1) Fix property name mismatch - use visibleHoles instead of visibleBlastHoles
			const visibleHoles = visibleElements.visibleHoles || [];
			visibleHoles.forEach((hole) => {
				if (params.useCollars) {
					// Step 2) Map collar coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0,
					});
				}
				if (params.useGrade && hole.gradeXLocation !== undefined) {
					// Step 3) Map grade coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0,
					});
				}
				if (params.useToe && hole.endXLocation !== undefined) {
					// Step 4) Map toe coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0,
					});
				}
				if (params.useMLength && hole.mLengthXLocation !== undefined) {
					// Step 5) Map measured length coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0,
					});
				}
			});
		}

		// Add KAD drawing vertices
		visibleElements.visibleKADDrawings.forEach((entity) => {
			if (entity.data && Array.isArray(entity.data)) {
				entity.data.forEach((point) => {
					elementVertices.push({
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0,
					});
				});
			}
		});

		await reportProgress(15, "Removing duplicate vertices from " + elementVertices.length.toLocaleString() + " points...");

		// Remove duplicate vertices within tolerance
		// Use async version for large datasets to keep UI responsive
		var LARGE_DATASET_THRESHOLD = 10000;
		if (elementVertices.length > LARGE_DATASET_THRESHOLD) {
			// Async version with progress
			elementVertices = await getUniqueElementVerticesAsync(elementVertices, tolerance, async function (percent, message) {
				// Map deduplication progress to 15-30% range
				var mappedPercent = 15 + Math.floor(percent * 0.15);
				await reportProgress(mappedPercent, message);
			});
		} else {
			// Sync version for small datasets
			elementVertices = getUniqueElementVertices(elementVertices, tolerance);
		}

		console.log("üéØ Unique vertices after deduplication:", elementVertices.length);

		if (elementVertices.length < 3) {
			console.warn("? Insufficient vertices for triangulation. Found:", elementVertices.length);
			return {
				resultTriangles: [],
				points: [],
			};
		}

		await reportProgress(30, "Creating triangulation with " + elementVertices.length + " vertices...");
		console.log("‚úÖ Creating triangulation with", elementVertices.length, "vertices");

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(elementVertices, getX, getY);

		await reportProgress(40, "Triangulation complete, processing triangles...");

		// Array to store valid triangles
		const resultTriangles = [];
		const totalTriangles = delaunay.triangles.length / 3;
		var lastProgressUpdate = Date.now();

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1.x - p2.x;
			const dy = p1.y - p2.y;
			return dx * dx + dy * dy;
		}

		// Process each triangle
		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			// Yield to event loop periodically for large datasets (every 100ms or 5000 triangles)
			var triangleIndex = i / 3;
			if (Date.now() - lastProgressUpdate > 100 || triangleIndex % 5000 === 0) {
				var progressPercent = 40 + Math.floor((triangleIndex / totalTriangles) * 25);
				await reportProgress(progressPercent, "Processing triangle " + triangleIndex.toLocaleString() + " of " + totalTriangles.toLocaleString() + "...");
				lastProgressUpdate = Date.now();
			}
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = elementVertices[p1Index];
			const p2 = elementVertices[p2Index];
			const p3 = elementVertices[p3Index];

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared(p1, p2);
			const edge2Squared = distanceSquared(p2, p3);
			const edge3Squared = distanceSquared(p3, p1);

			// Use user-defined max edge length or skip edge culling if 0
			const maxEdgeLengthSquared = maxEdgeLength > 0 ? maxEdgeLength ** 2 : Infinity;

			// Check if all edge lengths are within the limit (or skip if maxEdgeLength is 0)
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles
				if (minAngleTolerance > 0) {
					const edge1 = Math.sqrt(edge1Squared);
					const edge2 = Math.sqrt(edge2Squared);
					const edge3 = Math.sqrt(edge3Squared);

					// Calculate angles using law of cosines
					const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
					const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
					const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

					const minAngle = Math.min(angle1, angle2, angle3);

					// Reject very acute triangles
					if (minAngle < minAngleTolerance) {
						continue; // Skip this triangle
					}
				}

				// ? FIX: Create triangle in the CORRECT format that matches the rest of your system
				// This should match the format used in parseDXFToKAD and other parts
				resultTriangles.push({
					vertices: [
						{
							x: parseFloat(p1.x),
							y: parseFloat(p1.y),
							z: parseFloat(p1.z),
						}, // Vertex objects, not arrays
						{
							x: parseFloat(p2.x),
							y: parseFloat(p2.y),
							z: parseFloat(p2.z),
						},
						{
							x: parseFloat(p3.x),
							y: parseFloat(p3.y),
							z: parseFloat(p3.z),
						},
					],
					minZ: Math.min(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z)),
					maxZ: Math.max(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z)),
				});
			}
		}

		await reportProgress(65, "Generated " + resultTriangles.length.toLocaleString() + " triangles");
		console.log("üéâ Generated", resultTriangles.length, "triangles");

		// ? FIX: Return triangles in the correct format that matches your system
		return {
			resultTriangles: resultTriangles, // Already in correct format
			points: elementVertices, // Return the actual points used for triangulation
		};
	} catch (err) {
		console.error("? Error in createDelaunayTriangulation:", err);
		return {
			resultTriangles: [],
			points: [],
		};
	}
}

// ? FIX: Get the complete polygon data from allKADDrawingsMap
function deleteTrianglesByClippingPolygon(surfaceId, option = "outside") {
	console.log("üî™ Clipping triangles from surface:", surfaceId, "option:", option);

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// ? FIX: Get the complete polygon from allKADDrawingsMap using the entity name
	let selectedPolygon = null;
	if (selectedKADObject && selectedKADObject.entityType === "poly" && selectedKADObject.entityName) {
		selectedPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
		console.log("üîç Found polygon entity:", selectedKADObject.entityName, "with data:", selectedPolygon ? selectedPolygon.data?.length : "none");
	}

	if (!selectedPolygon || !selectedPolygon.data || selectedPolygon.data.length < 3) {
		console.error("? No valid polygon selected for clipping. Selected:", selectedKADObject?.entityName, "Found polygon:", !!selectedPolygon, "Data points:", selectedPolygon?.data?.length);
		return false;
	}

	console.log("üìê Clipping polygon:", selectedPolygon.entityName, "with", selectedPolygon.data.length, "points");

	// Filter triangles based on the option
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		// Calculate triangle centroid
		const centroidX = (parseFloat(triangle.vertices[0].x) + parseFloat(triangle.vertices[1].x) + parseFloat(triangle.vertices[2].x)) / 3;
		const centroidY = (parseFloat(triangle.vertices[0].y) + parseFloat(triangle.vertices[1].y) + parseFloat(triangle.vertices[2].y)) / 3;

		// Use your existing isPointInPolygonObject function with the complete polygon
		const isInside = isPointInPolygonObject(centroidX, centroidY, selectedPolygon);

		// Apply the clipping logic based on option
		if (option === "outside") {
			// Keep triangles inside the polygon (delete those outside)
			return isInside;
		} else if (option === "inside") {
			// Keep triangles outside the polygon (delete those inside)
			return !isInside;
		}

		// Default: keep all triangles
		return true;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("‚úÇÔ∏è Clipping complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.clippedTriangles = deletedCount;
		surface.metadata.clippingOption = option;
		surface.metadata.clippingPolygon = selectedPolygon.entityName;
	}

	return true;
}

// ? NEW: Delete triangles based on edge length criteria
function deleteTrianglesByEdgeLength(surfaceId, minEdgeLength = 0, maxEdgeLength = 0, use3DLength = false) {
	console.log("üìè Filtering triangles by edge length:", surfaceId, "min:", minEdgeLength, "max:", maxEdgeLength, "3D:", use3DLength);

	// Skip filtering if both min and max are 0
	if (minEdgeLength <= 0 && maxEdgeLength <= 0) {
		console.log("‚è≠Ô∏è Skipping edge length filtering (both min and max = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on edge lengths
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DLength) {
			// 3D edge lengths including Z
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only)
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		const edges = [edge1, edge2, edge3];
		const maxEdge = Math.max(...edges);
		const minEdge = Math.min(...edges);

		// Apply filtering criteria
		let keepTriangle = true;

		// Check minimum edge length
		if (minEdgeLength > 0 && minEdge < minEdgeLength) {
			keepTriangle = false;
		}

		// Check maximum edge length
		if (maxEdgeLength > 0 && maxEdge > maxEdgeLength) {
			keepTriangle = false;
		}

		return keepTriangle;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("üìè Edge length filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.edgeFilteredTriangles = deletedCount;
		surface.metadata.minEdgeLength = minEdgeLength;
		surface.metadata.maxEdgeLength = maxEdgeLength;
		surface.metadata.use3DLength = use3DLength;
	}

	return true;
}

// ? UPDATED: Delete triangles with internal angles smaller than minimum (2D or 3D)
function deleteTrianglesByInternalAngle(surfaceId, internalAngleMin = 0, use3DAngle = false) {
	console.log("üìê Filtering triangles by internal angle:", surfaceId, "min angle:", internalAngleMin + "¬∞", "3D:", use3DAngle);

	// Skip filtering if angle is 0
	if (internalAngleMin <= 0) {
		console.log("‚è≠Ô∏è Skipping angle filtering (min angle = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on internal angles
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DAngle) {
			// 3D edge lengths including Z for accurate 3D angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only) for plan view angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		// Calculate internal angles using law of cosines
		const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2 * edge2 + edge3 * edge3 - edge1 * edge1) / (2 * edge2 * edge3)))) * (180 / Math.PI);
		const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge3 * edge3 - edge2 * edge2) / (2 * edge1 * edge3)))) * (180 / Math.PI);
		const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge2 * edge2 - edge3 * edge3) / (2 * edge1 * edge2)))) * (180 / Math.PI);

		const minAngle = Math.min(angle1, angle2, angle3);

		// Keep triangles with all angles >= minimum
		return minAngle >= internalAngleMin;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("üìê Angle filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.angleFilteredTriangles = deletedCount;
		surface.metadata.minInternalAngle = internalAngleMin;
		surface.metadata.use3DAngle = use3DAngle;
	}

	return true;
}

// ? NEW: Get visible KAD entities filtered by clipping polygon if needed
function getVisibleKADEntitiesForConstraints(useClippingFilter = false) {
	const visibleEntities = [];

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		return visibleEntities;
	}

	// Get clipping polygon if needed
	let clippingPolygon = null;
	if (useClippingFilter && selectedKADObject && selectedKADObject.entityType === "poly") {
		clippingPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
	}

	allKADDrawingsMap.forEach((entity, entityName) => {
		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		// Check if entity is visible
		if (!isEntityVisible(entityName)) {
			return;
		}

		// Filter by clipping polygon if specified
		if (clippingPolygon && useClippingFilter) {
			if (!entityIntersectsClippingPolygon(entity, clippingPolygon)) {
				return;
			}
		}

		// Add valid constraint entity
		visibleEntities.push({
			...entity,
			entityName: entityName,
			pointList2D: entity.data.map((p) => ({
				x: parseFloat(p.pointXLocation),
				y: parseFloat(p.pointYLocation),
			})),
			pointList3D: entity.data.map((p) => ({
				x: parseFloat(p.pointXLocation),
				y: parseFloat(p.pointYLocation),
				z: parseFloat(p.pointZLocation) || 0,
			})),
			isLineOrPoly: entity.entityType,
		});
	});

	console.log("üìã Found", visibleEntities.length, "visible KAD entities for constraints");
	return visibleEntities;
}

// ? NEW: Check if entity intersects with clipping polygon
function entityIntersectsClippingPolygon(entity, clippingPolygon) {
	if (!entity.data || !clippingPolygon.data) return false;

	// Check if any point of the entity is inside or if any segment intersects the clipping polygon
	for (let i = 0; i < entity.data.length; i++) {
		const point = entity.data[i];
		const x = parseFloat(point.pointXLocation);
		const y = parseFloat(point.pointYLocation);

		// Check if point is inside clipping polygon
		if (isPointInPolygonObject(x, y, clippingPolygon)) {
			return true;
		}

		// Check if segment intersects clipping polygon boundary
		if (i < entity.data.length - 1) {
			const nextPoint = entity.data[i + 1];
			const x2 = parseFloat(nextPoint.pointXLocation);
			const y2 = parseFloat(nextPoint.pointYLocation);

			if (lineIntersectsPolygon(x, y, x2, y2, clippingPolygon)) {
				return true;
			}
		}
	}

	return false;
}

// ? NEW: Check if triangle intersects with KAD entity (line or polygon)
function checkTriangleIntersectsKADEntity(triangle, kadEntity) {
	const vertices = triangle.vertices;

	// For each segment in the KAD entity
	for (let i = 0; i < kadEntity.pointList2D.length - 1; i++) {
		const segStart = kadEntity.pointList2D[i];
		const segEnd = kadEntity.pointList2D[i + 1];

		// Check if KAD segment intersects any triangle edge
		for (let j = 0; j < 3; j++) {
			const triStart = vertices[j];
			const triEnd = vertices[(j + 1) % 3];

			if (lineSegmentsIntersect(segStart.x, segStart.y, segEnd.x, segEnd.y, triStart.x, triStart.y, triEnd.x, triEnd.y)) {
				return true;
			}
		}

		// Check if KAD segment passes through triangle interior
		if (lineIntersectsTriangle(segStart.x, segStart.y, segEnd.x, segEnd.y, vertices)) {
			return true;
		}
	}

	return false;
}

// ? HELPER: Check if two line segments intersect
function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	if (Math.abs(denom) < 1e-10) return false; // Lines are parallel

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// ? HELPER: Check if line intersects polygon
function lineIntersectsPolygon(x1, y1, x2, y2, polygon) {
	if (!polygon.data) return false;

	for (let i = 0; i < polygon.data.length - 1; i++) {
		const p1 = polygon.data[i];
		const p2 = polygon.data[i + 1];

		if (lineSegmentsIntersect(x1, y1, x2, y2, parseFloat(p1.pointXLocation), parseFloat(p1.pointYLocation), parseFloat(p2.pointXLocation), parseFloat(p2.pointYLocation))) {
			return true;
		}
	}

	return false;
}

// ===================================================================
// =============================================================================
// STEP 1: REPLACE - New Constrained Delaunay Triangulation Function
// =============================================================================

async function createConstrainedDelaunayTriangulation(params, updateProgress = null) {
	console.log("üîó Using FIXED Constrained Delaunay Triangulation (Constrainautor)");

	try {
		// Get visible elements
		const visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("üìä Found " + (visibleElements.visibleHoles?.length || 0) + " visible holes, " + (visibleElements.visibleKADDrawings?.length || 0) + " visible KAD drawings");

		// Collect data points with source tracking
		let elementVertices = [];
		const kadSourceMap = new Map(); // Track which KAD entities contributed vertices

		// *** FIX 1: Standardized blast hole coordinate access ***
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			const visibleHoles = visibleElements.visibleHoles || [];
			console.log("üï≥Ô∏è Processing " + visibleHoles.length + " blast holes");

			visibleHoles.forEach((hole, index) => {
				// Collar points (surface)
				if (params.useCollars && hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_collar",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid collar coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Grade points (mid-hole)
				if (params.useGrade && hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_grade",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid grade coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Toe points (bottom)
				if (params.useToe && hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_toe",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid toe coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Measured length points
				if (params.useMLength && hole.mLengthXLocation !== undefined && hole.mLengthYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_mlength",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid mLength coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}
			});
		}

		// *** FIX 2: KAD drawing vertices with constraint source tracking ***
		visibleElements.visibleKADDrawings.forEach((entity, entityIndex) => {
			if (entity.data && Array.isArray(entity.data)) {
				const entityName = entity.entityName || "entity_" + entityIndex;
				console.log('üìê Processing entity "' + entityName + '" (' + entity.entityType + ") with " + entity.data.length + " points");

				const entityVertices = [];

				entity.data.forEach((point, pointIndex) => {
					const coords = {
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0,
						id: "kad_" + entityName + "_" + pointIndex,
						sourceType: "kad",
						sourceEntityName: entityName,
						sourcePointIndex: pointIndex,
						originalPoint: point,
					};

					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
						entityVertices.push({
							vertex: coords,
							originalIndex: pointIndex,
							originalPoint: point,
						});
					} else {
						console.warn("?? Invalid KAD coordinates for " + entityName + " point " + pointIndex + ":", coords);
					}
				});

				// Store for constraint extraction later
				if (entityVertices.length > 0 && (entity.entityType === "line" || entity.entityType === "poly")) {
					kadSourceMap.set(entityName, {
						entity: entity,
						vertices: entityVertices,
					});
				}
			}
		});

		console.log("üìä Collected " + elementVertices.length + " vertices before deduplication");

		// *** FIX 3: Deduplicate vertices (this changes coordinates) ***
		// PERFORMANCE FIX 2025-12-28: Use async version for large datasets
		const originalVertexCount = elementVertices.length;
		var LARGE_DATASET_THRESHOLD = 10000;
		if (originalVertexCount > LARGE_DATASET_THRESHOLD) {
			if (updateProgress) await updateProgress(15, "Deduplicating " + originalVertexCount.toLocaleString() + " vertices...");
			elementVertices = await getUniqueElementVerticesAsync(elementVertices, params.tolerance || 0.001, async function (percent, message) {
				// Map deduplication progress to 15-25% range
				var mappedPercent = 15 + Math.floor(percent * 0.10);
				if (updateProgress) await updateProgress(mappedPercent, message);
			});
		} else {
			elementVertices = getUniqueElementVertices(elementVertices, params.tolerance || 0.001);
		}

		console.log("üîÑ Deduplication: " + originalVertexCount + " ‚Üí " + elementVertices.length + " vertices");

		if (elementVertices.length < 3) {
			throw new Error(`Insufficient points for triangulation: ${elementVertices.length}`);
		}

		// *** FIX 4: Extract constraints AFTER deduplication using deduplicated vertices ***
		const constraintData = extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, params.tolerance || 0.001);
		const constraintSegments = constraintData.constraints || constraintData; // Handle both old and new format
		const entitiesWithUnmappedSegments = constraintData.entitiesWithUnmappedSegments || new Set();

		console.log("üîó Extracted " + constraintSegments.length + " constraints from deduplicated vertices");
		if (entitiesWithUnmappedSegments.size > 0) {
			console.warn("?? " + entitiesWithUnmappedSegments.size + " entities have unmapped segments: " + Array.from(entitiesWithUnmappedSegments).join(", "));
		}

		// Step 0c) Update progress - starting triangulation
		if (updateProgress) updateProgress(30, "Creating Delaunay triangulation...");

		// Create the constrained triangulation
		const result = await createConstrainautorTriangulation(elementVertices, constraintSegments, {
			tolerance: params.tolerance || 1e-10,
			updateProgress: updateProgress, // Pass progress callback
			entitiesWithUnmappedSegments: entitiesWithUnmappedSegments, // Pass problematic entities info
		});

		if (!result || !result.resultTriangles || result.resultTriangles.length === 0) {
			console.warn("üö® Constrainautor CDT failed, falling back to basic Delaunay");
			return createFallbackTriangulation(elementVertices);
		}

		console.log("‚úÖ CDT Success: " + result.resultTriangles.length + " triangles created with " + (result.stats?.constraints || 0) + " constraints applied");

		return {
			resultTriangles: result.resultTriangles,
			points: result.points,
			constraintCount: constraintSegments.length,
			stats: result.stats,
		};
	} catch (error) {
		console.error("‚ùå CDT Error:", error);
		console.warn("üö® Falling back to basic Delaunay triangulation");

		// Fallback to basic triangulation
		return createDelaunayTriangulation(params);
	}
}

// =============================================================================
// STEP 2: ADD - New constraint extraction from deduplicated vertices
// =============================================================================

function extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, tolerance) {
	console.log("üîó Extracting constraints from deduplicated vertices...");

	const constraints = [];
	const entitiesWithUnmappedSegments = new Set(); // Track entities with mapping issues

	// *** FIX 5: Create spatial index for efficient vertex lookup ***
	const spatialIndex = createSpatialIndex(elementVertices, tolerance);

	// Extract constraints from each KAD entity
	kadSourceMap.forEach((entityData, entityName) => {
		const entity = entityData.entity;

		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		console.log("üîó Processing constraints for " + entity.entityType + ' "' + entityName + '"');

		const entityConstraints = [];
		let unmappedCount = 0;

		// Create segments between consecutive points
		for (let i = 0; i < entity.data.length - 1; i++) {
			const startPoint = entity.data[i];
			const endPoint = entity.data[i + 1];

			const startX = parseFloat(startPoint.pointXLocation) || parseFloat(startPoint.x);
			const startY = parseFloat(startPoint.pointYLocation) || parseFloat(startPoint.y);
			const endX = parseFloat(endPoint.pointXLocation) || parseFloat(endPoint.x);
			const endY = parseFloat(endPoint.pointYLocation) || parseFloat(endPoint.y);

			// Find corresponding deduplicated vertices
			const startIdx = findClosestVertexIndex(spatialIndex, startX, startY, tolerance);
			const endIdx = findClosestVertexIndex(spatialIndex, endX, endY, tolerance);

			if (startIdx !== null && endIdx !== null && startIdx !== endIdx) {
				const constraint = {
					start: elementVertices[startIdx],
					end: elementVertices[endIdx],
					startIndex: startIdx,
					endIndex: endIdx,
					entityName: entityName,
					segmentIndex: i,
				};

				entityConstraints.push(constraint);
				constraints.push(constraint);
			} else {
				unmappedCount++;
				console.warn("üö® Could not map constraint segment " + i + " for entity " + entityName);
				console.warn("  Start: (" + startX.toFixed(3) + ", " + startY.toFixed(3) + ") ? index " + startIdx);
				console.warn("  End: (" + endX.toFixed(3) + ", " + endY.toFixed(3) + ") ? index " + endIdx);
			}
		}

		// Close polygon for poly entities
		if (entity.entityType === "poly" && entity.data.length > 2) {
			const firstPoint = entity.data[0];
			const lastPoint = entity.data[entity.data.length - 1];

			const firstX = parseFloat(firstPoint.pointXLocation) || parseFloat(firstPoint.x);
			const firstY = parseFloat(firstPoint.pointYLocation) || parseFloat(firstPoint.y);
			const lastX = parseFloat(lastPoint.pointXLocation) || parseFloat(lastPoint.x);
			const lastY = parseFloat(lastPoint.pointYLocation) || parseFloat(lastPoint.y);

			// Only add closing segment if points are different
			if (Math.abs(firstX - lastX) > tolerance || Math.abs(firstY - lastY) > tolerance) {
				const firstIdx = findClosestVertexIndex(spatialIndex, firstX, firstY, tolerance);
				const lastIdx = findClosestVertexIndex(spatialIndex, lastX, lastY, tolerance);

				if (firstIdx !== null && lastIdx !== null && firstIdx !== lastIdx) {
					const closingConstraint = {
						start: elementVertices[lastIdx],
						end: elementVertices[firstIdx],
						startIndex: lastIdx,
						endIndex: firstIdx,
						entityName: entityName,
						segmentIndex: "closing",
					};

					entityConstraints.push(closingConstraint);
					constraints.push(closingConstraint);
				}
			}
		}

		// Track entities with unmapped segments (these can cause constraint intersection issues)
		if (unmappedCount > 0) {
			entitiesWithUnmappedSegments.add(entityName);
			console.warn("  üö® Entity " + entityName + " has " + unmappedCount + " unmapped segments - constraints from this entity may cause intersection issues");
		}

		console.log("  ‚úÖ Added " + entityConstraints.length + " constraints for entity " + entityName);
	});

	console.log("‚úÖ Total constraints extracted: " + constraints.length);

	// Return constraints along with tracking info for problematic entities
	return {
		constraints: constraints,
		entitiesWithUnmappedSegments: entitiesWithUnmappedSegments,
	};
}

// =============================================================================
// STEP 3: ADD - Spatial indexing for vertex lookup
// =============================================================================

function createSpatialIndex(vertices, tolerance) {
	console.log("üó∫Ô∏è Creating spatial index for " + vertices.length + " vertices with tolerance " + tolerance);

	const index = new Map();

	vertices.forEach((vertex, vertexIndex) => {
		// Create multiple grid keys around each vertex for tolerance-based lookup
		const baseX = Math.floor(vertex.x / tolerance) * tolerance;
		const baseY = Math.floor(vertex.y / tolerance) * tolerance;

		// Add to multiple grid cells to handle boundary cases
		for (let dx = -1; dx <= 1; dx++) {
			for (let dy = -1; dy <= 1; dy++) {
				const gridX = baseX + dx * tolerance;
				const gridY = baseY + dy * tolerance;
				const key = gridX.toFixed(10) + "_" + gridY.toFixed(10);

				if (!index.has(key)) {
					index.set(key, []);
				}
				index.get(key).push({ vertex, index: vertexIndex });
			}
		}

		// Also add exact coordinate key
		const exactKey = "exact_" + vertex.x.toFixed(10) + "_" + vertex.y.toFixed(10);
		if (!index.has(exactKey)) {
			index.set(exactKey, []);
		}
		index.get(exactKey).push({ vertex, index: vertexIndex });
	});

	console.log("üó∫Ô∏è Spatial index created with " + index.size + " grid cells");
	return index;
}

function findClosestVertexIndex(spatialIndex, targetX, targetY, tolerance) {
	// Try exact match first
	const exactKey = "exact_" + targetX.toFixed(10) + "_" + targetY.toFixed(10);
	const exactCandidates = spatialIndex.get(exactKey) || [];

	if (exactCandidates.length > 0) {
		return exactCandidates[0].index;
	}

	// Try grid-based lookup
	const gridX = Math.floor(targetX / tolerance) * tolerance;
	const gridY = Math.floor(targetY / tolerance) * tolerance;
	const gridKey = gridX.toFixed(10) + "_" + gridY.toFixed(10);
	const gridCandidates = spatialIndex.get(gridKey) || [];

	// Find closest candidate within tolerance
	let bestMatch = null;
	let bestDistance = Infinity;

	for (const candidate of gridCandidates) {
		const dx = candidate.vertex.x - targetX;
		const dy = candidate.vertex.y - targetY;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance && distance < bestDistance) {
			bestMatch = candidate;
			bestDistance = distance;
		}
	}

	return bestMatch ? bestMatch.index : null;
}

// =============================================================================
// STEP 4: REPLACE - Updated Constrainautor implementation
// =============================================================================

function createConstrainautorTriangulation(points, constraintSegments, options = {}) {
	return new Promise((resolve, reject) => {
		try {
			const updateProgress = options.updateProgress || null;
			const entitiesWithUnmappedSegments = options.entitiesWithUnmappedSegments || new Set();

			// Step 1) Check if Constrainautor is available (imported at top of file)
			if (typeof Constrainautor === "undefined") {
				throw new Error("Constrainautor library not loaded");
			}

			// Step 1a) Update progress
			if (updateProgress) updateProgress(35, "Initializing Constrainautor...");

			console.log("üî∫ Starting Constrainautor with " + points.length + " points, " + constraintSegments.length + " constraints");
			if (entitiesWithUnmappedSegments.size > 0) {
				console.warn("?? Will skip constraints from problematic entities in problematic range: " + Array.from(entitiesWithUnmappedSegments).join(", "));
			}

			// Step 2) Create basic Delaunay triangulation first
			const coords = new Float64Array(points.length * 2);
			for (let i = 0; i < points.length; i++) {
				coords[i * 2] = points[i].x;
				coords[i * 2 + 1] = points[i].y;
			}

			const delaunay = new Delaunator(coords);
			console.log("üî∫ Initial Delaunay: " + delaunay.triangles.length / 3 + " triangles");

			if (updateProgress) updateProgress(40, "Delaunay triangulation created");

			// Step 3) Use pre-calculated indices from constraint extraction
			const constraintEdges = [];
			const validConstraints = [];

			constraintSegments.forEach((segment, segmentIndex) => {
				const startIdx = segment.startIndex;
				const endIdx = segment.endIndex;

				// Indices should already be validated during extraction
				if (startIdx !== undefined && endIdx !== undefined && startIdx !== endIdx && startIdx >= 0 && startIdx < points.length && endIdx >= 0 && endIdx < points.length) {
					constraintEdges.push([startIdx, endIdx]);
					validConstraints.push(segment);
				} else {
					console.warn("?? Invalid constraint indices: [" + startIdx + ", " + endIdx + "] for segment " + segmentIndex);
				}
			});

			console.log("üîó Prepared " + constraintEdges.length + " valid constraint edges");

			// Step 3a) Sort constraints to process problematic ones FIRST
			// Constraints from entities with unmapped segments should be processed early
			// when the triangulation is simpler and there are fewer existing constraints
			if (entitiesWithUnmappedSegments.size > 0) {
				console.log("üîÉ Reordering constraints - processing " + entitiesWithUnmappedSegments.size + " problematic entities first");

				// Create arrays for problematic and normal constraints
				const problematicEdges = [];
				const problematicConstraints = [];
				const normalEdges = [];
				const normalConstraints = [];

				// Separate constraints by entity type
				for (let i = 0; i < constraintEdges.length; i++) {
					const constraint = validConstraints[i];
					const edge = constraintEdges[i];

					if (constraint?.entityName && entitiesWithUnmappedSegments.has(constraint.entityName)) {
						problematicEdges.push(edge);
						problematicConstraints.push(constraint);
					} else {
						normalEdges.push(edge);
						normalConstraints.push(constraint);
					}
				}

				// Rebuild arrays with problematic constraints first
				constraintEdges.length = 0;
				validConstraints.length = 0;

				// Add problematic constraints first
				for (let i = 0; i < problematicEdges.length; i++) {
					constraintEdges.push(problematicEdges[i]);
					validConstraints.push(problematicConstraints[i]);
				}

				// Then add normal constraints
				for (let i = 0; i < normalEdges.length; i++) {
					constraintEdges.push(normalEdges[i]);
					validConstraints.push(normalConstraints[i]);
				}

				console.log("   ? Reordered: " + problematicEdges.length + " problematic constraints first, then " + normalEdges.length + " normal constraints");
			}

			// Step 4) Create Constrainautor instance (using imported module)
			const constrainautor = new Constrainautor(delaunay);

			if (updateProgress) updateProgress(45, "Applying constraints...");

			// Step 5) Apply constraints in batches to avoid blocking UI
			let successfulConstraints = 0;
			if (constraintEdges.length > 0) {
				console.log("üîß Applying " + constraintEdges.length + " constraints...");

				// Step 5a) Track successfully constrained edges to avoid duplicates
				// Use normalized edge key (minIdx_maxIdx) to handle both directions
				const constrainedEdges = new Set();
				const constrainedEdgeList = []; // Also keep list for intersection checking
				const getEdgeKey = (startIdx, endIdx) => {
					return Math.min(startIdx, endIdx) + "_" + Math.max(startIdx, endIdx);
				};
				const isEdgeConstrained = (startIdx, endIdx) => {
					return constrainedEdges.has(getEdgeKey(startIdx, endIdx));
				};
				const markEdgeConstrained = (startIdx, endIdx) => {
					constrainedEdges.add(getEdgeKey(startIdx, endIdx));
					constrainedEdgeList.push([startIdx, endIdx]);
				};

				// Step 5a.1) Function to check if two line segments intersect (excluding endpoints)
				const segmentsIntersect = (p1, p2, p3, p4) => {
					// Check if segments [p1-p2] and [p3-p4] intersect
					// Using cross product method
					const d1 = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);
					const d2 = (p4.x - p3.x) * (p2.y - p3.y) - (p4.y - p3.y) * (p2.x - p3.x);
					const d3 = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
					const d4 = (p2.x - p1.x) * (p4.y - p1.y) - (p2.y - p1.y) * (p4.x - p1.x);

					// Check if segments intersect (not including endpoints)
					if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
						return true;
					}
					return false;
				};

				// Step 5a.2) Find all points that lie on the constraint edge (collinear points)
				// Returns array of point indices sorted by position along the edge
				const findPointsOnEdge = (startIdx, endIdx) => {
					const p1 = points[startIdx];
					const p2 = points[endIdx];

					if (!p1 || !p2) return [];

					const dx = p2.x - p1.x;
					const dy = p2.y - p1.y;
					const lengthSq = dx * dx + dy * dy;

					if (lengthSq < 0.00000001) return [];

					const tolerance = 0.01; // Tolerance for point-on-line detection (increased from 0.001 to catch more marginal cases)
					const toleranceSq = tolerance * tolerance;
					const pointsOnEdge = [];

					// Step 1) Calculate bounding box for quick rejection
					const minX = Math.min(p1.x, p2.x) - tolerance;
					const maxX = Math.max(p1.x, p2.x) + tolerance;
					const minY = Math.min(p1.y, p2.y) - tolerance;
					const maxY = Math.max(p1.y, p2.y) + tolerance;

					// Step 2) Check all points to find those on the edge
					for (let i = 0; i < points.length; i++) {
						// Step 3) Skip the endpoints
						if (i === startIdx || i === endIdx) continue;

						const p = points[i];
						if (!p) continue;

						// Step 4) Quick bounding box check
						if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;

						// Step 5) Calculate distance from point to line segment
						const px = p.x - p1.x;
						const py = p.y - p1.y;

						// Step 6) Project point onto line segment
						const t = (px * dx + py * dy) / lengthSq;

						// Step 7) Only consider points between endpoints (not at ends)
						if (t <= 0.001 || t >= 0.999) continue;

						// Step 8) Calculate closest point on segment
						const closestX = p1.x + t * dx;
						const closestY = p1.y + t * dy;

						// Step 9) Distance from point to segment (squared for efficiency)
						const distX = p.x - closestX;
						const distY = p.y - closestY;
						const distSq = distX * distX + distY * distY;

						// Step 10) If point is on the line (within tolerance)
						if (distSq < toleranceSq) {
							pointsOnEdge.push({ index: i, t: t });
						}
					}

					// Step 11) Sort by position along edge (t value)
					pointsOnEdge.sort((a, b) => a.t - b.t);

					// Step 12) Return just the indices
					return pointsOnEdge.map((item) => item.index);
				};

				// Step 5a.2a) Split constraint edge into segments through collinear points
				const splitConstraintThroughPoints = (startIdx, endIdx) => {
					const pointsOnEdge = findPointsOnEdge(startIdx, endIdx);

					if (pointsOnEdge.length === 0) {
						// No points on edge - return original constraint
						return [[startIdx, endIdx]];
					}

					// Step 1) Create segments: start -> point1, point1 -> point2, ..., pointN -> end
					const segments = [];
					let currentStart = startIdx;

					for (const pointIdx of pointsOnEdge) {
						segments.push([currentStart, pointIdx]);
						currentStart = pointIdx;
					}

					// Step 2) Add final segment to end
					segments.push([currentStart, endIdx]);

					return segments;
				};

				// Step 5a.3) Check if a constraint edge would intersect existing constrained edges
				const wouldIntersectConstrainedEdges = (startIdx, endIdx) => {
					const p1 = points[startIdx];
					const p2 = points[endIdx];

					if (!p1 || !p2) return false;

					// Check against all existing constrained edges
					for (const [existingStartIdx, existingEndIdx] of constrainedEdgeList) {
						// Skip if edges share an endpoint (they're allowed to meet at vertices)
						if (startIdx === existingStartIdx || startIdx === existingEndIdx || endIdx === existingStartIdx || endIdx === existingEndIdx) {
							continue;
						}

						const p3 = points[existingStartIdx];
						const p4 = points[existingEndIdx];

						if (!p3 || !p4) continue;

						// Check if segments intersect
						if (segmentsIntersect(p1, p2, p3, p4)) {
							return true;
						}
					}
					return false;
				};

				// Step 5b) Process constraints in batches with yields between batches
				// This prevents blocking the UI while processing multiple constraints per frame
				let currentIndex = 0;
				const startTime = Date.now();
				const MAX_CONSTRAINT_TIME = 30000; // Maximum 30 seconds for constraint application
				let lastProgressIndex = 0;
				let lastProgressTime = Date.now();
				const STUCK_THRESHOLD = 5000; // If no progress for 5 seconds, skip remaining
				const CONSTRAINTS_PER_BATCH = 10; // Process multiple constraints per frame for speed
				const PROGRESS_UPDATE_INTERVAL = 100; // Update progress at most every 100ms
				let lastProgressUpdateTime = Date.now();
				let batchStartIndex = 0; // Track start of current batch

				// Step 5a.1) Process constraints one at a time with yields between each
				const processNextConstraint = () => {
					try {
						// Check if we've exceeded maximum time
						const totalElapsed = Date.now() - startTime;
						if (totalElapsed > MAX_CONSTRAINT_TIME) {
							console.warn("?? Maximum constraint application time (" + MAX_CONSTRAINT_TIME / 1000 + "s) exceeded. Skipping remaining " + (constraintEdges.length - currentIndex) + " constraints.");
							// Force completion with what we have
							currentIndex = constraintEdges.length;
						}

						// Check if we're stuck (no progress for too long)
						if (currentIndex === lastProgressIndex) {
							const stuckTime = Date.now() - lastProgressTime;
							if (stuckTime > STUCK_THRESHOLD) {
								console.warn("?? Detected stuck constraint at index " + currentIndex + ". Skipping remaining " + (constraintEdges.length - currentIndex) + " constraints.");
								// Skip to end
								currentIndex = constraintEdges.length;
							}
						} else {
							// Progress detected - update tracking
							lastProgressIndex = currentIndex;
							lastProgressTime = Date.now();
						}

						if (currentIndex >= constraintEdges.length) {
							// All constraints processed
							const failedConstraints = constraintEdges.length - successfulConstraints;
							console.log("‚úÖ Processed " + constraintEdges.length + " constraints: " + successfulConstraints + " applied, " + failedConstraints + " skipped");

							if (failedConstraints > 0) {
								console.warn("üö® " + failedConstraints + " constraints were skipped due to conflicts or errors");
							}

							if (updateProgress) updateProgress(95, "Finalizing triangulation...");

							// Step 6) Convert result triangles
							const resultTriangles = [];
							const triangles = delaunay.triangles;

							for (let i = 0; i < triangles.length; i += 3) {
								const idx1 = triangles[i];
								const idx2 = triangles[i + 1];
								const idx3 = triangles[i + 2];

								const v1 = points[idx1];
								const v2 = points[idx2];
								const v3 = points[idx3];

								if (v1 && v2 && v3) {
									resultTriangles.push({
										vertices: [v1, v2, v3],
										indices: [idx1, idx2, idx3],
										minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
										maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
									});
								}
							}

							console.log("üéâ Constrainautor complete: " + resultTriangles.length + " triangles");

							if (updateProgress) updateProgress(100, "Complete!");

							resolve({
								resultTriangles,
								points: points,
								stats: {
									algorithm: "constrainautor",
									originalPoints: points.length,
									triangles: resultTriangles.length,
									constraints: successfulConstraints,
									constraintAttempts: constraintEdges.length,
									failedConstraints: failedConstraints,
								},
							});
							return;
						}

						// Process single constraint
						const [startIdx, endIdx] = constraintEdges[currentIndex];
						const constraint = validConstraints[currentIndex];
						const constraintStartTime = Date.now();
						const constraintIndex = currentIndex; // Store for logging

						try {
							// Check time before processing - if we're close to limit, skip this one
							const elapsedBefore = Date.now() - startTime;
							if (elapsedBefore > MAX_CONSTRAINT_TIME - 1000) {
								console.warn("üö® Skipping constraint " + constraintIndex + " - approaching time limit");
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.1) Check if edge is already constrained - skip if so
							if (isEdgeConstrained(startIdx, endIdx)) {
								// Edge already constrained - skip silently (this is expected for duplicate constraints)
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.1a) REMOVED - No longer needed since problematic constraints are processed first
							// Constraints from entities with unmapped segments are now handled early in the process
							// when the triangulation is simpler and there are fewer existing constraints to conflict with

							// Step 5c.2) Pre-validate constraint indices before applying
							if (startIdx < 0 || endIdx < 0 || startIdx >= points.length || endIdx >= points.length || startIdx === endIdx) {
								console.warn("üö® Skipping invalid constraint " + constraintIndex + ": invalid indices [" + startIdx + ", " + endIdx + "]");
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.3) Check if constraint edge length is reasonable (very short edges can cause issues)
							const p1 = points[startIdx];
							const p2 = points[endIdx];
							if (p1 && p2) {
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								const edgeLength = Math.sqrt(dx * dx + dy * dy);

								// Skip extremely short edges (< 0.0001) as they can cause numerical issues
								if (edgeLength < 0.0001) {
									console.warn("üö® Skipping constraint " + constraintIndex + " - edge too short: " + edgeLength.toFixed(6));
									currentIndex++;
									// Continue processing batch
									const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
									if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
										batchStartIndex = currentIndex;
										requestAnimationFrame(processNextConstraint);
									} else {
										processNextConstraint();
									}
									return;
								}
							}

							// Step 5c.3a) Check if constraint edge passes through other points (collinear issue)
							// Instead of skipping, split the constraint into smaller segments through the points
							let pointsOnEdge = findPointsOnEdge(startIdx, endIdx);

							// Step 5c.3a.1) If we're in the problematic range (700-720) and no points found, try with looser tolerance
							if (pointsOnEdge.length === 0 && constraintIndex >= 700 && constraintIndex <= 720) {
								// Re-check with 10x looser tolerance
								const findPointsOnEdgeLoose = (startIdx, endIdx) => {
									const p1 = points[startIdx];
									const p2 = points[endIdx];
									if (!p1 || !p2) return [];

									const dx = p2.x - p1.x;
									const dy = p2.y - p1.y;
									const lengthSq = dx * dx + dy * dy;
									if (lengthSq < 0.00000001) return [];

									const looseTolerance = 0.1; // 100x looser than original
									const looseToleranceSq = looseTolerance * looseTolerance;
									const pointsOnEdge = [];

									const minX = Math.min(p1.x, p2.x) - looseTolerance;
									const maxX = Math.max(p1.x, p2.x) + looseTolerance;
									const minY = Math.min(p1.y, p2.y) - looseTolerance;
									const maxY = Math.max(p1.y, p2.y) + looseTolerance;

									for (let i = 0; i < points.length; i++) {
										if (i === startIdx || i === endIdx) continue;
										const p = points[i];
										if (!p) continue;
										if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;

										const px = p.x - p1.x;
										const py = p.y - p1.y;
										const t = (px * dx + py * dy) / lengthSq;
										if (t <= 0.001 || t >= 0.999) continue;

										const closestX = p1.x + t * dx;
										const closestY = p1.y + t * dy;
										const distSq = (p.x - closestX) ** 2 + (p.y - closestY) ** 2;

										if (distSq < looseToleranceSq) {
											pointsOnEdge.push({ index: i, t: t });
										}
									}

									pointsOnEdge.sort((a, b) => a.t - b.t);
									return pointsOnEdge.map((item) => item.index);
								};

								pointsOnEdge = findPointsOnEdgeLoose(startIdx, endIdx);
								if (pointsOnEdge.length > 0) {
									console.log("üîò Loose tolerance detected " + pointsOnEdge.length + " collinear points for constraint " + constraintIndex);
								}
							}

							if (pointsOnEdge.length > 0) {
								// Step 1) Split constraint into segments through collinear points
								const splitSegments = splitConstraintThroughPoints(startIdx, endIdx);

								console.log("‚úÇÔ∏è Splitting constraint " + constraintIndex + " from entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.log("   Found " + pointsOnEdge.length + " collinear points: " + pointsOnEdge.join(", "));
								console.log("   Creating " + splitSegments.length + " sub-constraints");

								// Step 2) Apply each split segment as a separate constraint
								let splitSuccessCount = 0;
								for (let segIdx = 0; segIdx < splitSegments.length; segIdx++) {
									const [segStartIdx, segEndIdx] = splitSegments[segIdx];

									// Step 3) Skip if segment is already constrained
									if (isEdgeConstrained(segStartIdx, segEndIdx)) {
										continue;
									}

									try {
										// Step 4) Apply the split constraint
										constrainautor.constrainOne(segStartIdx, segEndIdx);
										markEdgeConstrained(segStartIdx, segEndIdx);
										splitSuccessCount++;
									} catch (splitError) {
										const splitErrorMsg = splitError.message || "";
										if (splitErrorMsg.includes("already constrained") || splitErrorMsg.includes("intersects already constrained")) {
											markEdgeConstrained(segStartIdx, segEndIdx);
										} else {
											console.warn("   ?? Failed to apply split segment " + segIdx + ": [" + segStartIdx + ", " + segEndIdx + "] - " + splitErrorMsg);
										}
									}
								}

								// Step 5) Mark original edge as constrained and continue
								markEdgeConstrained(startIdx, endIdx);
								successfulConstraints += splitSuccessCount;
								console.log("   ? Successfully applied " + splitSuccessCount + "/" + splitSegments.length + " split segments");

								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
								if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.3b) Check if this constraint would intersect existing constrained edges
							// This prevents hangs from intersecting constraints (especially from entities with unmapped segments)
							if (wouldIntersectConstrainedEdges(startIdx, endIdx)) {
								console.warn("?? Skipping constraint " + constraintIndex + " from entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: Edge would intersect existing constrained edge - this can cause hangs");
								// Mark as constrained anyway to prevent trying it again
								markEdgeConstrained(startIdx, endIdx);
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
								if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.4) Apply constraint - ENHANCED LOGGING for problematic constraints
							if (constraintIndex >= 705 && constraintIndex <= 710) {
								const p1 = points[startIdx];
								const p2 = points[endIdx];
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								const edgeLength = Math.sqrt(dx * dx + dy * dy);

								console.log("‚ÑπÔ∏è Detailed info for constraint " + constraintIndex + ":");
								console.log("   Entity: " + (constraint?.entityName || "unknown"));
								console.log("   Indices: [" + startIdx + ", " + endIdx + "]");
								console.log("   Coordinates: [" + p1.x.toFixed(3) + ", " + p1.y.toFixed(3) + ", " + (p1.z || 0).toFixed(3) + "] -> [" + p2.x.toFixed(3) + ", " + p2.y.toFixed(3) + ", " + (p2.z || 0).toFixed(3) + "]");
								console.log("   Edge length: " + edgeLength.toFixed(6));
								console.log("   Already constrained edges: " + constrainedEdges.size);

								// Check for nearby points with tighter tolerance
								const tighterPoints = findPointsOnEdge(startIdx, endIdx);
								if (tighterPoints.length > 0) {
									console.log("   üîò Collinear points detected: " + tighterPoints.join(", "));
								}

								// Check for very close points (even tighter tolerance)
								const veryClosePoints = [];
								const lengthSq = dx * dx + dy * dy;

								for (let i = 0; i < points.length; i++) {
									if (i === startIdx || i === endIdx) continue;
									const p = points[i];
									if (!p) continue;

									const px = p.x - p1.x;
									const py = p.y - p1.y;
									const t = (px * dx + py * dy) / lengthSq;

									if (t > 0 && t < 1) {
										const closestX = p1.x + t * dx;
										const closestY = p1.y + t * dy;
										const distSq = (p.x - closestX) ** 2 + (p.y - closestY) ** 2;
										const dist = Math.sqrt(distSq);

										if (dist < 0.01) {
											// Much tighter tolerance
											veryClosePoints.push({ idx: i, dist: dist.toFixed(6), t: t.toFixed(4) });
										}
									}
								}

								if (veryClosePoints.length > 0) {
									console.log("   ?? Very close points (< 0.01):", veryClosePoints);
								}
							}

							constrainautor.constrainOne(startIdx, endIdx);
							const constraintTime = Date.now() - constraintStartTime;

							// Mark edge as constrained after successful application
							markEdgeConstrained(startIdx, endIdx);

							// Check if constraint took too long (>2000ms) - might indicate a problem
							if (constraintTime > 2000) {
								console.warn("?? Constraint " + constraintIndex + " took " + constraintTime + "ms (very slow but completed)");
							}

							successfulConstraints++;
						} catch (constraintError) {
							// Check if error is because edge is already constrained
							const errorMsg = constraintError.message || "";
							if (errorMsg.includes("already constrained") || errorMsg.includes("intersects already constrained")) {
								// Edge is already constrained - mark it and continue silently
								markEdgeConstrained(startIdx, endIdx);
							} else if (errorMsg.includes("intersects point") || errorMsg.includes("Constraining edge intersects point")) {
								// Collinear point issue - this is expected and should be skipped
								console.warn("?? Skipping constraint " + constraintIndex + " for entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: " + constraintError.message + " (collinear point not detected in pre-check)");
								markEdgeConstrained(startIdx, endIdx);
							} else {
								// Other error - log but continue
								console.warn("?? Skipping constraint " + constraintIndex + " for entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: " + constraintError.message);
							}
						}

						currentIndex++;

						// Update progress throttled (every 100ms or at end of batch)
						const now = Date.now();
						const shouldUpdateProgress = now - lastProgressUpdateTime >= PROGRESS_UPDATE_INTERVAL || currentIndex >= constraintEdges.length;
						if (updateProgress && shouldUpdateProgress) {
							const constraintProgress = 45 + Math.round((currentIndex / constraintEdges.length) * 45);
							const progressPercent = Math.min(constraintProgress, 90);
							const elapsed = ((now - startTime) / 1000).toFixed(1);
							updateProgress(progressPercent, "Applying constraints: " + Math.round((currentIndex / constraintEdges.length) * 100) + "% (" + currentIndex + "/" + constraintEdges.length + ") - " + elapsed + "s elapsed");
							lastProgressUpdateTime = now;
						}

						// Process multiple constraints per frame, then yield to browser
						// This speeds up processing while still keeping UI responsive
						const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
						if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
							// Yield to browser after processing a batch
							batchStartIndex = currentIndex; // Reset batch counter for next batch
							requestAnimationFrame(processNextConstraint);
						} else {
							// Continue processing more constraints in this frame
							processNextConstraint();
						}
					} catch (batchError) {
						// Catch any errors in constraint processing
						console.error("? Error processing constraint " + currentIndex + ":", batchError);
						currentIndex++; // Skip this constraint and continue
						// Continue processing batch
						const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
						if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
							requestAnimationFrame(processNextConstraint);
						} else {
							processNextConstraint();
						}
					}
				};

				// Step 5e) Start processing constraints one at a time
				processNextConstraint();
			} else {
				// No constraints - just convert triangles
				if (updateProgress) updateProgress(50, "No constraints to apply, finalizing...");

				const resultTriangles = [];
				const triangles = delaunay.triangles;

				for (let i = 0; i < triangles.length; i += 3) {
					const idx1 = triangles[i];
					const idx2 = triangles[i + 1];
					const idx3 = triangles[i + 2];

					const v1 = points[idx1];
					const v2 = points[idx2];
					const v3 = points[idx3];

					if (v1 && v2 && v3) {
						resultTriangles.push({
							vertices: [v1, v2, v3],
							indices: [idx1, idx2, idx3],
							minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
							maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
						});
					}
				}

				if (updateProgress) updateProgress(100, "Complete!");

				resolve({
					resultTriangles,
					points: points,
					stats: {
						algorithm: "constrainautor",
						originalPoints: points.length,
						triangles: resultTriangles.length,
						constraints: 0,
						constraintAttempts: 0,
					},
				});
			}
		} catch (error) {
			console.error("? Constrainautor error:", error);
			reject(error);
		}
	});
}

// =============================================================================
// STEP 5: KEEP - Fallback triangulation function (unchanged)
// =============================================================================

function createFallbackTriangulation(points) {
	if (points.length < 3) {
		return { resultTriangles: [], points: [], stats: {} };
	}

	try {
		const getX = (p) => p.x;
		const getY = (p) => p.y;

		const delaunay = Delaunator.from(points, getX, getY);
		const resultTriangles = [];

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const v1 = points[delaunay.triangles[i]];
			const v2 = points[delaunay.triangles[i + 1]];
			const v3 = points[delaunay.triangles[i + 2]];

			resultTriangles.push({
				vertices: [v1, v2, v3],
				indices: [delaunay.triangles[i], delaunay.triangles[i + 1], delaunay.triangles[i + 2]],
				minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
				maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
			});
		}

		return {
			resultTriangles,
			points,
			stats: {
				algorithm: "delaunator_fallback",
				triangles: resultTriangles.length,
				points: points.length,
			},
		};
	} catch (error) {
		console.error("? Fallback triangulation failed:", error);
		return { resultTriangles: [], points: [], stats: {} };
	}
}

// Helper function to determine blast hole point type from params
function getBlastHolePointType(params) {
	if (params.useCollars) return "collar";
	if (params.useGrade) return "grade";
	if (params.useToe) return "toe";
	if (params.useMLength) return "measuredLength";
	return "collar"; // default
}

//======================================================

// ? VERBOSE REMOVAL COMMENT - showTriangulationPopup() and processTriangulationFormData() removed
// Step 1) These functions (~422 lines total, lines 13292-13713) were extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Functions extracted:
//        - showTriangulationPopup() - 401 lines - Dialog for Delaunay 2.5D triangulation
//        - processTriangulationFormData() - 18 lines - Helper to process triangulation form data
// Step 5) Both functions are exposed globally via window.functionName in KADDialogs.js


//===========================
//#endregion DELAUNAY TRIANGULATION  - SURFACE TOOL - END
//===========================

//===========================
//#region DELAUNAY TRIANGLES START
//===========================
/**
 * Function to generate a Delaunay triangulation from a set of 2D points, and
 * filter out triangles with edges that are longer than a specified maximum edge length.
 * @param {Array} points the set of 2D points to triangulate
 * @param {number} maxEdgeLength the maximum edge length to allow
 * @returns {Array} an array of triangles, where each triangle is an array of 3 points,
 * each point being an array of 3 numbers (x, y, z)
 */
function delaunayTriangles(points, maxEdgeLength) {
	// Only do the expensive calculation if slope or relief triangles are being displayed
	if (!displaySlope.checked && !displayRelief.checked) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}

	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}

	const factor = 1.6;
	const minAngleThreshold = 5;
	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}
	let resultTriangles = [];
	let reliefTriangles = [];
	try {
		const getX = (point) => parseFloat(point.startXLocation);
		const getY = (point) => parseFloat(point.startYLocation);

		// Helper function to get average distance to N nearest neighbors for a specific point
		function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
			const distances = [];

			for (let i = 0; i < allPoints.length; i++) {
				if (allPoints[i] === targetPoint) continue; // Skip self

				const dx = getX(targetPoint) - getX(allPoints[i]);
				const dy = getY(targetPoint) - getY(allPoints[i]);
				const distance = Math.sqrt(dx * dx + dy * dy);
				distances.push(distance);
			}

			// Sort distances and take the closest N neighbors
			distances.sort((a, b) => a - b);
			const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

			// Return average of nearest neighbors
			return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
		}

		// Cache for local averages to improve performance
		const localAverageCache = new Map();

		function getCachedLocalAverage(point) {
			if (!localAverageCache.has(point)) {
				localAverageCache.set(point, getLocalAverageDistance(point, points, 6));
			}
			return localAverageCache.get(point);
		}

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(points, getX, getY);

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1[0] - p2[0];
			const dy = p1[1] - p2[1];
			return dx * dx + dy * dy;
		}

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = points[p1Index];
			const p2 = points[p2Index];
			const p3 = points[p3Index];

			// Get cached local average distances for each vertex of the triangle
			const p1LocalAvg = getCachedLocalAverage(p1);
			const p2LocalAvg = getCachedLocalAverage(p2);
			const p3LocalAvg = getCachedLocalAverage(p3);

			// Use the average of the three vertices' local averages
			const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;

			// Create adaptive max edge length for this specific triangle
			// You can adjust the 1.8 multiplier to be more or less restrictive
			const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared([getX(p1), getY(p1)], [getX(p2), getY(p2)]);
			const edge2Squared = distanceSquared([getX(p2), getY(p2)], [getX(p3), getY(p3)]);
			const edge3Squared = distanceSquared([getX(p3), getY(p3)], [getX(p1), getY(p1)]);

			// Use the adaptive max edge length for this triangle
			const maxEdgeLengthSquared = adaptiveMaxEdgeLength ** 2;

			// Check if all edge lengths are within the adaptive limit
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles (bridging triangles)
				const edge1 = Math.sqrt(edge1Squared);
				const edge2 = Math.sqrt(edge2Squared);
				const edge3 = Math.sqrt(edge3Squared);

				// Calculate angles using law of cosines
				const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
				const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
				const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

				const minAngle = Math.min(angle1, angle2, angle3);

				// Only accept triangles with reasonable angles (reject very acute triangles)
				// You can adjust the 12 degree minimum angle threshold
				if (minAngle >= minAngleThreshold) {
					// Add the triangle to the result
					resultTriangles.push([
						[getX(p1), getY(p1), p1.startZLocation], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.startZLocation], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.startZLocation], // [x, y, z] of point 3
					]);

					reliefTriangles.push([
						[getX(p1), getY(p1), p1.holeTime], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.holeTime], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.holeTime], // [x, y, z] of point 3
					]);
				}
			}
		}

		// // Optional: Log some statistics for debugging
		// console.log("Triangulation completed:");
		// console.log("- Total triangles generated:", resultTriangles.length);
		// console.log("- Cache size:", localAverageCache.size);

		return {
			resultTriangles,
			reliefTriangles,
		};
	} catch (err) {
		console.log("Error in delaunayTriangles:", err);
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}
}

//Delaunay triangulation helper function
function getDelaunayFromPoints(points, useToeLocation) {
	try {
		return d3.Delaunay.from(
			points,
			function (p) {
				return useToeLocation ? parseFloat(p.endXLocation) : parseFloat(p.startXLocation);
			},
			function (p) {
				return useToeLocation ? parseFloat(p.endYLocation) : parseFloat(p.startYLocation);
			}
		);
	} catch (err) {
		console.log("Error in getDelaunayFromPoints:", err);
	}
}

//#endregion DELAUNAY TRIANGLES END

//===========================
//#region VORONOI DIAGRAM START
//===========================

//Voronoi Diagram
function getVoronoiMetrics(allBlastHoles, useToeLocation) {
	try {
		if (!allBlastHoles || allBlastHoles.length === 0) {
			console.warn("No Blast Holes to calculate Voronoi metrics");
			return [];
		}

		const delaunay = getDelaunayFromPoints(allBlastHoles, useToeLocation);

		const margin = 10; // optional
		const xExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endXLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startXLocation)))];
		const yExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endYLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startYLocation)))];

		const voronoi = delaunay.voronoi([xExtent[0] - margin, yExtent[0] - margin, xExtent[1] + margin, yExtent[1] + margin]);

		const voronoiResults = [];

		for (let i = 0; i < allBlastHoles.length; i++) {
			const polygon = voronoi.cellPolygon(i);
			if (!polygon) continue;

			// Area using shoelace formula
			let area = 0;
			for (let j = 0; j < polygon.length; j++) {
				const [x1, y1] = polygon[j];
				const [x2, y2] = polygon[(j + 1) % polygon.length];
				area += x1 * y2 - x2 * y1;
			}
			area = Math.abs(area / 2); // in m? if coords are meters

			const h = allBlastHoles[i];
			const length = parseFloat(h.measuredLength || h.benchHeight || 1);
			const measuredLength = parseFloat(h.measuredLength || 0);
			const designedLength = parseFloat(h.holeLengthCalculated || 0);
			const holeFiringTime = parseFloat(h.holeTime || 0);
			const mass = parseFloat(h.measuredMass || 0);
			const volume = area * length;
			const powderFactor = volume > 0 ? mass / volume : null;
			//Add more metrics here

			voronoiResults.push({
				index: i,
				hole: h,
				polygon: polygon,
				area: area,
				length: length,
				measuredLength: measuredLength,
				designedLength: designedLength,
				holeFiringTime: holeFiringTime,
				volume: volume,
				mass: mass,
				powderFactor: powderFactor,
				//add a scaled heelan vibration calculation here
			});
		}

		//console.log("Returning Voronoi Metrics", voronoiResults);
		return voronoiResults;
	} catch (err) {
		console.log("Error in getVoronoiMetrics:", err);
		return [];
	}
}

// All legends now use a cool-to-hot gradient: blue (cool, small) -> cyan -> green -> yellow -> red (hot, large)

function getPFColor(pf, min, max) {
	// Map PF to a visible spectrum (violet -> blue -> green -> yellow -> orange -> red)
	//console.log("Getting PF Color", pf, min, max);
	let ratio;
	let r, g, b;
	if (!isVoronoiLegendFixed) {
		const minPF = min;
		const maxPF = max;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		// Interpolate from violet (148,0,211) -> blue (0,0,255) -> cyan (0,255,255) -> green (0,255,0) -> yellow (255,255,0) -> red (255,0,0)
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	} else {
		// Fixed spectrum: min=0, max=3, 0=violet, 0.2=blue, 0.4=cyan, 0.6=green, 0.8=yellow, 1=red
		const minPF = 0.0;
		const maxPF = 3.0;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	}

	return `rgb(${r},${g},${b})`;
}

function getAreaColor(area, min, max) {
	// Map area to a cool-to-hot gradient (blue-cyan-green-yellow-red)

	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((area - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getLengthColor(length, min, max) {
	// Map length to a cool-to-hot gradient (blue-cyan-green-yellow-red)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((length - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getHoleFiringTimeColor(holeFiringTime, min, max) {
	// Color scale: lime green (min) to red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((holeFiringTime - minColor) / (maxColor - minColor), 0), 1);

	// Lime green: rgb(0, 150, 0), Red: rgb(200, 0, 0)
	const r = Math.round(50 + (255 - 50) * ratio);
	const g = Math.round(255 - 255 * ratio);
	const b = Math.round(50 - 50 * ratio);

	return `rgb(${r},${g},${b})`;
}

function getMassColor(mass, min, max) {
	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((mass - minColor) / (maxColor - minColor), 0), 1);

	// Interpolate through blue -> cyan -> green -> yellow -> red
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getVolumeColor(volume, min, max) {
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((volume - minColor) / (maxColor - minColor), 0), 1);

	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

//Draw function for Powderfactor
function drawVoronoiMetric(metrics, metricName, getColorForMetric) {
	const ctx = canvas.getContext("2d");

	for (let cell of metrics) {
		// Skip if the cell doesn't have a polygon or the metric is null/undefined
		if (!cell.polygon || cell[metricName] == null) continue;

		const color = getColorForMetric(cell[metricName]);

		ctx.beginPath();
		ctx.moveTo(cell.polygon[0][0], cell.polygon[0][1]);
		for (let j = 1; j < cell.polygon.length; j++) {
			ctx.lineTo(cell.polygon[j][0], cell.polygon[j][1]);
		}
		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}
}

//using resultTriangles from delaunayTriangles function create a bounding polygon
function createBlastBoundaryPolygon(triangles) {
	let blastBoundaryPolygon = [];

	if (triangles && triangles.length > 0) {
		// Extract all vertices from triangles
		let vertices = triangles.flat().map((point) => ({
			x: point[0],
			y: point[1],
		}));

		// Compute convex hull
		if (vertices.length > 0) {
			try {
				const hull = d3.polygonHull(vertices.map((v) => [v.x, v.y]));

				if (hull && hull.length > 0) {
					blastBoundaryPolygon = hull.map((point) => ({
						x: point[0],
						y: point[1],
					}));
				}
			} catch (error) {
				console.error("Error computing convex hull:", error);
				// Optionally, fall back to a simpler method or return an empty polygon
				blastBoundaryPolygon = [];
			}
		}
	}

	return blastBoundaryPolygon;
}
//#endregion DELAUNAY TRIANGLES END

//===========================
//#region RADII POLYGONS START
//===========================

/**
 * Generates polygons representing circles around given points, optionally performing a union of these circles.
 *
 * @param {Array<Object>} points - An array of objects, each with `startXLocation`, `startYLocation`, and `startZLocation` properties, representing the center of a circle.
 * @param {number} steps - The number of steps to use when generating the circle polygon. Higher values result in smoother circles.
 * @param {number} radius - The radius of the circles.
 * @param {boolean} union - If true, performs a union of all the circle polygons using the ClipperLib library.
 * @param {boolean} addToMaps - If true, adds the generated polygons to the `allKADDrawingsMap`.
 * @returns {Array<Array<Object>>} An array of polygons. Each polygon is an array of points, where each point is an object with `x`, `y`, and `z` properties.  Returns an empty array if the Clipper union fails.
 */
function getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation) {
	// Step 0) Early return if no points provided
	if (!points || points.length === 0) {
		return [];
	}

	const scale = 100000;
	const rawPolygons = [];

	// Generate circle polygons
	points.forEach((pt) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		const poly = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = cx + radius * Math.cos(angle);
			const y = cy + radius * Math.sin(angle);
			poly.push({
				x: x,
				y: y,
				z: z,
			});
		}

		rawPolygons.push(poly);
	});

	if (!union) {
		if (addToMaps) {
			rawPolygons.forEach((polygon) => {
				entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					data: polygon.map((pt) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: "",
						lineWidth: 5,
						color: 1,
						closed: true,
						entityType: "poly",
					})),
				});
			});
		}
		return rawPolygons; // each point includes x, y, z
	}

	// Convert for ClipperLib union
	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale),
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("Clipper union failed.");
			clipperUnionWarned = true;
		}
		return [];
	}
	// Interpolate Z using nearest original point
	const unionedPolygons = solution.map((path) =>
		path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ,
			};
		})
	);

	if (addToMaps) {
		unionedPolygons.forEach((polygon) => {
			entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
			//add pointID to each point starting from 1 to nth
			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});
			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 5,
					color: color || 1,
					closed: true,
					entityType: "poly",
				})),
			});
		});
	}

	return unionedPolygons; // includes x, y, z
}

/**
 * Enhanced Radii Polygons Generator
 *
 * Creates circular or starburst polygons around blast hole points with advanced features:
 * - Rotation offset for orienting polygons
 * - Starburst effect for creating star-shaped patterns
 * - Union capability for combining overlapping circles
 * - Automatic Z-elevation inheritance from nearest points
 *
 * @param {Array} points - Array of blast hole objects with location properties
 * @param {number} steps - Number of polygon vertices (3-100, higher = smoother circles)
 * @param {number} radius - Base radius in meters for polygon generation
 * @param {boolean} union - Whether to union overlapping polygons using Clipper
 * @param {boolean} addToMaps - Whether to add results to KAD drawings map
 * @param {string} color - Hex color code for polygon display
 * @param {number} lineWidth - Line width for polygon rendering
 * @param {boolean} useToeLocation - Use end/toe location (true) or start/collar (false)
 * @param {number} rotationOffset - Rotation angle in degrees (-360 to +360)
 * @param {number} starburstOffset - Starburst ratio 0-1 (1.0=circle, 0.5=half radius on even points, 0=star)
 *
 * @returns {Array} Array of polygon objects with {x, y, z} coordinates
 *
 * Features:
 * - Rotation: 0? = no rotation, +45? = clockwise, -45? = counter-clockwise
 * - Starburst: Even-numbered vertices get reduced radius, odd vertices keep full radius
 * - Example: 5m radius + 0.5 starburst = odd points at 5m, even points at 2.5m
 * - Union: Combines overlapping circles into single complex polygons
 * - Z-elevation: Automatically finds nearest point elevation for each vertex
 *
 * Entity Naming Convention:
 * - RAD-SRT: Start/collar location polygons
 * - RAD-END: End/toe location polygons
 * - -R45: Rotation offset suffix (e.g., 45 degrees)
 * - -S50: Starburst suffix (e.g., 50% ratio)
 * - -UNION: Indicates unioned polygons
 */

// Enhanced version with rotation and starburst capabilities
// Enhanced version with rotation and starburst capabilities (with 8-step minimum)
function getRadiiPolygonsEnhanced(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation, rotationOffset, starburstOffset) {
	// Step 0) Early return if no points provided
	if (!points || points.length === 0) {
		return [];
	}

	// Step 1: Initialize variables and convert rotation to radians
	const scale = 100000;
	const rawPolygons = [];
	const rotationRadians = (rotationOffset || 0) * (Math.PI / 180); // Convert degrees to radians

	// Step 2: Apply starburst constraint - only allow if steps >= 8
	let effectiveStarburstRatio;
	if (steps >= 8 && starburstOffset !== undefined) {
		effectiveStarburstRatio = starburstOffset;
	} else {
		effectiveStarburstRatio = 1.0; // Force normal circle for < 8 steps
	}

	console.log("üåü Creating enhanced radii polygons:");
	console.log("   Steps: " + steps + " (starburst " + (steps >= 8 ? "enabled" : "disabled") + ")");
	console.log("   Rotation: " + (rotationOffset || 0) + "¬∞ (" + rotationRadians.toFixed(4) + " rad)");
	console.log("   Starburst ratio: " + effectiveStarburstRatio + " (" + effectiveStarburstRatio * 100 + "%)");

	// Step 3: Generate enhanced circle polygons with rotation and starburst
	points.forEach((pt, pointIndex) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		console.log("   Processing point " + (pointIndex + 1) + " at (" + cx + ", " + cy + ", " + z + ")");

		const poly = [];

		// Step 4: Create polygon points with enhanced features
		for (let i = 0; i < steps; i++) {
			// Step 5: Calculate base angle with rotation offset
			const baseAngle = (i / steps) * Math.PI * 2;
			const angle = baseAngle + rotationRadians;

			// Step 6: Apply starburst effect only if enabled (steps >= 8)
			let currentRadius = radius;
			if (steps >= 8 && i % 2 === 0) {
				// Even-numbered points (0, 2, 4, ...) get starburst reduction
				currentRadius = radius * effectiveStarburstRatio;
			}
			// Odd-numbered points (1, 3, 5, ...) always keep full radius

			// Step 7: Calculate point coordinates
			const x = cx + currentRadius * Math.cos(angle);
			const y = cy + currentRadius * Math.sin(angle);

			poly.push({
				x: x,
				y: y,
				z: z,
			});

			// Debug logging for first few points
			if (pointIndex === 0 && i < 4) {
				console.log("     Point " + i + ": angle=" + ((angle * 180) / Math.PI).toFixed(1) + "¬∞, radius=" + currentRadius.toFixed(2) + "m, coords=(" + x.toFixed(2) + "," + y.toFixed(2) + ")");
			}
		}

		rawPolygons.push(poly);
	});

	// Step 8: Handle non-union case (multiple separate polygons)
	if (!union) {
		if (addToMaps) {
			rawPolygons.forEach((polygon, index) => {
				// Step 9: Create unique entity name with enhanced indicators
				let entityName = useToeLocation ? "RAD-END" : "RAD-SRT";
				if (rotationOffset !== 0) {
					entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
				}
				if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
					entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
				}
				entityName += "-" + Math.random().toString(36).substring(2, 6);

				// Step 10: Add polygon to KAD drawings map
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					data: polygon.map((pt, pointIndex) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: pointIndex + 1,
						lineWidth: lineWidth || 2,
						color: color || "#00FF00",
						closed: true,
						entityType: "poly",
					})),
				});

				console.log("‚úÖ Created enhanced polygon: " + entityName + " with " + polygon.length + " points");
			});
		}
		return rawPolygons;
	}

	// Continue with union logic (same as before)...
	console.log("üîó Performing union operation on " + rawPolygons.length + " polygons...");

	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale),
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("?? Clipper union failed for enhanced radii polygons.");
			clipperUnionWarned = true;
		}
		return [];
	}

	console.log("‚úÖ Union successful, created " + solution.length + " combined polygon(s)");

	const unionedPolygons = solution.map((path, pathIndex) => {
		console.log("   Processing union polygon " + (pathIndex + 1) + " with " + path.length + " points");

		return path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ,
			};
		});
	});

	if (addToMaps) {
		unionedPolygons.forEach((polygon, index) => {
			let entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + "-UNION";
			if (rotationOffset !== 0) {
				entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
			}
			if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
				entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
			}
			entityName += "-" + Math.random().toString(36).substring(2, 6);

			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});

			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 2,
					color: color || "#00FF00",
					closed: true,
					entityType: "poly",
				})),
			});

			console.log("‚úÖ Created enhanced union polygon: " + entityName + " with " + polygon.length + " points");
		});
	}

	return unionedPolygons;
}

function clipVoronoiCells(voronoiMetrics) {
	// Step 0) Early return if no blast holes or voronoi metrics
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return [];
	}
	if (!voronoiMetrics || voronoiMetrics.length === 0) {
		return [];
	}

	const scale = 100000;
	const allClippedCells = []; // Changed variable name for clarity

	// --- Your existing logic to calculate contractedPolygons ---
	const nearest = getNearestNeighborDistancesByAggregation(allBlastHoles, "mode", useToeLocation);
	const expand = nearest * 1.5;
	const contract = expand * 0.65;
	//----------------------getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation)
	const unionedPolygons = getRadiiPolygons(allBlastHoles, 36, expand, true, false, "red", 1, useToeLocation);
	//----------------------
	const simplifiedPolygons = unionedPolygons.map((polygon) => simplifyPolygon(polygon, 0.1, true));
	const contractedPolygons = simplifiedPolygons.map((polygon) => offsetPolygonClipper(polygon, -contract));
	// --- End of your existing logic ---

	const clipPathPolygons = contractedPolygons; // These are the actual geometric polygons
	/*
	console.log("nearest:", nearest);
	console.log("expand:", expand);
	console.log("unionedPolygons:", unionedPolygons);
	console.log("simplifiedPolygons:", simplifiedPolygons);
	console.log("contract:", contract);
	console.log("contractedPolygons:", contractedPolygons);
	console.log("clipPathPolygons for iteration:", clipPathPolygons);
	*/

	for (let cell of voronoiMetrics) {
		if (!cell.polygon || cell.polygon.length < 3) continue;

		const subjPath = cell.polygon.map((p) => ({
			X: Math.round((p.x || p[0]) * scale),
			Y: Math.round((p.y || p[1]) * scale),
		}));

		let cellSuccessfullyClippedAndAdded = false;
		// Iterate through each of your boundary polygons
		for (const currentBoundaryPolygon of clipPathPolygons) {
			if (!currentBoundaryPolygon || currentBoundaryPolygon.length < 3) continue;

			// Convert the current boundary polygon to Clipper format
			const clipperSingleClipPath = currentBoundaryPolygon.map((p) => ({
				X: Math.round(p.x * scale),
				Y: Math.round(p.y * scale),
			}));

			const clipper = new ClipperLib.Clipper();
			clipper.AddPath(subjPath, ClipperLib.PolyType.ptSubject, true);
			clipper.AddPath(clipperSingleClipPath, ClipperLib.PolyType.ptClip, true); // Use only ONE clip path here

			const solution = new ClipperLib.Paths();
			const success = clipper.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

			if (success && solution.length > 0 && solution[0].length > 0) {
				// Check solution[0] for valid polygon
				const clippedResultPolygon = solution[0].map((pt) => ({
					x: pt.X / scale,
					y: pt.Y / scale,
				}));

				const area = Math.abs(
					clippedResultPolygon.reduce((acc, curr, i, arr) => {
						const next = arr[(i + 1) % arr.length];
						return acc + curr.x * next.y - next.x * curr.y;
					}, 0) / 2
				);
				const volume = area * cell.length;
				const powderFactor = volume > 0 ? cell.mass / volume : null;

				allClippedCells.push({
					...cell,
					polygon: clippedResultPolygon,
					area,
					volume,
					powderFactor,
				});
				cellSuccessfullyClippedAndAdded = true;
				break; // Important: Cell is clipped by this boundary, no need to check others
			}
		}
		// If cellSuccessfullyClippedAndAdded is false here, the cell was not inside any of the boundaries.
	}
	return allClippedCells;
}

function simplifyPolygon(polygon, tolerance, forceClose) {
	if (!polygon || polygon.length < 3) return polygon;

	const scale = 100000;
	const scaledPath = polygon.map((p) => ({
		X: Math.round((p.x || p[0]) * scale),
		Y: Math.round((p.y || p[1]) * scale),
	}));

	const c = new ClipperLib.Clipper();
	const cleaned = ClipperLib.Clipper.CleanPolygon(scaledPath, tolerance * scale);

	if (!cleaned || cleaned.length < 3) return polygon;

	const simplified = cleaned.map((p) => ({
		x: p.X / scale,
		y: p.Y / scale,
	}));

	if (forceClose && simplified.length > 0) {
		simplified.push({
			...simplified[0],
		});
	}

	return simplified;
}

function offsetPolygonClipper(polygon, offsetMeters) {
	if (!polygon || polygon.length < 3) return [];

	const scale = 100000; // ClipperLib works in integers, scale up for precision

	// Convert to Clipper path format
	const path = polygon.map((p) => ({
		X: Math.round(p.x * scale),
		Y: Math.round(p.y * scale),
	}));

	// Initialize and execute offset
	const co = new ClipperLib.ClipperOffset();
	co.AddPath(path, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

	const offsetPaths = [];
	co.Execute(offsetPaths, offsetMeters * scale);

	// Convert back to float points
	if (offsetPaths.length === 0) return [];
	return offsetPaths[0].map((p) => ({
		x: p.X / scale,
		y: p.Y / scale,
	}));
}

// function to offset a selected KAD object. Uses clipper library to offset.
// All KAD are allowed Points, lines, Poly, circle and text.
// Projection at 0? inherits the existing KAD object elevation
// first select the kad object to offset.
// then click the offsetKADButton.  The button cannot be on it can only be click.  There must be a selection from the selectPointer.
// then show a popup with the amount to offset Positive or Negative. will define the direction.
// the popup will allow for projection up at and angle or down at and angle.
// 0? is horizontal, -ve? is down, +ve? is Up.  The distance is the amount from the orignal line.
// the popup will allow for multiple offset. 1 - 100
// the kad object will be offset by the amount positive expands and negative compresses.
// ================================
// OFFSET KAD FUNCTIONALITY
// ================================

// Update the offset button event listener with full functionality
offsetKADButton.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools and activate offset mode
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("offsetKADTool");

		isOffsetKAD = true;
		offsetKADButton.checked = true;

		// Check if there's already a selected KAD object
		if (selectedKADObject && (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly")) {
			// Show offset popup immediately for the selected object
			showOffsetKADPopup(selectedKADObject);
		} else {
			// Add click listener for offset operations
			canvas.addEventListener("click", handleOffsetKADClick);
			canvas.addEventListener("touchstart", handleOffsetKADClick);
			updateStatusMessage("Offset Tool Activated\nClick on a KAD object (line/polygon) to offset\nThen configure offset parameters");
		}
	} else {
		isOffsetKAD = false;
		canvas.removeEventListener("click", handleOffsetKADClick);
		canvas.removeEventListener("touchstart", handleOffsetKADClick);
		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Handle clicks when offset tool is active
function handleOffsetKADClick(event) {
	if (!isOffsetKAD) return;

	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;

	if (isNaN(clickX) || isNaN(clickY)) {
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	}

	// Find clicked KAD object
	const clickedKADObject = getClickedKADObject(clickX, clickY);

	if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
		// Show offset configuration popup
		showOffsetKADPopup(clickedKADObject);
	} else {
		updateStatusMessage("Please click on a line or polygon to offset");
		setTimeout(() => updateStatusMessage("Offset Tool Active - Click on a line or polygon"), 2000);
	}
}
// Show the offset configuration popup
//! Useing the FloatingDialog class to show the popup
// ? VERBOSE REMOVAL COMMENT - showOffsetKADPopup() removed
// Step 1) This function (148 lines, lines 14443-14590) was extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Function extracted: showOffsetKADPopup() - Dialog for offsetting KAD entities
// Step 5) Function is exposed globally via window.showOffsetKADPopup in KADDialogs.js

function createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null, keepElevations = true, limitElevation = false, elevationLimit = 0.0) {
	try {
		const originalPoints = originalEntity.data;

		// Fix Issue #2: Handle undefined entityName
		const baseEntityName = originalEntityName || originalEntity.entityName || "unnamed_entity";

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance from the line at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// Horizontal component of the offset (2D plane)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical component calculation
			// For distance priority, the vertical offset is based on the sine of the angle
			// and the ABSOLUTE value of the offset amount (distance is always positive)
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta Calculation:
			// - projectionAngle > 0: Going UP, so ADD to Z
			// - projectionAngle < 0: Going DOWN, so SUBTRACT from Z
			// - projectionAngle = 0: No vertical change
			// Note: We use the signed value of verticalOffset (which includes angle sign)
			zDelta = verticalOffset; // This already has the correct sign from sin(angle)
		} else {
			// Vertical Priority: The offset amount IS the vertical distance
			// The sign of the projection angle determines up/down direction
			// The sign of the offset amount only affects horizontal direction (left/right)

			if (projectionAngle > 0) {
				// Positive angle = going UP
				// Z increases by the absolute offset amount
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				// Z decreases by the absolute offset amount
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = pure horizontal, no Z change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset needed to achieve the vertical distance at the angle
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// Horizontal offset maintains the left/right direction from offsetAmount sign
					// but adjusts magnitude based on the angle
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount; // Fallback for very small angles
				}
			} else {
				// Pure horizontal offset when angle is 0
				horizontalOffset = offsetAmount;
			}
		}

		console.log("üîß Offset calculation:");
		console.log("  offsetAmount:", offsetAmount, "(direction:", offsetAmount > 0 ? "right" : "left", ")");
		console.log("  projectionAngle:", projectionAngle, "¬∞");
		console.log("  priorityMode:", priorityMode);
		console.log("  horizontalOffset:", horizontalOffset.toFixed(3));
		console.log("  verticalOffset:", verticalOffset.toFixed(3));
		console.log("  zDelta:", zDelta.toFixed(3));
		console.log("  baseEntityName:", baseEntityName); // Debug log
		console.log("  handleCrossovers", handleCrossovers);

		if (!handleCrossovers) {
			// Use the simple method without crossover handling
			return createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName);
		}

		// Create offset segments with crossover handling
		const offsetSegments = [];

		// Generate offset segments for each original segment
		for (let i = 0; i < originalPoints.length - 1; i++) {
			const p1 = originalPoints[i];
			const p2 = originalPoints[i + 1];

			// Calculate segment direction vector
			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length === 0) continue; // Skip zero-length segments

			// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
			// Negative dy and positive dx gives us the right-hand perpendicular
			let perpX1 = (-dy / length) * horizontalOffset;
			let perpY1 = (dx / length) * horizontalOffset;
			let perpX2 = perpX1;
			let perpY2 = perpY1;

			// Apply elevation limit (project to level) if enabled
			let p1ZDelta = parseFloat(zDelta);
			let p2ZDelta = parseFloat(zDelta);

			if (limitElevation && projectionAngle !== 0) {
				const angleRad = Math.abs(projectionAngle * Math.PI / 180);
				const tanAngle = Math.tan(angleRad);

				// Check p1 (start point) - limit projection to elevation limit
				const p1OrigZ = parseFloat(p1.pointZLocation);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p1OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						const verticalDrop = p1OrigZ - elevationLimit;
						const horizontalDistance = verticalDrop / tanAngle;
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p1OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						const verticalRise = elevationLimit - p1OrigZ;
						const horizontalDistance = verticalRise / tanAngle;
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				}

				// Check p2 (end point) - limit projection to elevation limit
				const p2OrigZ = parseFloat(p2.pointZLocation);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p2OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						const verticalDrop = p2OrigZ - elevationLimit;
						const horizontalDistance = verticalDrop / tanAngle;
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p2OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						const verticalRise = elevationLimit - p2OrigZ;
						const horizontalDistance = verticalRise / tanAngle;
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				}
			}

			// Create offset segment with proper Z calculation
			// IMPORTANT: Ensure all values are numbers, not strings
			const offsetSeg = {
				start: {
					x: p1.pointXLocation + perpX1,
					y: p1.pointYLocation + perpY1,
					z: parseFloat(p1.pointZLocation) + p1ZDelta,
				},
				end: {
					x: p2.pointXLocation + perpX2,
					y: p2.pointYLocation + perpY2,
					z: parseFloat(p2.pointZLocation) + p2ZDelta,
				},
				index: i,
			};

			offsetSegments.push(offsetSeg);
		}

		// Handle single segment lines
		if (originalPoints.length === 2 && offsetSegments.length === 0) {
			const p1 = originalPoints[0];
			const p2 = originalPoints[1];

			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length > 0) {
				//const perpX = (-dy / length) * horizontalOffset;
				//const perpY = (dx / length) * horizontalOffset;
//
				//offsetSegments.push({
				//	start: {
				//		x: p1.pointXLocation + perpX,
				//		y: p1.pointYLocation + perpY,
				//		z: parseFloat(p1.pointZLocation) + parseFloat(zDelta), // Fix string concatenation
				//	},
				//	end: {
				//		x: p2.pointXLocation + perpX,
				//		y: p2.pointYLocation + perpY,
				//		z: parseFloat(p2.pointZLocation) + parseFloat(zDelta), // Fix string concatenation
				//	},
				//	index: 0,
				//});
				  			let perpX1 = (-dy / length) * horizontalOffset;
  			let perpY1 = (dx / length) * horizontalOffset;
  			let perpX2 = perpX1;
  			let perpY2 = perpY1;

  			// Apply elevation limit (project to level) if enabled
  			let p1ZDelta = parseFloat(zDelta);
  			let p2ZDelta = parseFloat(zDelta);

  			if (limitElevation && projectionAngle !== 0) {
  				const angleRad = Math.abs(projectionAngle * Math.PI / 180);
  				const tanAngle = Math.tan(angleRad);

  				// Check p1 (start point) - limit projection to elevation limit
  				const p1OrigZ = parseFloat(p1.pointZLocation);

  				if (projectionAngle < 0) {
  					// Projecting downward
  					if (p1OrigZ > elevationLimit) {
  						// Point is above limit - project down to limit
  						p1ZDelta = elevationLimit - p1OrigZ;
  						const verticalDrop = p1OrigZ - elevationLimit;
  						const horizontalDistance = verticalDrop / tanAngle;
  						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
  						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
  					} else {
  						// Point is at or below limit - no offset
  						p1ZDelta = 0;
  						perpX1 = 0;
  						perpY1 = 0;
  					}
  				} else if (projectionAngle > 0) {
  					// Projecting upward
  					if (p1OrigZ < elevationLimit) {
  						// Point is below limit - project up to limit
  						p1ZDelta = elevationLimit - p1OrigZ;
  						const verticalRise = elevationLimit - p1OrigZ;
  						const horizontalDistance = verticalRise / tanAngle;
  						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
  						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
  					} else {
  						// Point is at or above limit - no offset
  						p1ZDelta = 0;
  						perpX1 = 0;
  						perpY1 = 0;
  					}
  				}

  				// Check p2 (end point) - limit projection to elevation limit
  				const p2OrigZ = parseFloat(p2.pointZLocation);

  				if (projectionAngle < 0) {
  					// Projecting downward
  					if (p2OrigZ > elevationLimit) {
  						// Point is above limit - project down to limit
  						p2ZDelta = elevationLimit - p2OrigZ;
  						const verticalDrop = p2OrigZ - elevationLimit;
  						const horizontalDistance = verticalDrop / tanAngle;
  						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
  						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
  					} else {
  						// Point is at or below limit - no offset
  						p2ZDelta = 0;
  						perpX2 = 0;
  						perpY2 = 0;
  					}
  				} else if (projectionAngle > 0) {
  					// Projecting upward
  					if (p2OrigZ < elevationLimit) {
  						// Point is below limit - project up to limit
  						p2ZDelta = elevationLimit - p2OrigZ;
  						const verticalRise = elevationLimit - p2OrigZ;
  						const horizontalDistance = verticalRise / tanAngle;
  						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
  						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
  					} else {
  						// Point is at or above limit - no offset
  						p2ZDelta = 0;
  						perpX2 = 0;
  						perpY2 = 0;
  					}
  				}
  			}

  			offsetSegments.push({
  				start: {
  					x: p1.pointXLocation + perpX1,
  					y: p1.pointYLocation + perpY1,
  					z: parseFloat(p1.pointZLocation) + p1ZDelta,
  				},
  				end: {
  					x: p2.pointXLocation + perpX2,
  					y: p2.pointYLocation + perpY2,
  					z: parseFloat(p2.pointZLocation) + p2ZDelta,
  				},
  				index: 0,
  			});
			}
		}

		// Handle crossovers by finding intersections and trimming/extending segments
		const cleanedSegments = handleCrossovers ? handleSegmentCrossovers(offsetSegments) : offsetSegments;

		// Convert cleaned segments to point array
		const offsetPoints = [];
		cleanedSegments.forEach((seg) => {
			offsetPoints.push(
				{
					pointXLocation: seg.start.x,
					pointYLocation: seg.start.y,
					pointZLocation: seg.start.z,
				},
				{
					pointXLocation: seg.end.x,
					pointYLocation: seg.end.y,
					pointZLocation: seg.end.z,
				}
			);
		});

		if (offsetPoints.length === 0) {
			throw new Error("No valid segments after crossover handling");
		}

		// Create unique name with short ID to avoid overwrites
		const shortId = Math.random().toString(36).substring(2, 6);
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + shortId;

		const newEntityData = offsetPoints.map((pt, index) => ({
			entityName: newEntityName,
			entityType: "line",
			pointID: index + 1,
			pointXLocation: pt.pointXLocation,
			pointYLocation: pt.pointYLocation,
			pointZLocation: pt.pointZLocation,
			lineWidth: originalPoints[0].lineWidth || 1,
			color: color,
			closed: false,
			visible: true,
		}));

		// Add to the map
		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: "line",
			data: newEntityData,
			visible: true,
		});

		console.log("‚úÖ Created crossover-handled line offset:", newEntityName, "with", newEntityData.length, "points");
		return newEntityName;
	} catch (error) {
		console.error("Error in createLineOffsetCustom:", error);
		throw error;
	}
}

// Simple line offset without crossover handling (updated with fixes)
function createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName) {
	const originalPoints = originalEntity.data;
	const offsetPoints = [];

	// Handle single segment and multi-segment lines
	for (let i = 0; i < originalPoints.length - 1; i++) {
		const p1 = originalPoints[i];
		const p2 = originalPoints[i + 1];

		const dx = p2.pointXLocation - p1.pointXLocation;
		const dy = p2.pointYLocation - p1.pointYLocation;
		const length = Math.sqrt(dx * dx + dy * dy);

		if (length === 0) continue;

		// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
		const perpX = (-dy / length) * horizontalOffset;
		const perpY = (dx / length) * horizontalOffset;

		// Apply the correct Z delta
		// IMPORTANT: Parse float to avoid string concatenation
		const offsetP1 = {
			pointXLocation: p1.pointXLocation + perpX,
			pointYLocation: p1.pointYLocation + perpY,
			pointZLocation: parseFloat(p1.pointZLocation) + parseFloat(zDelta), // Fix concatenation
		};

		const offsetP2 = {
			pointXLocation: p2.pointXLocation + perpX,
			pointYLocation: p2.pointYLocation + perpY,
			pointZLocation: parseFloat(p2.pointZLocation) + parseFloat(zDelta), // Fix concatenation
		};

		offsetPoints.push(offsetP1, offsetP2);
	}

	const timestamp = Date.now();
	const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + timestamp;

	const newEntityData = offsetPoints.map((pt, index) => ({
		entityName: newEntityName,
		entityType: "line",
		pointID: index + 1,
		pointXLocation: pt.pointXLocation,
		pointYLocation: pt.pointYLocation,
		pointZLocation: pt.pointZLocation,
		lineWidth: originalPoints[0].lineWidth || 1,
		color: color,
		closed: false,
		visible: true,
	}));

	allKADDrawingsMap.set(newEntityName, {
		entityName: newEntityName,
		entityType: "line",
		data: newEntityData,
		visible: true,
	});

	return newEntityName;
}

// Handle crossovers between offset segments
function handleSegmentCrossovers(segments) {
	if (segments.length < 2) return segments;

	const cleanedSegments = [...segments];

	// Find intersections between consecutive segments and extend/trim accordingly
	for (let i = 0; i < cleanedSegments.length - 1; i++) {
		const seg1 = cleanedSegments[i];
		const seg2 = cleanedSegments[i + 1];

		// Find intersection between the two line segments
		const intersection = findLineIntersection(seg1.start.x, seg1.start.y, seg1.end.x, seg1.end.y, seg2.start.x, seg2.start.y, seg2.end.x, seg2.end.y);

		if (intersection) {
			// Extend/trim segments to meet at intersection
			seg1.end.x = intersection.x;
			seg1.end.y = intersection.y;
			seg2.start.x = intersection.x;
			seg2.start.y = intersection.y;
		}
	}

	// Remove segments that became too short (less than 0.1m)
	return cleanedSegments.filter((seg) => {
		const length = Math.sqrt(Math.pow(seg.end.x - seg.start.x, 2) + Math.pow(seg.end.y - seg.start.y, 2));
		return length > 0.1;
	});
}

// Find intersection point between two line segments
function findLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

	if (Math.abs(denom) < 1e-10) {
		return null; // Lines are parallel
	}

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	// Check if intersection is within reasonable extension range
	if (t >= -0.5 && t <= 1.5 && u >= -0.5 && u <= 1.5) {
		return {
			x: x1 + t * (x2 - x1),
			y: y1 + t * (y2 - y1),
		};
	}

	return null; // No valid intersection
}

// Update the createOffsetEntity function for polygons
function createOffsetEntity(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null, keepElevations = true, limitElevation = false, elevationLimit = 0.0) {
	try {
		const scale = 100000;
		const originalPoints = originalEntity.data;

		if (originalPoints.length < 2) {
			throw new Error("Need at least 2 points for offset");
		}

		/// Fix Issue #2: Handle undefined entityName - use passed name or fallback
		const baseEntityName = originalEntityName || originalEntity.entityName || "undef";

		// For lines, use custom offset method
		if (originalEntity.entityType === "line") {
			return createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers, priorityMode, baseEntityName, keepElevations, limitElevation, elevationLimit);
		}

		// For polygons, use ClipperLib
		const clipperPath = originalPoints.map((pt) => ({
			X: Math.round(pt.pointXLocation * scale),
			Y: Math.round(pt.pointYLocation * scale),
		}));

		const clipperOffset = new ClipperLib.ClipperOffset();
		clipperOffset.AddPath(clipperPath, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// For polygons: offsetAmount controls expand(+) / contract(-)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical offset uses sine of angle and absolute offset
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta: Use the signed verticalOffset (sin includes angle sign)
			zDelta = verticalOffset;
		} else {
			// Vertical Priority: Distance becomes the vertical amount
			if (projectionAngle > 0) {
				// Positive angle = going UP
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = no vertical change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset for vertical priority
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// For polygons, maintain expand/contract behavior
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount;
				}
			} else {
				horizontalOffset = offsetAmount;
			}
		}

		const offsetPaths = [];
		clipperOffset.Execute(offsetPaths, horizontalOffset * scale);

		if (offsetPaths.length === 0) {
			throw new Error("Clipper offset returned no results - try a smaller offset amount");
		}

		const offsetPath = offsetPaths[0];
		// Create unique name with short ID to avoid overwrites
		const shortId = Math.random().toString(36).substring(2, 6);
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + shortId;

		const newEntityData = offsetPath.map((pt, index) => {
			const worldX = pt.X / scale;
			const worldY = pt.Y / scale;
					
			// Determine elevation based on keepElevations setting
			let worldZ;
			if (keepElevations) {
				// Find closest original point to interpolate/maintain elevation
				let closestPoint = originalPoints[0];
				let minDist = Infinity;
				for (let i = 0; i < originalPoints.length; i++) {
					const dx = worldX - originalPoints[i].pointXLocation;
					const dy = worldY - originalPoints[i].pointYLocation;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < minDist) {
						minDist = dist;
						closestPoint = originalPoints[i];
					}
				}

				// Calculate target Z with delta
				let targetZ = parseFloat(closestPoint.pointZLocation) + parseFloat(zDelta);

				// Apply elevation limit if enabled
				if (limitElevation && projectionAngle !== 0) {
					if ((projectionAngle > 0 && targetZ > elevationLimit) || (projectionAngle < 0 && targetZ < elevationLimit)) {
						// Cap at elevation limit
						targetZ = elevationLimit;
					}
				}

				worldZ = targetZ;
			} else {
				// Use max elevation (first point's Z as reference)
				let targetZ = parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta);

				// Apply elevation limit if enabled
				if (limitElevation && projectionAngle !== 0) {
					if ((projectionAngle > 0 && targetZ > elevationLimit) || (projectionAngle < 0 && targetZ < elevationLimit)) {
						targetZ = elevationLimit;
					}
				}

				worldZ = targetZ;
			}
			
			return {
				entityName: newEntityName,
				entityType: originalEntity.entityType,
				pointID: index + 1,
				pointXLocation: worldX,
				pointYLocation: worldY,
				pointZLocation: worldZ,
				lineWidth: originalPoints[0].lineWidth || 1,
				color: color,
				closed: originalEntity.entityType === "poly",
				visible: true,
			};
		});

		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: originalEntity.entityType,
			data: newEntityData,
			visible: true,
		});

		console.log("Created offset entity:", newEntityName, "with", newEntityData.length, "points");
		console.log("  baseEntityName:", baseEntityName); // Debug log
		console.log("  Original Z:", originalPoints[0].pointZLocation);
		console.log("  Z Delta:", zDelta);
		console.log("  New Z:", parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta));

		return newEntityName;
	} catch (error) {
		console.error("Error in createOffsetEntity:", error);
		throw error;
	}
}

// Update performKADOffset to pass the priority mode
function performKADOffset(entity, params) {
	try {
		const results = [];

		for (let i = 1; i <= params.numberOfOffsets; i++) {
			const offsetAmount = params.baseAmount * i;

			const offsetEntity = createOffsetEntity(entity, offsetAmount, params.projectionAngle, params.color, i, params.handleCrossovers, params.priorityMode, params.originalEntityName, params.keepElevations, params.limitElevation, params.elevationLimit);

			if (offsetEntity) {
				results.push(offsetEntity);
			}
		}

		if (results.length > 0) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			drawData(allBlastHoles, selectedHole);

			updateStatusMessage("Created " + results.length + " offset(s) successfully");
			setTimeout(() => updateStatusMessage(""), 3000);
		} else {
			updateStatusMessage("Failed to create offsets - check parameters");
		}
	} catch (error) {
		console.error("Error in performKADOffset:", error);
		updateStatusMessage("Error creating offsets: " + error.message);
	}
}
// ================================
// OFFSET KAD FUNCTIONALITY - ENDED
// ================================

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - STARTED
// ================================

radiiHolesOrKADsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("radiiHolesOrKADsTool");

		// Get all selected entities (holes + KAD objects)
		const selectedEntities = getSelectedEntitiesForRadii();

		if (selectedEntities.length === 0) {
			// No entities selected, show message and deactivate tool
			showModalMessage("No Selection", "Please select holes or KAD entities first, then activate the Radii tool.", "info");
			this.checked = false;
			resetFloatingToolbarButtons("none");
			return;
		}

		// Show radii configuration popup
		showRadiiConfigPopup(selectedEntities);
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("");
	}
});

// Show radii configuration popup using FloatingDialog
// Show radii configuration popup using FloatingDialog
// ? VERBOSE REMOVAL COMMENT - showRadiiConfigPopup() removed
// Step 1) This function (291 lines, lines 15102-15392) was extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Function extracted: showRadiiConfigPopup() - Dialog for creating radii/circles around entities
// Step 5) Function is exposed globally via window.showRadiiConfigPopup in KADDialogs.js

function createRadiiFromSelectedEntitiesFixed(selectedEntities, params) {
	try {
		// Step 1: Update status message
		updateStatusMessage("Creating radii polygons for " + selectedEntities.length + " selected entities...");

		// Step 2: Convert selectedEntities to simple point coordinates
		const pointsForRadii = [];

		selectedEntities.forEach((entity) => {
			let pointCoords;

			if (entity.type === "hole") {
				// Step 3: For holes, use start or end location based on user choice
				if (params.useToeLocation) {
					pointCoords = {
						startXLocation: entity.endXLocation,
						startYLocation: entity.endYLocation,
						startZLocation: entity.endZLocation,
						endXLocation: entity.endXLocation,
						endYLocation: entity.endYLocation,
						endZLocation: entity.endZLocation,
					};
				} else {
					pointCoords = {
						startXLocation: entity.startXLocation,
						startYLocation: entity.startYLocation,
						startZLocation: entity.startZLocation,
						endXLocation: entity.startXLocation,
						endYLocation: entity.startYLocation,
						endZLocation: entity.startZLocation,
					};
				}
			} else {
				// Step 4: For KAD objects, use the single point coordinate (no start/end distinction)
				pointCoords = {
					startXLocation: entity.startXLocation,
					startYLocation: entity.startYLocation,
					startZLocation: entity.startZLocation,
					endXLocation: entity.startXLocation, // Same as start for KAD objects
					endYLocation: entity.startYLocation, // Same as start for KAD objects
					endZLocation: entity.startZLocation, // Same as start for KAD objects
				};
			}

			pointsForRadii.push(pointCoords);
		});

		console.log("üî• Calling getRadiiPolygons with " + pointsForRadii.length + " points:");
		console.log("   Rotation: " + params.rotationOffset + "¬∞, Starburst: " + params.starburstOffset * 100 + "%");
		pointsForRadii.forEach((point, index) => {
			console.log("  Point " + (index + 1) + ": (" + point.startXLocation + ", " + point.startYLocation + ", " + point.startZLocation + ")");
		});

		// Step 5: Use existing getRadiiPolygons function with new rotation and starburst parameters
		const polygons = getRadiiPolygonsEnhanced(
			pointsForRadii,
			params.steps,
			params.radius,
			params.unionCircles,
			true, // addToMaps = true
			params.color,
			params.lineWidth,
			params.useToeLocation,
			params.rotationOffset,
			params.starburstOffset
		);

		console.log("‚úÖ getRadiiPolygonsEnhanced returned " + polygons.length + " polygon(s)");

		// Step 6: Update display and save
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedUpdateTreeView();

		// Step 7: Create success message
		const resultMessage = params.unionCircles ? "Unioned radii polygon created successfully." : polygons.length + " radii polygon(s) created successfully.";

		updateStatusMessage(resultMessage);

		// Step 8: Show success dialog using FloatingDialog
		showSuccessDialog(
			"Radii Creation Successful",
			`
            <div style="text-align: center;">
                <p><strong>` +
			resultMessage +
			`</strong></p>
                <p><strong>Input:</strong> ` +
			selectedEntities.length +
			` entities</p>
                <p><strong>Output:</strong> ` +
			polygons.length +
			` polygon(s)</p>
                <p><strong>Radius:</strong> ` +
			params.radius +
			`m</p>
                <p><strong>Rotation:</strong> ` +
			params.rotationOffset +
			`?</p>
                <p><strong>Starburst:</strong> ` +
			params.starburstOffset * 100 +
			`%</p>
                <p><strong>Line Width:</strong> ` +
			params.lineWidth +
			`</p>
                <p><strong>Location:</strong> ` +
			(params.useToeLocation ? "End/Toe" : "Start/Collar") +
			`</p>
                <p><strong>Zoom or scroll to see the results.</strong></p>
            </div>
        `
		);
	} catch (error) {
		// Step 9: Handle errors with FloatingDialog
		console.error("? Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");

		showErrorDialog(
			"Radii Creation Failed",
			`
            <div style="text-align: center;">
                <p><strong>Failed to create radii polygons.</strong></p>
                <hr style="border-color: #555; margin: 15px 0;">
                <p><strong>Error:</strong><br>` +
			(error.message || "Unknown error occurred") +
			`</p>
            </div>
        `
		);
	}
}

// Helper function to show success dialog using FloatingDialog
function showSuccessDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 300,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		},
	});

	dialog.show();
}

// Helper function to show error dialog using FloatingDialog
function showErrorDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;
	contentDiv.style.color = "#ff6b6b";

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 200,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		},
	});

	dialog.show();
}
// Get all selected entities for radii creation
function getSelectedEntitiesForRadii() {
	const selectedEntities = [];

	// Add selected holes (handle both single and multiple selection)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach((hole) => {
			selectedEntities.push({
				type: "hole",
				data: hole,
				startXLocation: hole.startXLocation,
				startYLocation: hole.startYLocation,
				startZLocation: hole.startZLocation,
				endXLocation: hole.endXLocation,
				endYLocation: hole.endYLocation,
				endZLocation: hole.endZLocation,
			});
		});
	} else if (selectedHole) {
		// Handle single selected hole
		selectedEntities.push({
			type: "hole",
			data: selectedHole,
			startXLocation: selectedHole.startXLocation,
			startYLocation: selectedHole.startYLocation,
			startZLocation: selectedHole.startZLocation,
			endXLocation: selectedHole.endXLocation,
			endYLocation: selectedHole.endYLocation,
			endZLocation: selectedHole.endZLocation,
		});
	}

	// Add selected KAD object (singular) - with comprehensive debugging
	if (selectedKADObject) {
		console.log("üîç Processing selectedKADObject:", selectedKADObject);

		// Check if data exists and is an array
		if (selectedKADObject.data && Array.isArray(selectedKADObject.data)) {
			console.log("üìä KAD object has data array with " + selectedKADObject.data.length + " items");

			if (selectedKADObject.entityType === "point") {
				// For points, use the point location
				selectedKADObject.data.forEach((point, index) => {
					console.log("üîµ Processing point " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_point",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly") {
				// For lines and polygons, use each vertex
				selectedKADObject.data.forEach((point, index) => {
					console.log("üìç Processing vertex " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_vertex",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "text") {
				// For text, use the text position
				selectedKADObject.data.forEach((textPoint, index) => {
					console.log("üìù Processing text " + (index + 1) + ":", textPoint);
					selectedEntities.push({
						type: "kad_text",
						data: selectedKADObject,
						startXLocation: textPoint.pointXLocation,
						startYLocation: textPoint.pointYLocation,
						startZLocation: textPoint.pointZLocation || 0,
						endXLocation: textPoint.pointXLocation,
						endYLocation: textPoint.pointYLocation,
						endZLocation: textPoint.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "circle") {
				// For circles, use the center point
				selectedKADObject.data.forEach((circlePoint, index) => {
					console.log("‚≠ï Processing circle " + (index + 1) + ":", circlePoint);
					selectedEntities.push({
						type: "kad_circle",
						data: selectedKADObject,
						startXLocation: circlePoint.pointXLocation,
						startYLocation: circlePoint.pointYLocation,
						startZLocation: circlePoint.pointZLocation || 0,
						endXLocation: circlePoint.pointXLocation,
						endYLocation: circlePoint.pointYLocation,
						endZLocation: circlePoint.pointZLocation || 0,
					});
				});
			}
		} else {
			// Alternative approach - try to extract from selectedKADObject itself
			console.warn("?? KAD object doesn't have proper data array, trying alternative extraction");
			console.log("KAD Object structure:", selectedKADObject);

			// Check if it's stored in allKADDrawingsMap
			if (selectedKADObject.entityName) {
				const entity = allKADDrawingsMap.get(selectedKADObject.entityName);
				if (entity && entity.data && Array.isArray(entity.data)) {
					console.log("‚úÖ Found entity in allKADDrawingsMap with " + entity.data.length + " points");

					entity.data.forEach((point, index) => {
						console.log("üîÑ Processing entity point " + (index + 1) + ":", point);
						selectedEntities.push({
							type: "kad_entity_point",
							data: entity,
							startXLocation: point.pointXLocation,
							startYLocation: point.pointYLocation,
							startZLocation: point.pointZLocation || 0,
							endXLocation: point.pointXLocation,
							endYLocation: point.pointYLocation,
							endZLocation: point.pointZLocation || 0,
						});
					});
				}
			}

			// Last resort - use selectedKADObject directly if it has coordinates
			if (selectedEntities.length === 0 && selectedKADObject.pointXLocation !== undefined && selectedKADObject.pointYLocation !== undefined) {
				console.log("üÜò Using fallback direct coordinates");
				selectedEntities.push({
					type: "kad_fallback",
					data: selectedKADObject,
					startXLocation: selectedKADObject.pointXLocation,
					startYLocation: selectedKADObject.pointYLocation,
					startZLocation: selectedKADObject.pointZLocation || 0,
					endXLocation: selectedKADObject.pointXLocation,
					endYLocation: selectedKADObject.pointYLocation,
					endZLocation: selectedKADObject.pointZLocation || 0,
				});
			}
		}
	}

	console.log("üéØ Final selectedEntities array has " + selectedEntities.length + " entities:");
	selectedEntities.forEach((entity, index) => {
		console.log("  " + (index + 1) + ". " + entity.type + " at (" + entity.startXLocation + ", " + entity.startYLocation + ", " + entity.startZLocation + ")");
	});

	return selectedEntities;
}

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - ENDED
// ================================

// ================================
// DRAW BLAST BOUNDARY FUNCTIONALITY - STARTED
// ================================

function drawBlastBoundary(polygon, strokeColor) {
	//convert wold coords to screen cords
	const screenCoords = polygon.map((point) => {
		const x = (point.x - centroidX) * currentScale + canvas.width / 2;
		const y = (-point.y + centroidY) * currentScale + canvas.height / 2;
		return {
			x,
			y,
		};
	});

	ctx.beginPath();
	ctx.moveTo(screenCoords[0].x, screenCoords[0].y);
	for (let i = 1; i < screenCoords.length; i++) {
		ctx.lineTo(screenCoords[i].x, screenCoords[i].y);
	}
	ctx.closePath();
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 2;
	ctx.stroke();
}

function offsetPolygonMathematical(polygon, offset) {
	const result = [];
	const n = polygon.length;
	const quadrantRads = [];

	for (let i = 0; i < n; i++) {
		const dx = polygon[(i + 1) % n].x - polygon[i].x;
		const dy = polygon[(i + 1) % n].y - polygon[i].y;
		const dist = Math.sqrt(dx * dx + dy * dy);

		let angle = 0;
		if (dist > 0) {
			if (dy >= 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.asin(dx / dist);
			} else if (dy < 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.acos(dy / dist);
			} else if (dy < 0 && dx < 0) {
				angle = (3 * Math.PI) / 2 - Math.asin(-dx / dist);
			} else {
				angle = (3 * Math.PI) / 2 - Math.acos(-dy / dist);
			}
		}
		quadrantRads.push(angle);
	}

	const offsetSegments = [];
	for (let i = 0; i < n; i++) {
		const theta = quadrantRads[i];
		const dx = offset * -Math.sin(theta);
		const dy = offset * Math.cos(theta);

		const p1 = {
			x: polygon[i].x + dx,
			y: polygon[i].y + dy,
		};
		const p2 = {
			x: polygon[(i + 1) % n].x + dx,
			y: polygon[(i + 1) % n].y + dy,
		};
		offsetSegments.push([p1, p2]);
	}

	for (let i = 0; i < n; i++) {
		const [p1a, p1b] = offsetSegments[i];
		const [p2a, p2b] = offsetSegments[(i + 1) % n];

		const denom = -(p2b.x - p2a.x) * -Math.sin(quadrantRads[i]) - Math.cos(quadrantRads[i]) * (p2b.y - p2a.y);

		if (denom === 0) {
			result.push(p1b); // fallback
			continue;
		}

		const s = Math.cos(quadrantRads[(i + 1) % n]) * (p2b.y - p2a.y) - (p2b.x - p2a.x) * Math.sin(quadrantRads[(i + 1) % n]);
		const t = s / denom;

		const x = p1b.x + Math.cos(quadrantRads[i]) * t;
		const y = p1b.y + Math.sin(quadrantRads[i]) * t;
		result.push({
			x: x,
			y: y,
		});
	}

	return result;
}

// FIXED: Much faster getAverageDistance function
function getAverageDistance(points) {
	if (!points || !Array.isArray(points) || points.length < 2) return 1;

	// For large datasets, use sampling to avoid O(n?) performance
	if (points.length > 1000) {
		// Sample every Nth point to keep it manageable
		const sampleSize = Math.min(500, Math.floor(points.length / 10));
		const step = Math.floor(points.length / sampleSize);
		const sampledPoints = [];

		for (let i = 0; i < points.length; i += step) {
			sampledPoints.push(points[i]);
		}

		// Use the sampled points for calculation
		return getAverageDistanceSmall(sampledPoints);
	}

	// For small datasets, use the original algorithm
	return getAverageDistanceSmall(points);
}

// Helper function for small datasets
function getAverageDistanceSmall(points) {
	let total = 0;
	let count = 0;

	for (let i = 0; i < points.length; i++) {
		let minDist = Infinity;

		for (let j = 0; j < points.length; j++) {
			if (i === j) continue;

			const dx = points[i].startXLocation - points[j].startXLocation;
			const dy = points[i].startYLocation - points[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);

			if (dist < minDist) {
				minDist = dist;
			}
		}

		if (minDist < Infinity) {
			total += minDist;
			count++;
		}
	}

	return count > 0 ? total / count : 1;
}

//=================================================
// Three.js Drawing Helper Functions
//=================================================

// Step 1) Helper - Convert RGB string to Three.js Color object
function rgbStringToThreeColor(rgbString) {
	// Parse "rgb(r, g, b)" string
	const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
	if (match) {
		const r = parseInt(match[1]) / 255;
		const g = parseInt(match[2]) / 255;
		const b = parseInt(match[3]) / 255;
		return { r: r, g: g, b: b };
	}
	return { r: 1, g: 1, b: 1 }; // Default white
}

// Note: Three.js drawing functions moved to src/draw/canvas3DDrawing.js

//=================================================
// End Three.js Drawing Helper Functions
//=================================================

/*** CODE TO DRAW POINTS FROM KAD DATA ***/
//Draws an open poly line from the kadLinesArray

function drawAllKADSelectionVisuals() {
	console.log("Drawing selections - single:", selectedKADObject ? 1 : 0, "multiple:", selectedMultipleKADObjects.length); // DEBUG - ADD THIS LINE
	// Handle single selection
	if (isSelectionPointerActive && selectedKADObject) {
		if (selectedKADObject.entityType === "circle") {
			// Highlight circles with a ring
			drawCircleSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "text") {
			// Highlight text with a box
			drawTextSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "point") {
			// Highlight points with a larger circle
			drawPointSelection(selectedKADObject);
		} else {
			// Use existing polygon selection for lines/polygons
			drawKADPolyUnified(selectedKADObject);
		}
	}

	// Handle multiple selections - use the same style as single selection
	if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		selectedMultipleKADObjects.forEach((kadObj) => {
			const entity = allKADDrawingsMap.get(kadObj.entityName);
			if (entity) {
				// Use the same selection functions for each selected object
				if (entity.entityType === "circle") {
					drawCircleSelection(entity);
				} else if (entity.entityType === "text") {
					drawTextSelection(entity);
				} else if (entity.entityType === "point") {
					drawPointSelection(entity);
				} else if (entity.entityType === "poly" || entity.entityType === "line") {
					// Use the same polygon/line selection drawing
					drawKADPolyUnified(entity.data);
				}
			}
		});
	}
}
// Unified drawing function for both lines and polygons
function drawKADPolyUnified(points) {
	if (points.length < 1) return;

	let currentPath = [];

	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		currentPath.push(point);

		// Check if this is the end of a path (closed or last point)
		const isLastPoint = i === points.length - 1;
		const isClosedPolygon = point.closed === true;

		if (isLastPoint || isClosedPolygon) {
			// Draw the accumulated path
			if (currentPath.length === 1) {
				// Single point - draw as dot
				const [x, y] = worldToCanvas(currentPath[0].pointXLocation, currentPath[0].pointYLocation);
				drawKADPoints(x, y, currentPath[0].pointZLocation, currentPath[0].color);
			} else if (currentPath.length >= 2) {
				// Multiple points - draw as polyline/polygon
				drawPolyPath(currentPath, isClosedPolygon);
			}

			// Reset for next path
			currentPath = [];
		}
	}
}

// Helper function to draw a path of connected points
function drawPolyPath(pathPoints, closed) {
	if (pathPoints.length < 2) return;

	const lineWidth = pathPoints[0].lineWidth || 1;
	const strokeColor = pathPoints[0].color || "#FF0000";

	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = lineWidth;
	ctx.beginPath();

	// Start at first point
	const [startX, startY] = worldToCanvas(pathPoints[0].pointXLocation, pathPoints[0].pointYLocation);
	ctx.moveTo(startX, startY);

	// Draw to subsequent points
	for (let i = 1; i < pathPoints.length; i++) {
		const [x, y] = worldToCanvas(pathPoints[i].pointXLocation, pathPoints[i].pointYLocation);
		ctx.lineTo(x, y);
	}

	// Close if it's a polygon
	if (closed) {
		ctx.closePath();
	}

	ctx.stroke();
}

// Add this to your drawData function
function drawPolygonSelection(ctx) {
	if (!isPolygonSelectionActive || polyPointsX.length < 2) return;

	ctx.beginPath();
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		if (i === 0) {
			ctx.moveTo(x, y);
		} else {
			ctx.lineTo(x, y);
		}
	}

	// Close the polygon by connecting back to first point
	if (polyPointsX.length >= 2) {
		const [firstX, firstY] = worldToCanvas(polyPointsX[0], polyPointsY[0]);
		ctx.lineTo(firstX, firstY);
	}

	ctx.strokeStyle = "rgba(200, 0, 200, 0.5)";
	ctx.lineWidth = 1;
	ctx.stroke();

	// Draw vertices
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		ctx.beginPath();
		ctx.arc(x, y, 4, 0, Math.PI * 2);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.fill();
	}
}

// Enhanced KAD preview function - FIXED VERSION
function drawKADPreviewLine(ctx) {
	// Check which tools are active
	const isPointActive = addPointDraw.checked;
	const isLineActive = addLineDraw.checked;
	const isCircleActive = addCircleDraw.checked;
	const isPolyActive = addPolyDraw.checked;
	const isTextActive = addTextDraw.checked;
	// const isPolygonSelectionActive_local = isPolyActive;

	const anyToolActive = isPointActive || isLineActive || isCircleActive || isPolyActive || isTextActive; // || isPolygonSelectionActive_local;

	if (!anyToolActive) return;

	// Skip if mouse is at origin (not moved yet)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	let previewStartX = null;
	let previewStartY = null;
	let previewColor = "rgba(255, 255, 255, 0.7)"; // Default white
	let previewStyle = [5, 5]; // Default dash pattern
	let shouldDraw = false;

	// Handle polygon selection first (it has its own tracking)
	if (isPolyActive && polyPointsX.length > 0) {
		previewStartX = polyPointsX[polyPointsX.length - 1];
		previewStartY = polyPointsY[polyPointsY.length - 1];
		previewColor = "rgba(255, 0, 255, 0.7)"; // Magenta for polygon selection
		previewStyle = [5, 5];
		shouldDraw = true;
	}
	// For other tools, use lastKADDrawPoint if available and actively drawing
	else if (lastKADDrawPoint && createNewEntity === false) {
		previewStartX = lastKADDrawPoint.x;
		previewStartY = lastKADDrawPoint.y;
		shouldDraw = true;

		// Set colors and styles for different tools
		if (isLineActive) {
			previewColor = "rgba(0, 255, 255, 0.7)"; // Cyan for lines
			previewStyle = [8, 4];
		} else if (isCircleActive) {
			previewColor = "rgba(255, 165, 0, 0.7)"; // Orange for circles
			previewStyle = [6, 3];
		} else if (isPointActive) {
			previewColor = "rgba(209, 0, 0, 0.8)"; // Red for points
			previewStyle = [4, 2];
		} else if (isTextActive) {
			previewColor = "rgba(0, 255, 0, 0.7)"; // Green for text
			previewStyle = [10, 5];
		} else if (isPolyActive) {
			previewColor = "rgba(215, 0, 215, 0.7)"; // Purple for polygons
			previewStyle = [7, 3];
		}
	}

	// Show tool indicators for ALL active tools (even if no previous point)
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	if (isPointActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(209, 0, 0, 0.8)"; // Purple for points
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var pointDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var pointBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(pointDist, pointBearing, "point", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isCircleActive) {
		ctx.beginPath();
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var circleDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var circleBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(circleDist, circleBearing, "circle", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, parseFloat(circleRadius.value) * currentScale, 0, Math.PI * 2);
		// // Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		//color of the circle to be drawn
		ctx.fillStyle = getJSColorHexDrawing() + "4D"; // Drawing color at 30% opacity
		ctx.fill();
	} else if (isTextActive) {
		// Show crosshair for Text tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 255, 0, 0.6)"; // Green for Text
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var textDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var textBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(textDist, textBearing, "text", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isLineActive) {
		// Show crosshair for line tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 207, 207, 0.8)"; // Cyan for lines
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var lineDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var lineBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(lineDist, lineBearing, "line", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
		//ctx.setLineDash([]);
	} else if (isPolyActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(215, 0, 215, 0.6)"; // Purple for polygons
		ctx.lineWidth = 2;
		// Show for polygon tool
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var polyDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var polyBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(polyDist, polyBearing, "poly", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);

		ctx.stroke();
	}

	// Draw preview line if we have a start point
	if (shouldDraw) {
		const [startCanvasX, startCanvasY] = worldToCanvas(previewStartX, previewStartY);

		// Draw the preview line
		ctx.beginPath();
		ctx.setLineDash(previewStyle);
		ctx.strokeStyle = previewColor;
		ctx.lineWidth = 2;
		ctx.moveTo(startCanvasX, startCanvasY);
		ctx.lineTo(mouseCanvasX, mouseCanvasY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Draw a small indicator at the start point
		ctx.beginPath();
		ctx.arc(startCanvasX, startCanvasY, 3, 0, Math.PI * 2);
		ctx.fillStyle = previewColor;
		ctx.fill();
	}
}
// Function to update the last KAD draw point when user draws something
function updateLastKADDrawPoint(x, y, z) {
	lastKADDrawPoint = {
		x: x,
		y: y,
		z: z,
	};
}
// Simplified test version of the KAD preview function
function drawKADTESTPreviewLine(ctx) {
	// Simple test: just check if any tool is active and draw a line
	const anyToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked || isPolygonSelectionActive;

	if (!anyToolActive) return;

	// Use mouse coordinates (they're 0 by default, not null)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	// For testing, let's always use the center of the canvas as start point
	const testStartX = centroidX;
	const testStartY = centroidY;

	// Convert to canvas coordinates
	const [startCanvasX, startCanvasY] = worldToCanvas(testStartX, testStartY);
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	// Draw a bright red test line
	ctx.beginPath();
	ctx.setLineDash([10, 10]);
	ctx.strokeStyle = "rgba(255, 0, 0, 1.0)"; // Bright red
	ctx.lineWidth = 3;
	ctx.moveTo(startCanvasX, startCanvasY);
	ctx.lineTo(mouseCanvasX, mouseCanvasY);
	ctx.stroke();
	ctx.setLineDash([]);

	// Draw a circle at mouse position for debugging
	ctx.beginPath();
	ctx.arc(mouseCanvasX, mouseCanvasY, 5, 0, Math.PI * 2);
	ctx.fillStyle = "rgba(255, 0, 0, 1.0)";
	ctx.fill();
}

// Fix the drawKADCircles function around line 6450:
// Also update the drawKADTexts function to handle multiline calculations
/*** CODE TO DRAW POINTS FROM CSV DATA ***/

// Note: drawHexagon moved to src/draw/canvas2DDrawing.js

// Note: drawMultilineText moved to src/draw/canvas2DDrawing.js

// Note: drawDirectionArrow moved to src/draw/canvas2DDrawing.js

// Note: drawArrow moved to src/draw/canvas2DDrawing.js

// Note: drawArrowDelayText moved to src/draw/canvas2DDrawing.js
function drawDelauanySlopeMap(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.fillStyle = fillColor;
	ctx.lineWidth = 1;
	console.log("drawDelauanySlopeMap: " + triangles.length);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		const edge1 = {
			x: tBX - tAX,
			y: tBY - tAY,
			z: tBZ - tAZ,
		};
		const edge2 = {
			x: tCX - tAX,
			y: tCY - tAY,
			z: tCZ - tAZ,
		};
		const edge3 = {
			x: tCX - tBX,
			y: tCY - tBY,
			z: tCZ - tBZ,
		};

		// Calculate the maximum absolute slope angle for this triangle
		//const slopeAngles = [Math.abs(getEdgeSlopeAngle(triangle[0], triangle[1])), Math.abs(getEdgeSlopeAngle(triangle[1], triangle[2])), Math.abs(getEdgeSlopeAngle(triangle[2], triangle[0]))];
		//let maxSlopeAngle = Math.max(...slopeAngles);

		let maxSlopeAngle = getDipAngle(triangle);

		// Create a triangle array
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aAZ = tAZ;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aBZ = tBZ;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;
		const aCZ = tCZ;

		// Define the minimum and maximum RGB values (rgb(50, 50, 50) and rgb(200, 200, 200))
		const minRGB = [225, 225, 225];
		const maxRGB = [100, 100, 100];

		// Calculate the RGB values based on maxSlopeAngle using linear interpolation
		const r = Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const g = Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const b = Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		const ir = 255 - Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const ig = 255 - Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const ib = 255 - Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		// Define the color ranges and corresponding RGB values
		let triangleFillColor;
		if (maxSlopeAngle >= 0 && maxSlopeAngle < 5) {
			// Cornflower blue for angles in the range [0, 4)
			triangleFillColor = "rgb(51, 139, 255)";
		} else if (maxSlopeAngle >= 5 && maxSlopeAngle < 7) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 102, 204)";
		} else if (maxSlopeAngle >= 7 && maxSlopeAngle < 9) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 204, 204)";
		} else if (maxSlopeAngle >= 9 && maxSlopeAngle < 12) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(102, 204, 0)";
		} else if (maxSlopeAngle >= 12 && maxSlopeAngle < 15) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(204, 204, 0)";
		} else if (maxSlopeAngle >= 15 && maxSlopeAngle < 17) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 128, 0)";
		} else if (maxSlopeAngle >= 17 && maxSlopeAngle < 20) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 0, 0)";
		} else {
			// Default to grey for all other angles
			triangleFillColor = "rgb(153, 0, 76)";
		}

		// Combine the calculated RGB values into the final fill color
		// triangleFillColor = `rgb(${r}, ${g}, ${b})`;
		const triangleStrokeColor = `rgb(${r}, ${g}, ${b})`;
		// Invert the color by subtracting each channel value from 255
		const invertedColor = `rgb(${ir}, ${ig}, ${ib})`;

		ctx.strokeStyle = triangleStrokeColor;
		ctx.fillStyle = triangleFillColor;
		ctx.lineWidth = 1;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();

		ctx.lineWidth = 1;
	}
}

function drawDelauanyBurdenRelief(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 1;
	//console.log("drawDelauanyBurdenRelief: " + triangles.length);
	// const reliefResults = delaunayContourBurdenRelief(triangles, 20, 0);
	// console.log("Relief Results:", reliefResults);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		// Find the earliest and latest times
		const earliestTime = Math.min(tAZ, tBZ, tCZ);
		const latestTime = Math.max(tAZ, tBZ, tCZ);

		// Calculate the time difference
		const timeDifference = latestTime - earliestTime; // ms

		// Determine which points correspond to the earliest and latest times
		let p1, p2;
		if (earliestTime === tAZ) {
			p1 = {
				x: tAX,
				y: tAY,
			};
		} else if (earliestTime === tBZ) {
			p1 = {
				x: tBX,
				y: tBY,
			};
		} else {
			p1 = {
				x: tCX,
				y: tCY,
			};
		}

		if (latestTime === tAZ) {
			p2 = {
				x: tAX,
				y: tAY,
			};
		} else if (latestTime === tBZ) {
			p2 = {
				x: tBX,
				y: tBY,
			};
		} else {
			p2 = {
				x: tCX,
				y: tCY,
			};
		}

		// Calculate the distance between the two points (earliest and latest)
		const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

		// Calculate burden relief in ms/m
		const burdenRelief = timeDifference / distance;

		//console.log("Time Difference (ms):", timeDifference);
		//console.log("Distance (m):", distance);
		//console.log("Burden Relief (ms/m):", burdenRelief);

		// Color mapping based on timing relief (adjust values as needed)
		let triangleFillColor;
		if (burdenRelief < 4) {
			triangleFillColor = "rgb(75, 20, 20)"; // fast
		} else if (burdenRelief < 7) {
			triangleFillColor = "rgb(255, 40, 40)";
		} else if (burdenRelief < 10) {
			triangleFillColor = "rgb(255, 120, 50)"; //
		} else if (burdenRelief < 13) {
			triangleFillColor = "rgb(255, 255, 50)"; //
		} else if (burdenRelief < 16) {
			triangleFillColor = "rgb(50, 255, 70)"; //
		} else if (burdenRelief < 19) {
			triangleFillColor = "rgb(50, 255, 200)"; //
		} else if (burdenRelief < 22) {
			triangleFillColor = "rgb(50, 230, 255)"; //
		} else if (burdenRelief < 25) {
			triangleFillColor = "rgb(50, 180, 255)"; //
		} else if (burdenRelief < 30) {
			triangleFillColor = "rgb(50, 100, 255)"; // Blue
		} else if (burdenRelief < 40) {
			triangleFillColor = "rgb(0, 0, 180)"; // Navy (actual dark blue)
		} else {
			triangleFillColor = "rgb(75, 0, 150)"; // Purple - slow
		}

		ctx.fillStyle = triangleFillColor;

		// Draw triangle
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	}
}

function drawReliefLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function

	const legend0to4 = "rgb(75, 20, 20)"; // fast
	const legend4to7 = "rgb(255, 40, 40)";
	const legend7to10 = "rgb(255, 120, 50)"; //
	const legend10to13 = "rgb(255, 255, 50)"; //
	const legend13to16 = "rgb(50, 255, 70)"; //
	const legend16to19 = "rgb(50, 255, 200)"; //
	const legend19to22 = "rgb(50, 230, 255)"; //
	const legend22to25 = "rgb(50, 180, 255)"; //
	const legend25to30 = "rgb(50, 100, 255)"; //
	const legend30to40 = "rgb(50, 0, 255)"; //
	const legend40above = "rgb(75, 0, 150)"; // slow

	//draw the legend
	ctx.beginPath();
	ctx.fill();

	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Relief", 10, canvas.height / 2 - 70);
	ctx.fillText("0ms/m - 4ms/m", 10, canvas.height / 2 - 40);
	ctx.fillText("4ms/m - 7ms/m", 10, canvas.height / 2 - 10);
	ctx.fillText("7ms/m - 10ms/m", 10, canvas.height / 2 + 20);
	ctx.fillText("10ms/m - 13ms/m", 10, canvas.height / 2 + 50);
	ctx.fillText("13ms/m - 16ms/m", 10, canvas.height / 2 + 80);
	ctx.fillText("16ms/m - 19ms/m", 10, canvas.height / 2 + 110);
	ctx.fillText("19ms/m - 22ms/m", 10, canvas.height / 2 + 140);
	ctx.fillText("22ms/m - 25ms/m", 10, canvas.height / 2 + 170);
	ctx.fillText("25ms/m - 30ms/m", 10, canvas.height / 2 + 200);
	ctx.fillText("30ms/m - 40ms/m", 10, canvas.height / 2 + 230);
	ctx.fillText("40ms/m above", 10, canvas.height / 2 + 260);
	ctx.fillStyle = legend0to4;
	ctx.fillRect(130, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend4to7;
	ctx.fillRect(130, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to10;
	ctx.fillRect(130, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend10to13;
	ctx.fillRect(130, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend13to16;
	ctx.fillRect(130, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend16to19;
	ctx.fillRect(130, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend19to22;
	ctx.fillRect(130, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend22to25;
	ctx.fillRect(130, canvas.height / 2 + 155, 20, 20);
	ctx.fillStyle = legend25to30;
	ctx.fillRect(130, canvas.height / 2 + 185, 20, 20);
	ctx.fillStyle = legend30to40;
	ctx.fillRect(130, canvas.height / 2 + 215, 20, 20);
	ctx.fillStyle = legend40above;
	ctx.fillRect(130, canvas.height / 2 + 245, 20, 20);
	ctx.stroke();
}

function drawTriangleAngleText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let maxSlopeAngle = getDipAngle(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(maxSlopeAngle).toFixed(1), strokeColor);
}

function drawTriangleBurdenReliefText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let burdenRelief = getBurdenRelief(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(burdenRelief).toFixed(1), strokeColor);
}

function getAngleBetweenEdges(edge1, edge2) {
	const dotProduct = edge1.x * edge2.x + edge1.y * edge2.y + edge1.z * edge2.z;
	const magEdge1 = Math.sqrt(edge1.x * edge1.x + edge1.y * edge1.y + edge1.z * edge1.z);
	const magEdge2 = Math.sqrt(edge2.x * edge2.x + edge2.y * edge2.y + edge2.z * edge2.z);
	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero

	if (Math.abs(magEdge1) < epsilon || Math.abs(magEdge2) < epsilon) {
		// Handle the case where either edge is degenerate (magnitude close to zero)
		return 0;
	}

	let angle = Math.acos(dotProduct / (magEdge1 * magEdge2));
	return (angle * 180) / Math.PI;
}

function calculateTriangleCentroid(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];

	const triangleCentroid = {
		x: (tAX + tBX + tCX) / 3,
		y: (tAY + tBY + tCY) / 3,
		z: (tAZ + tBZ + tCZ) / 3,
	};
	return triangleCentroid;
}

function getDipAngle(triangle) {
	const edge1 = [triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]];
	const edge2 = [triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]];

	// Calculate the normal vector of the triangle's plane
	const normalVector = [edge1[1] * edge2[2] - edge1[2] * edge2[1], edge1[2] * edge2[0] - edge1[0] * edge2[2], edge1[0] * edge2[1] - edge1[1] * edge2[0]];

	// Calculate the dot product with the vertical direction (0, 0, 1)
	const dotProduct = normalVector[0] * 0 + normalVector[1] * 0 + normalVector[2] * 1;
	const magNormal = Math.sqrt(normalVector[0] ** 2 + normalVector[1] ** 2 + normalVector[2] ** 2);

	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero
	if (Math.abs(magNormal) < epsilon) {
		// Handle degenerate case
		return 0;
	}

	const angleRadians = Math.acos(dotProduct / magNormal);
	const angleDegrees = (angleRadians * 180) / Math.PI;

	// Calculate the dip angle between the dot product and the horizontal plane (0 degrees)
	const dipAngle = 180 - angleDegrees;

	return dipAngle;
}

function getEdgeSlopeAngle(p1, p2) {
	const dx = p2[0] - p1[0];
	const dy = p2[1] - p1[1];
	const dz = p2[2] - p1[2]; // Consider the z-axis difference for vertical deviation
	const slopeAngleRadians = Math.atan2(dz, Math.sqrt(dx * dx + dy * dy));
	const slopeAngleDegrees = (slopeAngleRadians * 180) / Math.PI;
	return slopeAngleDegrees;
}

function getAngleBetweenPoints(p1, p2) {
	// Calculate the inferred point p3
	const p3 = [p1[0], p1[1], p2[2]];

	// Calculate the edges
	const edge1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
	const edge2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];

	// Calculate the angle between the edges
	const angleRadians = Math.acos((edge1[0] * edge2[0] + edge1[1] * edge2[1] + edge1[2] * edge2[2]) / (vectorMagnitude(edge1) * vectorMagnitude(edge2)));

	// Convert the angle to degrees
	const angleDegrees = (angleRadians * 180) / Math.PI;

	return angleDegrees;
}

function vectorMagnitude(vector) {
	return Math.sqrt(vector[0] ** 2 + vector[1] ** 2 + vector[2] ** 2);
}

function getBurdenRelief(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];
	// Find the earliest and latest times
	const earliestTime = Math.min(tAZ, tBZ, tCZ);
	const latestTime = Math.max(tAZ, tBZ, tCZ);

	// Calculate the time difference
	const timeDifference = latestTime - earliestTime; // ms

	// Determine which points correspond to the earliest and latest times
	let p1, p2;
	if (earliestTime === tAZ) {
		p1 = {
			x: tAX,
			y: tAY,
		};
	} else if (earliestTime === tBZ) {
		p1 = {
			x: tBX,
			y: tBY,
		};
	} else {
		p1 = {
			x: tCX,
			y: tCY,
		};
	}

	if (latestTime === tAZ) {
		p2 = {
			x: tAX,
			y: tAY,
		};
	} else if (latestTime === tBZ) {
		p2 = {
			x: tBX,
			y: tBY,
		};
	} else {
		p2 = {
			x: tCX,
			y: tCY,
		};
	}

	// Calculate the distance between the two points (earliest and latest)
	const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

	// Calculate burden relief in ms/m
	const burdenRelief = timeDifference / distance;

	//console.log("Time Difference (ms):", timeDifference);
	//console.log("Distance (m):", distance);
	//console.log("Burden Relief (ms/m):", burdenRelief);
	return burdenRelief;
}

function drawMousePosition(x, y) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	ctx.rect(x - 7, y - 7, 14, 14);
	ctx.lineWidth = 1;
	ctx.stroke();
}
//-------------------------SELECTION OF BLAST HOLES----------------------//
function getClickedHole(clickX, clickY) {
	// Step 2a) Only process 2D selection when 2D canvas is active
	if (onlyShowThreeJS) {
		// 3D mode is active, don't process 2D selection
		return null;
	}

	// Add null check at the very beginning
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null; // No holes to check
	}

	// Adjust the click coordinates based on the current scale and centroid
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY; // Invert the Y-coordinate
	// Calculate the distance threshold based on the scale factor

	//Create a constant called thresold set it to  (10/(currentScale/2).  If the value of thresold is less than 0.1 then set it to 0.1 else if it is greater than 2 set it to 2 else set it to 10/currentScale/2
	let threshold = 10 / (currentScale / 2);
	if (threshold > 0.2 && threshold <= 1.5) {
		10 / (currentScale / 2);
	} else if (threshold > 1.5) {
		threshold = 1.5;
	} else if (threshold < 0.2) {
		threshold = 0.2;
	}

	//keep an existing selection while the Move tool is active
	if (!isMultiHoleSelectionEnabled && !isMoveToolActive) {
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}

	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ? CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;
		let holeX = hole.startXLocation;
		let holeY = hole.startYLocation;
		let currentEntity = hole.entity;

		let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));
		if (distance > threshold) {
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Reset the selected hole ID
		}
	}
	if (isAddingConnector || isAddingMultiConnector) {
		// Loop through the points array to find the clicked hole
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			// Calculate the distance between the clicked point and the hole
			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			// Check if the distance is within the threshold
			if (distance <= threshold) {
				//Remove this if statement if the if & if else doesn't work
				if (firstSelectedHole == null) {
					firstSelectedHole = hole;
					secondSelectedHole = null;
				} else if (secondSelectedHole == null && firstSelectedHole != hole && hole != null) {
					secondSelectedHole = hole;
					firstSelectedHole = null;
				} else {
					firstSelectedHole = null;
					secondSelectedHole = hole;
				}
				return hole; // Return the clicked hole
			}
		}
		//calculateTimes(points);
	} else if (!isMultiHoleSelectionEnabled && isMeasureRecording) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID

				//

				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
	}
	//! IMPORTANT alway check if the bool needs to be put here for drawing to work.
	else if (!isMultiHoleSelectionEnabled && (isSelectionPointerActive || isPolygonSelectionActive || isHoleEditing || isLengthPopupEditing || isDeletingHole || isTypeEditing || isBlastNameEditing || isBearingToolActive || isMoveToolActive)) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;
			let holeXEnd = hole.endXLocation;
			let holeYEnd = hole.endYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID
				// Update slider attributes here
				let holeNorthingSlider = document.getElementById("holeNorthingSlider");
				let holeEastingSlider = document.getElementById("holeEastingSlider");
				let holeElevationSlider = document.getElementById("holeElevationSlider");
				let holeLengthSlider = document.getElementById("holeLengthSlider");
				let holeDiameterSlider = document.getElementById("holeDiameterSlider");
				let holeAngleSlider = document.getElementById("holeAngleSlider");
				let holeBearingSlider = document.getElementById("holeBearingSlider");
				let holeSubdrillSlider = document.getElementById("holeSubdrillSlider");

				// Update slider attributes here

				holeEastingSlider.min = hole.startXLocation - 20;
				holeEastingSlider.max = hole.startXLocation + 20;
				holeEastingSlider.step = 0.1;

				holeNorthingSlider.min = hole.startYLocation - 20;
				holeNorthingSlider.max = hole.startYLocation + 20;
				holeNorthingSlider.step = 0.1;
				// Update slider attributes here

				holeElevationSlider.min = hole.startZLocation - 20;
				holeElevationSlider.max = hole.startZLocation + 20;
				holeElevationSlider.step = 0.1;

				//Length
				holeLengthSlider.step = 0.1;

				// Update slider attributes here
				holeAngleSlider.step = 1;

				// Update slider attributes here
				holeDiameterSlider.step = 1;

				// Update slider attributes here
				holeBearingSlider.step = 0.5;
				holeSubdrillSlider.step = 0.1;

				holeEastingSlider.value = hole.startXLocation;
				holeNorthingSlider.value = hole.startYLocation;
				holeElevationSlider.value = hole.startZLocation;
				holeLengthSlider.value = hole.holeLengthCalculated;
				holeDiameterSlider.value = hole.holeDiameter;
				holeAngleSlider.value = hole.holeAngle;
				holeBearingSlider.value = hole.holeBearing;
				holeSubdrillSlider.value = hole.subdrillAmount;

				holeEastingLabel.textContent = "Hole Easting (X) : " + parseFloat(hole.startXLocation).toFixed(2) + "mE";
				holeNorthingLabel.textContent = "Hole Northing (Y): " + parseFloat(hole.startYLocation).toFixed(2) + "mN";
				holeElevationLabel.textContent = "Hole Elevation (Z) : " + parseFloat(hole.startZLocation).toFixed(2) + "m";
				holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(hole.holeDiameter).toFixed(0) + "mm";
				holeLengthLabel.textContent = "Hole Length: " + parseFloat(hole.holeLengthCalculated).toFixed(1) + "m";
				holeAngleLabel.textContent = "Hole Angle: " + parseFloat(hole.holeAngle).toFixed(0) + "\u00B0";
				holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(hole.holeBearing).toFixed(1) + "\u00B0";
				holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(hole.subdrillAmount).toFixed(1) + "m";
				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
		if (isDisplayingContours) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}

			// directionArrows now contains the arrow data for later drawing
		}
		if (isDisplayingSlopeTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingReliefTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingDirectionArrows) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}
		}
		// If no hole is clicked or found within the threshold
		// Reset only the firstSelectedHole
		firstSelectedHole = null;
	}
	return null; // Return null if no hole is clicked
}
//------------------MULTIPLE SELECTION OF BLAST HOLES----------------------//
function getMultipleClickedHoles(clickX, clickY) {
	if (!isMultiHoleSelectionEnabled) {
		return selectedMultipleHoles || [];
	}

	// Prevent selection modification if called during a mouse move that's not intended to change selection
	if (isUpdatingSelectionFromMove) {
		return selectedMultipleHoles || [];
	}

	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = Math.max(Math.min(10 / (currentScale / 2), 1.5), 0.2);

	let holesWithinThreshold = [];
	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ? CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;

		let distance = Math.sqrt((hole.startXLocation - adjustedX) ** 2 + (hole.startYLocation - adjustedY) ** 2);
		if (distance < threshold) {
			holesWithinThreshold.push(hole);
		}
	}
	// Fix null reference issue - initialize selectedMultipleHoles if null
	if (!selectedMultipleHoles) {
		selectedMultipleHoles = [];
	}

	holesWithinThreshold.forEach((hole) => {
		if (!selectedMultipleHoles.includes(hole)) {
			selectedMultipleHoles.push(hole);
		} else {
			selectedMultipleHoles = selectedMultipleHoles.filter((h) => h !== hole);
			// Add UI feedback for deselection here
		}
		drawData(allBlastHoles, selectedHole);
	});

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let eastingAverage = 0;
	let northingAverage = 0;
	let elevationAverage = 0;
	let lengthAverage = 0;
	let diameterAverage = 0;
	let angleAverage = 0;
	let bearingAverage = 0;
	let subdrillSum = 0;
	let subdrillAverage = 0;

	if (isMultiHoleSelectionEnabled && (isHoleEditing || isPolygonSelectionActive || isSelectionPointerActive || isDeletingHole || isBlastNameEditing || isTypeEditing || isLengthPopupEditing)) {
		console.log("Selected Multiple Holes: ", selectedMultipleHoles);
		selectedMultipleHoles.forEach((hole) => {
			// Average the values of the selected holes in the selectedMultipleHoles array
			// Update slider attributes with the averaged values for each attribute
			// Update the UI labels with the averaged values for each attribute
			//console.log(selectedMultipleHoles);
			eastingSum += parseFloat(hole.startXLocation);
			northingSum += parseFloat(hole.startYLocation);
			elevationSum += parseFloat(hole.startZLocation);
			lengthSum += parseFloat(hole.holeLengthCalculated);
			diameterSum += parseFloat(hole.holeDiameter);
			angleSum += parseFloat(hole.holeAngle);
			bearingSum += parseFloat(hole.holeBearing);
			subdrillSum += parseFloat(hole.subdrillAmount);
			//console.log("Sums: \n   ", eastingSum, "\n   y", northingSum, "\n   z", elevationSum, "\n   l", lengthSum, "\n   d", diameterSum, "\n   a", angleSum, "\n   b", bearingSum);
			//console.log("Length: " + selectedMultipleHoles.length);

			eastingAverage = selectedMultipleHoles.length > 1 ? parseFloat(eastingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(eastingSum);
			northingAverage = selectedMultipleHoles.length > 1 ? parseFloat(northingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(northingSum);
			elevationAverage = selectedMultipleHoles.length > 1 ? parseFloat(elevationSum) / parseInt(selectedMultipleHoles.length) : parseFloat(elevationSum);
			lengthAverage = selectedMultipleHoles.length > 1 ? parseFloat(lengthSum) / parseInt(selectedMultipleHoles.length) : parseFloat(lengthSum);
			diameterAverage = selectedMultipleHoles.length > 1 ? parseFloat(diameterSum) / parseInt(selectedMultipleHoles.length) : parseFloat(diameterSum);
			angleAverage = selectedMultipleHoles.length > 1 ? parseFloat(angleSum) / parseInt(selectedMultipleHoles.length) : parseFloat(angleSum);
			bearingAverage = selectedMultipleHoles.length > 1 ? parseFloat(bearingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(bearingSum);
			subdrillAverage = selectedMultipleHoles.length > 1 ? parseFloat(subdrillSum) / parseInt(selectedMultipleHoles.length) : parseFloat(subdrillSum);

			//console.log("Averages: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);

			holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
			holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
			holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
			holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
			holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
			holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
			holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
			holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";
			//set the min max range to a value either side the average value
			holeEastingSlider.min = eastingAverage - 20;
			holeEastingSlider.max = eastingAverage + 20;
			holeNorthingSlider.min = northingAverage - 20;
			holeNorthingSlider.max = northingAverage + 20;
			holeElevationSlider.min = elevationAverage - 20;
			holeElevationSlider.max = elevationAverage + 20;
			//set the value of the slider
			holeEastingSlider.value = eastingAverage;
			holeNorthingSlider.value = northingAverage;
			holeElevationSlider.value = elevationAverage;
			holeLengthSlider.value = lengthAverage;
			holeDiameterSlider.value = diameterAverage;
			holeAngleSlider.value = angleAverage;
			holeBearingSlider.value = bearingAverage;
			holeSubdrillSlider.value = subdrillAverage;
			//console.log("Averages 2: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);
		});
	}

	return selectedMultipleHoles || [];
}

// New function to handle averaging and slider updates
function updateSelectionAveragesAndSliders(selectedHoles) {
	if (!selectedHoles || selectedHoles.length === 0) return;

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let subdrillSum = 0;

	// Calculate sums
	selectedHoles.forEach((hole) => {
		eastingSum += parseFloat(hole.startXLocation);
		northingSum += parseFloat(hole.startYLocation);
		elevationSum += parseFloat(hole.startZLocation);
		lengthSum += parseFloat(hole.holeLengthCalculated);
		diameterSum += parseFloat(hole.holeDiameter);
		angleSum += parseFloat(hole.holeAngle);
		bearingSum += parseFloat(hole.holeBearing);
		subdrillSum += parseFloat(hole.subdrillAmount);
	});

	// Calculate averages
	const count = selectedHoles.length;
	const eastingAverage = count > 1 ? eastingSum / count : eastingSum;
	const northingAverage = count > 1 ? northingSum / count : northingSum;
	const elevationAverage = count > 1 ? elevationSum / count : elevationSum;
	const lengthAverage = count > 1 ? lengthSum / count : lengthSum;
	const diameterAverage = count > 1 ? diameterSum / count : diameterSum;
	const angleAverage = count > 1 ? angleSum / count : angleSum;
	const bearingAverage = count > 1 ? bearingSum / count : bearingSum;
	const subdrillAverage = count > 1 ? subdrillSum / count : subdrillSum;

	// Update labels
	holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
	holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
	holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
	holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
	holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
	holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
	holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
	holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";

	// Update slider ranges
	holeEastingSlider.min = eastingAverage - 20;
	holeEastingSlider.max = eastingAverage + 20;
	holeNorthingSlider.min = northingAverage - 20;
	holeNorthingSlider.max = northingAverage + 20;
	holeElevationSlider.min = elevationAverage - 20;
	holeElevationSlider.max = elevationAverage + 20;

	// Update slider values
	holeEastingSlider.value = eastingAverage;
	holeNorthingSlider.value = northingAverage;
	holeElevationSlider.value = elevationAverage;
	holeLengthSlider.value = lengthAverage;
	holeDiameterSlider.value = diameterAverage;
	holeAngleSlider.value = angleAverage;
	holeBearingSlider.value = bearingAverage;
	holeSubdrillSlider.value = subdrillAverage;
}

const colorConnectorElement = document.getElementById("connectorColor");
const floatingConnectorColorElement = document.getElementById("floatingConnectorColor");
const colorDrawingElement = document.getElementById("drawingColor");

function getJSColorHexDrawing() {
	// Get the JSColor instance from the element
	const jsColorInstance = colorDrawingElement.jscolor;
	// Get the color value
	const colorHex = jsColorInstance.toHEXString(); // This will get the color in HEX format, e.g., "#FF0000"
	return colorHex;
}

// Wait for DOM, then set up color picker syncing
document.addEventListener("DOMContentLoaded", function () {
	// Step #) Sync Connector Color pickers (existing)
	if (colorConnectorElement && colorConnectorElement.jscolor && floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		// Sync from the main color picker to the floating one
		colorConnectorElement.jscolor.option("onInput", function () {
			// 'this' refers to the jscolor instance that triggered the event
			floatingConnectorColorElement.jscolor.fromString(this.toHEXString());
		});

		// Sync from the floating color picker to the main one
		floatingConnectorColorElement.jscolor.option("onInput", function () {
			colorConnectorElement.jscolor.fromString(this.toHEXString());
		});
	}

	// Step #) Sync KAD Drawing Color pickers (floatingKADColor <-> drawingColor)
	var floatingKADColorElement = document.getElementById("floatingKADColor");
	if (colorDrawingElement && colorDrawingElement.jscolor && floatingKADColorElement && floatingKADColorElement.jscolor) {
		// Sync from main drawingColor to floatingKADColor
		colorDrawingElement.jscolor.option("onInput", function () {
			floatingKADColorElement.jscolor.fromString(this.toHEXString());
		});

		// Sync from floatingKADColor to main drawingColor
		floatingKADColorElement.jscolor.option("onInput", function () {
			colorDrawingElement.jscolor.fromString(this.toHEXString());
		});
	}

	// Step #) Sync Elevation inputs (drawingElevationToolbar <-> drawingElevation)
	var drawingElevationToolbarElement = document.getElementById("drawingElevationToolbar");
	var drawingElevationElement = document.getElementById("drawingElevation");
	if (drawingElevationToolbarElement && drawingElevationElement) {
		// Sync from main drawingElevation to toolbar
		drawingElevationElement.addEventListener("input", function () {
			drawingElevationToolbarElement.value = this.value;
		});
		drawingElevationElement.addEventListener("change", function () {
			drawingElevationToolbarElement.value = this.value;
		});

		// Sync from toolbar to main drawingElevation
		drawingElevationToolbarElement.addEventListener("input", function () {
			drawingElevationElement.value = this.value;
			drawingZValue = parseFloat(this.value) || 0.0;
		});
		drawingElevationToolbarElement.addEventListener("change", function () {
			drawingElevationElement.value = this.value;
			drawingZValue = parseFloat(this.value) || 0.0;
		});
	}

	// Step #) Sync Radius inputs (drawingKADRadiusToolbar <-> drawingRadius)
	var drawingKADRadiusToolbarElement = document.getElementById("drawingKADRadiusToolbar");
	var drawingRadiusElement = document.getElementById("drawingRadius");
	if (drawingKADRadiusToolbarElement && drawingRadiusElement) {
		// Sync from main drawingRadius to toolbar
		drawingRadiusElement.addEventListener("input", function () {
			drawingKADRadiusToolbarElement.value = this.value;
		});
		drawingRadiusElement.addEventListener("change", function () {
			drawingKADRadiusToolbarElement.value = this.value;
		});

		// Sync from toolbar to main drawingRadius
		drawingKADRadiusToolbarElement.addEventListener("input", function () {
			drawingRadiusElement.value = this.value;
		});
		drawingKADRadiusToolbarElement.addEventListener("change", function () {
			drawingRadiusElement.value = this.value;
		});
	}

	// Step #) Sync holesAddingTool with addHoleSwitch (two-way)
	var holesAddingToolElement = document.getElementById("holesAddingTool");
	var addHoleSwitchElement = document.getElementById("addHoleSwitch");
	if (holesAddingToolElement && addHoleSwitchElement) {
		// When sidenav addHoleSwitch changes, update floating toolbar
		addHoleSwitchElement.addEventListener("change", function () {
			holesAddingToolElement.checked = this.checked;
		});
	}
});

function getJSColorHex() {
	// Try floating first, then main
	if (floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		return floatingConnectorColorElement.jscolor.toHEXString();
	}
	if (colorConnectorElement && colorConnectorElement.jscolor) {
		return colorConnectorElement.jscolor.toHEXString();
	}
	return "#FF0000"; // Default fallback
}

const delayElement = document.getElementById("delay");
const floatingDelayElement = document.getElementById("floatingDelay");

delayElement.addEventListener("input", function () {
	floatingDelayElement.value = this.value;
});

floatingDelayElement.addEventListener("input", function () {
	delayElement.value = this.value;
});

function getDelayValue() {
	// Return the floating delay if it exists and has a value, otherwise use main delay
	if (floatingDelayElement && floatingDelayElement.value) {
		return parseInt(floatingDelayElement.value);
	}
	if (delayElement && delayElement.value) {
		return parseInt(delayElement.value);
	}
	return 0; // Default fallback value
}

function handleConnectorClick(event) {
	// Get the click/touch coordinates relative to the canvas
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	const clickedHole = getClickedHole(clickX, clickY);
	if (isAddingConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				selectedHole = clickedHole;
				const delay = getDelayValue();
				const clickedHoleIndex = allBlastHoles.findIndex((hole) => hole === clickedHole);

				if (clickedHoleIndex !== -1) {
					// Use the new combined format for fromHoleID
					allBlastHoles[clickedHoleIndex].fromHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;
					allBlastHoles[clickedHoleIndex].timingDelayMilliseconds = delay;
					allBlastHoles[clickedHoleIndex].colorHexDecimal = getJSColorHex();
				}
				fromHoleStore = null;
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step #) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Save connector changes to IndexedDB
				debouncedSaveHoles();

				// directionArrows now contains the arrow data for later drawing
				timeChart();
				drawData(allBlastHoles, selectedHole);
			}
		}
	} else if (isAddingMultiConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				const selectedHole = clickedHole;
				const pointsInLine = getPointsInLine(fromHoleStore, selectedHole);
				if (pointsInLine.length > 0) {
					connectHolesInLine(pointsInLine);
				}
				// Reset the fromHole and exit add connector mode
				fromHoleStore = null;
				// RECALCULATE TIMING, CONTOURS AND DIRECTION ARROWS
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step #) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Save multi-connector changes to IndexedDB
				debouncedSaveHoles();

				// Update timing chart display
				timeChart();

				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
	}
}

function getPointsInLine(startPoint, endPoint, tolerance) {
	const pointsInLine = [];
	tolerance = connectAmount;
	const dx = endPoint.startXLocation - startPoint.startXLocation;
	const dy = endPoint.startYLocation - startPoint.startYLocation;
	const length = Math.sqrt(dx * dx + dy * dy);
	const dirX = dx / length;
	const dirY = dy / length;
	const points = allBlastHoles; //Assign the point as allBlastHoles

	for (const point of points) {
		if (point !== startPoint && point !== endPoint) {
			const vecX = point.startXLocation - startPoint.startXLocation;
			const vecY = point.startYLocation - startPoint.startYLocation;
			const dotProduct = vecX * dirX + vecY * dirY;
			if (dotProduct >= 0 && dotProduct <= length) {
				const distanceToLine = Math.abs(vecX * dirY - vecY * dirX);
				if (distanceToLine <= tolerance) {
					pointsInLine.push(point);
				}
			}
		}
	}

	// Add start and end points to the array
	pointsInLine.unshift(startPoint);
	pointsInLine.push(endPoint);

	return pointsInLine;
}

function connectHolesInLine(pointsInLine) {
	// Sort points based on distance from the fromHoleStore
	pointsInLine.sort((a, b) => {
		const distanceA = calculateDistance(fromHoleStore, a);
		const distanceB = calculateDistance(fromHoleStore, b);
		return distanceA - distanceB;
	});

	let previousHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;

	// Connect each point to the previous point
	for (let i = 1; i < pointsInLine.length; i++) {
		const hole = pointsInLine[i];
		const holeIndex = allBlastHoles.findIndex((h) => h === hole);

		if (holeIndex !== -1) {
			allBlastHoles[holeIndex].fromHoleID = previousHoleID;
			allBlastHoles[holeIndex].timingDelayMilliseconds = getDelayValue();
			allBlastHoles[holeIndex].colorHexDecimal = getJSColorHex();
		}

		previousHoleID = `${hole.entityName}:::${hole.holeID}`;
	}
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, deltaX, deltaY);
	contourLinesArray = result.contourLinesArray;
	directionArrows = result.directionArrows;
	// Step #) Update contour overlay to reflect new timing
	updateOverlayColorsForTheme();
	timeChart();
	drawData(allBlastHoles, selectedHole);
}

// Function to calculate the distance between two points
function calculateDistance(point1, point2) {
	const dx = point2.startXLocation - point1.startXLocation;
	const dy = point2.startYLocation - point1.startYLocation;
	return Math.sqrt(dx * dx + dy * dy);
}

//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPointInMap(map, clickX, clickY) {
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = 10 / (currentScale / 2);
	let closestPoint = null;
	let minDistance = threshold;

	// Iterate over the keys of the map
	for (const entityName of map.keys()) {
		const entity = map.get(entityName);
		for (const point of entity.data) {
			const distance = Math.sqrt(Math.pow(point.pointXLocation - adjustedX, 2) + Math.pow(point.pointYLocation - adjustedY, 2));

			if (distance <= threshold && distance < minDistance) {
				closestPoint = point;
				minDistance = distance;
			}
		}
	}
	drawData(allBlastHoles, selectedHole);
	return closestPoint;
}
//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPoint(event) {
	// get the values from clicking in the canvas
	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;
	if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
		// Handle the case when the values are NaN
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	} else {
		// Proceed with the calculation using the valid values
		clickX = event.clientX - rect.left;
		clickY = event.clientY - rect.top;
	}
	// SNAPPIN SNAP CODE:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isDeletingKAD) {
		selectedPoint = getClickedPointInMap(allKADDrawingsMap, clickX, clickY);
		drawData(allBlastHoles, selectedHole);
		return selectedPoint;
	}

	drawData(allBlastHoles, selectedHole);
	// If none of the flags match, return null
	return null;
}

/**

 * Offsets a selected object (line or polyline) by a specified amount in a given direction
 * @param {Map} map - The map containing all KAD drawings
 * @param {Object} selectedPoint - The selected point object containing entity info
 * @param {string} direction - Direction to offset ("right", "left", "up", "down")
 * @param {number} offsetAmount - Distance to offset in map units
 * @param {boolean} [checkForCrossover=false] - Whether to check and prevent line segment crossovers
 * @param {boolean} [extendIfNecessary=false] - Whether to extend line segments that get too far apart
 * @returns {Object|undefined} The newly created offset entity, or undefined if no point selected
 */
function offsetObjectWithSelectedPoint(map, selectedPoint, direction, offsetAmount, checkForCrossover = false, extendIfNecessary = false) {
	if (selectedPoint) {
		const entityName = selectedPoint.entityName;
		const entityType = selectedPoint.entityType;

		// Create a new entity for the offset polyline
		const newEntity = {
			entityName: `${entityName}_offset`, // Modify this as needed
			entityType: entityType,
			data: [],
		};

		let prevPoint = null;

		// Offset and check for crossovers if needed
		for (const point of selectedPoint.data) {
			let offsetX = point.pointXLocation;
			let offsetY = point.pointYLocation;

			if (direction === "right") {
				offsetX += offsetAmount;
			} else if (direction === "left") {
				offsetX -= offsetAmount;
			} else if (direction === "up") {
				offsetY -= offsetAmount;
			} else if (direction === "down") {
				offsetY += offsetAmount;
			}

			if (checkForCrossover && prevPoint) {
				// Check for crossover and shorten the segment if needed
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					const ratio = offsetAmount / distance;
					offsetX = prevPoint.pointXLocation + (offsetX - prevPoint.pointXLocation) * ratio;
					offsetY = prevPoint.pointYLocation + (offsetY - prevPoint.pointYLocation) * ratio;
				}
			}

			// Add the offset point to the new entity
			newEntity.data.push({
				entityName: newEntity.entityName,
				entityType: newEntity.entityType,
				pointID: point.pointID, // Preserve point ID or modify as needed
				pointXLocation: offsetX,
				pointYLocation: offsetY,
				pointZLocation: point.pointZLocation,
				lineWidth: point.lineWidth,
				color: point.color,
			});

			if (extendIfNecessary && prevPoint) {
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					// Extend the line segment if points get further away after offsetting
					newEntity.data.push({
						entityName: newEntity.entityName,
						entityType: newEntity.entityType,
						pointID: point.pointID, // Preserve point ID or modify as needed
						pointXLocation: offsetX,
						pointYLocation: offsetY,
						pointZLocation: point.pointZLocation,
						lineWidth: point.lineWidth,
						color: point.color,
					});
				}
			}

			prevPoint = point;
		}

		// Add the new entity to the appropriate map (line or poly)
		if (entityType === "poly") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		} else if (entityType === "line") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		}

		// Redraw the canvas or perform any other necessary updates
		drawData(allBlastHoles, selectedHole);

		// Return the newly created entity if needed
		return newEntity;
	}
}

function deleteSelectedPoint() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("‚ùå Cannot delete point from hidden entity: " + entityName);
			return;
		}
		deletePointInMap(allKADDrawingsMap, selectedPoint);
	}
}

// Helper function to get entity name from selected point
function getEntityNameFromSelectedPoint(selectedPoint) {
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entityName;
		}
	}
	return null;
}

// Helper function to determine entity type from selected point
function getEntityTypeFromSelectedPoint(selectedPoint) {
	// Find which entity this point belongs to
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entity.entityType;
		}
	}
	return null;
}

function deleteSelectedObject() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("‚ùå Cannot delete object from hidden entity: " + entityName);
			return;
		}
		deleteObjectInMap(allKADDrawingsMap, selectedPoint);
		// ADD THIS: Save after delete
		debouncedSaveKAD();
	}
}

function deleteSelectedAll() {
	if (selectedPoint && isDeletingKAD) {
		// Determine entity type from the selected point
		const entityType = getEntityTypeFromSelectedPoint(selectedPoint);
		if (entityType) {
			// Only delete visible entities of this type
			const visibleEntitiesToDelete = [];
			for (const [entityName, entity] of allKADDrawingsMap.entries()) {
				if (entity.entityType === entityType && isEntityVisible(entityName)) {
					visibleEntitiesToDelete.push(entityName);
				}
			}

			if (visibleEntitiesToDelete.length === 0) {
				console.log("‚ùå No visible entities of type " + entityType + " to delete");
				return;
			}

			// Delete only visible entities
			visibleEntitiesToDelete.forEach((entityName) => {
				allKADDrawingsMap.delete(entityName);
			});

			console.log("üóëÔ∏è Deleted " + visibleEntitiesToDelete.length + " visible " + entityType + " entities");
			// ADD THIS: Save after delete all of type
			debouncedSaveKAD();
		}
	}
}

// Enhanced function to delete only specific entity types and clear selection
function deleteAllOfType(map, entityType) {
	const entitiesToDelete = [];
	let shouldClearSelection = false;

	// Find all entities of the specified type
	for (const [entityName, entity] of map.entries()) {
		if (entity.entityType === entityType) {
			entitiesToDelete.push(entityName);

			// Check if the selected point belongs to this entity
			if (selectedPoint && entity.data.some((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation)) {
				shouldClearSelection = true;
			}
		}
	}

	// Delete them
	entitiesToDelete.forEach((entityName) => {
		map.delete(entityName);
		console.log(`Deleted ${entityType} entity: ${entityName}`);
	});

	// Clear selection if the selected point was deleted
	if (shouldClearSelection) {
		selectedPoint = null;
		selectedKADObject = null; // Clear this too if it exists
		selectedKADPolygon = null; // And this one
	}

	updateStatusMessage(`Deleted ${entitiesToDelete.length} ${entityType} entities`);
	drawData(allBlastHoles, selectedHole);
	setTimeout(() => updateStatusMessage(""), 2000);
}

// Replace the deletePointInMap function around line 9227
function deletePointInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const dataIndex = entity.data.findIndex((point) => {
			return point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation;
		});

		if (dataIndex !== -1) {
			entity.data.splice(dataIndex, 1);
			updateStatusMessage("Deleted point " + pointToDelete.pointID + " from " + entity.entityType);

			// ? ADD: Renumber remaining points sequentially starting from 1
			renumberEntityPoints(entity);

			// If entity has no more points, delete the entire entity
			if (entity.data.length === 0) {
				map.delete(entityName);
				updateStatusMessage("Deleted empty " + entity.entityType + " entity: " + entityName);
			}

			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete point
			debouncedSaveKAD();
			break;
		}
	}
}

// ? ADD: New function to renumber points in an entity
function renumberEntityPoints(entity) {
	if (!entity || !entity.data || entity.data.length === 0) return;

	// Renumber all points sequentially starting from 1
	for (let i = 0; i < entity.data.length; i++) {
		entity.data[i].pointID = i + 1;
	}

	console.log("‚úÖ Renumbered " + entity.data.length + " points in " + entity.entityType + " entity");
}

function deleteObjectInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const foundPoint = entity.data.find((point) => point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation);

		if (foundPoint) {
			map.delete(entityName);
			updateStatusMessage(`Deleted ${entity.entityType} entity: ${entityName}`);
			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete object
			debouncedSaveKAD();
			break;
		}
	}
}

function deleteAllInMap(map) {
	map.clear();
	selectedPoint = null;
	drawData(allBlastHoles, selectedHole);
	// ADD THIS: Save after delete all in map
	debouncedSaveKAD();
}

function deleteSelectedHoles() {
	let holesWereActuallyDeleted = false; // To track if the allBlastHoles array was modified

	if (isDeletingHole) {
		const entitiesToRenumber = new Set(); // Store unique entity names that need renumbering
		const deletedCombinedIDs = new Set(); // Track deleted holes for fromHoleID cleanup

		if (selectedMultipleHoles.length > 0) {
			console.log("Processing deletion for " + selectedMultipleHoles.length + " selected holes.");
			const originalPointsLength = allBlastHoles.length;

			// Create a Set of hole references for efficient filtering
			const holesToDeleteReferences = new Set(selectedMultipleHoles);

			allBlastHoles = allBlastHoles.filter((hole) => {
				if (holesToDeleteReferences.has(hole)) {
					//console.log("Deleting Hole ID:", point.holeID, "in:", point.entityName);
					deletedCombinedIDs.add(hole.entityName + ":::" + hole.holeID);
					if (isRenumberingHoles) {
						entitiesToRenumber.add(hole.entityName);
					}
					return false; // Exclude this point (effectively deleting it)
				}
				return true; // Keep this point
			});

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
			}

			// Clear selections after processing
			selectedMultipleHoles = [];
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Ensure single selection is also cleared
		} else if (selectedHole !== null) {
			//console.log("Processing deletion for single Hole ID:", selectedHole.holeID, "in:", selectedHole.entityName);
			const holeToRemove = selectedHole; // Cache before selectedHole is nulled
			deletedCombinedIDs.add(holeToRemove.entityName + ":::" + holeToRemove.holeID);
			const originalPointsLength = allBlastHoles.length;

			allBlastHoles = allBlastHoles.filter((hole) => hole !== holeToRemove);

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
				if (isRenumberingHoles) {
					entitiesToRenumber.add(holeToRemove.entityName);
				}
			}
			// Clear selection after processing
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		if (holesWereActuallyDeleted) {
			// Clean up orphaned fromHoleID references before renumbering
			allBlastHoles.forEach((hole) => {
				if (deletedCombinedIDs.has(hole.fromHoleID)) {
					const selfReference = hole.entityName + ":::" + hole.holeID;
					console.log("üï≥Ô∏è Orphaned hole " + selfReference + " now references itself");
					hole.fromHoleID = selfReference;
				}
			});

			// Perform renumbering for all affected entities if enabled
			if (isRenumberingHoles) {
				entitiesToRenumber.forEach((entityName) => {
					// deleteRenumberStart is expected to be globally available and set appropriately
					//console.log("Renumbering for Entity:", entityName, "starting at:", deleteRenumberStart);
					renumberHolesFunction(deleteRenumberStart, entityName);
				});
			}

			// Save to IndexedDB after deletion
			debouncedSaveHoles();

			// Reset fromHoleStore as selections involving it are now gone
			fromHoleStore = null;

			// Note: Original intermediate recalculations and drawData(points, null) call
			// are omitted here because refreshPoints() handles these operations comprehensively.
		}
	}

	refreshPoints(); // This function will save changes, reload points, recalculate all necessary data, and redraw.
}

//function to delete holes that have the same entity name in both the allBlastHoles array and the map
function deleteSelectedPattern() {
	if (isDeletingHole) {
		if (selectedHole !== null) {
			// find the selected holeIDs entityName
			let entityNameToDelete = allBlastHoles.find((hole) => hole === selectedHole).entityName;

			// Remove holes with the same entityName from kadHolesMap
			// for (const [entityName, entity] of kadHolesMap) {
			// 	if (entityName === entityNameToDelete) {
			// 		kadHolesMap.delete(entityName);
			// 	}
			// }

			// Remove holes with the same entityName from the points array
			allBlastHoles = allBlastHoles.filter((hole) => hole.entityName !== entityNameToDelete);

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			drawData(allBlastHoles, selectedHole);
		} else {
			drawData(allBlastHoles, selectedHole);
		}
	}
	refreshPoints();
}

//function to delete All Entities in the kadHolesMap and all the Entityies in the allBlastHoles array
function deleteSelectedAllPatterns() {
	console.log("üö® deleteSelectedAllPatterns called!");
	console.log("isDeletingHole:", isDeletingHole);
	console.log("selectedHole:", selectedHole);
	console.log("selectedMultipleHoles:", selectedMultipleHoles);
	console.log("Stack trace:", new Error().stack);
	if (isDeletingHole) {
		if (selectedHole !== null || selectedMultipleHoles.length > 0) {
			// Remove all holes from kadHolesMap
			//kadHolesMap.clear();

			// Remove all holes from the points array
			allBlastHoles = [];

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			drawData(allBlastHoles, selectedHole);
		} else {
			drawData(allBlastHoles, selectedHole);
		}
	}
}

function handleHoleDeletingClick(event) {
	if (isDeletingHole) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
		}
	}
}

// Update renumberHolesFunction to preserve rowID/posID structure
function renumberHolesFunction(startNumber, selectedEntityName) {
	console.log("Renumbering holes for Entity:", selectedEntityName, "Starting at:", startNumber);

	const oldToNewHoleIDMap = new Map();

	// Get all holes for this entity
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === selectedEntityName);

	// Sort holes by rowID first, then by posID within each row
	entityHoles.sort((a, b) => {
		// First sort by rowID
		const rowDiff = (a.rowID || 0) - (b.rowID || 0);
		if (rowDiff !== 0) return rowDiff;

		// Then sort by posID within the same row
		return (a.posID || 0) - (b.posID || 0);
	});

	const startValue = startNumber.toString();
	const alphaMatch = startValue.match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;
	const canParseAsInt = !isNaN(parseInt(startValue)) && isFinite(startValue);

	if (isAlphaNumerical) {
		// ALPHA-NUMERICAL RENUMBERING BY ROW - Use rowID/posID structure
		console.log("Using alpha-numerical renumbering with rowID/posID structure starting at:", startValue);

		const startRowLetter = alphaMatch[1];
		const startHoleNumber = parseInt(alphaMatch[2]);

		// Group holes by rowID
		const rowGroups = new Map();
		entityHoles.forEach((hole) => {
			const rowID = hole.rowID || 1;
			if (!rowGroups.has(rowID)) {
				rowGroups.set(rowID, []);
			}
			rowGroups.get(rowID).push(hole);
		});

		// Sort each row by posID
		rowGroups.forEach((holes) => {
			holes.sort((a, b) => (a.posID || 0) - (b.posID || 0));
		});

		// Get sorted rowIDs
		const sortedRowIDs = Array.from(rowGroups.keys()).sort((a, b) => a - b);

		let currentRowLetter = startRowLetter;

		// Renumber each row
		sortedRowIDs.forEach((rowID) => {
			const rowHoles = rowGroups.get(rowID);
			rowHoles.forEach((hole, posIndex) => {
				const newHoleID = currentRowLetter + (startHoleNumber + posIndex);
				oldToNewHoleIDMap.set(hole.holeID, newHoleID);
				hole.holeID = newHoleID;
			});

			// Move to next row letter
			if (currentRowLetter === "Z") {
				currentRowLetter = "AA";
			} else if (currentRowLetter === "ZZ") {
				currentRowLetter = "AAA";
			} else {
				currentRowLetter = incrementLetter(currentRowLetter);
			}
		});
	} else {
		// NUMERICAL RENUMBERING - Respect rowID/posID order
		console.log("Using numerical renumbering with rowID/posID structure starting at:", startValue);

		const startNum = canParseAsInt ? parseInt(startValue) : 1;
		let currentNumber = startNum;

		entityHoles.forEach((hole) => {
			oldToNewHoleIDMap.set(hole.holeID, currentNumber.toString());
			hole.holeID = currentNumber.toString();
			currentNumber++;
		});
	}

	// Update fromHoleID references
	allBlastHoles.forEach((hole) => {
		if (hole.fromHoleID) {
			const [entity, oldHoleID] = hole.fromHoleID.split(":::");
			if (entity === selectedEntityName && oldToNewHoleIDMap.has(oldHoleID)) {
				hole.fromHoleID = entity + ":::" + oldToNewHoleIDMap.get(oldHoleID);
			}
		}
	});

	refreshPoints();
	drawData(allBlastHoles, selectedHole);
	console.log("Renumbered", entityHoles.length, "holes respecting rowID/posID structure");
}

function renumberPatternAfterClipping(entityName) {
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);

	if (entityHoles.length === 0) return;

	// For patterns generated in polygons, the offset-aware numbering is already applied during generation
	// This function now just ensures proper A1 start and maintains the existing numbering structure

	// Step 1: Automatically detect row orientation from the pattern
	let rowOrientation = 90; // Default to East (90?) if can't determine

	if (entityHoles.length >= 2) {
		// Sort holes by Y coordinate to find potential row mates
		const sortedByY = [...entityHoles].sort((a, b) => b.startYLocation - a.startYLocation);

		// Find the first two holes that are likely in the same row (similar Y coordinates)
		const tolerance = 2.0; // 2 meter tolerance for same row
		let firstRowHoles = [sortedByY[0]];

		for (let i = 1; i < sortedByY.length; i++) {
			if (Math.abs(sortedByY[i].startYLocation - sortedByY[0].startYLocation) <= tolerance) {
				firstRowHoles.push(sortedByY[i]);
			} else {
				break; // Found different row
			}
		}

		// If we have at least 2 holes in the same row, calculate row orientation
		if (firstRowHoles.length >= 2) {
			// Sort by X coordinate to get leftmost and rightmost holes in the row
			firstRowHoles.sort((a, b) => a.startXLocation - b.startXLocation);
			const leftHole = firstRowHoles[0];
			const rightHole = firstRowHoles[firstRowHoles.length - 1];

			// Calculate bearing from left to right hole using your protractor formula
			const deltaX = rightHole.startXLocation - leftHole.startXLocation;
			const deltaY = rightHole.startYLocation - leftHole.startYLocation;

			// Use the same bearing calculation as your protractor tool
			rowOrientation = (90 - (Math.atan2(deltaY, deltaX) * 180) / Math.PI + 360) % 360;
		}
	}

	console.log("Detected row orientation: " + rowOrientation + "¬∞ for entity: " + entityName);

	// Step 2: Convert compass bearing to math radians for projections
	const rowBearingRadians = (90 - rowOrientation) * (Math.PI / 180);
	const burdenBearingRadians = rowBearingRadians - Math.PI / 2; // Perpendicular to row direction

	// Step 3: Project each hole onto the burden axis (perpendicular to rows) and spacing axis (along rows)
	entityHoles.forEach((hole) => {
		// Project onto burden direction (perpendicular to rows) - this determines which row
		hole.burdenProjection = hole.startXLocation * Math.cos(burdenBearingRadians) + hole.startYLocation * Math.sin(burdenBearingRadians);
		// Project onto spacing direction (along rows) - this determines position within row
		hole.spacingProjection = hole.startXLocation * Math.cos(rowBearingRadians) + hole.startYLocation * Math.sin(rowBearingRadians);
	});

	// Step 4: Sort by burden projection (to group rows), then by spacing projection (within each row)
	entityHoles.sort((a, b) => {
		const burdenDiff = Math.abs(a.burdenProjection - b.burdenProjection);
		if (burdenDiff > 1.5) {
			// Tolerance for row grouping
			return b.burdenProjection - a.burdenProjection; // Sort rows (highest burden first)
		}
		return a.spacingProjection - b.spacingProjection; // Sort within row (left to right along row)
	});

	// Step 5: Group holes by rows using burden projection
	const tolerance = 2.0; // Tolerance in meters for row grouping
	const rows = [];

	if (entityHoles.length > 0) {
		let currentRow = [entityHoles[0]];
		let currentBurdenPos = entityHoles[0].burdenProjection;

		for (let i = 1; i < entityHoles.length; i++) {
			const hole = entityHoles[i];
			if (Math.abs(hole.burdenProjection - currentBurdenPos) <= tolerance) {
				currentRow.push(hole);
			} else {
				// Sort current row by spacing projection (along the row direction)
				currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
				rows.push(currentRow);
				currentRow = [hole];
				currentBurdenPos = hole.burdenProjection;
			}
		}

		// Don't forget the last row
		if (currentRow.length > 0) {
			currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
			rows.push(currentRow);
		}
	}

	// Step 6: Simple renumbering starting from A1 (offset logic already applied during generation)
	let rowLetter = "A";
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		const row = rows[rowIndex];

		// For clipped patterns, just renumber sequentially starting from 1 in each row
		for (let pos = 0; pos < row.length; pos++) {
			const hole = row[pos];
			const newHoleID = rowLetter + (pos + 1);

			// Update fromHoleID references
			allBlastHoles.forEach((hole) => {
				if (hole.fromHoleID === entityName + ":::" + hole.holeID) {
					hole.fromHoleID = entityName + ":::" + newHoleID;
				}
			});

			hole.holeID = newHoleID;
		}

		// Move to next row letter
		if (rowLetter === "Z") {
			rowLetter = "AA";
		} else if (rowLetter === "ZZ") {
			rowLetter = "AAA";
		} else {
			rowLetter = incrementLetter(rowLetter);
		}
	}

	// Step 7: Clean up temporary projection properties
	entityHoles.forEach((hole) => {
		delete hole.burdenProjection;
		delete hole.spacingProjection;
	});

	console.log("Renumbered " + entityHoles.length + " holes in " + rows.length + " rows for entity: " + entityName + " with detected row orientation: " + rowOrientation + "¬∞");
}

// Step #1: Unified deleteHoleAndRenumber for rowID/posID and alphanumeric holeID
function deleteHoleAndRenumber(holeToDelete) {
	const entityName = holeToDelete.entityName;
	const holeID = holeToDelete.holeID;
	const rowID = holeToDelete.rowID;
	const posID = holeToDelete.posID;
	const deletedCombinedID = entityName + ":::" + holeID;

	// Step #2: Find the hole in allBlastHoles and remove it
	const holeIndex = allBlastHoles.findIndex((hole) => hole.entityName === entityName && hole.holeID === holeID);
	if (holeIndex !== -1) {
		allBlastHoles.splice(holeIndex, 1);
		console.log("‚ùåüï≥Ô∏è Deleted hole:", entityName + ":" + holeID);

		// Step #2a: Clean up fromHoleID references - orphaned holes should reference themselves
		allBlastHoles.forEach((hole) => {
			if (hole.fromHoleID === deletedCombinedID) {
				const selfReference = hole.entityName + ":::" + hole.holeID;
				console.log("üï≥Ô∏è Orphaned hole " + selfReference + " now references itself");
				hole.fromHoleID = selfReference;
			}
		});

		// Step #2b: Save to IndexedDB after deletion
		debouncedSaveHoles();
	} else {
		console.warn("üö® Hole not found for deletion:", entityName + ":" + holeID);
		return;
	}

	// Step #3: If rowID/posID exist, use rowID/posID logic
	if (rowID && posID) {
		// Get all holes in the same row that come after the deleted hole
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID && hole.posID > posID);

		// Renumber positions in this row
		sameRowHoles.forEach((hole) => {
			const oldHoleID = hole.holeID;
			hole.posID = hole.posID - 1; // Shift position down by 1

			// Update fromHoleID references if needed
			allBlastHoles.forEach((h) => {
				if (h.fromHoleID === entityName + ":::" + oldHoleID) {
					h.fromHoleID = entityName + ":::" + hole.holeID;
				}
			});
		});

		console.log("Renumbered " + sameRowHoles.length + " holes in row " + rowID);
		return; // Step #4: Exit after rowID/posID logic
	}

	// Step #5: If not rowID/posID, check for alphanumeric holeID
	const alphaMatch = holeID && holeID.toString().match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;

	if (isAlphaNumerical) {
		const deletedRowLetter = alphaMatch[1];
		const deletedHoleNumber = parseInt(alphaMatch[2]);

		// Get all holes in the same row (same letter) and entity
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.holeID && hole.holeID.toString().startsWith(deletedRowLetter));

		// Sort by hole number within the row
		sameRowHoles.sort((a, b) => {
			const aMatch = a.holeID.toString().match(/^[A-Z]+(\d+)$/);
			const bMatch = b.holeID.toString().match(/^[A-Z]+(\d+)$/);
			if (aMatch && bMatch) {
				return parseInt(aMatch[1]) - parseInt(bMatch[1]);
			}
			return 0;
		});

		// Renumber holes in this row that come after the deleted hole
		sameRowHoles.forEach((hole) => {
			const currentMatch = hole.holeID.toString().match(/^([A-Z]+)(\d+)$/);
			if (currentMatch) {
				const currentHoleNumber = parseInt(currentMatch[2]);
				if (currentHoleNumber > deletedHoleNumber) {
					const oldHoleID = hole.holeID;
					const newHoleID = deletedRowLetter + (currentHoleNumber - 1);
					hole.holeID = newHoleID;

					// Update fromHoleID references
					allBlastHoles.forEach((h) => {
						if (h.fromHoleID === entityName + ":::" + oldHoleID) {
							h.fromHoleID = entityName + ":::" + newHoleID;
						}
					});
				}
			}
		});

		console.log("Renumbered " + sameRowHoles.length + " holes in row " + deletedRowLetter);
		return; // Step #6: Exit after alphanumeric logic
	}

	// Step #7: For numerical holes, no automatic renumbering on delete
	// (user can manually renumber if needed)
}

// Expose hole deletion and renumbering functions globally for HolesContextMenu.js
window.deleteHoleAndRenumber = deleteHoleAndRenumber;
window.renumberHolesFunction = renumberHolesFunction;
window.renumberPatternAfterClipping = renumberPatternAfterClipping;

// Expose setMeasuredDate for HolePropertyDialogs.js
window.setMeasuredDate = setMeasuredDate;

// Expose KAD functions for KADDialogs.js
window.performKADOffset = performKADOffset;
window.createRadiiFromSelectedEntitiesFixed = createRadiiFromSelectedEntitiesFixed;
window.resetFloatingToolbarButtons = resetFloatingToolbarButtons;
window.getEntityFromKADObject = getEntityFromKADObject;
window.handleOffsetKADClick = handleOffsetKADClick;

// Expose KAD tool variables for KADDialogs.js
window.offsetKADButton = offsetKADButton;
window.isOffsetKAD = isOffsetKAD;
window.radiiHolesOrKADsTool = radiiHolesOrKADsButton; // Alias for consistency

// Expose triangulation functions for KADDialogs.js
window.createConstrainedDelaunayTriangulation = createConstrainedDelaunayTriangulation;
window.createDelaunayTriangulation = createDelaunayTriangulation;
window.deleteTrianglesByClippingPolygon = deleteTrianglesByClippingPolygon;
window.deleteTrianglesByInternalAngle = deleteTrianglesByInternalAngle;
window.deleteTrianglesByEdgeLength = deleteTrianglesByEdgeLength;
window.updateCentroids = updateCentroids;

// Expose utility functions for dialogs
window.isIOS = isIOS;
window.showErrorDialog = showErrorDialog;

// Expose KAD renumbering function globally for KADContextMenu.js
window.renumberEntityPoints = renumberEntityPoints;

function handleHoleAddingClick(event) {
	if (isAddingHole) {
		console.log("‚ûïüï≥Ô∏è handleHoleAddingClick fired");
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = parseFloat(snapResult.worldX);
		worldY = parseFloat(snapResult.worldY);

		// Set worldZ if available from snap result, otherwise use current elevation
		if (snapResult.worldZ !== undefined && snapResult.worldZ !== null) {
			worldZ = parseFloat(snapResult.worldZ);
		} else {
			// Use drawing elevation or default
			worldZ = parseFloat(document.getElementById("drawingElevation")?.value || 0);
		}

		// Expose on window object for AddHoleDialog.js to access
		window.worldX = worldX;
		window.worldY = worldY;
		window.worldZ = worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		console.log("üìç worldX/worldY/worldZ set:", worldX, worldY, worldZ);
		console.log("üìç window.worldX/worldY/worldZ:", window.worldX, window.worldY, window.worldZ);

		// Step 1) Check if we're in multiple mode (have stored form data)
		if (window.isAddingSingleHole && window.multipleAddHoleFormData) {
			// Multiple mode: Reuse stored form data, don't show dialog
			console.log("üìçüìç Multiple mode: Reusing stored form data");
			if (typeof window.addHoleMultipleMode === "function") {
				window.addHoleMultipleMode(worldX, worldY);
			} else {
				console.error("? addHoleMultipleMode function not found");
				addHolePopup(); // Fallback to showing dialog
			}
		} else {
			// Single mode or first click: Show dialog
			console.log("üìç Single mode or first click: Showing dialog");
			addHolePopup();
		}
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		// Clear window properties too
		window.worldX = null;
		window.worldY = null;
		window.worldZ = null;
	}
}

//================================================
//DRAWING FUNCTIONS ADD KAD DRAWING POINT - LINE - POLY - CIRCLE - TEXT
//===============================================

// Add these variables to track the current drawing state
let currentDrawingEntityName = null;
let deleteKeyPressed = false;
let deleteKeyCount = 0;

// Enhanced key listener for delete/backspace functionality
function handleDrawingKeyEvents(event) {
	// Check for Delete or Backspace keys
	if (event.key === "Delete" || event.key === "Backspace") {
		event.preventDefault(); // Prevent default browser behavior

		// Only allow deletion if we have a current drawing entity
		if (currentDrawingEntityName && allKADDrawingsMap.has(currentDrawingEntityName)) {
			const entity = allKADDrawingsMap.get(currentDrawingEntityName);

			if (entity.data.length > 0) {
				// Remove the last point
				const removedPoint = entity.data.pop();
				deleteKeyCount++;

				// Update the last draw point to the previous point (if any)
				if (entity.data.length > 0) {
					const lastPoint = entity.data[entity.data.length - 1];
					updateLastKADDrawPoint(lastPoint.pointXLocation, lastPoint.pointYLocation);
				} else {
					// If no points left, reset the last draw point
					lastKADDrawPoint = null;
				}

				// Show user feedback
				const remainingPoints = entity.data.length;
				const entityType = entity.entityType;
				let message = "";

				if (remainingPoints === 0) {
					message = "Removed last point. Entity is now empty.";
				} else {
					message = "Removed last point. " + remainingPoints + " point" + (remainingPoints > 1 ? "s" : "") + " remaining in " + entityType + ".";
				}

				updateStatusMessage(message);
				setTimeout(() => updateStatusMessage(""), 2000);

				// Redraw the canvas
				drawData(allBlastHoles, selectedHole);
				debouncedSaveKAD();

				console.log("üóëÔ∏è Removed point from " + currentDrawingEntityName + ". Points remaining: " + remainingPoints);
			} else {
				updateStatusMessage("No points to remove from current " + entity.entityType + ".");
				setTimeout(() => updateStatusMessage(""), 1500);
			}
		} else {
			updateStatusMessage("No active drawing to remove points from.");
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		return true; // Signal that we handled the key
	}
	return false; // Signal that we didn't handle the key
}
// Enhanced function to update the current drawing entity name
function setCurrentDrawingEntity(entityName) {
	currentDrawingEntityName = entityName;
	deleteKeyCount = 0; // Reset delete count when starting new entity
	console.log("üé® Set current drawing entity: " + entityName);
}
// Function to clear current drawing entity when switching tools
function clearCurrentDrawingEntity() {
	currentDrawingEntityName = null;
	deleteKeyCount = 0;
	console.log("üßπ Cleared current drawing entity");
}

function handleKADPointClick(event) {
	if (isDrawingPoint) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADPoint();
		debouncedUpdateTreeView();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedUpdateTreeView(); // Use debounced version
		debouncedSaveKAD();
	}
}

// Step #) Helper function to generate unique KAD entity names
// This prevents duplicate names when entities are deleted and new ones created
function getUniqueKADEntityName(prefix) {
	// Step 1) Find all existing entity names with this prefix
	var existingNumbers = [];
	allKADDrawingsMap.forEach(function (entity, name) {
		if (name.startsWith(prefix)) {
			// Extract the number from the name (e.g., "polyObject5_a3k7" -> 5)
			var numStr = name.substring(prefix.length);
			// Handle both old format (no underscore) and new format (with _uid)
			var underscoreIndex = numStr.indexOf("_");
			if (underscoreIndex !== -1) {
				numStr = numStr.substring(0, underscoreIndex);
			}
			var num = parseInt(numStr, 10);
			if (!isNaN(num)) {
				existingNumbers.push(num);
			}
		}
	});

	// Step 2) Find the next available number (starting from 1)
	var nextNum = 1;
	if (existingNumbers.length > 0) {
		// Sort and find the first gap, or use max + 1
		existingNumbers.sort(function (a, b) { return a - b; });
		for (var i = 0; i < existingNumbers.length; i++) {
			if (existingNumbers[i] !== nextNum) {
				break; // Found a gap
			}
			nextNum++;
		}
	}

	// Step 3) Add short unique ID suffix to guarantee uniqueness
	var shortId = Math.random().toString(36).substring(2, 6);
	return prefix + nextNum + "_" + shortId;
}

function addKADPoint() {
	if (isDrawingPoint) {
		const color = getJSColorHexDrawing();
		const entityType = "point";

		// Use the same entity management as lines/polygons
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = getUniqueKADEntityName("pointObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		// In addKADPoint() function around line 9720
		const pointObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth, // This is added for inter-changable types. points > lines > polys
			color: color,
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true,
			});
		}

		allKADDrawingsMap.get(entityName).data.push(pointObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedUpdateTreeView();
		console.log("Added point", pointID, "to", entityName);
	}
}

function handleKADLineClick(event) {
	if (isDrawingLine) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADLine();
		debouncedUpdateTreeView(); // Use debounced version
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADLine() {
	if (isDrawingLine) {
		const entityType = "line";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1; // Changed map
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();

		if (createNewEntity) {
			entityName = getUniqueKADEntityName("lineObject");
			createNewEntity = false;
			setCurrentDrawingEntity(entityName);
		}

		const lineObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: false, // Added: lines are open
			visible: true,
		};

		// Add to allKADDrawingsMap instead
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				data: [],
				visible: true,
			});
		}
		allKADDrawingsMap.get(entityName).data.push(lineObject); // Changed map
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
}

function handleKADPolyClick(event) {
	if (isDrawingPoly) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADPoly();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	}
}
// Function to add a point to the allKADDrawingsMap
function addKADPoly() {
	if (isDrawingPoly) {
		// Create a new point object or use the existing one
		const entityType = "poly";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();
		const closed = true; // Default to closed polygon

		if (createNewEntity) {
			entityName = getUniqueKADEntityName("polyObject");
			createNewEntity = false; // Set the flag to false after creating a new entity
			setCurrentDrawingEntity(entityName);
		}

		const polyObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: closed, // Set to true if the polygon is closed
			visible: true,
		};

		// Add the point to allKADDrawingsMap
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				data: [],
				visible: true,
			});
		}
		allKADDrawingsMap.get(entityName).data.push(polyObject);
		// Add this line to update the last draw point
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
	console.log("allKADDrawingsMap: ", allKADDrawingsMap);
}

function handleKADCircleClick(event) {
	if (isDrawingCircle) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADCircle();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADCircle() {
	if (isDrawingCircle) {
		const color = getJSColorHexDrawing();
		const radius = circleRadius.value;
		const entityType = "circle";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = getUniqueKADEntityName("circleObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		const circleObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			radius: radius,
			lineWidth: lineWidth,
			color: color,
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true,
			});
		}
		allKADDrawingsMap.get(entityName).data.push(circleObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		console.log("Added circle", pointID, "to", entityName);
	}
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedUpdateTreeView();
}

function handleKADTextClick(event) {
	if (isDrawingText) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADText();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

// Enhanced function to evaluate calculations with user-friendly error handling
async function processTextCalculationWithValidation(text) {
	if (text.startsWith("=")) {
		try {
			const expression = text.substring(1); // Remove '='
			const calculatedValue = evaluate(expression);

			// Check if result is valid
			if (isNaN(calculatedValue) || !isFinite(calculatedValue)) {
				throw new Error("Result is not a valid number");
			}

			return calculatedValue.toString(); // Return the result as a string
		} catch (error) {
			// Show user-friendly error popup
			const result = await showCalculationErrorPopup(text, error.message);
			return result; // Will be either corrected text or original
		}
	}
	return text; // Return original text if not a calculation
}
//TODO use the FloatingDialog class to create this popup
// Show calculation error popup with helpful feedback
function showCalculationErrorPopup(originalText, errorMessage) {
	return new Promise((resolve) => {
		// Generate helpful error message
		let helpfulMessage = "Unknown calculation error";
		let suggestions = "";

		if (errorMessage.includes("Unexpected token") || errorMessage.includes("Unexpected")) {
			helpfulMessage = "Invalid mathematical expression";
			suggestions = "? Check for typos in operators (+, -, *, /)<br>? Make sure parentheses are balanced<br>? Use numbers, operators, and math functions";
		} else if (errorMessage.includes("Undefined symbol") || errorMessage.includes("not defined")) {
			helpfulMessage = "Unknown variable or function";
			suggestions = "? Supported functions: sqrt, sin, cos, tan, abs, round, etc.<br>? Variables are not supported<br>? Check function spelling";
		} else if (errorMessage.includes("not a valid number")) {
			helpfulMessage = "Calculation result is invalid";
			suggestions = "? Check for division by zero<br>? Ensure the result is a finite number";
		} else {
			suggestions = "? Use format: =5+3 or =sqrt(16)<br>? Supported: +, -, *, /, (), sqrt, sin, cos, etc.<br>? Check for syntax errors";
		}

		// Step 1) Create content with error details using inline styles for dark mode
		const textColor = darkModeEnabled ? "#ffffff" : "#000000";
		const content = `
			<div style="text-align: center;">
				<label style="color: ${textColor}; font-size: 16px; font-weight: bold;"><strong>Formula:</strong> ${originalText}</label><br><br>
				<label style="color: ${textColor}; font-size: 14px; font-weight: bold;"><strong>Error:</strong> ${helpfulMessage}</label><br><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Suggestions:</strong></label><br>
				<div style="text-align: center; margin: 10px 20px;">
					<label style="color: ${textColor}; font-size: 10px;">${suggestions}</label>
				</div><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Examples:</strong></label><br>
				<label style="color: ${textColor}; font-size: 10px;">=5+3 ? 8</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=10*2.5 ? 25</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=(100+50)/2 ? 75</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=sqrt(16) ? 4</label>
			</div>
		`;

		// Step 2) Create FloatingDialog with three buttons
		const dialog = new FloatingDialog({
			title: "Calculation Error",
			content: content,
			width: 400,
			height: 300,
			showConfirm: true,
			showCancel: true,
			showDeny: false,
			showOption1: true, // Enable the third button
			showOption2: false,
			confirmText: "Fix It",
			cancelText: "Cancel",
			option1Text: "As Text", // Third button
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior
			layoutType: "default",
			onConfirm: () => {
				// Step 3) User wants to fix it - keep the text field focused for editing
				console.log("Calculation error dialog - Fix It selected");
				dialog.close();
				resolve(null); // Signal to not save and let user edit
			},
			onCancel: () => {
				// Step 4) User cancelled - don't save anything
				console.log("Calculation error dialog - Cancel selected");
				dialog.close();
				resolve(null);
			},
			onOption1: () => {
				// Step 5) User wants to use as regular text (remove the = sign)
				console.log("Calculation error dialog - As Text selected");
				dialog.close();
				resolve(originalText.substring(1)); // Remove = and store as plain text
			},
		});

		// Step 6) Show the dialog
		dialog.show();
	});
}

async function addKADText() {
	console.log("=== addKADText() called ===");
	console.log("createNewEntity:", createNewEntity);
	console.log("current entityName:", entityName);
	console.log("isDrawingText:", isDrawingText);

	if (isDrawingText) {
		// Get the text value from the input field
		let text = document.getElementById("drawingText").value.trim();

		// Check if text is blank and warn user
		if (text === "") {
			showModalMessage("No Text Entered", "Please enter text in the drawing tools text area.", "warning");
			return;
		}

		// ? ADD THIS: Process calculations if text starts with "="
		const processedText = await processTextCalculationWithValidation(text);

		// If processedText is null, user cancelled or wants to edit - return without saving
		if (processedText === null) {
			return;
		}

		// Use the processed text (either calculated result or original text)
		text = processedText;

		const color = getJSColorHexDrawing();
		const entityType = "text";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		// Step 17.6a) Use worldZ for snapping like other KAD tools
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;

		console.log("Before entity creation check:");
		console.log("  createNewEntity:", createNewEntity);
		console.log("  entityName:", entityName);
		console.log("  allKADDrawingsMap.has(entityName):", allKADDrawingsMap.has(entityName));

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			console.log("Creating new entity...");
			entityName = getUniqueKADEntityName("textObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
			console.log("New entityName:", entityName);
		} else {
			console.log("Using existing entityName:", entityName);
		}

		const textObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			text: text, // ? Now using the processed text
			color: color,
			fontHeight: 12, // Step B1) Default fontHeight for new text entities
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			console.log("Creating new map entry for:", entityName);
			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				data: [],
				visible: true,
			});
		} else {
			console.log("Using existing map entry for:", entityName);
			console.log("Existing entity type:", allKADDrawingsMap.get(entityName).entityType);
		}

		allKADDrawingsMap.get(entityName).data.push(textObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		drawData(allBlastHoles, selectedHole);
		debouncedUpdateTreeView();
		console.log("Added text", pointID, "to", entityName);
		console.log("Final entity type:", allKADDrawingsMap.get(entityName).entityType);
		debouncedSaveKAD();
	}
}
// Using SweetAlert Library Create a popup that gets input from the user.
//TODO use the FloatingDialog class to create this popup
//Add a column selections system to be able to select the manny attributes of the AQM file
//Ignore, Angle, Azimuth, Instruction, Diameter, Material Type, Name, Blast, Pattern, Easting, Northing, Elevation
//Eleven Possible columns
function saveAQMPopup() {
	// ? Filter points first
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);
	if (visibleBlastHoles.length === 0) {
		showModalMessage("No Visible Holes", "There are no visible holes to export.", "warning");
		return;
	}
	const savedAQMPopupSettings = JSON.parse(localStorage.getItem("savedAQMPopupSettings")) || {};
	let blastNameFromVisibleBlastHoles = visibleBlastHoles[0].entityName;
	console.log("blastName: " + blastNameFromVisibleBlastHoles);
	Swal.fire({
		title: "Export AQM file?",
		showCancelButton: true,
		confirmButtonText: "Confirm",
		cancelButtonText: "Cancel",
		html: `
            <div class="button-container-2col">
                <label class="labelWhite15" for="fileName">File Name</label>
                <input type="text" id="fileName" value="${blastNameFromVisibleBlastHoles}_AQM" placeholder="File Name"/>
				<label class="labelWhite15" for="blastName">Blast Name</label>
                <input type="text" id="blastName" value="${blastNameFromVisibleBlastHoles}" placeholder="Blast Name"/>
				<label class="labelWhite15" for="patternName">Pattern Name</label>
                <input type="text" id="patternName" value="${blastNameFromVisibleBlastHoles}" placeholder="Pattern Name"/>
				<label class="labelWhite15" for="materialType">Material Type</label>
				<input type="text" id="materialType" placeholder="Material Type" value="Material"/>
				<label class="labelWhite15" for="Instruction">Instruction</label>
				<input type="text" id="instruction" placeholder="Instruction" value="Instruction" />
            </div>
			<label class="labelWhite12">AQM file outputs Select the column order below:</label><br>
			<div class="button-container-2col">
				<label class="labelWhite12">Use hole type as instruction:</label>
				<input type="checkbox" id="useHoleTypeAsInstruction" name="useHoleTypeAsInstruction" value="useHoleTypeAsInstruction">
				<label class="labelWhite12">Write Ignore Columns:</label>
				<input type="checkbox" id="writeIgnoreColumn" name="writeIgnoreColumn" value="writeIgnoreColumn" checked="true">
				<label class="labelWhite12">Column 1:</label>
				<select id="column1Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast" selected>Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern" selected>Pattern</option>
				</select>
				<label class="labelWhite12">Column 2:</label>
				<select id="column2Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast" selected>Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 3:</label>
				<select id="column3Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name" selected>Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 4:</label>
				<select id="column4Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting" selected>Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 5:</label>
				<select id="column5Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing" selected>Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 6:</label>
				<select id="column6Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation" selected>Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 7:</label>
				<select id="column7Dropdown">
					<option value="Angle" selected>Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 8:</label>
				<select id="column8Dropdown">	
					<option value="Angle">Angle</option>
					<option value="Azimuth" selected>Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 9:</label>
				<select id="column9Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter" selected>Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 10:</label>
				<select id="column10Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction" selected>Instruction</option>
					<option value="Material Type">Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
				<label class="labelWhite12">Column 11:</label>
				<select id="column11Dropdown">
					<option value="Angle">Angle</option>
					<option value="Azimuth">Azimuth</option>
					<option value="Blast">Blast</option>
					<option value="Diameter">Diameter</option>
					<option value="Easting">Easting</option>
					<option value="Elevation">Elevation</option>
					<option value="Ignore">Ignore</option>
					<option value="Instruction">Instruction</option>
					<option value="Material Type" selected>Material Type</option>
					<option value="Name">Name</option>
					<option value="Northing">Northing</option>
					<option value="Pattern">Pattern</option>
				</select>
			</div>
        `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon",
		},
		preConfirm: () => {
			// Get user input values
			const fileNameInput = document.getElementById("fileName");
			const blastNameInput = document.getElementById("blastName");
			const patternNameInput = document.getElementById("patternName");
			const materialTypeInput = document.getElementById("materialType");
			const instructionInput = document.getElementById("instruction");
			const useHoleTypeAsInstructionInput = document.getElementById("useHoleTypeAsInstruction");
			const writeIgnoreColumnInput = document.getElementById("writeIgnoreColumn");
			const column1Dropdown = document.getElementById("column1Dropdown");
			const column2Dropdown = document.getElementById("column2Dropdown");
			const column3Dropdown = document.getElementById("column3Dropdown");
			const column4Dropdown = document.getElementById("column4Dropdown");
			const column5Dropdown = document.getElementById("column5Dropdown");
			const column6Dropdown = document.getElementById("column6Dropdown");
			const column7Dropdown = document.getElementById("column7Dropdown");
			const column8Dropdown = document.getElementById("column8Dropdown");
			const column9Dropdown = document.getElementById("column9Dropdown");
			const column10Dropdown = document.getElementById("column10Dropdown");
			const column11Dropdown = document.getElementById("column11Dropdown");

			const fileNameValue = fileNameInput.value;
			const blastName = blastNameInput.value;
			const patternName = patternNameInput.value;
			const materialType = materialTypeInput.value;
			const instruction = instructionInput.value;
			const useHoleTypeAsInstruction = useHoleTypeAsInstructionInput.checked;
			const writeIgnoreColumn = writeIgnoreColumnInput.checked;

			const column1Value = column1Dropdown.value;
			const column2Value = column2Dropdown.value;
			const column3Value = column3Dropdown.value;
			const column4Value = column4Dropdown.value;
			const column5Value = column5Dropdown.value;
			const column6Value = column6Dropdown.value;
			const column7Value = column7Dropdown.value;
			const column8Value = column8Dropdown.value;
			const column9Value = column9Dropdown.value;
			const column10Value = column10Dropdown.value;
			const column11Value = column11Dropdown.value;

			// Create the column order array
			let columnOrderArray = [column1Value, column2Value, column3Value, column4Value, column5Value, column6Value, column7Value, column8Value, column9Value, column10Value, column11Value];
			// Save the selected settings to localStorage
			savedAQMPopupSettings.fileNameValue = fileNameValue;
			savedAQMPopupSettings.blastName = blastName;
			savedAQMPopupSettings.patternName = patternName;
			savedAQMPopupSettings.materialType = materialType;
			savedAQMPopupSettings.instruction = instruction;
			savedAQMPopupSettings.useHoleTypeAsInstruction = useHoleTypeAsInstruction;
			savedAQMPopupSettings.writeIgnoreColumn = writeIgnoreColumn;
			savedAQMPopupSettings.columnOrderArray = columnOrderArray;
			localStorage.setItem("savedAQMPopupSettings", JSON.stringify(savedAQMPopupSettings));
		},
	}).then((result) => {
		if (result.isConfirmed) {
			// Get user input values
			const fileNameInput = document.getElementById("fileName");
			const fileNameValue = fileNameInput.value;
			const blastNameInput = document.getElementById("blastName");
			const blastName = blastNameInput.value;
			const patternNameInput = document.getElementById("patternName");
			const patternName = patternNameInput.value;
			const materialTypeInput = document.getElementById("materialType");
			const materialType = materialTypeInput.value;
			const instructionInput = document.getElementById("instruction");
			const instruction = instructionInput.value;
			if (fileNameValue === "") {
				// Show an alert to the user with a customized error button
				Swal.fire({
					title: "File Name is Null or Invalid",
					icon: "error",
					showCancelButton: false,
					confirmButtonText: "Error",
					customClass: {
						container: "custom-popup-container",
						title: "swal2-title",
						confirmButton: "cancel",
						content: "swal2-content",
						htmlContainer: "swal2-html-container",
						icon: "swal2-icon",
					},
				});
				return; // Exit the function
			}
			let useHoleTypeAsInstruction = document.getElementById("useHoleTypeAsInstruction").checked;
			let writeIgnoreColumn = document.getElementById("writeIgnoreColumn").checked;
			// Get selected values from the dropdowns
			const column1Dropdown = document.getElementById("column1Dropdown");
			const column2Dropdown = document.getElementById("column2Dropdown");
			const column3Dropdown = document.getElementById("column3Dropdown");
			const column4Dropdown = document.getElementById("column4Dropdown");
			const column5Dropdown = document.getElementById("column5Dropdown");
			const column6Dropdown = document.getElementById("column6Dropdown");
			const column7Dropdown = document.getElementById("column7Dropdown");
			const column8Dropdown = document.getElementById("column8Dropdown");
			const column9Dropdown = document.getElementById("column9Dropdown");
			const column10Dropdown = document.getElementById("column10Dropdown");
			const column11Dropdown = document.getElementById("column11Dropdown");
			const column1Value = column1Dropdown.value;
			const column2Value = column2Dropdown.value;
			const column3Value = column3Dropdown.value;
			const column4Value = column4Dropdown.value;
			const column5Value = column5Dropdown.value;
			const column6Value = column6Dropdown.value;
			const column7Value = column7Dropdown.value;
			const column8Value = column8Dropdown.value;
			const column9Value = column9Dropdown.value;
			const column10Value = column10Dropdown.value;
			const column11Value = column11Dropdown.value;
			// Create the column order array
			let columnOrderArray = [column1Value, column2Value, column3Value, column4Value, column5Value, column6Value, column7Value, column8Value, column9Value, column10Value, column11Value];
			// Convert the points to a CSV string using the selected column orders
			let aqm = convertPointsToAQMCSV(visibleBlastHoles, fileNameValue, blastName, patternName, materialType, instruction, useHoleTypeAsInstruction, writeIgnoreColumn, columnOrderArray);
			if (isIOS()) {
				// Create a Blob with the XML data
				const blob = new Blob([aqm], {
					type: "text/csv;charset=utf-8",
				});
				// Create a URL for the Blob
				const url = URL.createObjectURL(blob);
				// Create an anchor element with the download link
				const link = document.createElement("a");
				link.href = url;
				link.download = fileNameValue + ".aqm";
				link.textContent = "Click here to download";
				// Append the link to the document
				document.body.appendChild(link);
				// Programmatically trigger the click event on the link
				link.click();
				// Remove the link from the document
				document.body.removeChild(link);
			} else {
				// Create an invisible anchor element
				const link = document.createElement("a");
				link.style.display = "none";

				// Set the XML content as the "href" attribute
				link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(aqm);
				link.download = fileNameValue + ".aqm";

				// Append the link to the document
				document.body.appendChild(link);

				// Programmatically trigger the click event on the link
				link.click();

				// Remove the link from the document
				document.body.removeChild(link);
			}
		}
	});
	// Populate form fields with saved settings
	const fileNameInput = document.getElementById("fileName");
	const blastNameInput = document.getElementById("blastName");
	const patternNameInput = document.getElementById("patternName");
	const materialTypeInput = document.getElementById("materialType");
	const instructionInput = document.getElementById("instruction");
	const useHoleTypeAsInstructionInput = document.getElementById("useHoleTypeAsInstruction");
	const writeIgnoreColumnInput = document.getElementById("writeIgnoreColumn");
	const column1Dropdown = document.getElementById("column1Dropdown");
	const column2Dropdown = document.getElementById("column2Dropdown");
	const column3Dropdown = document.getElementById("column3Dropdown");
	const column4Dropdown = document.getElementById("column4Dropdown");
	const column5Dropdown = document.getElementById("column5Dropdown");
	const column6Dropdown = document.getElementById("column6Dropdown");
	const column7Dropdown = document.getElementById("column7Dropdown");
	const column8Dropdown = document.getElementById("column8Dropdown");
	const column9Dropdown = document.getElementById("column9Dropdown");
	const column10Dropdown = document.getElementById("column10Dropdown");
	const column11Dropdown = document.getElementById("column11Dropdown");
	// Add more dropdown elements as needed

	fileNameInput.value = savedAQMPopupSettings.fileNameValue || "";
	blastNameInput.value = savedAQMPopupSettings.blastName || "";
	patternNameInput.value = savedAQMPopupSettings.patternName || "";
	materialTypeInput.value = savedAQMPopupSettings.materialType || "";
	instructionInput.value = savedAQMPopupSettings.instruction || "";
	useHoleTypeAsInstructionInput.checked = savedAQMPopupSettings.useHoleTypeAsInstruction || false;
	writeIgnoreColumnInput.checked = savedAQMPopupSettings.writeIgnoreColumn || true;
	column1Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[0] : "Pattern";
	column2Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[1] : "Blast";
	column3Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[2] : "Name";
	column4Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[3] : "Easting";
	column5Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[4] : "Northing";
	column6Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[5] : "Elevation";
	column7Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[6] : "Angle";
	column8Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[7] : "Azimuth";
	column9Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[8] : "Diameter";
	column10Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[9] : "Instruction";
	column11Dropdown.value = savedAQMPopupSettings.columnOrderArray ? savedAQMPopupSettings.columnOrderArray[10] : "Material Type";
	// Set values for more dropdowns as needed
}

//TODO use the FloatingDialog class to create this popup
// Using SweetAlert Library Create a popup that gets input from the user.
// Updated addHolePopup function with proper field handling
function addHolePopup() {
	// Moved to src/dialog/popups/generic/AddHoleDialog.js
	window.showAddHoleDialog();
}

function handlePatternAddingClick(event) {
	if (isAddingPattern) {
		// Get the click/touch coordinates relative to the canvas
		//const rect = canvas.getBoundingClientRect();
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addPatternPopup(parseFloat(worldX.toFixed(3)), parseFloat(worldY.toFixed(3)));
		//console.log("worldX: " + worldX + " worldY: " + worldY);
	} else {
		worldX = null;
		worldY = null;
	}
}
//TODO use the FloatingDialog class to create this popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
function addPatternPopup(worldX, worldY) {
	window.showPatternDialog("add_pattern", worldX, worldY);
}

// Same Space Checker
function checkHoleProximity(newX, newY, newDiameter, existingHoles) {
	// Use 0.1m for dummy holes or holes with no diameter
	const checkDiameter = newDiameter || 0.1;
	const minDistance = checkDiameter / 1000; // Convert mm to meters, 1 diameter minimum

	const proximityHoles = [];

	for (let i = 0; i < existingHoles.length; i++) {
		const existingHole = existingHoles[i];
		const existingDiameter = existingHole.holeDiameter || 0.1;
		const existingMinDistance = existingDiameter / 1000;

		// Calculate distance between hole centers
		const distance = Math.sqrt(Math.pow(newX - existingHole.startXLocation, 2) + Math.pow(newY - existingHole.startYLocation, 2));

		// Check if holes are too close (less than 1 diameter apart)
		const combinedMinDistance = Math.max(minDistance, existingMinDistance);
		if (distance < combinedMinDistance) {
			proximityHoles.push({
				hole: existingHole,
				distance: distance,
				requiredDistance: combinedMinDistance,
			});
		}
	}

	return proximityHoles;
}

// Step 1) Function to show proximity warning and get user decision
// Converted to FloatingDialog class - returns Promise matching Swal result format
function showProximityWarning(proximityHoles, newHoleInfo) {
	// Step 1a) Build hole list for display
	const holeList = proximityHoles.map((ph) => "‚Ä¢ " + ph.hole.entityName + ":" + ph.hole.holeID + " (" + ph.distance.toFixed(3) + "m apart, need " + ph.requiredDistance.toFixed(3) + "m)").join("\n");

	// Step 1b) Create content div with proper styling
	const contentDiv = document.createElement("div");
	contentDiv.style.textAlign = "left";
	contentDiv.style.maxHeight = "300px";
	contentDiv.style.overflowY = "auto";
	contentDiv.style.padding = "10px";

	// Step 1c) Detect dark mode for text color
	const darkModeEnabled = typeof window.darkModeEnabled !== "undefined" ? window.darkModeEnabled : false;
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	// Step 1d) Create warning header
	const warningHeader = document.createElement("p");
	warningHeader.style.fontWeight = "bold";
	warningHeader.style.marginBottom = "10px";
	warningHeader.style.color = textColor;
	warningHeader.textContent = "New hole would be too close to existing holes:";
	contentDiv.appendChild(warningHeader);

	// Step 1e) Create new hole info paragraph
	const newHolePara = document.createElement("p");
	newHolePara.style.marginBottom = "10px";
	newHolePara.style.color = textColor;
	newHolePara.textContent = "New hole: " + newHoleInfo.entityName + ":" + newHoleInfo.holeID + " at (" + newHoleInfo.x.toFixed(3) + ", " + newHoleInfo.y.toFixed(3) + ")";
	contentDiv.appendChild(newHolePara);

	// Step 1f) Create conflicting holes header
	const conflictingHeader = document.createElement("p");
	conflictingHeader.style.fontWeight = "bold";
	conflictingHeader.style.marginTop = "15px";
	conflictingHeader.style.marginBottom = "10px";
	conflictingHeader.style.color = textColor;
	conflictingHeader.textContent = "Conflicting holes:";
	contentDiv.appendChild(conflictingHeader);

	// Step 1g) Create pre element for hole list with red color
	const holeListPre = document.createElement("pre");
	holeListPre.style.fontSize = "12px";
	holeListPre.style.color = "#ff6b6b";
	holeListPre.style.marginBottom = "15px";
	holeListPre.style.whiteSpace = "pre-wrap";
	holeListPre.textContent = holeList;
	contentDiv.appendChild(holeListPre);

	// Step 1h) Create options header
	const optionsHeader = document.createElement("p");
	optionsHeader.style.fontWeight = "bold";
	optionsHeader.style.marginTop = "15px";
	optionsHeader.style.marginBottom = "10px";
	optionsHeader.style.color = textColor;
	optionsHeader.textContent = "Options:";
	contentDiv.appendChild(optionsHeader);

	// Step 1i) Create options list
	const optionsList = document.createElement("ul");
	optionsList.style.textAlign = "left";
	optionsList.style.paddingLeft = "20px";
	optionsList.style.marginBottom = "10px";
	optionsList.style.color = textColor;

	const skipLi = document.createElement("li");
	skipLi.innerHTML = "<strong>Skip:</strong> Skip this hole and continue with pattern";
	optionsList.appendChild(skipLi);

	const ignoreLi = document.createElement("li");
	ignoreLi.innerHTML = "<strong>Ignore Warning:</strong> Add this hole and continue adding others";
	optionsList.appendChild(ignoreLi);

	const cancelLi = document.createElement("li");
	cancelLi.innerHTML = "<strong>Cancel:</strong> Cancel the entire operation";
	optionsList.appendChild(cancelLi);

	contentDiv.appendChild(optionsList);

	// Step 1j) Return Promise matching Swal result format
	// Also set up theme change listener for font responsiveness
	return new Promise((resolve) => {
		const dialog = new window.FloatingDialog({
			title: "Hole Proximity Warning",
			content: contentDiv,
			width: 400,
			height: 350,
			layoutType: "default",
			draggable: true,
			resizable: true,
			closeOnOutsideClick: false, // Modal behavior - prevent clicks outside
			showConfirm: true,
			showCancel: true,
			showDeny: true, // Enable Ignore Warning button
			showOption1: false,
			showOption2: false,
			confirmText: "Skip", // Skip is the default safe choice - primary green button
			cancelText: "Cancel",
			denyText: "Ignore Warning", // Ignore Warning is dangerous - orange deny button
			onConfirm: () => {
				// Step 1k) User chose Skip - skip this hole and continue with pattern (safe default)
				console.log("Proximity warning: User chose Skip");
				cleanupThemeListener();
				dialog.close();
				resolve({
					isConfirmed: false,
					isDenied: true, // Skip maps to isDenied (safe action)
					isDismissed: false
				});
			},
			onDeny: () => {
				// Step 1l) User chose Ignore Warning - add this hole and continue (dangerous action)
				console.log("Proximity warning: User chose Ignore Warning");
				cleanupThemeListener();
				dialog.close();
				resolve({
					isConfirmed: true, // Ignore Warning maps to isConfirmed (dangerous action)
					isDenied: false,
					isDismissed: false
				});
			},
			onCancel: () => {
				// Step 1m) User chose Cancel - cancel the entire operation
				// CRITICAL: Set flag IMMEDIATELY (synchronously) before Promise resolves
				// This ensures pattern generation loops can check it before they complete
				console.log("Proximity warning: User chose Cancel");
				cleanupThemeListener();

				// Set cancellation flag immediately so pattern generation loops can check it
				window.holeGenerationCancelled = true;

				dialog.close();
				// Resolve the promise with cancellation flag
				resolve({
					isConfirmed: false,
					isDenied: false,
					isDismissed: true,
					cancelled: true // Special flag for cancellation
				});
			}
		});

		// Step 1n) Function to update text colors based on theme
		const updateTextColors = () => {
			const darkModeEnabled = typeof window.darkModeEnabled !== "undefined" ? window.darkModeEnabled : false;
			const textColor = darkModeEnabled ? "#ffffff" : "#000000";

			// Update all text elements
			const textElements = contentDiv.querySelectorAll("p, li");
			textElements.forEach((el) => {
				// Don't override red color for conflicting holes list
				if (!el.textContent.includes("m apart")) {
					el.style.color = textColor;
				}
			});
		};

		// Step 1o) Set up theme change listener
		let themeListener = null;
		if (typeof window.addEventListener !== "undefined") {
			// Listen for custom theme change events or check periodically
			themeListener = () => {
				updateTextColors();
			};

			// Check if there's a theme change event we can listen to
			// Otherwise, we'll check on a timer
			const checkTheme = setInterval(() => {
				updateTextColors();
			}, 500);

			// Store interval ID for cleanup
			dialog._themeCheckInterval = checkTheme;
		}

		// Step 1p) Cleanup function
		const cleanupThemeListener = () => {
			if (dialog._themeCheckInterval) {
				clearInterval(dialog._themeCheckInterval);
				dialog._themeCheckInterval = null;
			}
		};

		// Step 1q) Set higher z-index to ensure proximity warning appears on top of success dialogs
		// FloatingDialog defaults to 10000, we need higher priority for warnings
		if (dialog.element) {
			dialog.element.style.zIndex = "15000";
		}

		// Step 1r) Show the dialog
		dialog.show();

		// Step 1s) Ensure z-index is set after show() in case element wasn't created yet
		setTimeout(() => {
			if (dialog.element) {
				dialog.element.style.zIndex = "15000";
			}
			// Initial color update
			updateTextColors();
		}, 0);
	});
}

// Function to generate the pattern of holes
// added rowid and posid 14 july 2025
function addPattern(offset, entityName, nameTypeIsNumerical, useGradeZ, rowOrientation, x, y, z, gradeZ, diameter, type, angle, bearing, length, subdrill, burden, spacing, rows, holesPerRow) {
	let entityType = "hole";
	let useGradeToCalcLength = useGradeZ;
	let startXLocation = parseFloat(x);
	let startYLocation = parseFloat(y);
	let startZLocation = parseFloat(z);
	// Step 1) Calculate gradeZLocation based on mode
	// If useGradeZ: use the user-provided gradeZ directly
	// Otherwise: calculate from length and subdrill
	let gradeZLocation = useGradeToCalcLength ? parseFloat(gradeZ) : parseFloat(startZLocation - (length - subdrill) * Math.cos(angle * (Math.PI / 180)));
	// Step 2) Calculate hole length (bench height - collar to grade)
	// BUG FIX 2025-12-28: When using gradeZ, calculate bench height as (CollarZ - GradeZ) / cos(angle)
	// Previously was calculating total length which caused subdrill to be counted twice
	let angleRad = parseFloat(angle) * (Math.PI / 180);
	let cosAngle = Math.cos(angleRad);
	// Protect against division by zero for horizontal holes
	if (Math.abs(cosAngle) < 0.001) cosAngle = 0.001;
	let holeLength = useGradeToCalcLength ? parseFloat((startZLocation - gradeZLocation) / cosAngle) : parseFloat(length);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let subdrillAmount = parseFloat(subdrill);
	let patternburden = parseFloat(burden);
	let patternspacing = parseFloat(spacing);
	let patternrows = parseInt(rows);
	let patternholesPerRow = parseInt(holesPerRow);
	let patternoffset = parseFloat(offset);
	let patternnameTypeIsNumerical = nameTypeIsNumerical;
	let patternrowOrientation = parseFloat((90 - rowOrientation) * (Math.PI / 180));

	let referenceX = startXLocation;
	let referenceY = startYLocation;

	let currentLetter = "A";
	let globalHoleCounter = allBlastHoles.length > 0 ? Math.max(...allBlastHoles.map((h) => parseInt(h.holeID) || 0)) + 1 : 1;

	// Get the starting rowID for this pattern
	const startingRowID = getNextRowID(entityName);
	console.log("Starting rowID for addPattern:", startingRowID);

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	for (let i = 0; i < patternrows; i++) {
		// Check for cancellation before each row
		if (window.holeGenerationCancelled) {
			console.log("Pattern generation cancelled by user");
			break;
		}

		// Each pattern row gets its own rowID
		const currentRowID = startingRowID + i;

		for (let j = 0; j < patternholesPerRow; j++) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user");
				break;
			}
			const relativeX = j * patternspacing;
			const relativeY = i * patternburden;

			let offsetX = 0;
			if (i % 2 === 1) {
				offsetX = patternoffset * patternspacing;
			}

			const rotatedX = (relativeX + offsetX) * Math.cos(patternrowOrientation) - relativeY * Math.sin(patternrowOrientation);
			const rotatedY = (relativeX + offsetX) * Math.sin(patternrowOrientation) + relativeY * Math.cos(patternrowOrientation);

			const finalX = referenceX + rotatedX;
			const finalY = referenceY + rotatedY;

			let holeID;
			const useCustomHoleID = true;

			if (!patternnameTypeIsNumerical) {
				holeID = currentLetter + (j + 1);
			} else {
				holeID = globalHoleCounter.toString();
				globalHoleCounter++;
			}

			// Position ID is sequential for each hole in this row (j + 1)
			const posID = j + 1;

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user - stopping hole addition");
				break;
			}

			addHole(useCustomHoleID, useGradeZ, entityName, holeID, parseFloat(finalX), parseFloat(finalY), parseFloat(startZLocation), parseFloat(gradeZLocation), parseFloat(holeDiameter), holeType, parseFloat(holeLength), parseFloat(subdrillAmount), parseFloat(holeAngle), parseFloat(holeBearing), currentRowID, posID, patternburden, patternspacing);
		}

		// Increment the current letter for the next row ONLY IF alphanumeric naming is used
		if (!patternnameTypeIsNumerical) {
			if (currentLetter === "Z") {
				currentLetter = "AA";
			} else if (currentLetter === "ZZ") {
				currentLetter = "AAA";
			} else {
				currentLetter = incrementLetter(currentLetter);
			}
		}
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Reset the pattern adding state
	isAddingPattern = false;
	addPatternSwitch.checked = false;
	resetZoom();
	drawData(allBlastHoles, selectedHole);

	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	} else if (typeof updateTreeView === "function") {
		updateTreeView();
	}

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated pattern with " + patternrows + " rows (rowIDs " + startingRowID + "-" + (startingRowID + patternrows - 1) + ")");
	}
}

// Expose addPattern globally for PatternGenerationDialogs.js
window.addPattern = addPattern;
// Expose functions globally for AddHoleDialog.js
window.addHole = addHole;
window.checkHoleProximity = checkHoleProximity;
window.showProximityWarning = showProximityWarning;
// Expose world coordinate variables globally for AddHoleDialog.js
window.worldX = worldX;
window.worldY = worldY;
window.worldZ = worldZ;

function incrementLetter(str) {
	// Helper function to increment letters
	const lastIndex = str.length - 1;
	let carry = false;
	const newStr = str
		.split("")
		.reverse()
		.map((char, index) => {
			if (index === 0 || carry) {
				if (char === "Z") {
					carry = true;
					return "A";
				} else {
					carry = false;
					return String.fromCharCode(char.charCodeAt(0) + 1);
				}
			} else {
				return char;
			}
		})
		.reverse()
		.join("");
	if (carry) {
		return "A" + newStr;
	}
	return newStr;
}

function setMeasuredDate() {
	const date = new Date();
	const day = date.getDate();
	const month = date.getMonth() + 1;
	const year = date.getFullYear();
	const hours = date.getHours();
	const minutes = date.getMinutes();
	const seconds = date.getSeconds();
	return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
}

function handleBlastNameClick(event) {
	if (isBlastNameEditing) {
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && editBlastNameSwitch.checked == false) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (clickedHole && editBlastNameSwitch.checked == true) {
			editBlastNamePopup(selectedHole);
		}
	}

	clickedHole = null;
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	isBlastNameEditing = false;
	editBlastNameSwitch.checked = false;
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView(); // Use debounced version
}

// IMPORTANT IMPLEMENTING A ROW ID AND POS ID FOR BLASTHOLES THIS WILL HELP WITH ORDERING
// Helper function to get the next rowID for a given entityName
function getNextRowID(entityName) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest rowID for this entityName
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);
	if (entityHoles.length === 0) {
		return 1;
	}

	let maxRowID = 0;
	entityHoles.forEach((hole) => {
		if (hole.rowID && !isNaN(hole.rowID)) {
			maxRowID = Math.max(maxRowID, parseInt(hole.rowID));
		}
	});

	return maxRowID + 1;
}

// Helper function to get the next posID for a given entityName and rowID
function getNextPosID(entityName, rowID) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest posID for this entityName and rowID
	const rowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID);

	if (rowHoles.length === 0) {
		return 1;
	}

	let maxPosID = 0;
	rowHoles.forEach((hole) => {
		if (hole.posID && !isNaN(hole.posID)) {
			maxPosID = Math.max(maxPosID, parseInt(hole.posID));
		}
	});

	return maxPosID + 1;
}

/**
 * Add hole to the allBlastHoles array popup using sweetalert and then draw the allBlastHoles
 * @param {boolean} useCustomHoleID - If true, use the custom hole ID
 * @param {boolean} useGradeZ - If true, use grade Z instead of length
 * @param {string} entityName - The name of the entity
 * @param {number} holeID - The ID of the hole
 * @param {number} startXLocation - The X location of the start of the hole
 * @param {number} startYLocation - The Y location of the start of the hole
 * @param {number} startZLocation - The Z location of the start of the hole
 * @param {number} gradeZLocation - The Z location of the grade of the hole
 * @param {number} diameter - The diameter of the hole
 * @param {string} type - The type of the hole
 * @param {number} length - The length of the hole
 * @param {number} subdrill - The subdrill of the hole
 * @param {number} angle - The angle of the hole
 * @param {number} bearing - The bearing of the hole
 * @param {number} rowID - The row ID (Vulcan-style organization)
 * @param {number} posID - The position ID within the row (Vulcan-style organization)
 * @param {number} burden - The burden of the hole
 * @param {number} spacing - The spacing of the hole
 *
 */
function addHole(useCustomHoleID, useGradeZ, entityName, holeID, startXLocation, startYLocation, startZLocation, gradeZLocation, diameter, type, length, subdrill, angle, bearing, rowID = null, posID = null, burden, spacing) {
	if (typeof entityName === "string" && entityName.trim() !== "") {
		entityName = entityName.trim();
	} else {
		entityName = "undefined";
	}
	const entityType = "hole";

	// Initialize allBlastHoles as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	// Auto-assign rowID and posID if not provided (for individual hole creation)
	if (rowID === null) {
		rowID = getNextRowID(entityName);
	}
	if (posID === null) {
		posID = getNextPosID(entityName, rowID);
	}

	let newHoleID = null;
	if (useCustomHoleID === true) {
		// CRITICAL: Check for duplicate hole ID before using the custom ID
		const originalHoleID = holeID.toString();
		newHoleID = validateUniqueHoleID(entityName, originalHoleID);

		if (newHoleID !== originalHoleID) {
			console.warn("‚ö†Ô∏è Duplicate hole ID detected during addHole:", entityName + ":" + originalHoleID, "? Auto-assigned:", newHoleID);
		}
	} else if (useCustomHoleID === false) {
		if (allBlastHoles !== null) {
			newHoleID = allBlastHoles.length + 1;
		} else {
			newHoleID = 1;
		}
	} else {
		newHoleID = 9999;
	}

	// Parse values first
	startXLocation = parseFloat(startXLocation);
	startYLocation = parseFloat(startYLocation);
	startZLocation = parseFloat(startZLocation);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeLengthCalculated = parseFloat(length);
	let subdrillAmount = parseFloat(subdrill);
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let connectorCurve = 0;

	// Handle NaN values
	if (isNaN(holeAngle)) {
		holeAngle = 0;
	}
	if (isNaN(holeBearing)) {
		holeBearing = 0;
	}

	// Calculate length from gradeZ if length is null and useGradeZ is true
	if (useGradeZ && isNaN(holeLengthCalculated) && !isNaN(parseFloat(gradeZLocation))) {
		let deltaZ = startZLocation - parseFloat(gradeZLocation);
		holeLengthCalculated = Math.abs(deltaZ / Math.cos(holeAngle * (Math.PI / 180)));
	}

	// Calculate gradeZLocation from length - subdrill if gradeZLocation is null
	if (useGradeZ && isNaN(parseFloat(gradeZLocation)) && !isNaN(holeLengthCalculated)) {
		gradeZLocation = startZLocation - (holeLengthCalculated - subdrillAmount) * Math.cos(holeAngle * (Math.PI / 180));
	}

	// Set default length to 0 if both length and gradeZ are null
	if (isNaN(holeLengthCalculated)) {
		holeLengthCalculated = 0;
	}

	// Step 2.5) Calculate angle components for geometry
	let angleRad = angle * (Math.PI / 180);
	let bearingRad = ((450 - bearing) % 360) * (Math.PI / 180);
	let cosAngle = Math.cos(angleRad);
	let sinAngle = Math.sin(angleRad);

	// Step 2.6) Calculate benchHeight from gradeZ or holeLengthCalculated
	// benchHeight is the VERTICAL distance from collar to grade
	let benchHeight;
	if (useGradeZ && !isNaN(parseFloat(gradeZLocation))) {
		benchHeight = startZLocation - parseFloat(gradeZLocation);
	} else {
		benchHeight = holeLengthCalculated * cosAngle;
	}

	// Step 2.7) Calculate total hole length along axis (collar to toe)
	// This already includes subdrill when calculated from gradeZ
	let totalLength = holeLengthCalculated;

	// Step 2.8) Calculate horizontal projection for toe
	let horizontalProjection = totalLength * sinAngle;

	// Step 3) Calculate end locations (toe) using the total length
	let endXLocation = parseFloat(startXLocation + horizontalProjection * Math.cos(bearingRad));
	let endYLocation = parseFloat(startYLocation + horizontalProjection * Math.sin(bearingRad));
	let endZLocation = parseFloat(startZLocation - totalLength * cosAngle);

	// Step 3.5) Calculate grade locations using bench length only (without subdrill)
	// benchLength is the distance along the hole axis from collar to grade
	let benchLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
	let horizontalProjectionToGrade = benchLength * sinAngle;
	let gradeXLocation = parseFloat(startXLocation + horizontalProjectionToGrade * Math.cos(bearingRad));
	let gradeYLocation = parseFloat(startYLocation + horizontalProjectionToGrade * Math.sin(bearingRad));
	
	// Only overwrite gradeZLocation if useGradeZ is false (using length-based calculation)
	if (!useGradeZ) {
		gradeZLocation = parseFloat(startZLocation - benchHeight);
	}

	// Step 3.6) Calculate subdrillLength (distance along hole axis from grade to toe)
	// This is the measured length of the subdrill section
	let subdrillLength = Math.abs(cosAngle) > 1e-9 ? subdrillAmount / cosAngle : subdrillAmount;

	// Check if endXLocation, endYLocation, or endZLocation is NaN
	if (isNaN(endXLocation)) {
		endXLocation = startXLocation;
	}
	if (isNaN(endYLocation)) {
		endYLocation = startYLocation;
	}
	if (isNaN(endZLocation)) {
		endZLocation = startZLocation;
	}

	// Check if gradeXLocation, gradeYLocation, or gradeZLocation is NaN
	if (isNaN(gradeXLocation)) {
		gradeXLocation = startXLocation;
	}
	if (isNaN(gradeYLocation)) {
		gradeYLocation = startYLocation;
	}
	if (isNaN(gradeZLocation)) {
		gradeZLocation = startZLocation;
	}

	let toHoleCombinedID = entityName.toString() + ":::" + newHoleID.toString();
	let timingDelayMilliseconds = 0;
	let colorHexDecimal = "red";
	let measuredLength = 0;
	let measuredLengthTimeStamp = "09/05/1975 00:00:00";
	let measuredMass = 0;
	let measuredMassTimeStamp = "09/05/1975 00:00:00";
	let measuredComment = "None";
	let measuredCommentTimeStamp = "09/05/1975 00:00:00";

	// benchHeight already calculated above in Step 2.6
	// No need to recalculate here

	// PROXIMITY CHECK: Check for nearby holes before adding
	const proximityHoles = checkHoleProximity(startXLocation, startYLocation, holeDiameter, allBlastHoles);

	if (proximityHoles.length > 0) {
		// Show warning and get user decision
		const newHoleInfo = {
			entityName: entityName,
			holeID: newHoleID.toString(),
			x: startXLocation,
			y: startYLocation,
			diameter: holeDiameter,
		};

		showProximityWarning(proximityHoles, newHoleInfo).then((result) => {
			if (result.isConfirmed) {
				// User chose Ignore Warning - add the hole
				addHoleToAllBlastHoles(
					entityName,
					entityType,
					newHoleID,
					startXLocation,
					startYLocation,
					startZLocation,
					endXLocation,
					endYLocation,
					endZLocation,
					gradeXLocation,
					gradeYLocation,
					gradeZLocation,
					subdrillAmount,
					subdrillLength,
					benchHeight,
					holeDiameter,
					holeType,
					holeLengthCalculated,
					holeAngle,
					holeBearing,
					toHoleCombinedID,
					timingDelayMilliseconds,
					colorHexDecimal,
					measuredLength,
					measuredLengthTimeStamp,
					measuredMass,
					measuredMassTimeStamp,
					measuredComment,
					measuredCommentTimeStamp,
					rowID,
					posID,
					burden || 0,
					spacing || 0,
					connectorCurve || 0
				);
			} else if (result.isDenied) {
				// User chose Skip - don't add this hole but continue
				console.log("Skipped hole due to proximity: " + newHoleID);
			} else if (result.isDismissed || result.cancelled) {
				// User chose Cancel - flag already set synchronously in dialog onCancel handler
				// Just remove holes and save (flag was set immediately above)
				console.log("Cancelled hole generation due to proximity warning - removing holes");

				// Remove all holes added during this generation session
				if (typeof window.holeGenerationStartCount !== "undefined" && window.allBlastHoles) {
					const startCount = window.holeGenerationStartCount;
					const currentCount = window.allBlastHoles.length;
					if (currentCount > startCount) {
						console.log("Removing " + (currentCount - startCount) + " holes added during cancelled generation");
						window.allBlastHoles.splice(startCount, currentCount - startCount);
						// Save to IndexedDB to persist the removal
						if (typeof window.debouncedSaveHoles === "function") {
							window.debouncedSaveHoles();
						}
						// Redraw and update
						if (typeof window.drawData === "function") {
							window.drawData(window.allBlastHoles, window.selectedHole);
						}
						if (typeof window.debouncedUpdateTreeView === "function") {
							window.debouncedUpdateTreeView();
						}
					}
				}
			}
		}).catch((error) => {
			console.error("Error in proximity warning:", error);
		});

		return; // Exit early, let the promise handle the result
	}

	// No proximity issues - add the hole normally
	addHoleToAllBlastHoles(
		entityName,
		entityType,
		newHoleID,
		startXLocation,
		startYLocation,
		startZLocation,
		endXLocation,
		endYLocation,
		endZLocation,
		gradeXLocation,
		gradeYLocation,
		gradeZLocation,
		subdrillAmount,
		subdrillLength,
		benchHeight,
		holeDiameter,
		holeType,
		holeLengthCalculated,
		holeAngle,
		holeBearing,
		toHoleCombinedID,
		timingDelayMilliseconds,
		colorHexDecimal,
		measuredLength,
		measuredLengthTimeStamp,
		measuredMass,
		measuredMassTimeStamp,
		measuredComment,
		measuredCommentTimeStamp,
		rowID,
		posID,
		burden || 0,
		spacing || 0,
		connectorCurve || 0
	);

	if (isAddingHole && !isAddingPattern) {
		debouncedUpdateTreeView();
		drawData(allBlastHoles, selectedHole);
	}
}

// Helper function to actually add the hole to allBlastHoles array
function addHoleToAllBlastHoles(
	entityName,
	entityType,
	newHoleID,
	startXLocation,
	startYLocation,
	startZLocation,
	endXLocation,
	endYLocation,
	endZLocation,
	gradeXLocation,
	gradeYLocation,
	gradeZLocation,
	subdrillAmount,
	subdrillLength,
	benchHeight,
	holeDiameter,
	holeType,
	holeLengthCalculated,
	holeAngle,
	holeBearing,
	toHoleCombinedID,
	timingDelayMilliseconds,
	colorHexDecimal,
	measuredLength,
	measuredLengthTimeStamp,
	measuredMass,
	measuredMassTimeStamp,
	measuredComment,
	measuredCommentTimeStamp,
	rowID,
	posID,
	burden,
	spacing,
	connectorCurve
) {
	allBlastHoles.push({
		entityName: entityName,
		entityType: entityType,
		holeID: newHoleID.toString(),
		startXLocation: startXLocation,
		startYLocation: startYLocation,
		startZLocation: startZLocation,
		endXLocation: endXLocation,
		endYLocation: endYLocation,
		endZLocation: endZLocation,
		gradeXLocation: gradeXLocation,
		gradeYLocation: gradeYLocation,
		gradeZLocation: gradeZLocation,
		subdrillAmount: subdrillAmount,
		subdrillLength: subdrillLength,
		benchHeight: benchHeight,
		holeDiameter: holeDiameter,
		holeType: holeType,
		holeLengthCalculated: holeLengthCalculated,
		holeAngle: holeAngle,
		holeBearing: holeBearing,
		fromHoleID: toHoleCombinedID.toString(),
		timingDelayMilliseconds: timingDelayMilliseconds,
		colorHexDecimal: colorHexDecimal.toString(),
		measuredLength: measuredLength,
		measuredLengthTimeStamp: measuredLengthTimeStamp,
		measuredMass: measuredMass,
		measuredMassTimeStamp: measuredMassTimeStamp,
		measuredComment: measuredComment,
		measuredCommentTimeStamp: measuredCommentTimeStamp,
		visible: true,
		rowID: parseInt(rowID),
		posID: parseInt(posID),
		burden: burden,
		spacing: spacing,
		connectorCurve: connectorCurve,
	});

	//console.log("Added Hole: " + newHoleID + " (Row: " + rowID + ", Pos: " + posID + ")");
}

function handleMeasuredLengthClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredLengthTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole.holeID);
		if (clickedHole && measuredLengthSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			}
		} else if (clickedHole && measuredLengthSwitch.checked == true) {
			measuredLengthPopup();
		}
	}
}

function handleMeasuredMassClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredMassTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredMassSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredMassSwitch.checked == true) {
			measuredMassPopup();
		}
	}
}

function handleMeasuredCommentClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredCommentTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredCommentSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredCommentSwitch.checked == true) {
			measuredCommentPopup();
		}
	}
}

function handleHoleTypeEditClick(event) {
	if (isTypeEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editHoleTypePopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editHoleTypePopupSwitch.checked == true) {
			editHoleTypePopup();
		}
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editHoleTypePopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

function handleHoleLengthEditClick(event) {
	if (isLengthPopupEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editLengthPopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editLengthPopupSwitch.checked == true) {
			editHoleLengthPopup();
		}
		// Replace the problematic lines with null-safe versions:
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editLengthPopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView();
		}
	}
}

// Modified handleSelection function to support multiple KAD object selection
function handleSelection(event) {
	if (developerModeEnabled) {
		console.log("=== HANDLE SELECTION DEBUG ===");
		console.log("isSelectionPointerActive:", isSelectionPointerActive);
		console.log("event.shiftKey:", event.shiftKey);
		console.log("Click coordinates:", event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
	}

	if (isSelectionPointerActive) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Step 5) Respect radio selection mode
		const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
		const selectingKAD = selectKADRadio && selectKADRadio.checked;

		// Check if Shift key is pressed for multiple selection
		const isShiftPressed = event.shiftKey;

		// Step 6) Try Holes (only if Holes radio is selected)
		let clickedHole = null;
		if (selectingHoles) {
			clickedHole = getClickedHole(clickX, clickY);
		}

		if (clickedHole && selectingHoles && !isMultiHoleSelectionEnabled) {
			// Single hole selection
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			} else {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			}
		}

		// Step 7) Multiple holes (only if Holes radio is selected)
		let multipleClickedHoles = selectingHoles ? getMultipleClickedHoles(clickX, clickY) : [];
		if (selectingHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles];
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedMultipleKADObjects = []; // Clear multiple KAD selection
		}

		// Step 8) Try KAD objects (only if KAD radio is selected)
		let clickedKADObject = null;
		if (selectingKAD) {
			clickedKADObject = getClickedKADObject(clickX, clickY);

			if (clickedKADObject) {
				// Allow multiple selection for ALL entity types, not just poly
				if (isShiftPressed) {
					if (developerModeEnabled) {
						console.log("Shift pressed - multiple selection mode for", clickedKADObject.entityType);
					}

					// Multiple selection mode with Shift key
					const existingIndex = selectedMultipleKADObjects.findIndex(function (obj) {
						return obj.entityName === clickedKADObject.entityName && obj.entityType === clickedKADObject.entityType;
					});

					if (existingIndex === -1) {
						// Add to multiple selection
						selectedMultipleKADObjects.push(clickedKADObject);
					} else {
						// Remove from multiple selection
						selectedMultipleKADObjects.splice(existingIndex, 1);
					}

					// Clear single selection when using multiple
					selectedKADObject = null;
					selectedKADPolygon = null;
				} else {
					// Single selection - clear multiple selection
					selectedKADObject = clickedKADObject;
					selectedKADPolygon = clickedKADObject; // Maintain backward compatibility
					selectedMultipleKADObjects = [];

					const entity = getEntityFromKADObject(selectedKADObject);
					const hasMultipleElements = entity && entity.data.length > 1;

					// Step 9c) Set selectedPoint - for segments, highlight the endpoint that will be deleted
					if (clickedKADObject.selectionType === "segment" && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
						const isPoly = clickedKADObject.entityType === "poly";
						const numPoints = entity.data.length;
						const endpointIndex = isPoly ? (clickedKADObject.elementIndex + 1) % numPoints : clickedKADObject.elementIndex + 1;
						selectedPoint = entity.data[endpointIndex];
					} else {
						selectedPoint = entity.data[clickedKADObject.elementIndex];
					}
				}

				// Clear hole selections when KAD object is selected
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// Step 9) Nothing was clicked - clear all selections if not shift clicking
		if (!isShiftPressed && !clickedHole && !multipleClickedHoles.length && !clickedKADObject) {
			if (selectingKAD) {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = [];
				selectedPoint = null;
			}
			if (selectingHoles) {
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// HUD: Show selection message (consistent format for 2D/3D)
		if (selectedMultipleHoles.length > 0) {
			var holeIDs = selectedMultipleHoles.map((h) => h.holeID);
			var displayIDs = holeIDs.length > 10 ? holeIDs.slice(0, 10).join(",") + "..." : holeIDs.join(",");
			showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs + "}\nEscape key to clear Selection");
			console.log("Selected Multiple Holes:", selectedMultipleHoles);
		} else if (selectedHole) {
			showSelectionMessage("Editing Selected Hole: " + selectedHole.holeID + " in: " + selectedHole.entityName + "\nEscape key to clear Selection");
		} else if (selectedMultipleKADObjects.length > 0) {
			showSelectionMessage("Editing " + selectedMultipleKADObjects.length + " KAD objects\nEscape key to clear Selection");
			console.log("Selected Multiple KAD Objects:", selectedMultipleKADObjects);
		} else if (selectedKADObject) {
			showSelectionMessage("Editing KAD: " + selectedKADObject.entityName + "\nEscape key to clear Selection");
		} else {
			clearStatus();
		}

		// Step 10) Sync selections to TreeView
		if (typeof syncCanvasToTreeView === "function") {
			syncCanvasToTreeView();
		}

		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("Selection pointer NOT active - exiting");
	}
}

function completePolygonSelection() {
	if (!isPolygonSelectionActive || polyPointsX.length < 3) return;

	// Step 1) Remove the last moving point
	polyPointsX.pop();
	polyPointsY.pop();

	// Step 2) Clear previous selections
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	selectedHole = null; // Clear single hole selection

	// Step 3) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	// Step 4) Mutually exclusive selection logic
	if (selectingHoles) {
		// Only select holes
		allBlastHoles.forEach((hole) => {
			if (isHoleVisible(hole) && isPointInPolygon(hole.startXLocation, hole.startYLocation, polyPointsX, polyPointsY)) {
				selectedMultipleHoles.push(hole);
			}
		});
	} else if (selectingKAD) {
		// Only select KAD objects
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			if (!isEntityVisible(entityName)) continue;

			let isInsideSelection = false;

			// For all entity types, check if any point is inside the selection polygon
			for (const point of entity.data) {
				if (isPointInPolygon(point.pointXLocation, point.pointYLocation, polyPointsX, polyPointsY)) {
					isInsideSelection = true;
					break;
				}
			}

			// Additional check: if any segment intersects the selection polygon boundary
			if (!isInsideSelection && entity.data.length >= 2) {
				let numPoints = entity.data.length;
				let isClosed = entity.entityType === "poly";

				for (let i = 0; i < (isClosed ? numPoints : numPoints - 1); i++) {
					const p1x = entity.data[i].pointXLocation;
					const p1y = entity.data[i].pointYLocation;
					const p2x = entity.data[(i + 1) % numPoints].pointXLocation;
					const p2y = entity.data[(i + 1) % numPoints].pointYLocation;

					for (let j = 0; j < polyPointsX.length; j++) {
						const q1x = polyPointsX[j];
						const q1y = polyPointsY[j];
						const q2x = polyPointsX[(j + 1) % polyPointsX.length];
						const q2y = polyPointsY[(j + 1) % polyPointsY.length];

						if (lineSegmentsIntersect(p1x, p1y, p2x, p2y, q1x, q1y, q2x, q2y)) {
							isInsideSelection = true;
							break;
						}
					}
					if (isInsideSelection) break;
				}
			}

			if (isInsideSelection) {
				// Create object in same format as shift-click selection
				const kadObject = {
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: 0, // Default to first element
					selectionType: "entity", // Mark as full entity selection
				};

				// Add specific properties based on entity type
				if (entity.entityType === "circle" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.radius = entity.data[0].radius;
				} else if (entity.entityType === "text" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.text = entity.data[0].text;
				} else if (entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
				}

				selectedMultipleKADObjects.push(kadObject);
			}
		}
	}

	// Step 5) HUD: Show selection message (consistent format for 2D/3D)
	if (selectedMultipleHoles.length > 0) {
		var holeIDsPoly = selectedMultipleHoles.map((h) => h.holeID);
		var displayIDsPoly = holeIDsPoly.length > 10 ? holeIDsPoly.slice(0, 10).join(",") + "..." : holeIDsPoly.join(",");
		showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDsPoly + "}\nEscape key to clear Selection");
	} else if (selectedMultipleKADObjects.length > 0) {
		showSelectionMessage("Editing " + selectedMultipleKADObjects.length + " KAD objects\nEscape key to clear Selection");
	} else {
		showStatusMessage("No objects found in selection area", 3000);
	}

	// Step 6) Enable multi-selection mode if we have selections
	if (selectedMultipleHoles.length > 0) {
		isMultiHoleSelectionEnabled = true;
	}

	// Step 7) Clear polygon selection points
	polyPointsX = [];
	polyPointsY = [];

	// Step 8) Update visual display and tree view
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();

	// Step 9) Highlight selected nodes in tree view using existing system
	if (treeView) {
		const nodeIds = [];

		// Add selected holes to node IDs
		if (selectedMultipleHoles.length > 0) {
			selectedMultipleHoles.forEach((hole) => {
				nodeIds.push("hole‚£ø" + hole.holeID);
			});
		}

		// Add selected KAD objects to node IDs
		if (selectedMultipleKADObjects.length > 0) {
			selectedMultipleKADObjects.forEach((kad) => {
				nodeIds.push(kad.entityType + "‚£ø" + kad.entityName);
			});
		}

		// Highlight all selected nodes at once
		treeView.highlightNodes(nodeIds);
	}
}
function handleHoleEditingSelection(event) {
	if (isHoleEditing || selectPointerTool.checked) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

// Step 0) Invalidate contour cache - call this when holes are added/modified/deleted
function invalidateContourCache() {
	cachedContourHash = null;
	cachedContourLinesArray = [];
	cachedDirectionArrows = [];
}

// Step 0a) Force recalculate contours regardless of display options (for pre-caching)
function forceRecalculateContours(blastHoles) {
	if (!blastHoles || blastHoles.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	try {
		// Step 1) Calculate hole times
		var times = calculateTimes(blastHoles);

		// Step 2) Prepare contour data
		var contourData = [];
		for (var i = 0; i < times.length; i++) {
			var parts = times[i][0].split(":::");
			var entityName = parts[0];
			var holeID = parts[1];
			var time = times[i][1];

			var hole = null;
			for (var j = 0; j < blastHoles.length; j++) {
				if (blastHoles[j].entityName === entityName && blastHoles[j].holeID === holeID) {
					hole = blastHoles[j];
					break;
				}
			}

			if (hole) {
				contourData.push({
					x: hole.startXLocation,
					y: hole.startYLocation,
					z: time,
				});
			}
		}

		if (contourData.length === 0) {
			return { contourLinesArray: [], directionArrows: [] };
		}

		// Step 3) Call delaunayContours
		var result = delaunayContours(contourData, null, maxEdgeLength);

		if (!result || !result.contourLinesArray) {
			return { contourLinesArray: [], directionArrows: [] };
		}

		// Step 4) Cache the results
		cachedContourHash = computeContourHash(blastHoles);
		cachedContourLinesArray = result.contourLinesArray;
		cachedDirectionArrows = result.directionArrows || [];

		return {
			contourLinesArray: cachedContourLinesArray,
			directionArrows: cachedDirectionArrows,
		};
	} catch (err) {
		console.error("Error in forceRecalculateContours:", err);
		return { contourLinesArray: [], directionArrows: [] };
	}
}

// Step 1) Helper function to compute a hash of hole positions, times, AND display options for caching
function computeContourHash(holes) {
	if (!holes || holes.length === 0) return "";
	// Step 1a) Create a hash based on hole positions and times
	var hashStr = "";
	for (var i = 0; i < holes.length; i++) {
		var h = holes[i];
		hashStr += h.startXLocation.toFixed(2) + "," + h.startYLocation.toFixed(2) + "," + (h.holeTime || 0) + ";";
	}

	// Step 1b) Include display options that affect contour/arrow generation
	// This ensures cache is invalidated when user toggles checkboxes or adjusts sliders
	hashStr += "opts:" +
		(displayContours ? displayContours.checked : false) + "," +
		(displayFirstMovements ? displayFirstMovements.checked : false) + "," +
		(displayRelief ? displayRelief.checked : false) + "," +
		(typeof intervalAmount !== "undefined" ? intervalAmount : 25) + "," +
		(typeof firstMovementSize !== "undefined" ? firstMovementSize : 2);

	// Step 1c) Simple hash function
	var hash = 0;
	for (var j = 0; j < hashStr.length; j++) {
		var chr = hashStr.charCodeAt(j);
		hash = (hash << 5) - hash + chr;
		hash |= 0; // Convert to 32bit integer
	}
	return hash.toString();
}

function recalculateContours(allBlastHoles, deltaX, deltaY) {
	// Step 1) Check if we have holes
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	// Step 2) Calculate hole times (always needed)
	holeTimes = calculateTimes(allBlastHoles);
	timeChart();

	// Step 3) Only recalculate if contours or direction arrows are being displayed
	if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
		// Return cached if available, otherwise empty
		if (cachedContourLinesArray && cachedContourLinesArray.length > 0) {
			return {
				contourLinesArray: cachedContourLinesArray,
				directionArrows: cachedDirectionArrows,
			};
		}
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	try {
		// Step 4) Compute hash to check if we can use cached contours
		var currentHash = computeContourHash(allBlastHoles);
		if (currentHash === cachedContourHash && cachedContourLinesArray && cachedContourLinesArray.length > 0) {
			// Cache hit - return cached results
			return {
				contourLinesArray: cachedContourLinesArray,
				directionArrows: cachedDirectionArrows,
			};
		}

		// Step 5) Prepare contour data
		var contourData = [];
		for (var i = 0; i < holeTimes.length; i++) {
			var parts = holeTimes[i][0].split(":::");
			var entityName = parts[0];
			var holeID = parts[1];
			var time = holeTimes[i][1];

			var hole = null;
			for (var j = 0; j < allBlastHoles.length; j++) {
				if (allBlastHoles[j].entityName === entityName && allBlastHoles[j].holeID === holeID) {
					hole = allBlastHoles[j];
					break;
				}
			}

			if (hole) {
				contourData.push({
					x: hole.startXLocation,
					y: hole.startYLocation,
					z: time,
				});
			}
		}

		if (contourData.length === 0) {
			throw new Error("No valid contour data holes found.");
		}

		// Step 6) Call delaunayContours ONCE - it calculates ALL contour levels
		var result = delaunayContours(contourData, null, maxEdgeLength);

		// Step 7) Check if result is valid
		if (!result || !result.contourLinesArray) {
			console.warn("delaunayContours returned invalid result");
			return {
				contourLinesArray: [],
				directionArrows: [],
			};
		}

		// Step 8) Cache the results
		cachedContourHash = currentHash;
		cachedContourLinesArray = result.contourLinesArray;
		cachedDirectionArrows = result.directionArrows || [];

		// Step 9) Return the complete result (already contains all contour levels)
		return {
			contourLinesArray: cachedContourLinesArray,
			directionArrows: cachedDirectionArrows,
		};
	} catch (err) {
		console.error("Error in recalculateContours:", err);
		// Return empty arrays instead of undefined
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}
}

function calculateHoleGeometry(clickedHole, newValue, modeLAB) {
	const index = allBlastHoles.findIndex((hole) => hole.holeID === clickedHole.holeID && hole.entityName === clickedHole.entityName);
	if (index === -1) {
		return; // Hole not found
	}

	// Work directly on the original hole object instead of creating a copy
	let hole = allBlastHoles[index];

	// Destructure for easier access
	let { startXLocation: startX, startYLocation: startY, startZLocation: startZ, holeAngle, holeBearing, benchHeight, subdrillAmount } = hole;

	const radBearing = ((450 - holeBearing) % 360) * (Math.PI / 180);

	if (modeLAB === 1) {
		// Length
		const newLength = parseFloat(newValue);
		hole.holeLengthCalculated = newLength;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			const subdrillLength = subdrillAmount / cosAngle;
			const newBenchDrillLength = newLength - subdrillLength;
			hole.benchHeight = newBenchDrillLength * cosAngle;
		}

		// Recalculate everything based on the new length
		const newTotalVerticalDrop = newLength * cosAngle;
		hole.endZLocation = startZ - newTotalVerticalDrop;
		const horizontalProjection = newLength * sinAngle;
		hole.endXLocation = startX + horizontalProjection * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjection * Math.sin(radBearing);

		hole.gradeZLocation = startZ - hole.benchHeight;
		const benchDrillLength = hole.benchHeight / (Math.abs(cosAngle) > 1e-9 ? cosAngle : 1);
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);
	} else if (modeLAB === 2) {
		// Angle
		const newAngle = parseFloat(newValue);
		hole.holeAngle = newAngle;
		const radAngle = newAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + subdrillAmount) / cosAngle;
		} // For horizontal holes, length is independent

		hole.gradeZLocation = startZ - benchHeight;
		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0; // No bench drop for horizontal
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 3) {
		// Bearing
		const newBearing = parseFloat(newValue);
		hole.holeBearing = newBearing;
		const newRadBearing = ((450 - newBearing) % 360) * (Math.PI / 180);
		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(newRadBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(newRadBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(newRadBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(newRadBearing);

		// FIX: Add the missing endZLocation calculation
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 4) {
		// Easting (X) - Simple delta shift
		const deltaX = newValue - hole.startXLocation;
		hole.startXLocation = newValue;
		hole.gradeXLocation += deltaX;
		hole.endXLocation += deltaX;
	} else if (modeLAB === 5) {
		// Northing (Y) - Simple delta shift
		const deltaY = newValue - hole.startYLocation;
		hole.startYLocation = newValue;
		hole.gradeYLocation += deltaY;
		hole.endYLocation += deltaY;
	} else if (modeLAB === 6) {
		// Elevation (Z)
		const deltaZ = newValue - hole.startZLocation;
		hole.startZLocation = newValue;
		hole.gradeZLocation += deltaZ;
		hole.endZLocation += deltaZ;
	} else if (modeLAB === 7) {
		// Diameter
		hole.holeDiameter = newValue;
	} else if (modeLAB === 8) {
		// Subdrill Amount
		const newSubdrillAmount = parseFloat(newValue);

		if (isNaN(newSubdrillAmount)) {
			console.warn("Invalid subdrill amount:", newValue);
			return;
		}
		hole.subdrillAmount = newSubdrillAmount;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + newSubdrillAmount) / cosAngle;
		}

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	}
	debouncedUpdateTreeView(); // Use debounced version
	// No need to reassign allBlastHoles[index] since we're working on the original object
}

let isUpdatingTimeChart = false;
let timeChartUpdateTimer = null;

function timeChart() {
	if (isUpdatingTimeChart) {
		if (developerModeEnabled) {
			console.log("‚ùå Preventing recursive timechart call");
		}
		return;
	}

	isUpdatingTimeChart = true;

	// Step 1) Clear any pending timer
	if (timeChartUpdateTimer) {
		clearTimeout(timeChartUpdateTimer);
	}

	const chart = document.getElementById("timeChart");
	// If no holeTimes data, create a blank chart instead of returning
	if (!Array.isArray(holeTimes) || holeTimes.length === 0) {
		const layout = {
			title: {
				text: "Time Window Chart - No Data",
				xanchor: "right",
				font: {
					size: 10,
				},
			},
			plot_bgcolor: noneColor,
			paper_bgcolor: noneColor,
			font: {
				color: textFillColor,
			},
			modebar: {
				orientation: "v",
				bgcolor: noneColor,
				color: "rgba(255, 0, 0, 0.4)",
				activecolor: "red",
				position: "left",
			},
			margin: {
				l: 5,
				r: 50,
				b: 25,
				t: 25,
				pad: 2,
			},
			xaxis: {
				title: {
					text: "milliseconds (ms)",
					font: {
						size: 10,
					},
				},
				showgrid: true,
				range: [0, 100],
			},
			yaxis: {
				title: {
					text: "Holes Firing",
					font: {
						size: 10,
					},
				},
				showgrid: true,
				range: [0, 10],
			},
			height: 380,
			width: chart.offsetWidth - 50,
			annotations: [
				{
					text: "Load holes and connect them to see timing data",
					xref: "paper",
					yref: "paper",
					x: 0.5,
					y: 0.5,
					xanchor: "center",
					yanchor: "middle",
					showarrow: false,
					font: {
						size: 12,
						color: textFillColor,
					},
				},
			],
		};

		Plotly.react("timeChart", [], layout, {
			responsive: true,
			displayModeBar: true,
			modeBarButtonsToRemove: ["lasso2d", "select2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
			modeBarButtons: [["zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]],
		});

		// Reset flag for blank chart
		timeChartUpdateTimer = setTimeout(() => {
			isUpdatingTimeChart = false;
		}, 300);

		return; // Exit early after creating blank chart
	}

	const times = holeTimes.map((time) => time[1]);
	const maxTime = Math.max(...times);
	const timeRange = parseInt(document.getElementById("timeRange").value);
	const timeOffset = parseInt(document.getElementById("timeOffset").value);
	const numBins = Math.ceil(maxTime / timeRange);
	const binStart = -timeOffset;

	const measuredMassRadio = document.getElementById("measuredMassRadio");
	const holeCountRadio = document.getElementById("holeCountRadio");
	let useMass;
	useMass = useMass ? holeCountRadio?.checked : measuredMassRadio?.checked || false;

	let counts = Array(numBins).fill(0);
	let massSum = Array(numBins).fill(0);
	let validMassCount = 0;

	for (let hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			counts[binIndex]++;
			const mass = Number(hole.measuredMass);
			if (useMass && !isNaN(mass) && isFinite(mass)) {
				massSum[binIndex] += mass;
				validMassCount++;
			}
		}
	}

	const fallbackToCount = useMass && validMassCount < 2;
	const yValues = useMass && !fallbackToCount ? massSum : counts;

	const binEdges = Array(numBins)
		.fill(0)
		.map((_, index) => index * timeRange + binStart);

	const binCenters = binEdges.map((edge) => edge + timeRange / 2);
	const xTickInterval = Math.ceil(numBins / 10); // label ~5 ticks
	const tickvals = binCenters.filter((_, i) => i % xTickInterval === 0);
	const ticktext = tickvals.map((center) => center - timeRange / 2 + "?" + (center + timeRange / 2));

	const holeIDs = Array(numBins).fill(null);

	for (const hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			holeIDs[binIndex] = holeIDs[binIndex] || [];
			holeIDs[binIndex].push(hole.entityName + ":" + hole.holeID);
		}
	}

	const entityholeIDTexts = holeIDs.map((bin) => {
		if (!bin) return "";
		return bin
			.map((combinedID) => {
				const [entityName, holeID] = combinedID.split(":");
				const hole = allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
				return hole ? hole.entityName + ":" + hole.holeID : "";
			})
			.filter(Boolean)
			.join(", ");
	});

	const hoverText = entityholeIDTexts.map((text, index) => {
		const totalMass = useMass && !fallbackToCount && massSum[index] ? massSum[index].toFixed(1) + " kg" : "";
		return totalMass ? text + "<br>Mass: " + totalMass : text;
	});

	const currentLayout = chart?._fullLayout;
	const newYLabel = useMass && !fallbackToCount ? "Total Measured Mass (kg)" : "Holes Firing";
	const currentYLabel = currentLayout?.yaxis?.title?.text;
	const preserveYRange = currentYLabel === newYLabel;

	const maxYValue = Math.max(...yValues) + 1;

	// Step 1) Extract numeric range values to avoid circular references
	let yAxisRange = [0, maxYValue - 0.5];
	if (preserveYRange && currentLayout && currentLayout.yaxis && currentLayout.yaxis.range) {
		const r0 = Number(currentLayout.yaxis.range[0]);
		const r1 = Number(currentLayout.yaxis.range[1]);
		if (!isNaN(r0) && !isNaN(r1) && isFinite(r0) && isFinite(r1)) {
			yAxisRange = [r0, r1];
		}
	}

	const layout = {
		title: {
			text: "Time Window Chart",
			xanchor: "right",
			font: {
				size: 10,
			},
		},
		plot_bgcolor: noneColor,
		paper_bgcolor: noneColor,
		font: {
			color: textFillColor,
		},
		modebar: {
			orientation: "v",
			bgcolor: noneColor,
			color: "rgba(255, 0, 0, 0.4)",
			activecolor: "red",
			position: "left",
		},
		margin: {
			l: 5,
			r: 50,
			b: 25,
			t: 25,
			pad: 2,
		},
		xaxis: {
			title: {
				text: "milliseconds (ms)",
				font: {
					size: 10,
				},
			},
			showgrid: true,
			rangeslider: {
				visible: true,
				thickness: 0.1,
			},
			tickvals: "auto", //tickvals, // if you want bin ranges
			ticktext: "~s", //ticktext, //if you want bin ranges
		},
		yaxis: {
			title: {
				text: newYLabel,
				font: {
					size: 10,
				},
			},
			showgrid: true,
			automargin: true,
			range: yAxisRange,
		},
		height: 380,
		width: chart.offsetWidth - 50, // ? dynamic width based on container,
	};

	// Step 1) Create fresh color array for initial chart - NEVER pass defaultColor directly
	const initialColors = [];
	for (let i = 0; i < numBins; i++) {
		initialColors.push("red");
	}

	const data = [
		{
			x: binCenters,
			y: yValues,
			type: "bar",
			width: timeRange, // ?? match bin width
			marker: {
				color: initialColors, // Use fresh array, not defaultColor
			},
			// text: hoverText,
			// textposition: "none", // ? disables labels drawn on bars
			//hoverinfo: "text+y",
			hovertemplate: "Bin: %{x} ms<br>" + (useMass && !fallbackToCount ? "Mass" : "Value") + ": %{y}<extra></extra>",
		},
	];

	Plotly.react("timeChart", data, layout, {
		responsive: true,
		displayModeBar: true,
		modeBarButtonsToRemove: ["lasso2d", "select2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
		modeBarButtons: [["zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]],
	});

	// ? Clear previously registered listeners
	chart.removeAllListeners?.("plotly_click");
	chart.removeAllListeners?.("plotly_deselect");

	let lastClickedIndex = null;
	let eventThrottleTimer = null;

	// Step 1) Helper to create fresh color array (NEVER reuse arrays - Plotly contaminates them)
	function createFreshColorArray(binCount, selectedIndex = -1) {
		const colors = [];
		for (let i = 0; i < binCount; i++) {
			if (i === selectedIndex) {
				colors.push("lime");
			} else {
				colors.push("red");
			}
		}
		return colors;
	}

	// Step 2) Throttled handler for single bar selection
	function handleSelection(selectedIndex) {
		// Clear any pending throttle
		if (eventThrottleTimer) {
			clearTimeout(eventThrottleTimer);
		}

		// Throttle rapid events
		eventThrottleTimer = setTimeout(() => {
			// Update selected holes array for single bin
			timingWindowHolesSelected = holeIDs[selectedIndex]
				? holeIDs[selectedIndex]
					.map((combinedID) => {
						const [entityName, holeID] = combinedID.split(":");
						return allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
					})
					.filter(Boolean)
				: [];

			// Redraw canvas WITHOUT calling timeChart
			const wasUpdating = isUpdatingTimeChart;
			isUpdatingTimeChart = true;
			drawData(allBlastHoles, selectedHole);
			isUpdatingTimeChart = wasUpdating;
		}, 100); // 100ms throttle to batch rapid events
	}

	chart.on("plotly_click", function (data) {
		if (isUpdatingTimeChart) return; // Skip if already updating

		const clickedIndex = data.points?.[0]?.pointIndex;
		if (clickedIndex == null) return;

		// Create FRESH color array - never reuse
		const currentColors = createFreshColorArray(numBins, clickedIndex);

		try {
			Plotly.restyle("timeChart", {
				"marker.color": [currentColors],
			});
		} catch (e) {
			console.warn("?? Plotly.restyle error:", e);
			return;
		}

		lastClickedIndex = clickedIndex;

		// Handle selection with throttling
		handleSelection(clickedIndex);
	});

	chart.on("plotly_deselect", function () {
		if (isUpdatingTimeChart) return; // Skip if already updating

		// Create FRESH color array - all red (no selection)
		const resetColors = createFreshColorArray(numBins, -1);

		try {
			Plotly.restyle("timeChart", {
				"marker.color": [resetColors],
			});
		} catch (e) {
			console.warn("?? Plotly.restyle error:", e);
			return;
		}

		timingWindowHolesSelected = [];
		lastClickedIndex = null;

		// Redraw immediately without throttle for deselect
		const wasUpdating = isUpdatingTimeChart;
		isUpdatingTimeChart = true;
		drawData(allBlastHoles, selectedHole);
		isUpdatingTimeChart = wasUpdating;
	});

	// Step 2) Reset flag after Plotly has finished processing
	timeChartUpdateTimer = setTimeout(() => {
		isUpdatingTimeChart = false;
	}, 300);
}

// Log Helper Functions for the play slider
function playSpeedLogScale(sliderValue) {
	if (sliderValue <= 50) {
		// First half: 0.01 to 1.0
		const normalizedValue = sliderValue / 50;
		const minLog = Math.log10(0.01);
		const maxLog = Math.log10(1.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	} else {
		// Second half: 1.0 to 10.0
		const normalizedValue = (sliderValue - 50) / 50;
		const minLog = Math.log10(1.0);
		const maxLog = Math.log10(10.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	}
}

function updatePlaySpeed() {
	const playSpeedInput = document.getElementById("playSpeed");
	const sliderValue = parseFloat(playSpeedInput.value);

	// Use logarithmic scaling instead of direct value
	playSpeed = playSpeedLogScale(sliderValue);

	// Update button text with actual speed
	const playButton = document.getElementById("play");
	playButton.textContent = "PLAY @ " + playSpeed.toFixed(3) + "x";
}

// Optional: Add visual markers to show the scale divisions
function addPlaySpeedMarkers() {
	const slider = document.getElementById("playSpeed");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.01x</span><span>1x</span><span>10x</span>";

	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}

// Add click event listener to the "Play" button
const playButton = document.getElementById("play");

playButton.addEventListener("click", () => {
	// Step 1) Update play speed
	updatePlaySpeed();

	// Step 2) Calculate max time safely
	let maxTime = 0;
	if (holeTimes && holeTimes.length > 0) {
		const times = holeTimes.map((time) => time[1]).filter((t) => !isNaN(t) && isFinite(t));
		maxTime = times.length > 0 ? Math.max(...times) : 0;
	}
	console.log("Calculated maxTime:", maxTime);

	// Step 3) Set animation state
	isPlaying = true;

	// Step 4) Clear any existing animation
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
	}

	// Step 5) Initialize animation variables
	let currentTime = 0;
	let lastFrameTime = performance.now();

	// Step 6) Define the animation loop using requestAnimationFrame
	function animationLoop() {
		if (!isPlaying) return; // Exit if stopped

		const now = performance.now();
		const realTimeElapsed = now - lastFrameTime; // Real milliseconds elapsed
		const blastTimeToAdvance = realTimeElapsed * playSpeed; // Scale by playSpeed

		currentTime += blastTimeToAdvance;
		lastFrameTime = now;

		// Step 7) Update and render if within time bounds
		if (currentTime <= maxTime + playSpeed * 100) {
			timingWindowHolesSelected = allBlastHoles.filter((hole) => hole.holeTime <= currentTime);
			drawData(allBlastHoles, timingWindowHolesSelected);

			// Step 8) Request next frame
			animationFrameId = requestAnimationFrame(animationLoop);
		} else {
			// Step 9) Animation complete
			stopButton.click();
		}
	}

	// Step 10) Start the animation loop
	animationFrameId = requestAnimationFrame(animationLoop);
});

// Add click event listener to the "Stop" button
const stopButton = document.getElementById("stop");
stopButton.addEventListener("click", () => {
	// Step 1) Stop animation state
	isPlaying = false;

	// Step 2) Clear interval-based animation if exists
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}

	// Step 3) Cancel requestAnimationFrame-based animation if exists
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
		animationFrameId = null;
	}

	// Step 4) Reset the selected holes array
	timingWindowHolesSelected = [];
});

// Add input event listener to the playSpeed input range
const playSpeedInput = document.getElementById("playSpeed");
playSpeedInput.addEventListener("input", updatePlaySpeed);

function drawLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function
	//the legend should display the roundedAngleDip Ranges and there colors
	const legend0to5 = "rgb(51, 139, 255)";
	const legend5to7 = "rgb(0, 102, 204)";
	const legend7to9 = "rgb(0, 204, 204)";
	const legend9to12 = "rgb(102, 204, 0)";
	const legend12to15 = "rgb(204, 204, 0)";
	const legend15to17 = "rgb(255, 128, 0)";
	const legend17to20 = "rgb(255, 0, 0)";
	const legend20above = "rgb(153, 0, 76)";
	//draw the legend
	ctx.beginPath();
	ctx.fill();
	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Slope", 10, canvas.height / 2 - 70);
	ctx.fillText("0\u00B0-5\u00B0", 10, canvas.height / 2 - 40);
	ctx.fillText("5\u00B0-7\u00B0", 10, canvas.height / 2 - 10);
	ctx.fillText("7\u00B0-9\u00B0", 10, canvas.height / 2 + 20);
	ctx.fillText("9\u00B0-12\u00B0", 10, canvas.height / 2 + 50);
	ctx.fillText("12\u00B0-15\u00B0", 10, canvas.height / 2 + 80);
	ctx.fillText("15\u00B0-17\u00B0", 10, canvas.height / 2 + 110);
	ctx.fillText("17\u00B0-20\u00B0", 10, canvas.height / 2 + 140);
	ctx.fillText("20\u00B0+", 10, canvas.height / 2 + 170);
	ctx.fillStyle = legend0to5;
	ctx.fillRect(60, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend5to7;
	ctx.fillRect(60, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to9;
	ctx.fillRect(60, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend9to12;
	ctx.fillRect(60, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend12to15;
	ctx.fillRect(60, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend15to17;
	ctx.fillRect(60, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend17to20;
	ctx.fillRect(60, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend20above;
	ctx.fillRect(60, canvas.height / 2 + 155, 20, 20);
	ctx.stroke();
}

function worldToCanvas(x, y) {
	return [(x - centroidX) * currentScale + canvas.width / 2, (-y + centroidY) * currentScale + canvas.height / 2];
}

// Helper to fetch display options once
function getDisplayOptions() {
	return {
		holeID: document.getElementById("display1").checked,
		holeLen: document.getElementById("display2").checked,
		holeDia: document.getElementById("display2A").checked,
		holeAng: document.getElementById("display3").checked,
		holeDip: document.getElementById("display4").checked,
		holeBea: document.getElementById("display5").checked,
		holeSubdrill: document.getElementById("display5B").checked,
		connector: document.getElementById("display5A").checked,
		delayValue: document.getElementById("display6").checked,
		initiationTime: document.getElementById("display6A").checked,
		contour: document.getElementById("display8").checked,
		slopeMap: document.getElementById("display8A").checked,
		burdenRelief: document.getElementById("display8B").checked,
		firstMovement: document.getElementById("display8C").checked,
		xValue: document.getElementById("display9").checked,
		yValue: document.getElementById("display10").checked,
		zValue: document.getElementById("display11").checked,
		holeType: document.getElementById("display12").checked,
		measuredLength: document.getElementById("display13").checked,
		measuredMass: document.getElementById("display14").checked,
		measuredComment: document.getElementById("display15").checked,
		voronoiPF: document.getElementById("display16").checked,
		displayRowAndPosId: document.getElementById("rowAndPosDisplay").checked,
	};
}

// Build hole map for quick lookup by entityName and holeID
function buildHoleMap(allBlastHoles) {
	const map = new Map();
	if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
		for (const pt of allBlastHoles) {
			map.set(pt.entityName + ":::" + pt.holeID, pt);
		}
	}
	return map;
}

let drawMouseLines = true; //used to debug mouse location

function drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, showSnapRadius = true, showMouseLines = true) {
	//draw a vertical lin the height of the canvas at the mouse x location and draw a line the width of the canvas at the y location of the mouse. it should be color grey at 50% opacity
	if (showMouseLines) {
		ctx.lineWidth = 0.5;
		ctx.beginPath();
		ctx.moveTo(mouseX, 0);
		ctx.lineTo(mouseX, canvas.height);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
		ctx.beginPath();
		ctx.moveTo(0, mouseY);
		ctx.lineTo(canvas.width, mouseY);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
	if (showSnapRadius && snapRadiusPixels > 0) {
		// Draw the snapping radius circle
		ctx.beginPath();
		ctx.arc(mouseX, mouseY, snapRadiusPixels, 0, 2 * Math.PI);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
}

// Main draw function
function drawData(allBlastHoles, selectedHole) {
	// Expose globals to window for canvas3DDrawing.js module
	exposeGlobalsToWindow();

	// Step 0.5) Initialize mouse indicator on first draw in 3D mode
	// This ensures the grey torus appears immediately on startup
	if (onlyShowThreeJS && threeInitialized && interactionManager && threeRenderer && !mouseIndicatorInitialized && allBlastHoles && allBlastHoles.length > 0) {
		mouseIndicatorInitialized = true; // Set flag immediately to prevent multiple calls

		// Use requestAnimationFrame to ensure canvas is fully rendered
		requestAnimationFrame(() => {
			const threeCanvas = threeRenderer.getCanvas();
			if (threeCanvas) {
				// Get canvas center coordinates
				const rect = threeCanvas.getBoundingClientRect();
				const centerX = rect.left + rect.width / 2;
				const centerY = rect.top + rect.height / 2;

				// Create and dispatch a synthetic mousemove event at canvas center
				const syntheticEvent = new MouseEvent("mousemove", {
					bubbles: true,
					cancelable: true,
					clientX: centerX,
					clientY: centerY,
					button: 0,
					buttons: 0,
				});

				// Dispatch on document (same as the real mousemove handler)
				document.dispatchEvent(syntheticEvent);
			}
		});
	}

	if (canvas) {
		// For UI version 2, this is ESSENTIAL.
		// For UI version 1, it adds robustness if its display size could ever change.
		if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
		}
	}

	// Step 0) Initialize Three.js on first draw
	if (!threeInitialized && !threeInitializationFailed) {
		initializeThreeJS();
	}

	// Step 0a) Ensure Three.js canvas size matches 2D canvas
	if (threeInitialized && threeRenderer && canvas) {
		const threeCanvas = threeRenderer.getCanvas();
		if (threeCanvas && (threeCanvas.width !== canvas.clientWidth || threeCanvas.height !== canvas.clientHeight)) {
			threeRenderer.resize(canvas.clientWidth, canvas.clientHeight);
		}
	}

	// Step 0b) Update local origin if any data is loaded (holes or surfaces)
	if (threeLocalOriginX === 0 && threeLocalOriginY === 0) {
		const hasHoles = allBlastHoles && allBlastHoles.length > 0;
		const hasSurfaces = loadedSurfaces && loadedSurfaces.size > 0;
		const hasKADDrawings = allKADDrawingsMap && allKADDrawingsMap.size > 0;

		if (hasHoles || hasSurfaces || hasKADDrawings) {
			updateThreeLocalOrigin();
			// Step 0b.1) Sync camera to view the data after setting origin
			syncCameraToThreeJS();
		}
	}

	// Step 0c) Calculate Z centroid for orbit center
	dataCentroidZ = calculateDataZCentroid();

	// Step 1) Clear Three.js geometry for rebuild
	// Note: Super-batch optimization (ONE draw call for all lines) makes this fast even for large DXFs
	clearThreeJS();

	// Step 1a) Clear 2D canvas always (to remove old content)
	if (ctx) {
		clearCanvas();
	}

	// Step 1b) Only process 2D drawing if not in Three.js-only mode
	if (ctx && !onlyShowThreeJS) {
		// Step 1b.1) Set canvas smoothing for 2D drawing
		ctx.imageSmoothingEnabled = false;

		const displayOptions = getDisplayOptions();
		let holeMap = new Map();
		if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			holeMap = buildHoleMap(allBlastHoles);
		}

		// Draw background images FIRST (bottom layer) - 2D ONLY
		drawBackgroundImage();

		// Draw surfaces SECOND - 2D ONLY
		// Note: drawSurface() will handle both 2D canvas drawing AND 3D geometry addition
		// when in hybrid mode (both visible). In pure 2D mode, only 2D triangles are drawn.
		drawSurface();

		// Step 4e) Highlight single selected point if needed (2D only)
		if (selectedPoint !== null && !onlyShowThreeJS) {
			const [x, y] = worldToCanvas(selectedPoint.pointXLocation, selectedPoint.pointYLocation);
			drawHiHole(x, y, 10, "rgba(255, 102, 255, 0.3)", "rgba(255, 0, 255, 0.6)");
		}

		// In drawData function, replace the drawing logic with hierarchical visibility:
		if (drawingsGroupVisible) {
			// ? ADD: Check overall drawings group visibility
			for (const [name, entity] of allKADDrawingsMap.entries()) {
				// ? Check entity visibility
				if (entity.visible === false) continue;

				// ? ADD: Check sub-group visibility based on entity type
				let subGroupVisible = true;
				switch (entity.entityType) {
					case "point":
						subGroupVisible = pointsGroupVisible;
						break;
					case "line":
						subGroupVisible = linesGroupVisible;
						break;
					case "poly":
						subGroupVisible = polygonsGroupVisible;
						break;
					case "circle":
						subGroupVisible = circlesGroupVisible;
						break;
					case "text":
						subGroupVisible = textsGroupVisible;
						break;
				}

				if (!subGroupVisible) continue; // ? Skip if sub-group is hidden

				if (developerModeEnabled && entity.entityType === "point") {
					entity.data.forEach((point) => {
						// ? Check individual element visibility
						if (point.visible === false) return;
						const screenX = (point.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(point.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						let lineWidthForDisplay = point.lineWidth;
						if (point.lineWidth <= 1) {
							lineWidthForDisplay = 1;
						}
						drawKADPoints(screenX, screenY, point.pointZLocation, lineWidthForDisplay, point.color);
						drawKADCoordinates(point, screenX, screenY);
					});
				} else if (entity.entityType === "point") {
					// Apply pixel distance simplification to points for performance
					const originalPoints = entity.data.filter((point) => point.visible !== false);
					const simplifiedPoints = simplifyByPxDist(originalPoints, 3);

					for (const pointData of simplifiedPoints) {
						let lineWidthForDisplay = pointData.lineWidth;
						if (pointData.lineWidth <= 1) {
							lineWidthForDisplay = 1;
						}
						const [x, y] = worldToCanvas(pointData.pointXLocation, pointData.pointYLocation);
						drawKADPoints(x, y, pointData.pointZLocation, lineWidthForDisplay, pointData.color);
						drawKADCoordinates(pointData, x, y);
					}
				} else if (entity.entityType === "circle") {
					// ? FIXED: Move visibility check inside forEach loop
					entity.data.forEach((circle) => {
						if (circle.visible === false) return; // ? Check individual element visibility
						const screenX = (circle.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(circle.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						drawKADCircles(screenX, screenY, circle.pointZLocation, circle.radius, circle.lineWidth, circle.color);
						drawKADCoordinates(circle, screenX, screenY);
					});
				} else if (entity.entityType === "text") {
					entity.data.forEach((textData) => {
						if (textData.visible === false) return; // ? Check individual element visibility
						if (textData && textData.text) {
							const screenX = (textData.pointXLocation - centroidX) * currentScale + canvas.width / 2;
							const screenY = -(textData.pointYLocation - centroidY) * currentScale + canvas.height / 2;
							// Step B2) Pass fontHeight to 2D text drawing
							var textFontHeight2D = textData.fontHeight || 12;
							drawKADTexts(screenX, screenY, textData.pointZLocation, textData.text, textData.color, textFontHeight2D);
							drawKADCoordinates(textData, screenX, screenY);
						}
					});
				} else if (developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// ? FIXED: Filter visible points first, then use filtered data
					var visiblePoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});
					if (visiblePoints.length < 2) continue;

					// Draw all segments without any simplification
					// NOTE: Use nextPoint's color - segment TO the point uses that point's color
					for (var i = 0; i < visiblePoints.length - 1; i++) {
						var currentPoint = visiblePoints[i];
						var nextPoint = visiblePoints[i + 1];

						var coords1 = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						var coords2 = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);
						var sx = coords1[0],
							sy = coords1[1],
							ex = coords2[0],
							ey = coords2[1];

						// Step #) Use nextPoint's color and lineWidth - segment TO the point uses that point's attributes
						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, nextPoint.lineWidth, nextPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === visiblePoints[visiblePoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					var isClosed = entity.entityType === "poly";
					if (isClosed && visiblePoints.length > 2) {
						var firstPoint = visiblePoints[0];
						var lastPoint = visiblePoints[visiblePoints.length - 1];
						var coordsLast = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						var coordsFirst = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);
						var sx = coordsLast[0],
							sy = coordsLast[1],
							ex = coordsFirst[0],
							ey = coordsFirst[1];

						// For closing segment, use firstPoint's color (the segment goes TO firstPoint)
						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, firstPoint.lineWidth, firstPoint.color, false);
					}
				} else if (!developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// --- Pixel-distance simplification for performance ---
					var originalPoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});
					if (originalPoints.length < 2) continue;

					// Simplify by pixel distance
					// Get the scale ratio like the overlay does
					var PIXELS_PER_METER_96DPI = 3779.52;
					var scaleRatio = PIXELS_PER_METER_96DPI / currentScale;
					// Use scale ratio to determine pixel threshold
					var pointThreshold;
					if (scaleRatio > 3000) {
						pointThreshold = 4; // Normal zoom
					}
					else if (scaleRatio > 600) {
						pointThreshold = 3; // Normal zoom
					} else if (scaleRatio > 400) {
						pointThreshold = 2; // Normal zoom
					} else {
						pointThreshold = 1; // Zoomed in
					}

					var simplifiedPoints = simplifyByPxDist(originalPoints, pointThreshold);

					// Draw the simplified line/polygon
					// NOTE: Use nextPoint's color - segment TO the point uses that point's color
					for (var i = 0; i < simplifiedPoints.length - 1; i++) {
						var currentPoint = simplifiedPoints[i];
						var nextPoint = simplifiedPoints[i + 1];

						var coords1 = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						var coords2 = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);
						var sx = coords1[0],
							sy = coords1[1],
							ex = coords2[0],
							ey = coords2[1];

						// Step #) Use nextPoint's color and lineWidth - segment TO the point uses that point's attributes
						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, nextPoint.lineWidth, nextPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === simplifiedPoints[simplifiedPoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					var isClosed = entity.entityType === "poly";
					if (isClosed && simplifiedPoints.length > 2) {
						var firstPoint = simplifiedPoints[0];
						var lastPoint = simplifiedPoints[simplifiedPoints.length - 1];
						var coordsLast = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						var coordsFirst = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);
						var sx = coordsLast[0],
							sy = coordsLast[1],
							ex = coordsFirst[0],
							ey = coordsFirst[1];

						// For closing segment, use firstPoint's color (the segment goes TO firstPoint)
						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, firstPoint.lineWidth, firstPoint.color, false);
					}
				}
			}
		}

		// Voronoi Powder Factor
		if (displayOptions.voronoiPF) {
			// VORONOI PF & OVERLAYS
			const tri = delaunayTriangles(allBlastHoles, maxEdgeLength);
			const blastBoundaryPolygon = createBlastBoundaryPolygon(tri.resultTriangles);
			const offsetBoundaryPolygon = offsetPolygonClipper(blastBoundaryPolygon, getAverageDistance(allBlastHoles) / 2);
			// console.log("DEBUG: VORONOI PF");
			switch (selectedVoronoiMetric) {
				case "powderFactor":
					// console.log("Drawing Powder Factor");
					//get the min and max values for the PF if isVoronoiLegendFixed is false
					let minPF, maxPF, intervalPF, deltaPF;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI PF NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.powderFactor).filter((v) => v != null && !isNaN(v));
						minPF = 0; //values.length > 0 ? Math.min(...values) : 0;
						maxPF = values.length > 0 ? Math.max(...values) : 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF / 4;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI PF FIXED");
						minPF = 0;
						maxPF = 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF > 0 ? Math.ceil(deltaPF / 10) : 0.5;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getPFColor(value, minPF, maxPF), "Legend Powder Factor", minPF, maxPF, intervalPF);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Powder Factor (kg/m\u00b3)", minPF, maxPF);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCells = clipVoronoiCells(voronoiMetrics);
						drawVoronoiCellsThreeJS(
							clippedCells,
							function (value) {
								return getPFColor(value, minPF, maxPF);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"powderFactor"
						);
					}
					break;
				case "mass":
					// console.log("Drawing Mass");
					let minMass, maxMass, intervalMass, deltaMass;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI MASS NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.mass).filter((v) => v != null && !isNaN(v));
						minMass = values.length > 0 ? Math.min(...values) : 0;
						maxMass = values.length > 0 ? Math.max(...values) : 500;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass / 4;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI MASS FIXED");
						minMass = 0;
						maxMass = 1000;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass > 0 ? Math.ceil(deltaMass / 10) : 250;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getMassColor(value, minMass, maxMass), "Legend Mass", minMass, maxMass, intervalMass);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Mass (kg)", minMass, maxMass);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsMass = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsMass = clipVoronoiCells(voronoiMetricsMass);
						drawVoronoiCellsThreeJS(
							clippedCellsMass,
							function (value) {
								return getMassColor(value, minMass, maxMass);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"mass"
						);
					}
					break;
				case "volume": {
					// console.log("Drawing Volume");
					let minVol, maxVol, intervalVol, deltaVol;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.volume).filter((v) => v != null && !isNaN(v));
						minVol = values.length > 0 ? Math.min(...values) : 0;
						maxVol = values.length > 0 ? Math.max(...values) : 100;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = deltaVol / 10;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					} else {
						minVol = 0;
						maxVol = 5000;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = 500;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getVolumeColor(value, minVol, maxVol), "Legend Volume", minVol, maxVol, intervalVol);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Volume (m\u00b3)", minVol, maxVol);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsVol = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsVol = clipVoronoiCells(voronoiMetricsVol);
						drawVoronoiCellsThreeJS(
							clippedCellsVol,
							function (value) {
								return getVolumeColor(value, minVol, maxVol);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"volume"
						);
					}
					break;
				}
				case "area": {
					// console.log("Drawing Area");
					let minArea, maxArea, intervalArea, deltaArea;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.area).filter((v) => v != null && !isNaN(v));
						minArea = values.length > 0 ? Math.min(...values) : 0;
						maxArea = values.length > 0 ? Math.max(...values) : 100;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = deltaArea / 10;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					} else {
						minArea = 0;
						maxArea = 500;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = 50;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getAreaColor(value, minArea, maxArea), "Legend Area", minArea, maxArea, intervalArea);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Area (m\u00b2)", minArea, maxArea);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsArea = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsArea = clipVoronoiCells(voronoiMetricsArea);
						drawVoronoiCellsThreeJS(
							clippedCellsArea,
							function (value) {
								return getAreaColor(value, minArea, maxArea);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"area"
						);
					}
					break;
				}
				case "measuredLength": {
					// console.log("Drawing Measured Length");
					let minMLen, maxMLen, intervalMLen, deltaMLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.measuredLength).filter((v) => v != null && !isNaN(v));
						minMLen = values.length > 0 ? Math.min(...values) : 0;
						maxMLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = deltaMLen / 10;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					} else {
						minMLen = 0;
						maxMLen = 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = 5;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minMLen, maxMLen), "Legend Measured Length", minMLen, maxMLen, intervalMLen);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Measured Length (m)", minMLen, maxMLen);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsMLen = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsMLen = clipVoronoiCells(voronoiMetricsMLen);
						drawVoronoiCellsThreeJS(
							clippedCellsMLen,
							function (value) {
								return getLengthColor(value, minMLen, maxMLen);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"measuredLength"
						);
					}
					break;
				}
				case "designedLength": {
					// console.log("Drawing Designed Length");
					let minDLen, maxDLen, intervalDLen, deltaDLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.designedLength).filter((v) => v != null && !isNaN(v));
						minDLen = values.length > 0 ? Math.min(...values) : 0;
						maxDLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = deltaDLen / 10;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					} else {
						minDLen = 0;
						maxDLen = 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = 5;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minDLen, maxDLen), "Legend Designed Length", minDLen, maxDLen, intervalDLen);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Designed Length (m)", minDLen, maxDLen);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsDLen = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsDLen = clipVoronoiCells(voronoiMetricsDLen);
						drawVoronoiCellsThreeJS(
							clippedCellsDLen,
							function (value) {
								return getLengthColor(value, minDLen, maxDLen);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"designedLength"
						);
					}
					break;
				}
				case "holeFiringTime": {
					// console.log("Drawing Hole Firing Time");
					let minHTime, maxHTime, intervalHTime, deltaHTime;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const holeTimes = clippedCells.map((c) => c.holeFiringTime).filter((t) => t != null && !isNaN(t));
						minHTime = holeTimes.length > 0 ? Math.min(...holeTimes) : 0;
						maxHTime = holeTimes.length > 0 ? Math.max(...holeTimes) : 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime / 10;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					} else {
						minHTime = 0;
						maxHTime = 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime > 0 ? Math.ceil(deltaHTime / 10) : 1000;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getHoleFiringTimeColor(value, minHTime, maxHTime), "Legend Hole Firing Time", minHTime, maxHTime, intervalHTime);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Hole Firing Time (ms)", minHTime, maxHTime);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsHTime = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsHTime = clipVoronoiCells(voronoiMetricsHTime);
						drawVoronoiCellsThreeJS(
							clippedCellsHTime,
							function (value) {
								return getHoleFiringTimeColor(value, minHTime, maxHTime);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"holeFiringTime"
						);
					}
					break;
				}
			}
		} else {
			// Hide Voronoi legend when not displayed
			hideVoronoiLegend();
		}

		// Slope Map
		if (displayOptions.slopeMap) {
			const centroid = {
				x: centroidX,
				y: centroidY,
			};
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

			// Step 6a) Draw 2D slope map only when NOT in 3D-only mode
			if (!onlyShowThreeJS) {
				drawDelauanySlopeMap(resultTriangles, centroid, strokeColor);
				for (const triangle of resultTriangles) {
					drawTriangleAngleText(triangle, centroid, strokeColor);
				}
				// HUD: Show slope legend (replaces ctx drawLegend)
				showSlopeLegend();
			}

			// Step 6b) Draw slope map in Three.js ONLY when in 3D mode
			// This prevents duplicate rendering when in 2D-only mode
			if (threeInitialized && onlyShowThreeJS && resultTriangles && resultTriangles.length > 0) {
				drawSlopeMapThreeJS(resultTriangles, allBlastHoles);
			}
		} else {
			// Hide slope legend when not displayed
			hideSlopeLegend();
		}

		// Burden Relief
		if (displayOptions.burdenRelief) {
			const centroid = {
				x: centroidX,
				y: centroidY,
			};
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

			// Step 7a) Draw 2D relief map only when NOT in 3D-only mode
			if (!onlyShowThreeJS) {
				drawDelauanyBurdenRelief(reliefTriangles, centroid, strokeColor);
				for (const triangle of reliefTriangles) {
					drawTriangleBurdenReliefText(triangle, centroid, strokeColor);
				}
				// HUD: Show relief legend (replaces ctx drawReliefLegend)
				showReliefLegend();
			}

			// Step 7b) Draw burden relief map in Three.js ONLY when in 3D mode
			// This prevents duplicate rendering when in 2D-only mode
			if (threeInitialized && onlyShowThreeJS && reliefTriangles && reliefTriangles.length > 0) {
				drawBurdenReliefMapThreeJS(reliefTriangles, allBlastHoles);
			}
		} else {
			// Hide relief legend when not displayed
			hideReliefLegend();
		}

		// Step 8) Contour Lines - Draw on main canvas for responsive pan/zoom
		if (displayOptions.contour && contourLinesArray && contourLinesArray.length > 0) {
			// Step 8a) Draw 2D contours (we're in the 2D-only block)
			// Skip if overlay system is handling contours (useContourOverlay = true)
			if (!useContourOverlay) {
				// Step 8b) Calculate interval for time labels
				var maxHoleTimeForLabels = 0;
				for (var hi = 0; hi < allBlastHoles.length; hi++) {
					var ht = allBlastHoles[hi].holeTime || 0;
					if (ht > maxHoleTimeForLabels) maxHoleTimeForLabels = ht;
				}
				var contourInterval = maxHoleTimeForLabels < 350 ? 25 : maxHoleTimeForLabels < 700 ? 100 : 250;
				if (typeof intervalAmount !== "undefined") {
					contourInterval = parseInt(intervalAmount);
				}

				// Step 8c) Set up contour line style
				ctx.lineWidth = 2;
				ctx.setLineDash([8, 4]);

				// Step 8d) Draw each contour level
				for (var levelIdx = 0; levelIdx < contourLinesArray.length; levelIdx++) {
					var contourLevel = contourLinesArray[levelIdx];
					if (!contourLevel || contourLevel.length === 0) continue;

					// Step 8e) Alternate colors for visibility
					ctx.strokeStyle = levelIdx % 2 === 0 ? "#FFFF00" : "#FF00FF";

					// Step 8f) Draw each line segment in this level
					for (var li = 0; li < contourLevel.length; li++) {
						var line = contourLevel[li];
						if (!line || !line[0] || !line[1]) continue;

						var startCoords = worldToCanvas(line[0].x, line[0].y);
						var endCoords = worldToCanvas(line[1].x, line[1].y);

						ctx.beginPath();
						ctx.moveTo(startCoords[0], startCoords[1]);
						ctx.lineTo(endCoords[0], endCoords[1]);
						ctx.stroke();
					}
				}

				// Step 8g) Reset line dash and line width for other drawing
				ctx.setLineDash([]);
				ctx.lineWidth = 1;
			}
			// Note: 3D contour drawing moved to the Three.js-only block (Step 3.0)
		}

		// First Movement Direction Arrows
		if (displayOptions.firstMovement) {
			connScale = document.getElementById("connSlider").value;

			// Step 9a) Draw 2D direction arrows (we're in the 2D-only block, no need for onlyShowThreeJS check)
			for (const arrow of directionArrows) {
				const [startX, startY] = worldToCanvas(arrow[0], arrow[1]);
				const [endX, endY] = worldToCanvas(arrow[2], arrow[3]);
				drawDirectionArrow(startX, startY, endX, endY, arrow[4], strokeColor, arrow[5]);
			}
			// Note: 3D direction arrow drawing moved to the Three.js-only block (Step 3.0b)
		}

		// Main hole loop
		ctx.lineWidth = 1;
		ctx.strokeStyle = strokeColor;
		ctx.font = parseInt(currentFontSize) + "px Arial";
		if (blastGroupVisible && allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			// ? ADD: Check blast group visibility
			for (const hole of allBlastHoles) {
				if (hole.visible === false) continue;
				const [x, y] = worldToCanvas(hole.startXLocation, hole.startYLocation);
				const [gradeX, gradeY] = worldToCanvas(hole.gradeXLocation, hole.gradeYLocation);
				const [lineEndX, lineEndY] = worldToCanvas(hole.endXLocation, hole.endYLocation);

				toeSizeInMeters = document.getElementById("toeSlider").value;
				connScale = document.getElementById("connSlider").value;

				// Draw collar-to-toe track if angled
				if (hole.holeAngle > 0) {
					drawTrack(x, y, lineEndX, lineEndY, gradeX, gradeY, strokeColor, hole.subdrillAmount);
				}

				// Step 4a) Highlight selected holes for animation/time window selection (2D only)
				// Only draw 2D highlighting when in 2D mode
				if (!onlyShowThreeJS) {
					handleHoleHighlighting(hole, x, y);
				}

				// Draw toe if hole length is not zero
				if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
					const radiusInPixels = toeSizeInMeters * currentScale;
					drawHoleToe(lineEndX, lineEndY, transparentFillColor, strokeColor, radiusInPixels);
				}

				// Calculate text offsets
				const textOffset = parseInt((hole.holeDiameter / 1000) * holeScale * currentScale);
				const leftSideToe = parseInt(lineEndX) - textOffset;
				const rightSideToe = parseInt(lineEndX) + textOffset;
				const leftSideCollar = parseInt(x) - textOffset;
				const rightSideCollar = parseInt(x) + textOffset;
				const topSideToe = parseInt(lineEndY - textOffset);
				const middleSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize / 4));
				const bottomSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize));
				const topSideCollar = parseInt(y - textOffset);
				const middleSideCollar = parseInt(y + parseInt(currentFontSize / 2));
				const bottomSideCollar = parseInt(y + textOffset + parseInt(currentFontSize));

				// Draw text/labels based on displayOptions
				drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, {
					leftSideToe,
					rightSideToe,
					leftSideCollar,
					rightSideCollar,
					topSideToe,
					middleSideToe,
					bottomSideToe,
					topSideCollar,
					middleSideCollar,
					bottomSideCollar,
					holeMap,
					displayOptions,
				});

				// Draw main hole geometry, with selection highlight logic
				drawHoleMainShape(hole, x, y, selectedHole);

				// Step 3) DO NOT draw Three.js geometry in 2D block
				// 3D hole rendering happens in 3D-only block at line 22587
				// This prevents dual rendering when camera is orbited

				// Font slider/label only needs to be updated once, after loop
			}
		}

		// Step 4) DO NOT draw KAD 3D geometry in 2D block
		// KAD 3D rendering happens in 3D-only block
		// This prevents dual rendering when camera is orbited

		// Step 7) Highlight selected KAD objects in 2D mode
		// Draw 2D selection visuals only (3D highlights happen in 3D-only block below)
		// highlightSelectedKADThreeJS(); // ? REMOVED: This was causing 3D highlights in 2D mode

		// After all other drawing operations but before font updates
		if (isPolygonSelectionActive) {
			drawPolygonSelection(ctx);
		}
		// Add preview lines right after polygon selection
		drawKADPreviewLine(ctx);

		// Step HUD) Update HUD stats panel instead of ctx.fillText
		// Use lastMouseX and lastMouseY if available, otherwise default to 0
		const mouseX = typeof lastMouseX !== "undefined" ? lastMouseX : 0;
		const mouseY = typeof lastMouseY !== "undefined" ? lastMouseY : 0;
		// Convert canvas (mouse) coordinates to world coordinates
		const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
		const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

		// Count KAD entities by type from allKADDrawingsMap
		var kadPointCount = 0, kadLineCount = 0, kadPolyCount = 0, kadCircleCount = 0, kadTextCount = 0;
		if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
			allKADDrawingsMap.forEach(function (kadObj) {
				if (kadObj.entityType === "point") kadPointCount++;
				else if (kadObj.entityType === "line") kadLineCount++;
				else if (kadObj.entityType === "poly") kadPolyCount++;
				else if (kadObj.entityType === "circle") kadCircleCount++;
				else if (kadObj.entityType === "text") kadTextCount++;
			});
		}

		// Count unique blast names
		var blastNames = new Set();
		if (allBlastHoles && Array.isArray(allBlastHoles)) {
			for (var i = 0; i < allBlastHoles.length; i++) {
				if (allBlastHoles[i].entityName) {
					blastNames.add(allBlastHoles[i].entityName);
				}
			}
		}

		// Emit to HUD
		emitStats({
			blastsCount: blastNames.size,
			holesCount: allBlastHoles ? allBlastHoles.length : 0,
			pointsCount: kadPointCount,
			linesCount: kadLineCount,
			polysCount: kadPolyCount,
			circlesCount: kadCircleCount,
			textsCount: kadTextCount,
			version: buildVersion
		});

		// Get Z from snapped point or drawing elevation
		var worldZ = currentMouseWorldZ || drawingZValue || 0;
		// Check if currently snapped (snapHighlight is set when snapped)
		var isCurrentlySnapped = snapHighlight !== null && snapEnabled;
		emitCoords(
			{ x: mouseX, y: mouseY },
			{ x: worldX, y: worldY, z: parseFloat(worldZ) || 0 },
			currentScale,
			isCurrentlySnapped
		);

		if (drawMouseLines) {
			drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, true, true);
		}

		// Draw crosshair indicator for Add Hole tool
		if (isAddingHole) {
			ctx.beginPath();
			ctx.strokeStyle = "rgba(209, 0, 0, 0.8)"; // Red crosshair
			ctx.lineWidth = 2;

			// Horizontal line
			ctx.moveTo(mouseX - snapRadiusPixels * 1.5, mouseY);
			ctx.lineTo(mouseX + snapRadiusPixels * 1.5, mouseY);
			// Vertical line
			ctx.moveTo(mouseX, mouseY - snapRadiusPixels * 1.5);
			ctx.lineTo(mouseX, mouseY + snapRadiusPixels * 1.5);
			ctx.stroke();

			// Optional: Draw small circle at center
			ctx.beginPath();
			ctx.arc(mouseX, mouseY, 3, 0, Math.PI * 2);
			ctx.fillStyle = "rgba(209, 0, 0, 0.6)";
			ctx.fill();
		}

		// Draw live ruler while measuring
		if (isRulerActive && rulerStartPoint && !rulerEndPoint) {
			// Get current snap result at mouse position
			const snapResult = canvasToWorldWithSnap(mouseX, mouseY);

			// // DEBUG: Log the actual values being used
			// console.log("Live Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, rulerStartPoint.z);
			// console.log("  Mouse Point:", snapResult.worldX, snapResult.worldY, snapResult.worldZ);
			// console.log("  Snap Result:", snapResult);

			// Use the snapped coordinates
			const worldMouseX = snapResult.worldX;
			const worldMouseY = snapResult.worldY;
			const worldMouseZ = snapResult.worldZ;

			// Ensure we have valid Z values
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = worldMouseZ !== undefined && worldMouseZ !== null ? worldMouseZ : startZ;

			// console.log("  Final Z values - startZ:", startZ, "endZ:", endZ);

			// Draw the full ruler from start point to mouse position
			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, worldMouseX, worldMouseY, endZ);
		}
		// Draw active rulers (completed measurements)
		if (isRulerActive && rulerStartPoint && rulerEndPoint) {
			// Ensure Z values exist and are valid numbers
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = rulerEndPoint.z !== undefined && rulerEndPoint.z !== null ? rulerEndPoint.z : 0;

			// console.log("Completed Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, startZ);
			// console.log("  End Point:", rulerEndPoint.x, rulerEndPoint.y, endZ);

			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, rulerEndPoint.x, rulerEndPoint.y, endZ);
		}
		// Draw completed bearing measurement
		if (isRulerProtractorActive && rulerProtractorPoints.length === 3) {
			drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, rulerProtractorPoints[2].x, rulerProtractorPoints[2].y);
		}

		// Draw live bearing measurement preview
		if (isRulerProtractorActive && rulerProtractorPoints.length > 0 && rulerProtractorPoints.length < 3) {
			const worldMouseX = (mouseX - canvas.width / 2) / currentScale + centroidX;
			const worldMouseY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

			if (rulerProtractorPoints.length === 1) {
				// After first click - show line from center to mouse
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, worldMouseX, worldMouseY, rulerProtractorPoints[0].x, rulerProtractorPoints[0].y); // Same point for p3
			} else if (rulerProtractorPoints.length === 2) {
				// After second click - show both legs with live second leg
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, worldMouseX, worldMouseY);
			}
		}
		// Step A) Draw pattern tool visuals (2D only - 3D handled in 3D block below)
		drawPatternInPolygonVisual();
		drawPatternOnPolylineVisual();
		drawKADPolygonHighlightSelectedVisuals();
		drawHolesAlongLineVisuals();
		drawKADHighlightSelectionVisuals(); // ADD THIS AS THE VERY LAST LINE:
		// drawAllKADSelectionVisuals(); // this function doesn't get used...
		drawSurfaceLegend();
		// HUD: Show status message (replaces ctx.fillText for status)
		if (statusMessage) {
			showStatusMessage(statusMessage);
		}
		// Update font slider and label after loop (once)
		fontSlider.value = currentFontSize;
		fontLabel.textContent = "Font Size: " + parseFloat(currentFontSize).toFixed(1) + "px";
		if (printMode) {
			drawPrintBoundary(ctx, canvas);
		}
	} else if (!ctx) {
		// Handle missing context
		console.warn("?? Canvas context not available");
	} else if (onlyShowThreeJS) {
		// Three.js-only mode: 2D canvas drawing intentionally skipped
		// This is normal, not an error
	}

	// ===================================================================================
	// CRITICAL AI AGENT NOTICE - DO NOT MODIFY THIS RENDERING LOGIC
	// ===================================================================================
	// When in a Dimension Mode (2D or 3D), the alternate mode must NOT render.
	//
	// REASONS:
	// 1. Performance/Overheads: Rendering both modes doubles the computational load
	// 2. Responsiveness: Dual rendering causes lag and poor user experience
	// 3. Confusion: Users expect only ONE rendering mode active at a time
	//
	// RULE: Use ONLY the onlyShowThreeJS flag to determine which mode renders.
	// DO NOT use isIn3DMode or camera orbit angles - they cause dual rendering!
	//
	// CORRECT LOGIC:
	// - if (onlyShowThreeJS) ? Render ONLY 3D, skip ALL 2D
	// - if (!onlyShowThreeJS) ? Render ONLY 2D, skip ALL 3D
	//
	// This has been broken and fixed multiple times. DO NOT BREAK IT AGAIN.
	// ===================================================================================

	// Step 1c) Create Three.js geometry ONLY when in Three.js-only mode
	// DO NOT check isIn3DMode or orbit angles - that causes dual rendering!
	if (onlyShowThreeJS && threeInitialized) {
		// Step 1d) Draw background images in Three.js
		if (imagesGroupVisible) {
			//console.log("üñºÔ∏è [3D IMAGE] Processing images for 3D display. Total images:", loadedImages.size);
			loadedImages.forEach((image, imageKey) => {
				console.log("üñºÔ∏è [3D IMAGE] Checking image:", imageKey, {
					visible: image.visible,
					hasCanvas: !!image.canvas,
					hasBbox: !!image.bbox,
					bbox: image.bbox,
					zElevation: image.zElevation,
				});

				if (image.visible && image.canvas && image.bbox) {
					const imageId = image.id || image.name || "image_" + Date.now();
					const imageTransparency = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;
					const imageZElevation = image.zElevation !== undefined ? image.zElevation : null;
					console.log("üñºÔ∏è[3D IMAGE] Drawing image in 3D:", imageId, "transparency:", imageTransparency, "zElevation:", imageZElevation);
					drawBackgroundImageThreeJS(imageId, image.canvas, image.bbox, imageTransparency, imageZElevation);
				}
			});
		}

		// Draw surfaces (includes Three.js rendering)
		drawSurface();

		// Step 2.4a) Update surface legend in 3D mode (must be called after drawSurface)
		drawSurfaceLegend();

		// Step 2.5) Get display options for 3D rendering
		const displayOptions3D = getDisplayOptions();

		// Step 3.0) Draw contours in Three.js (3D-only mode)
		// CRITICAL FIX: This was incorrectly placed inside the 2D-only block, so 3D contours never rendered
		// The 3D contour drawing must be here in the Three.js-only block
		if (displayOptions3D.contour && contourLinesArray && contourLinesArray.length > 0) {
			console.log("üî∂ 3D Contours: Drawing " + contourLinesArray.length + " contour levels in Three.js");
			drawContoursThreeJS(contourLinesArray, strokeColor, allBlastHoles);
		}

		// Step 3.0b) Draw direction arrows in Three.js (3D-only mode)
		// CRITICAL FIX: This was incorrectly placed inside the 2D-only block, so 3D arrows never rendered
		if (displayOptions3D.firstMovement && directionArrows && directionArrows.length > 0) {
			console.log("üî∂ 3D Direction Arrows: Drawing " + directionArrows.length + " arrows in Three.js");
			drawDirectionArrowsThreeJS(directionArrows, allBlastHoles);
		}

		// Step 3.1) Draw slope map in Three.js (3D-only mode)
		if (displayOptions3D.slopeMap && allBlastHoles && allBlastHoles.length > 0) {
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			if (resultTriangles && resultTriangles.length > 0) {
				drawSlopeMapThreeJS(resultTriangles, allBlastHoles);
				// HUD: Show slope legend in 3D mode
				showSlopeLegend();
			}
		} else {
			// HUD: Hide slope legend in 3D mode when not displayed
			hideSlopeLegend();
		}

		// Step 3.2) Draw burden relief map in Three.js (3D-only mode)
		if (displayOptions3D.burdenRelief && allBlastHoles && allBlastHoles.length > 0) {
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			if (reliefTriangles && reliefTriangles.length > 0) {
				drawBurdenReliefMapThreeJS(reliefTriangles, allBlastHoles);
				// HUD: Show relief legend in 3D mode
				showReliefLegend();
			}
		} else {
			// HUD: Hide relief legend in 3D mode when not displayed
			hideReliefLegend();
		}

		// Step 3.3) Draw Voronoi cells in Three.js (3D-only mode)
		if (displayOptions3D.voronoiPF && allBlastHoles && allBlastHoles.length > 0) {
			var voronoiMetrics3D = getVoronoiMetrics(allBlastHoles, useToeLocation);
			var clippedCells3D = clipVoronoiCells(voronoiMetrics3D);
			if (clippedCells3D && clippedCells3D.length > 0) {
				// Step 3.3a) Use the selected voronoi metric for coloring
				var selectedMetric3D = selectedVoronoiMetric || "powder_factor";
				var colorFunction3D;
				// Step 3.3b) Map metric name to cell property name
				var cellPropertyName = selectedMetric3D;
				if (selectedMetric3D === "powder_factor") {
					cellPropertyName = "powderFactor";
				}

				// Step 3.3c) Apply isVoronoiLegendFixed check to match 2D behavior
				switch (selectedMetric3D) {
					case "powderFactor":
						var minPF3D, maxPF3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.1) Min-Max mode: calculate from data (min always 0 for PF)
							var pfValues3D = clippedCells3D
								.map(function (c) {
									return c.powderFactor;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minPF3D = 0; // PF min is always 0 per 2D logic (line 21031)
							maxPF3D = pfValues3D.length > 0 ? Math.max.apply(null, pfValues3D) : 3;
						} else {
							// Step 3.3c.2) Fixed mode: use hardcoded values matching 2D (lines 21043-21044)
							minPF3D = 0;
							maxPF3D = 3;
						}
						colorFunction3D = function (value) {
							return getPFColor(value, minPF3D, maxPF3D);
						};
						break;
					case "mass":
						var minMass3D, maxMass3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.3) Min-Max mode: calculate from data (lines 21083-21084)
							var massValues3D = clippedCells3D
								.map(function (c) {
									return c.mass;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minMass3D = massValues3D.length > 0 ? Math.min.apply(null, massValues3D) : 0;
							maxMass3D = massValues3D.length > 0 ? Math.max.apply(null, massValues3D) : 500;
						} else {
							// Step 3.3c.4) Fixed mode: use hardcoded values matching 2D (lines 21095-21096)
							minMass3D = 0;
							maxMass3D = 1000;
						}
						colorFunction3D = function (value) {
							return getMassColor(value, minMass3D, maxMass3D);
						};
						break;
					case "volume":
						var minVol3D, maxVol3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.5) Min-Max mode: calculate from data (lines 21120-21121)
							var volValues3D = clippedCells3D
								.map(function (c) {
									return c.volume;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minVol3D = volValues3D.length > 0 ? Math.min.apply(null, volValues3D) : 0;
							maxVol3D = volValues3D.length > 0 ? Math.max.apply(null, volValues3D) : 100;
						} else {
							// Step 3.3c.6) Fixed mode: use hardcoded values matching 2D (lines 21131-21132)
							minVol3D = 0;
							maxVol3D = 5000;
						}
						colorFunction3D = function (value) {
							return getVolumeColor(value, minVol3D, maxVol3D);
						};
						break;
					case "area":
						var minArea3D, maxArea3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.7) Min-Max mode: calculate from data (lines 21161-21162)
							var areaValues3D = clippedCells3D
								.map(function (c) {
									return c.area;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minArea3D = areaValues3D.length > 0 ? Math.min.apply(null, areaValues3D) : 0;
							maxArea3D = areaValues3D.length > 0 ? Math.max.apply(null, areaValues3D) : 100;
						} else {
							// Step 3.3c.8) Fixed mode: use hardcoded values matching 2D (lines 21172-21173)
							minArea3D = 0;
							maxArea3D = 500;
						}
						colorFunction3D = function (value) {
							return getAreaColor(value, minArea3D, maxArea3D);
						};
						break;
					case "measuredLength":
						var minMLen3D, maxMLen3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.9) Min-Max mode: calculate from data (lines 21204-21205)
							var mLenValues3D = clippedCells3D
								.map(function (c) {
									return c.measuredLength;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minMLen3D = mLenValues3D.length > 0 ? Math.min.apply(null, mLenValues3D) : 0;
							maxMLen3D = mLenValues3D.length > 0 ? Math.max.apply(null, mLenValues3D) : 50;
						} else {
							// Step 3.3c.10) Fixed mode: use hardcoded values matching 2D (lines 21219-21220)
							minMLen3D = 0;
							maxMLen3D = 50;
						}
						colorFunction3D = function (value) {
							return getLengthColor(value, minMLen3D, maxMLen3D);
						};
						break;
					case "designedLength":
						var minDLen3D, maxDLen3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.11) Min-Max mode: calculate from data (lines 21254-21255)
							var dLenValues3D = clippedCells3D
								.map(function (c) {
									return c.designedLength;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minDLen3D = dLenValues3D.length > 0 ? Math.min.apply(null, dLenValues3D) : 0;
							maxDLen3D = dLenValues3D.length > 0 ? Math.max.apply(null, dLenValues3D) : 50;
						} else {
							// Step 3.3c.12) Fixed mode: use hardcoded values matching 2D (lines 21269-21270)
							minDLen3D = 0;
							maxDLen3D = 50;
						}
						colorFunction3D = function (value) {
							return getLengthColor(value, minDLen3D, maxDLen3D);
						};
						break;
					case "holeFiringTime":
						var minHTime3D, maxHTime3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.13) Min-Max mode: calculate from data (lines 21354-21355)
							var hTimeValues3D = clippedCells3D
								.map(function (c) {
									return c.holeFiringTime;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minHTime3D = hTimeValues3D.length > 0 ? Math.min.apply(null, hTimeValues3D) : 0;
							maxHTime3D = hTimeValues3D.length > 0 ? Math.max.apply(null, hTimeValues3D) : 5000;
						} else {
							// Step 3.3c.14) Fixed mode: use hardcoded values matching 2D (lines 21365-21366)
							minHTime3D = 0;
							maxHTime3D = 5000;
						}
						colorFunction3D = function (value) {
							return getHoleFiringTimeColor(value, minHTime3D, maxHTime3D);
						};
						break;
					default:
						// Step 3.3c.15) Default to PF with fixed range
						colorFunction3D = function (value) {
							return getPFColor(value, 0, 3);
						};
						cellPropertyName = "powderFactor";
				}
				drawVoronoiCellsThreeJS(clippedCells3D, colorFunction3D, allBlastHoles, 0.2, useToeLocation, cellPropertyName);

				// HUD: Show appropriate Voronoi legend in 3D mode
				switch (selectedMetric3D) {
					case "powderFactor":
						showVoronoiLegend("Powder Factor (kg/m\u00b3)", minPF3D, maxPF3D);
						break;
					case "mass":
						showVoronoiLegend("Mass (kg)", minMass3D, maxMass3D);
						break;
					case "volume":
						showVoronoiLegend("Volume (m\u00b3)", minVol3D, maxVol3D);
						break;
					case "area":
						showVoronoiLegend("Area (m\u00b2)", minArea3D, maxArea3D);
						break;
					case "measuredLength":
						showVoronoiLegend("Measured Length (m)", minMLen3D, maxMLen3D);
						break;
					case "designedLength":
						showVoronoiLegend("Designed Length (m)", minDLen3D, maxDLen3D);
						break;
					case "holeFiringTime":
						showVoronoiLegend("Hole Firing Time (ms)", minHTime3D, maxHTime3D);
						break;
				}
			}
		} else {
			// HUD: Hide Voronoi legend in 3D mode when not displayed
			hideVoronoiLegend();
		}

		// Step 3.4) CLEAR old highlights and stadium zones EVERY frame (regardless of hole count)
		// This MUST run before any highlighting code to prevent accumulation
		if (threeRenderer) {
			var typesToClear = ["selectionHighlight", "stadiumZone", "kadHighlight", "kadSelectionHighlight", "vertexSelectionHighlight"];
			var groupsToClear = [threeRenderer.holesGroup, threeRenderer.connectorsGroup, threeRenderer.kadGroup];

			groupsToClear.forEach(function (group) {
				if (!group) return;
				var childrenToRemove = [];
				group.children.forEach(function (child) {
					if (child.userData && typesToClear.indexOf(child.userData.type) !== -1) {
						childrenToRemove.push(child);
					}
				});
				childrenToRemove.forEach(function (child) {
					// Dispose geometry and material to prevent memory leaks
					if (child.traverse) {
						child.traverse(function (obj) {
							if (obj.geometry) obj.geometry.dispose();
							if (obj.material) {
								if (Array.isArray(obj.material)) {
									obj.material.forEach(function (m) { m.dispose(); });
								} else {
									obj.material.dispose();
								}
							}
						});
					}
					group.remove(child);
				});
			});
		}

		// Draw holes - ONLY rebuild geometry when data changes
		var toeSizeInMeters3D = document.getElementById("toeSlider") ? document.getElementById("toeSlider").value : 1;
		if (blastGroupVisible && allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			// Step 3.1) Check if instanced rendering is enabled
			var usingInstancedHoles = useInstancedHoles && allBlastHoles.length > 10; // Only use instancing for >10 holes

			// Step 3.1a) Create hole geometry
			if (usingInstancedHoles && threeRenderer) {
				// Step 3.2) Use instanced rendering for hole collars/grades (performance optimization)
				var instanceData = GeometryFactory.createInstancedHoles(
					allBlastHoles,
					holeScale,
					darkModeEnabled,
					worldToThreeLocal
				);

				if (instanceData) {
					// Step 3.2a) Store instanced meshes in renderer
					threeRenderer.instancedCollars = instanceData.instancedCollars;
					threeRenderer.instancedGrades = instanceData.instancedGrades;
					threeRenderer.instanceIdToHole = instanceData.instanceIdToHole;
					threeRenderer.holeToInstanceId = instanceData.holeToInstanceId;
					threeRenderer.instancedHolesCount = instanceData.holeCount;

					// Step 3.2b) Add instanced meshes to scene
					threeRenderer.holesGroup.add(instanceData.instancedCollars);
					threeRenderer.holesGroup.add(instanceData.instancedGrades);

					// Step 3.2c) CRITICAL: Instanced collars only draw circles, NOT tracks/toes/text!
					// We still need to draw the tracks, toe markers, and text labels individually
					for (var holeIdx = 0; holeIdx < allBlastHoles.length; holeIdx++) {
						var hole = allBlastHoles[holeIdx];
						if (hole.visible === false) continue;

						// Step 3.2c.1) Draw track lines (collar->grade->toe) - NOT instanced!
						// These vary in length/angle so can't be efficiently instanced
						var holeLength = parseFloat(hole.holeLengthCalculated);
						if (holeLength > 0 && !isNaN(holeLength)) {
							// Draw track from collar to toe using individual geometry
							var collarLocal = worldToThreeLocal(hole.startXLocation, hole.startYLocation);
							var gradeLocal = worldToThreeLocal(hole.gradeXLocation, hole.gradeYLocation);
							var toeLocal = worldToThreeLocal(hole.endXLocation, hole.endYLocation);
							var trackGroup = GeometryFactory.createHoleTrack(
								collarLocal.x, collarLocal.y, hole.startZLocation || 0,
								gradeLocal.x, gradeLocal.y, hole.gradeZLocation || 0,
								toeLocal.x, toeLocal.y, hole.endZLocation || 0,
								hole.holeDiameter, hole.holeColor || "#FF0000", holeScale, hole.subdrillAmount || 0, darkModeEnabled
							);
							if (trackGroup) {
								threeRenderer.holesGroup.add(trackGroup);
							}

							// Step 3.2c.2) Draw toe circle in Three.js
							var toeRadiusWorld = parseFloat(toeSizeInMeters3D);
							var toeColor = strokeColor;
							var toeHoleId = hole.entityName + ":::" + hole.holeID;
							drawHoleToeThreeJS(hole.endXLocation, hole.endYLocation, hole.endZLocation || 0, toeRadiusWorld, toeColor, toeHoleId);
						}

						// Step 3.2c.3) Draw hole text labels
						if (threeInitialized) {
							drawHoleTextsAndConnectorsThreeJS(hole, displayOptions3D);
						}
					}

					if (developerModeEnabled) {
						console.log("üöÄ Instanced holes: " + instanceData.holeCount + " collars/grades + individual tracks/toes/text");
					}
				}
			} else {
				// Step 3.2c) Non-instanced: draw individual hole geometry
				for (var holeIdx = 0; holeIdx < allBlastHoles.length; holeIdx++) {
					var hole = allBlastHoles[holeIdx];
					if (hole.visible === false) continue;
					drawHoleThreeJS(hole);

					// Draw toe circle in Three.js (if hole has length)
					if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
						var toeRadiusWorld = parseFloat(toeSizeInMeters3D);
						var toeColor = strokeColor;
						var toeHoleId = hole.entityName + ":::" + hole.holeID;
						drawHoleToeThreeJS(hole.endXLocation, hole.endYLocation, hole.endZLocation || 0, toeRadiusWorld, toeColor, toeHoleId);
					}

					// Draw hole text labels
					if (threeInitialized) {
						drawHoleTextsAndConnectorsThreeJS(hole, displayOptions3D);
					}
				}
			}

			// Step 3.5) Highlighting and connectors - run EVERY frame (not just on rebuild)
			// NOTE: Highlight clearing moved to Step 3.4 (outside holes block) so it runs even with 0 holes

			for (var holeIdx = 0; holeIdx < allBlastHoles.length; holeIdx++) {
				var hole = allBlastHoles[holeIdx];
				if (hole.visible === false) continue;

				// Step 4) Draw connectors in Three.js
				if (threeInitialized && displayOptions3D.connector && hole.fromHoleID) {
					// Build hole map for connector lookup
					const holeMap3D = new Map();
					allBlastHoles.forEach((h) => {
						holeMap3D.set(h.entityName + ":::" + h.holeID, h);
					});

					const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
					const fromHole = holeMap3D.get(splitEntityName + ":::" + splitFromHoleID);
					if (fromHole) {
						const connColor = hole.colorHexDecimal || hole.holeColor || "#FF0000";
						const delayText = displayOptions3D.delayValue ? hole.timingDelayMilliseconds : null;
						const connScale3D = document.getElementById("connSlider") ? document.getElementById("connSlider").value : 100;
						drawConnectorThreeJS(fromHole, hole, connColor, hole.connectorCurve || 0, delayText, connScale3D);
					}
				}

				// Step 5) Draw selection highlighting in Three.js (matching 2D style)
				if (threeInitialized) {
					// Connector mode highlighting
					if (isAddingConnector || isAddingMultiConnector) {
						// Step 5.1) Check if this is the fromHoleStore (compare by entityName and holeID)
						const isFromHole = fromHoleStore && fromHoleStore.entityName === hole.entityName && fromHoleStore.holeID === hole.holeID;
						if (isFromHole) {
							highlightSelectedHoleThreeJS(hole, "first");
							if (isAddingMultiConnector && currentMouseWorldX !== undefined && currentMouseWorldY !== undefined) {
								drawConnectStadiumZoneThreeJS(hole, { x: currentMouseWorldX, y: currentMouseWorldY, z: hole.startZLocation || window.dataCentroidZ || 0 }, connectAmount);
							}
							drawToolPromptThreeJS("1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)", { x: hole.startXLocation, y: hole.startYLocation, z: hole.startZLocation }, "rgba(0, 190, 0, .8)");
						} else if (firstSelectedHole && firstSelectedHole.entityName === hole.entityName && firstSelectedHole.holeID === hole.holeID) {
							highlightSelectedHoleThreeJS(hole, "first");
							drawToolPromptThreeJS("1st Selected Hole: " + hole.holeID + " in: " + hole.entityName, { x: hole.startXLocation, y: hole.startYLocation, z: hole.startZLocation }, "rgba(0, 190, 0, .8)");
						} else if (secondSelectedHole && secondSelectedHole === hole) {
							highlightSelectedHoleThreeJS(hole, "second");
							drawToolPromptThreeJS("2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)", { x: hole.startXLocation, y: hole.startYLocation, z: hole.startZLocation }, "rgba(255, 200, 0, .8)");
						}
					}
					// Regular selection highlighting
					else if (selectedHole && selectedHole === hole) {
						highlightSelectedHoleThreeJS(hole, "selected");
						// HUD: Show selection message (replaces drawToolPromptThreeJS)
						showSelectionMessage("Editing Selected Hole: " + selectedHole.holeID + " in: " + selectedHole.entityName + "\nEscape key to clear Selection");
					}
					// Multiple selection highlighting
					else if (selectedMultipleHoles && selectedMultipleHoles.find((h) => h.entityName === hole.entityName && h.holeID === hole.holeID)) {
						highlightSelectedHoleThreeJS(hole, "multi");
						if (hole === selectedMultipleHoles[0]) {
							// HUD: Show multi-selection message (cap at 10 holes)
							var holeIDs = selectedMultipleHoles.map((h) => h.holeID);
							var displayIDs = holeIDs.length > 10 ? holeIDs.slice(0, 10).join(",") + "..." : holeIDs.join(",");
							showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs + "}\nEscape key to clear Selection");
						}
					}
					// Animation/timing window highlighting
					if (timingWindowHolesSelected && timingWindowHolesSelected.find((h) => h.entityName === hole.entityName && h.holeID === hole.holeID)) {
						if (isPlaying) {
							highlightSelectedHoleThreeJS(hole, "animation-playing");
						} else {
							highlightSelectedHoleThreeJS(hole, "animation-paused");
						}
					}
				}
			}
		}

		// Step 3) Draw KAD entities in Three.js
		if (drawingsGroupVisible) {
			// Step 3.1) SUPER-BATCH: For large DXF files, merge ALL lines/polys into ONE geometry
			// This reduces 3799 draw calls to just 1 - massive performance improvement!
			var linePolyEntities = [];
			var pointEntities = [];
			var circleEntities = [];
			var hasLinesOrPolys = (linesGroupVisible || polygonsGroupVisible);
			var usedSuperBatchLines = false;
			var usedSuperBatchPoints = false;
			var usedSuperBatchCircles = false;
			var superBatchedLineEntities = new Map(); //Track which line/poly entities were actually superbatched.

			if (use3DSimplification && allKADDrawingsMap.size > 50) {
				// Step 3.1a) Collect all visible entities by type for super-batch
				for (var [entityName, entity] of allKADDrawingsMap.entries()) {
					if (entity.visible === false) continue;
					// Add entityName to entity for reference in super-batch
					entity.entityName = entityName;

					if (entity.entityType === "line" && linesGroupVisible) {
						linePolyEntities.push(entity);
					} else if (entity.entityType === "poly" && polygonsGroupVisible) {
						linePolyEntities.push(entity);
					} else if (entity.entityType === "point" && pointsGroupVisible) {
						pointEntities.push(entity);
					} else if (entity.entityType === "circle" && circlesGroupVisible) {
						circleEntities.push(entity);
					}
				}

				// Step 3.1b) Create HYBRID super-batched geometry for LINES/POLYGONS
				// Uses fast LineBasicMaterial for thin lines (<=1), FatLines for thick (>1)
				if (linePolyEntities.length > 0) {
					// LineMaterial resolution uses window dimensions (CSS pixels)
					var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
					var hybridBatch = GeometryFactory.createHybridSuperBatchedLines(linePolyEntities, worldToThreeLocal, resolution);
					if (hybridBatch) {
						// Add thin lines batch (1 draw call for all standard lines)
						if (hybridBatch.thinLineSegments) {
							threeRenderer.kadGroup.add(hybridBatch.thinLineSegments);
						}
						// Add fat lines batches (1 draw call per unique thick lineWidth)
						hybridBatch.fatLinesByWidth.forEach(function (fatBatch) {
							threeRenderer.kadGroup.add(fatBatch);
						});
						usedSuperBatchLines = true;
						superBatchedLineEntities = hybridBatch.entityRanges;
						if (developerModeEnabled) {
							var fatCount = hybridBatch.fatLinesByWidth.size;
							var drawCalls = (hybridBatch.thinLineSegments ? 1 : 0) + fatCount;
							console.log("üöÄ HYBRID-BATCH LINES: " + linePolyEntities.length + " entities (" + hybridBatch.thinCount + " thin + " + hybridBatch.thickCount + " thick segments) in " + drawCalls + " draw calls");
						}
					}
				}

				// Step 3.1c) Create super-batched geometry for POINTS
				if (pointEntities.length > 0) {
					var superBatchPoints = drawKADSuperBatchedPointsThreeJS(pointEntities, worldToThreeLocal);
					if (superBatchPoints) {
						usedSuperBatchPoints = true;
						if (developerModeEnabled) {
							console.log("üöÄ SUPER-BATCH POINTS: " + pointEntities.length + " entities (" + superBatchPoints.totalPoints + " points) merged into 1 draw call");
						}
					}
				}

				// Step 3.1d) Create HYBRID super-batched geometry for CIRCLES
				// Uses fast LineBasicMaterial for thin circles (<=1), FatLines for thick (>1)
				if (circleEntities.length > 0) {
					// LineMaterial resolution uses window dimensions (CSS pixels)
					var circleResolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
					var hybridCircles = GeometryFactory.createHybridSuperBatchedCircles(circleEntities, worldToThreeLocal, circleResolution);
					if (hybridCircles) {
						// Add thin circles batch
						if (hybridCircles.thinLineSegments) {
							threeRenderer.kadGroup.add(hybridCircles.thinLineSegments);
						}
						// Add fat circles batches
						hybridCircles.fatLinesByWidth.forEach(function (fatBatch) {
							threeRenderer.kadGroup.add(fatBatch);
						});
						usedSuperBatchCircles = true;
						if (developerModeEnabled) {
							var fatCircleCount = hybridCircles.fatLinesByWidth.size;
							var circleDrawCalls = (hybridCircles.thinLineSegments ? 1 : 0) + fatCircleCount;
							console.log("üöÄ HYBRID-BATCH CIRCLES: " + circleEntities.length + " entities (" + hybridCircles.thinCount + " thin + " + hybridCircles.thickCount + " thick) in " + circleDrawCalls + " draw calls");
						}
					}
				}
				
				// Step 3.1e) CRITICAL: Update LineMaterial resolution after adding all fat lines
				// This ensures fat lines render with correct thickness on initial draw
				if (typeof updateAllLineMaterialResolution === "function") {
					updateAllLineMaterialResolution();
				}
			}

			// Step 3.2) Draw remaining entities (texts, and points/circles/lines/polys if not super-batched)

			for (const [name, entity] of allKADDrawingsMap.entries()) {
				if (entity.visible === false) continue;

				// Step 4) Check sub-group visibility and skip if super-batched
				let subGroupVisible = true;
				switch (entity.entityType) {
					case "point":
						subGroupVisible = pointsGroupVisible;
						// Skip if already super-batched
						if (usedSuperBatchPoints) continue;
						break;
					case "line":
						subGroupVisible = linesGroupVisible;
						// Skip if already super-batched
						if (superBatchedLineEntities.has(name)) continue;
						break;
					case "poly":
						subGroupVisible = polygonsGroupVisible;
						// Skip if already super-batched
						if (superBatchedLineEntities.has(name)) continue;
						break;
					case "circle":
						subGroupVisible = circlesGroupVisible;
						// Skip if already super-batched
						if (usedSuperBatchCircles) continue;
						break;
					case "text":
						subGroupVisible = textsGroupVisible;
						break;
				}

				if (!subGroupVisible) continue;

				// Step 5) Render each KAD entity type (with local coordinate conversion)
				if (entity.entityType === "point") {
					for (const pointData of entity.data) {
						if (pointData.visible === false) continue;
						const size = ((pointData.lineWidth || 2) / 2) * 0.25; // Convert diameter to radius (lineWidth 3 = radius 1.5, scaled by 0.1)
						const local = worldToThreeLocal(pointData.pointXLocation, pointData.pointYLocation);
						const vertexIndex = entity.data.indexOf(pointData);
						const kadId = name + ":::" + vertexIndex;
						drawKADPointThreeJS(local.x, local.y, pointData.pointZLocation || 0, size, pointData.color || "#FF0000", kadId); // kadId format: "entityName:::vertexIndex"
					}
				} else if (entity.entityType === "line" || entity.entityType === "poly") {
					// Step 6) Lines and Polygons: Draw segment-by-segment (matches 2D canvas behavior)
					// Each segment gets its own lineWidth and color from point data
					var visiblePoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});

					if (visiblePoints.length >= 2) {
						// Step 6a) Skip frustum culling for now - just use all visible points
						// The batching alone gives 100x performance improvement
						var pointsToRender = visiblePoints;

						// Step 6b) Check if lineWidths vary across points
						var hasVaryingLineWidths = false;
						if (pointsToRender.length > 1) {
							var firstWidth = pointsToRender[0].lineWidth || 1;
							for (var i = 1; i < pointsToRender.length; i++) {
								if ((pointsToRender[i].lineWidth || 1) !== firstWidth) {
									hasVaryingLineWidths = true;
									break;
								}
							}
						}

						// Step 6c) Draw entity - BATCHED approach for performance when simplification enabled
						// CRITICAL OPTIMIZATION: Instead of creating one mesh per segment (thousands of draw calls),
						// create ONE mesh for the entire entity (one draw call per entity!)
						// NOTE: Batching requires uniform lineWidth - if widths vary, use segment-by-segment

						if (use3DSimplification && !hasVaryingLineWidths) {
							// Step 6c.1) FAST PATH: Use batched rendering (ONE draw call per entity!)
							// Convert points to local coordinates with COLORS for vertex coloring
							var batchedPoints = [];
							for (var i = 0; i < pointsToRender.length; i++) {
								var p = pointsToRender[i];
								var local = worldToThreeLocal(p.pointXLocation, p.pointYLocation);
								// Properly handle NaN values - NaN || 0 still gives NaN!
								var zVal = p.pointZLocation;
								if (isNaN(zVal) || zVal === null || zVal === undefined) {
									zVal = 0;
								}
								batchedPoints.push({
									x: local.x,
									y: local.y,
									z: zVal,
									color: p.color || "#777777" // Use actual color or DXF default gray
								});
							}

							// Use first point's lineWidth (lineWidth varies less than color typically)
							var entityLineWidth = pointsToRender[0].lineWidth || 1;
							var entityColor = pointsToRender[0].color || "#FFFFFF"; // Fallback color
							var isPolygon = entity.entityType === "poly";

							if(developerModeEnabled){
							console.log("[3D Batched] entity:", name, "lineWidth:", entityLineWidth, "rawValue:", pointsToRender[0].lineWidth, "numPoints:", pointsToRender.length);
						}

							// ONE draw call for entire entity with per-vertex colors!
							drawKADBatchedPolylineThreeJS(batchedPoints, entityLineWidth, entityColor, name, isPolygon);

						} else {
							// Step 6c.2) SLOW PATH: Segment-by-segment for full color/width control
							// NOTE: Segment color uses nextPoint.color (the "to" point) because when user clicks
							// a point with a new color, that color should apply to the segment leading TO that point
							var segmentsForThisEntity = pointsToRender.length - 1;

							console.log("[3D Segment-by-Segment] entity:", name, "numSegments:", segmentsForThisEntity);

							for (var i = 0; i < pointsToRender.length - 1; i++) {
								var currentPoint = pointsToRender[i];
								var nextPoint = pointsToRender[i + 1];

								var currentLocal = worldToThreeLocal(currentPoint.pointXLocation, currentPoint.pointYLocation);
								var nextLocal = worldToThreeLocal(nextPoint.pointXLocation, nextPoint.pointYLocation);

								// Use nextPoint's color and lineWidth - the segment TO the point uses that point's attributes
								var lineWidth = nextPoint.lineWidth || 1;
								var color = nextPoint.color || "#FF0000";

								if (i === 0) {
									console.log("[3D Segment] segment", i, "lineWidth:", lineWidth, "rawValue:", nextPoint.lineWidth, "color:", color);
								}

								if (entity.entityType === "line") {
									drawKADLineSegmentThreeJS(currentLocal.x, currentLocal.y, currentPoint.pointZLocation || 0, nextLocal.x, nextLocal.y, nextPoint.pointZLocation || 0, lineWidth, color, name);
								} else {
									drawKADPolygonSegmentThreeJS(currentLocal.x, currentLocal.y, currentPoint.pointZLocation || 0, nextLocal.x, nextLocal.y, nextPoint.pointZLocation || 0, lineWidth, color, name);
								}
							}

							// For polygons, close the loop with final segment
							// NOTE: Closing segment goes TO firstPoint, so use firstPoint's color
							if (entity.entityType === "poly" && pointsToRender.length > 2) {
								var firstPoint = pointsToRender[0];
								var lastPoint = pointsToRender[pointsToRender.length - 1];

								var firstLocal = worldToThreeLocal(firstPoint.pointXLocation, firstPoint.pointYLocation);
								var lastLocal = worldToThreeLocal(lastPoint.pointXLocation, lastPoint.pointYLocation);

								// Use firstPoint's color - the closing segment goes TO the first point
								var lineWidth = firstPoint.lineWidth || 1;
								var color = firstPoint.color || "#FF0000";

								drawKADPolygonSegmentThreeJS(lastLocal.x, lastLocal.y, lastPoint.pointZLocation || 0, firstLocal.x, firstLocal.y, firstPoint.pointZLocation || 0, lineWidth, color, name);
							}
						}

						// Step 6d) Draw invisible vertex markers for selection (raycasting only - no visual)
						// IMPORTANT: Use original visiblePoints, NOT simplified points, for vertex selection
						// Vertices are hidden but still selectable - pink highlight appears on selection via move tool
						for (var i = 0; i < visiblePoints.length; i++) {
							var point = visiblePoints[i];
							var local = worldToThreeLocal(point.pointXLocation, point.pointYLocation);
							var vertexIndex = entity.data.indexOf(point);
							var kadId = name + ":::" + vertexIndex;
							var vertexSize = 0.3; // Small marker for vertex selection (invisible)

							// Create invisible point for raycasting only
							var pointMesh = GeometryFactory.createKADPoint(local.x, local.y, point.pointZLocation || 0, vertexSize, point.color || "#FF0000");
							pointMesh.userData = { type: "kadPoint", kadId: kadId };
							pointMesh.visible = false; // Make invisible but keep in scene for raycasting
							window.threeRenderer.kadGroup.add(pointMesh);
						}
					}
				} else if (entity.entityType === "circle") {
					for (const circleData of entity.data) {
						if (circleData.visible === false) continue;
						const centerX = circleData.centerX || circleData.pointXLocation;
						const centerY = circleData.centerY || circleData.pointYLocation;
						const centerZ = circleData.centerZ || circleData.pointZLocation || 0;
						const radius = circleData.radius || 10; // Radius in world units
						const local = worldToThreeLocal(centerX, centerY);
						const vertexIndex = entity.data.indexOf(circleData);
						const kadId = name + ":::" + vertexIndex;
						drawKADCircleThreeJS(local.x, local.y, centerZ, radius, circleData.lineWidth || 1, circleData.color || "#FF0000", kadId); // kadId format: "entityName:::vertexIndex"
					}
				} else if (entity.entityType === "text") {
					for (const textData of entity.data) {
						if (textData.visible === false) continue;
						const local = worldToThreeLocal(textData.pointXLocation, textData.pointYLocation);
						const vertexIndex = entity.data.indexOf(textData);
						const kadId = name + ":::" + vertexIndex;
						// Step B2) Use fontHeight attribute for text size, default to 12
						var textFontSize = textData.fontHeight || 12;
						drawKADTextThreeJS(local.x, local.y, textData.pointZLocation || 0, textData.text || "", textFontSize, textData.color || "#000000", textData.backgroundColor || null, kadId); // kadId format: "entityName:::vertexIndex"
					}
				}
			}
		}

		// Step 6) Highlight selected KAD objects in Three.js (after KAD drawing)
		highlightSelectedKADThreeJS();
	}

	// Step 2) Render Three.js scene ONLY when in Three.js-only mode
	// CRITICAL: DO NOT check isIn3DMode - use ONLY onlyShowThreeJS flag
	if (onlyShowThreeJS) {
		// Step 2a) Ensure mouse indicator is always visible in 3D mode
		// Draw it at current mouse position or camera center if no mouse position yet
		if (onlyShowThreeJS && threeInitialized && threeRenderer && interactionManager) {
			// Use current mouse world position if available, otherwise use camera centroid
			let indicatorPos = null;
			if (currentMouseWorldX !== undefined && currentMouseWorldY !== undefined && isFinite(currentMouseWorldX) && isFinite(currentMouseWorldY)) {
				indicatorPos = {
					x: currentMouseWorldX,
					y: currentMouseWorldY,
					z: window.dataCentroidZ || 0,
				};
			} else {
				// Fallback to camera centroid
				const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
				if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
					const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
					const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
					indicatorPos = {
						x: cameraState.centroidX + originX,
						y: cameraState.centroidY + originY,
						z: window.dataCentroidZ || 0,
					};
				} else if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
					indicatorPos = {
						x: centroidX,
						y: centroidY,
						z: window.dataCentroidZ || 0,
					};
				}
			}

			if (indicatorPos && isFinite(indicatorPos.x) && isFinite(indicatorPos.y)) {
				drawMousePositionIndicatorThreeJS(indicatorPos.x, indicatorPos.y, indicatorPos.z);
			}
		}

		// Step B) Draw 3D visuals for pattern tools (MUST be in 3D block to actually render!)
		// These were incorrectly placed in the 2D block where onlyShowThreeJS is always false
		drawPatternInPolygon3DVisual();
		drawHolesAlongPolyline3DVisual();
		drawHolesAlongLine3DVisual();

		renderThreeJS();

		if (developerModeEnabled) {
			console.log("üßä Three.js scene rendered - drawData()");
		}
	}
}

function drawKADCoordinates(kadPoint, screenX, screenY) {
	const displayOptions = getDisplayOptions();

	// Calculate text offset based on current scale and font size
	const textOffset = Math.max(10, parseInt(currentFontSize * 0.5));
	const leftSide = parseInt(screenX) - textOffset;
	const rightSide = parseInt(screenX) + textOffset;
	const topSide = parseInt(screenY - textOffset);
	const middleSide = parseInt(screenY + parseInt(currentFontSize / 2));
	const bottomSide = parseInt(screenY + textOffset + parseInt(currentFontSize));

	// Set font for coordinate display
	ctx.font = parseInt(currentFontSize * 0.5) + "px Arial";

	// Display X coordinate (right side, top)
	if (displayOptions.xValue) {
		drawText(rightSide, topSide, parseFloat(kadPoint.pointXLocation).toFixed(2), textFillColor);
	}

	// Display Y coordinate (right side, middle)
	if (displayOptions.yValue) {
		drawText(rightSide, middleSide, parseFloat(kadPoint.pointYLocation).toFixed(2), textFillColor);
	}

	// Display Z coordinate (right side, bottom)
	if (displayOptions.zValue) {
		drawText(rightSide, bottomSide, parseFloat(kadPoint.pointZLocation).toFixed(2), textFillColor);
	}
}

// Draws Voronoi cells only - legend is now in HUD overlay
function drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, getColorForMetric, legendLabel, minValue, maxValue, step) {
	// Legend drawing removed - now using HUD overlay (showVoronoiLegend)

	const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
	const clippedCells = clipVoronoiCells(voronoiMetrics);

	for (const cell of clippedCells) {
		const value = cell[selectedVoronoiMetric];
		if (!cell.polygon || value == null) continue;
		ctx.beginPath();
		for (let j = 0; j < cell.polygon.length; j++) {
			const pt = cell.polygon[j];
			const [x, y] = worldToCanvas(pt.x !== undefined ? pt.x : pt[0], pt.y !== undefined ? pt.y : pt[1]);
			if (j === 0) ctx.moveTo(x, y);
			else ctx.lineTo(x, y);
		}
		ctx.closePath();
		ctx.fillStyle = getColorForMetric(value);
		ctx.fill();
		ctx.strokeStyle = "#222";
		ctx.lineWidth = 1;
		ctx.stroke();
	}
}

// === Helper: Draw hole labels, connectors, delay text, etc. ===
function drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, ctxObj) {
	const { leftSideToe, rightSideToe, leftSideCollar, rightSideCollar, topSideToe, middleSideToe, bottomSideToe, topSideCollar, middleSideCollar, bottomSideCollar, holeMap, displayOptions } = ctxObj;

	if (displayOptions.holeID) {
		drawText(rightSideCollar, topSideCollar, hole.holeID, textFillColor);
	}
	if (displayOptions.holeDia) {
		drawText(rightSideCollar, middleSideCollar, parseFloat(hole.holeDiameter).toFixed(0), "green");
	}
	if (displayOptions.holeLen) {
		drawText(rightSideCollar, bottomSideCollar, parseFloat(hole.holeLengthCalculated).toFixed(1), depthColor);
	}
	if (displayOptions.holeAng) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeDip) {
		drawRightAlignedText(leftSideToe, topSideToe, 90 - parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeBea) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.holeBearing).toFixed(1), "red");
	}
	if (displayOptions.holeSubdrill) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.subdrillAmount).toFixed(1), "blue");
	}
	if (displayOptions.initiationTime) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, hole.holeTime, "red");
	}
	if (displayOptions.connector && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			try {
				drawArrow(startX, startY, x, y, connColor, connScale, hole.connectorCurve || 0);
			} catch (error) {
				console.error("Error drawing arrow:", error);
			}
		}
	}
	if (displayOptions.delayValue && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			const pointDelay = hole.timingDelayMilliseconds;
			drawArrowDelayText(startX, startY, x, y, connColor, pointDelay, hole.connectorCurve || 0);
		}
	}
	if (displayOptions.xValue) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.startXLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.yValue) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, parseFloat(hole.startYLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.zValue) {
		drawRightAlignedText(leftSideCollar, bottomSideCollar, parseFloat(hole.startZLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.holeType) {
		drawText(rightSideCollar, middleSideCollar, hole.holeType, "green");
	}
	if (displayOptions.measuredLength) {
		drawRightAlignedText(leftSideCollar, bottomSideToe, hole.measuredLength, "#FF4400");
	}
	if (displayOptions.measuredMass) {
		drawRightAlignedText(leftSideCollar, topSideToe, hole.measuredMass, "#FF6600");
	}
	if (displayOptions.measuredComment) {
		drawText(rightSideCollar, middleSideCollar, hole.measuredComment, "#FF8800");
	}
	if (displayOptions.displayRowAndPosId) {
		drawRightAlignedText(leftSideCollar, topSideCollar, "Row:" + hole.rowID, "#FF00FF");
		drawRightAlignedText(leftSideCollar, middleSideCollar, "Pos:" + hole.posID, "#FF00FF");
	}
}

// === Helper: Draw hole labels in Three.js for 3D mode ===
// Note: drawHoleTextsAndConnectorsThreeJS moved to src/draw/canvas3DDrawing.js

function drawConnectStadiumZone(sx, sy, endX, endY, connectAmount) {
	// Only draw stadium zone if multi-connector tool is active
	if (isAddingMultiConnector) {
		// Convert world coordinates to canvas coordinates
		const [canvasStartX, canvasStartY] = worldToCanvas(sx, sy);
		const [canvasEndX, canvasEndY] = worldToCanvas(endX, endY);

		// connectAmount is already in meters, so just multiply by currentScale
		const radiusPx = connectAmount * currentScale;

		// Calculate the line vector and perpendicular vector
		const dx = canvasEndX - canvasStartX;
		const dy = canvasEndY - canvasStartY;
		const length = Math.sqrt(dx * dx + dy * dy);

		// Avoid division by zero
		if (length < 1) return;

		// Normalize the direction vector
		const dirX = dx / length;
		const dirY = dy / length;

		// Get perpendicular vector (for width)
		const perpX = -dirY;
		const perpY = dirX;

		// Calculate the four corners of the rectangle
		const corner1X = canvasStartX + perpX * radiusPx;
		const corner1Y = canvasStartY + perpY * radiusPx;
		const corner2X = canvasStartX - perpX * radiusPx;
		const corner2Y = canvasStartY - perpY * radiusPx;
		const corner3X = canvasEndX - perpX * radiusPx;
		const corner3Y = canvasEndY - perpY * radiusPx;
		const corner4X = canvasEndX + perpX * radiusPx;
		const corner4Y = canvasEndY + perpY * radiusPx;
		// Set stadium zone color with transparency
		ctx.strokeStyle = "rgba(0, 255, 0, 0.4)";
		ctx.fillStyle = "rgba(0, 255, 0, 0.15)";
		ctx.lineWidth = 2;
		ctx.setLineDash([5, 5]); // Set dashed line with 5px gap and 5px dash

		// Draw the stadium shape (rounded rectangle)
		ctx.beginPath();

		// Start at the center of the first semicircle
		ctx.arc(canvasStartX, canvasStartY, radiusPx, Math.atan2(perpY, perpX), Math.atan2(-perpY, -perpX), false);

		// Line to second corner
		ctx.lineTo(corner3X, corner3Y);

		// Second semicircle
		ctx.arc(canvasEndX, canvasEndY, radiusPx, Math.atan2(-perpY, -perpX), Math.atan2(perpY, perpX), false);

		// Line back to first corner
		ctx.lineTo(corner1X, corner1Y);

		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		// CRITICAL: Reset line dash back to solid line
		ctx.setLineDash([]);
	}
}

// === Helper: Draw main hole, highlight if selected ===
function drawHoleMainShape(hole, x, y, selectedHole) {
	const diameterPx = parseInt((hole.holeDiameter / 1000) * currentScale * holeScale);

	let highlightType = null;
	let highlightColor1 = null,
		highlightColor2 = null,
		highlightText = null;

	// Check if we're in connector mode
	if (isAddingConnector || isAddingMultiConnector) {
		// First selected hole in connector mode (using fromHoleStore)
		if (fromHoleStore && fromHoleStore === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)";
			// Step 4d) Draw 2D stadium zone only when in 2D mode
			if (!onlyShowThreeJS) {
				drawConnectStadiumZone(hole.startXLocation, hole.startYLocation, currentMouseWorldX, currentMouseWorldY, connectAmount);
			}
		}
		// Second selected hole in connector mode (using firstSelectedHole/secondSelectedHole)
		else if (firstSelectedHole && firstSelectedHole === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName;
		} else if (secondSelectedHole && secondSelectedHole === hole) {
			highlightType = "second";
			highlightColor1 = "rgba(255, 255, 0, 0.2)";
			highlightColor2 = "rgba(255, 200, 0, .8)";
			highlightText = "2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)";
		}
	}
	// Regular selection highlighting (NOT in connector mode)
	else if (selectedHole != null && selectedHole === hole) {
		highlightType = "selected";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		highlightText = "";  // Don't draw ctx text anymore
		// HUD: Show selection message
		showSelectionMessage("Editing Selected Hole: " + selectedHole.holeID + " in: " + selectedHole.entityName + "\nEscape key to clear Selection");
	}
	// Multiple selection highlighting
	else if (selectedMultipleHoles != null && selectedMultipleHoles.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		highlightType = "multi";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		if (hole === selectedMultipleHoles[0]) {
			// HUD: Show multi-selection message (cap at 10 holes)
			var holeIDs2D = selectedMultipleHoles.map((h) => h.holeID);
			var displayIDs2D = holeIDs2D.length > 10 ? holeIDs2D.slice(0, 10).join(",") + "..." : holeIDs2D.join(",");
			highlightText = "";  // Don't draw ctx text anymore
			showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs2D + "}\nEscape key to clear Selection");
		} else {
			highlightText = "";
		}
	}

	// Step 4c) Draw highlight, if any (2D only - only when in 2D mode)
	if (highlightType && !onlyShowThreeJS) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 900) * holeScale * currentScale), highlightColor1, highlightColor2);
		// Selection text now shown in HUD instead of ctx
	}

	// Draw main hole/track shape (dummy, missing, or real)
	ctx.lineWidth = 1;
	ctx.strokeStyle = strokeColor;
	if (parseFloat(hole.holeLengthCalculated).toFixed(1) == 0.0) {
		drawDummy(x, y, parseInt(0.2 * holeScale * currentScale), strokeColor);
	} else if (hole.holeDiameter == 0) {
		drawNoDiameterHole(x, y, 10, strokeColor);
	} else {
		drawHole(x, y, diameterPx, fillColor, strokeColor);
	}
}

// === Helper: Handle Highlighting for Animation/Time Window ===
function handleHoleHighlighting(hole, x, y) {
	if (isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 400) * holeScale * currentScale), "rgba(255, 150, 0, 0.7)", "rgba(200, 200, 0, 0.7)");
	}
	if (!isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 500) * holeScale * currentScale), "rgba(0, 255, 0, 0.5)", "rgba(0, 255, 0, 0.7)");
	}
}

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	const canvasX = evt.clientX - rect.left;
	const canvasY = evt.clientY - rect.top;

	lastMouseX = canvasX;
	lastMouseY = canvasY;

	return {
		x: canvasX,
		y: canvasY,
	};
}

function openHelp() {
	window.open("kirrausermanual.html");
}

function zoomIn() {
	// Step 1) Check if 3D mode is active
	if (window.onlyShowThreeJS && window.cameraControls) {
		// Step 1a) Get current camera state
		const currentState = window.cameraControls.getCameraState();
		const zoomFactor = 1.1; // Zoom in by 10%
		const newScale = currentState.scale * zoomFactor;

		// Step 1b) Update camera state with new scale
		window.cameraControls.setCameraState(currentState.centroidX, currentState.centroidY, newScale, currentState.rotation, currentState.orbitX, currentState.orbitY);
		return;
	}

	// Step 2) 2D mode - use existing logic
	currentScale += 1; // increase the current scale by 1
	currentFontSize += 1;
	drawData(allBlastHoles, selectedHole);
}

function zoomOut() {
	// Step 1) Check if 3D mode is active
	if (window.onlyShowThreeJS && window.cameraControls) {
		// Step 1a) Get current camera state
		const currentState = window.cameraControls.getCameraState();
		const zoomFactor = 0.9; // Zoom out by 10%
		const newScale = Math.max(0.01, currentState.scale * zoomFactor);

		// Step 1b) Update camera state with new scale
		window.cameraControls.setCameraState(currentState.centroidX, currentState.centroidY, newScale, currentState.rotation, currentState.orbitX, currentState.orbitY);
		return;
	}

	// Step 2) 2D mode - use existing logic
	currentScale = Math.max(0.25, currentScale - 1); // decrease the current scale by 0.25, but not below 1
	currentFontSize -= 1;
	drawData(allBlastHoles, selectedHole);
}

function getHoleBoundaries() {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null;
	}

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	for (const hole of allBlastHoles) {
		if (hole.startXLocation < minX) minX = hole.startXLocation;
		if (hole.startXLocation > maxX) maxX = hole.startXLocation;
		if (hole.startYLocation < minY) minY = hole.startYLocation;
		if (hole.startYLocation > maxY) maxY = hole.startYLocation;
	}

	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

function zoomToFitAll() {
	const holeBoundaries = getHoleBoundaries();
	const kadBoundaries = getKADBoundaries();
	const surfaceBoundaries = getSurfaceBoundaries(); // NEW
	const imageBoundaries = getImageBoundaries(); // NEW

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	// Include hole boundaries
	if (holeBoundaries) {
		minX = Math.min(minX, holeBoundaries.minX);
		maxX = Math.max(maxX, holeBoundaries.maxX);
		minY = Math.min(minY, holeBoundaries.minY);
		maxY = Math.max(maxY, holeBoundaries.maxY);
	}

	// Include KAD drawing boundaries
	if (kadBoundaries) {
		minX = Math.min(minX, kadBoundaries.minX);
		maxX = Math.max(maxX, kadBoundaries.maxX);
		minY = Math.min(minY, kadBoundaries.minY);
		maxY = Math.max(maxY, kadBoundaries.maxY);
	}

	// NEW: Include surface boundaries
	if (surfaceBoundaries) {
		minX = Math.min(minX, surfaceBoundaries.minX);
		maxX = Math.max(maxX, surfaceBoundaries.maxX);
		minY = Math.min(minY, surfaceBoundaries.minY);
		maxY = Math.max(maxY, surfaceBoundaries.maxY);
	}

	// NEW: Include background image boundaries
	if (imageBoundaries) {
		minX = Math.min(minX, imageBoundaries.minX);
		maxX = Math.max(maxX, imageBoundaries.maxX);
		minY = Math.min(minY, imageBoundaries.minY);
		maxY = Math.max(maxY, imageBoundaries.maxY);
	}

	if (minX === Infinity) {
		// Just set defaults without calling resetZoom()
		currentScale = scale;
		currentFontSize = fontSize;
		updateCentroids();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	centroidX = minX + (maxX - minX) / 2;
	centroidY = minY + (maxY - minY) / 2;

	const dataWidth = maxX - minX;
	const dataHeight = maxY - minY;

	if (dataWidth === 0 || dataHeight === 0) {
		currentScale = 1;
	} else {
		const scaleX = (canvas.width * 0.9) / dataWidth;
		const scaleY = (canvas.height * 0.9) / dataHeight;
		currentScale = Math.min(scaleX, scaleY);
	}

	// Step 1) Sync camera to Three.js after calculating new position/scale
	syncCameraToThreeJS();

	drawData(allBlastHoles, selectedHole);
}
// REPLACE the entire function:
function getSurfaceBoundaries() {
	if (loadedSurfaces.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedSurfaces.forEach((surface) => {
		if (surface.points && surface.points.length > 0) {
			surface.points.forEach((point) => {
				if (point.x < minX) minX = point.x;
				if (point.x > maxX) maxX = point.x;
				if (point.y < minY) minY = point.y;
				if (point.y > maxY) maxY = point.y;
			});
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

// REPLACE the entire function:
function getImageBoundaries() {
	if (loadedImages.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedImages.forEach((image) => {
		if (image.bbox && image.bbox.length >= 4) {
			// image.bbox is [minX, minY, maxX, maxY] format
			if (image.bbox[0] < minX) minX = image.bbox[0];
			if (image.bbox[2] > maxX) maxX = image.bbox[2];
			if (image.bbox[1] < minY) minY = image.bbox[1];
			if (image.bbox[3] > maxY) maxY = image.bbox[3];
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

function resetZoom() {
	currentScale = scale; // reset the current scale to the original scale
	currentFontSize = fontSize;

	// Reset Three.js camera rotation and orbit to top-down view
	if (threeInitialized && cameraControls) {
		currentRotation = 0; // Reset Z-axis rotation
		// Reset orbit angles
		cameraControls.rotation = 0;
		cameraControls.orbitX = 0;
		cameraControls.orbitY = 0;
		console.log("üì∑ Camera reset to top-down view");
	}

	//calculate the centroids from the data in the maps and points
	updateCentroids();

	// Step 2) Sync camera after resetting
	syncCameraToThreeJS();

	drawData(allBlastHoles, selectedHole);
	zoomToFitAll();
}
///SAVE and LOAD ALLBLASTHOLES ARRAY TO LOCAL STORAGE /////////////////////////////////
// DEPRECATED: This function is deprecated. Use debouncedSaveHoles() or saveHolesToDB() instead.
// Kept for backward compatibility but no longer used for persistence.
function saveHolesToLocalStorage(allBlastHoles) {
	if (allBlastHoles !== null) {
		/* STRUCTURE OF THE POINTS ARRAY
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
		entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID,burden,spacing,connectorCurve
	*/
		const lines = allBlastHoles.map((hole) => {
			return `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.gradeXLocation},${hole.gradeYLocation},${hole.gradeZLocation},${hole.subdrillAmount},${hole.subdrillLength},${hole.benchHeight},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated},${hole.holeAngle},${hole.holeBearing},${hole.initiationTime},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}\n`;
		});

		const csvString = lines.join("\n");
		const pointsMap = new Map();

		localStorage.setItem("kirraDataPoints", csvString);

		for (const entity of pointsMap.values()) {
			// console.log(entity);
		}
	}
	console.log("All blast Holes saved to local storage");
	console.log(allBlastHoles);
}

function refreshPoints() {
	// Step 1) Update play speed input based on hole count
	const playSpeedInput = document.getElementById("playSpeed");
	if (allBlastHoles.length > 1000) {
		playSpeedInput.max = 50;
	} else {
		playSpeedInput.max = 15;
	}

	// Step 2) Validate data integrity (duplicate check)
	const duplicateCheck = checkAndResolveDuplicateHoleIDs(allBlastHoles, "data reload");
	if (duplicateCheck.hasDuplicates) {
		console.warn("?? Data corruption detected during reload - duplicates resolved automatically");
		// Save the corrected data via debounced save
		debouncedSaveHoles();
	}

	// Step 3) Recalculate all derived data
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, deltaX, deltaY);
	contourLinesArray = result.contourLinesArray;
	directionArrows = result.directionArrows;

	// Step 4) Recalculate triangles
	const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

	// Step 5) Redraw and update tree view
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();

	return allBlastHoles;
}

// Use this function whenever you need to refresh the state and redraw the canvas
// For example, after deleting a hole or renumbering holes:
// refreshPoints();

// DEPRECATED: This function is deprecated. Use loadHolesFromDB() instead.
// Kept for backward compatibility but no longer used for persistence.
function loadHolesFromLocalStorage() {
	// Initialize points as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}
	/* STRUCTURE OF THE POINTS ARRAY
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
		entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,initiationTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID
	*/
	const csvString = localStorage.getItem("kirraDataPoints");
	//console.log(csvString);
	if (csvString) {
		allBlastHoles = parseK2Dcsv(csvString);
		//console.log(points);
		updateCentroids();
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
		drawData(allBlastHoles, selectedHole);
		//console.log the points array in a blob for each entityname
		const blastHolesMap = new Map();
		for (const hole of allBlastHoles) {
			if (!blastHolesMap.has(hole.entityName)) {
				blastHolesMap.set(hole.entityName, {
					entityName: hole.entityName,
					data: [],
				});
			}
			blastHolesMap.get(hole.entityName).data.push(hole);
		}
		for (const entity of blastHolesMap.values()) {
			//console.log(entity);
		}
		console.log("///////////////////POINTS DATA ON LOAD//////////////");
		console.log(allBlastHoles);
		return allBlastHoles;
	}
	return null;
}

// --- IndexedDB & Local Storage Management ---

let db;
const DB_NAME = "Kirra-DATABASE";
const STORE_NAME = "KADDRAWINGS";
const SURFACE_STORE_NAME = "KADSURFACE";
const IMAGE_STORE_NAME = "KADIMAGES";
const BLASTHOLES_STORE_NAME = "BLASTHOLES";

// Define all required stores - THIS WAS MISSING
const REQUIRED_STORES = [STORE_NAME, SURFACE_STORE_NAME, IMAGE_STORE_NAME, BLASTHOLES_STORE_NAME];

// Start with a higher version that you'll use going forward
const DB_VERSION = 5; // Set this higher than your current version

async function initDB() {
	return new Promise((resolve, reject) => {
		// Open without version to get current state
		const initialRequest = indexedDB.open(DB_NAME);

		initialRequest.onsuccess = (event) => {
			const db = event.target.result;
			const currentVersion = db.version;
			const existingStores = Array.from(db.objectStoreNames);
			const missingStores = REQUIRED_STORES.filter((store) => !existingStores.includes(store));

			console.log("Current version: " + currentVersion);
			console.log("Existing stores: " + existingStores);
			console.log("Missing stores: " + missingStores);

			if (missingStores.length === 0) {
				// All good, use this connection
				resolve(db);
			} else {
				// Need to upgrade
				db.close();

				const upgradeRequest = indexedDB.open(DB_NAME, currentVersion + 1);

				upgradeRequest.onsuccess = () => resolve(upgradeRequest.result);
				upgradeRequest.onerror = () => reject(upgradeRequest.error);

				upgradeRequest.onupgradeneeded = (event) => {
					const upgradeDb = event.target.result;
					console.log("Upgrading database - creating missing stores");

					missingStores.forEach((storeName) => {
						console.log(`Creating store: ${storeName}`);
						const store = upgradeDb.createObjectStore(storeName, {
							keyPath: "id",
						});

						if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
							store.createIndex("name", "name", {
								unique: false,
							});
							store.createIndex("type", "type", {
								unique: false,
							});
						}
					});
				};
			}
		};

		initialRequest.onerror = () => reject(initialRequest.error);

		// Handle new database creation
		initialRequest.onupgradeneeded = (event) => {
			const db = event.target.result;
			console.log("Creating new database with all stores");

			REQUIRED_STORES.forEach((storeName) => {
				console.log(`Creating store: ${storeName}`);
				const store = db.createObjectStore(storeName, {
					keyPath: "id",
				});

				if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
					store.createIndex("name", "name", {
						unique: false,
					});
					store.createIndex("type", "type", {
						unique: false,
					});
				}
			});
		};
	});
}

let saveTimeout;
//Staged Saving for large files as these can't be save on the instantquit of a window close.
function debouncedSaveKAD() {
	// Clear any existing pending save
	clearTimeout(saveTimeout);
	// Set a new save to trigger after 2 seconds
	saveTimeout = setTimeout(() => {
		console.log("Auto-saving KAD drawings to DB...");
		// Only save if DB is initialized
		if (db) {
			saveKADToDB(allKADDrawingsMap);
		} else {
			console.log("DB not ready, skipping auto-save");
		}
	}, 2000);
}

function saveKADToDB(mapData) {
	if (!db) {
		console.error("DB not initialized. Cannot save.");
		return;
	}

	const transaction = db.transaction([STORE_NAME], "readwrite");
	const store = transaction.objectStore(STORE_NAME);
	let request;

	if (mapData.size === 0) {
		request = store.delete("kadDrawingData"); // ? Use consistent record key
	} else {
		const dataToStore = Array.from(mapData.entries());
		request = store.put({
			id: "kadDrawingData",
			data: dataToStore,
		}); // ? Proper object format
	}

	request.onerror = (event) => {
		console.error("Error saving KAD data to IndexedDB:", event.target.error);
	};
}

function loadKADFromDB() {
	return new Promise((resolve, reject) => {
		if (!db) {
			console.error("DB not initialized. Cannot load.");
			return reject("DB not initialized");
		}
		const transaction = db.transaction([STORE_NAME], "readonly");
		const store = transaction.objectStore(STORE_NAME);
		const request = store.get("kadDrawingData"); // ? Use same record key

		request.onsuccess = (event) => {
			const result = event.target.result;
			if (result && result.data && result.data.length > 0) {
				allKADDrawingsMap = new Map(result.data); // ? Access the data property
				console.log("‚úÖ //-- LOADED UNIFIED DRAWING OBJECTS FROM IndexedDB --//");
				debouncedUpdateTreeView();
				drawData(allBlastHoles, selectedHole);
				resolve(true);
			} else {
				resolve(false);
			}
		};

		request.onerror = (event) => {
			console.error("Error loading KAD data from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}

// Step 1) Save blast holes to IndexedDB
// Stores entire allBlastHoles array as single record with id "blastHolesData"
function saveHolesToDB(holesArray) {
	if (!db) {
		console.error("DB not initialized. Cannot save holes.");
		return;
	}

	const transaction = db.transaction([BLASTHOLES_STORE_NAME], "readwrite");
	const store = transaction.objectStore(BLASTHOLES_STORE_NAME);
	let request;

	if (!holesArray || holesArray.length === 0) {
		request = store.delete("blastHolesData"); // Delete record if array is empty
	} else {
		request = store.put({
			id: "blastHolesData",
			data: holesArray,
		}); // Store entire array as data property
	}

	request.onerror = (event) => {
		console.error("Error saving holes data to IndexedDB:", event.target.error);
	};

	request.onsuccess = () => {
		console.log("üíæ Blast holes saved to IndexedDB (" + holesArray.length + " holes)");
	};
}

// Step 2) Load blast holes from IndexedDB
// Returns Promise that resolves to boolean indicating if data was loaded
function loadHolesFromDB() {
	return new Promise((resolve, reject) => {
		if (!db) {
			console.error("DB not initialized. Cannot load holes.");
			return reject("DB not initialized");
		}
		const transaction = db.transaction([BLASTHOLES_STORE_NAME], "readonly");
		const store = transaction.objectStore(BLASTHOLES_STORE_NAME);
		const request = store.get("blastHolesData"); // Use same record key

		request.onsuccess = (event) => {
			const dbResult = event.target.result;
			if (dbResult && dbResult.data && Array.isArray(dbResult.data) && dbResult.data.length > 0) {
				allBlastHoles = dbResult.data; // Populate array from stored data
				console.log("üìä Loaded " + allBlastHoles.length + " blast holes from IndexedDB");

				// Step 2a) Perform same initialization as loadHolesFromLocalStorage()
				updateCentroids();
				holeTimes = calculateTimes(allBlastHoles);

				// Step 2a.1) Force pre-calculate contours regardless of display options
				// This ensures contours are cached and ready when the user enables them
				invalidateContourCache();
				var forceCalcResult = forceRecalculateContours(allBlastHoles);
				contourLinesArray = forceCalcResult.contourLinesArray;
				directionArrows = forceCalcResult.directionArrows;

				// Step 2b) Recalculate triangles
				const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

				// Step 2c) Redraw and update tree view
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();

				resolve(true);
			} else {
				console.log("No holes data found in IndexedDB");
				resolve(false);
			}
		};

		request.onerror = (event) => {
			console.error("Error loading holes data from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}

// Step 3) Debounced save function for blast holes
// Staged saving for large files as these can't be saved on instant quit of window close
let holesSaveTimeout;
function debouncedSaveHoles() {
	// Clear any existing pending save
	clearTimeout(holesSaveTimeout);
	// Set a new save to trigger after 2 seconds
	holesSaveTimeout = setTimeout(() => {
		console.log("Auto-saving blast holes to DB...");
		// Only save if DB is initialized
		if (db) {
			saveHolesToDB(allBlastHoles);
		} else {
			console.log("DB not ready, skipping auto-save");
		}
	}, 2000);
}

//Improved saveSurfaceToDB
async function saveSurfaceToDB(surfaceId) {
	return new Promise((resolve, reject) => {
		try {
			// ? FIX: Better validation and error handling
			if (!db) {
				console.error("‚ùå Database not initialized");
				reject(new Error("Database not initialized"));
				return;
			}

			const surface = loadedSurfaces.get(surfaceId);
			if (!surface) {
				console.error("‚ùå Surface not found in loadedSurfaces:", surfaceId);
				reject(new Error(`Surface ${surfaceId} not found`));
				return;
			}

			// ? FIX: Validate surface structure
			if (!surface.points || !Array.isArray(surface.points)) {
				console.error("‚ùå Surface missing points array:", surface);
				reject(new Error("Surface missing valid points array"));
				return;
			}

			if (!surface.triangles || !Array.isArray(surface.triangles)) {
				console.error("‚ùå Surface missing triangles array:", surface);
				reject(new Error("Surface missing valid triangles array"));
				return;
			}

			// ? FIX: Validate triangle format before saving
			const isValidTriangleFormat = surface.triangles.every((triangle) => {
				return triangle.vertices && Array.isArray(triangle.vertices) && triangle.vertices.length === 3 && triangle.vertices.every((vertex) => vertex && typeof vertex.x === "number" && typeof vertex.y === "number" && typeof vertex.z === "number");
			});

			if (!isValidTriangleFormat) {
				console.error("‚ùå Invalid triangle format detected:", surface.triangles.slice(0, 3));
				reject(new Error("Invalid triangle format - vertices must be objects with x,y,z properties"));
				return;
			}

			console.log("üíæ Saving surface to database:", {
				id: surfaceId,
				name: surface.name,
				pointCount: surface.points.length,
				triangleCount: surface.triangles.length,
			});

			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);

			// ? FIX: Create properly structured surface record
			var surfaceRecord = {
				id: surfaceId,
				name: surface.name,
				type: surface.type || "triangulated",
				points: surface.points,
				triangles: surface.triangles,
				visible: surface.visible !== undefined ? surface.visible : true,
				gradient: surface.gradient || "default",
				transparency: surface.transparency || 1.0,
				hillshadeColor: surface.hillshadeColor || null, // Step 0a) Save hillshade color for 2D/3D rendering
				minLimit: surface.minLimit || null,
				maxLimit: surface.maxLimit || null,
				created: surface.created || new Date().toISOString(),
				metadata: surface.metadata || {},
			};

			// Step 1) Add textured mesh fields if this is a textured OBJ
			if (surface.isTexturedMesh) {
				surfaceRecord.isTexturedMesh = true;
				surfaceRecord.objContent = surface.objContent || null;
				surfaceRecord.mtlContent = surface.mtlContent || null;
				surfaceRecord.meshBounds = surface.meshBounds || null;

				// Step 2) Store texture blobs if present
				if (surface.textureBlobs) {
					surfaceRecord.textureBlobs = surface.textureBlobs;
				}

				// Step 2a) Store material properties (serializable, no WebGL resources)
				if (surface.materialProperties) {
					surfaceRecord.materialProperties = surface.materialProperties;
					console.log("üíæ Saving material properties for surface: " + surfaceId);
				} else {
					console.warn("üö® No material properties to save for textured mesh: " + surfaceId);
				}

				// Step 2b) Store flattened image data if present (saves recreation on reload)
				if (surface.flattenedImageDataURL) {
					surfaceRecord.flattenedImageDataURL = surface.flattenedImageDataURL;
					surfaceRecord.flattenedImageBounds = surface.flattenedImageBounds;
					surfaceRecord.flattenedImageDimensions = surface.flattenedImageDimensions;
					console.log("üíæ Saving flattened image data for surface: " + surfaceId);
				}

				console.log("üíæ Saving textured mesh data for surface: " + surfaceId);
			}

			// ? FIX: Add proper transaction handlers
			transaction.oncomplete = () => {
				console.log("‚úÖ Surface saved successfully to database:", surfaceId);
				resolve(true);
			};

			transaction.onerror = (event) => {
				console.error("‚ùå Transaction failed:", event.target.error);
				reject(new Error(`Transaction failed: ${event.target.error}`));
			};

			transaction.onabort = (event) => {
				console.error("‚ùå Transaction aborted:", event.target.error);
				reject(new Error(`Transaction aborted: ${event.target.error}`));
			};

			// Perform the actual save operation
			const request = store.put(surfaceRecord);

			request.onsuccess = (event) => {
				console.log("‚úÖ Surface record stored successfully");
				// Transaction will complete automatically
			};

			request.onerror = (event) => {
				console.error("‚ùå Failed to store surface record:", event.target.error);
				reject(new Error(`Failed to store surface: ${event.target.error}`));
			};
		} catch (error) {
			console.error("‚ùå Unexpected error in saveSurfaceToDB:", error);
			reject(error);
		}
	});
}
// Load a specific surface into the multi-surface system
async function loadSurfaceIntoMemory(surfaceId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const store = transaction.objectStore(SURFACE_STORE_NAME);
		const request = store.get(surfaceId);

		return new Promise((resolve) => {
			request.onsuccess = () => {
				const surfaceData = request.result;
				if (surfaceData) {
					loadedSurfaces.set(surfaceData.id, {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						gradient: surfaceData.gradient || "default",
						transparency: surfaceData.transparency || 1.0,
						hillshadeColor: surfaceData.hillshadeColor || null, // Step 0b) Load hillshade color from DB
						minLimit: surfaceData.minLimit || null,
						maxLimit: surfaceData.maxLimit || null,
					});
					console.log("‚úÖ Surface " + surfaceData.name + " loaded into memory");
				}
				resolve(surfaceData);
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading surface into memory:", error);
		return null;
	}
}

// Step 0a) Load all data types with unified progress dialog
async function loadAllDataWithProgress() {
	var loadingDialog = null;

	try {
		// Step 1) Show progress dialog
		loadingDialog = showLoadingProgressDialog();
		updateLoadingProgress(loadingDialog, "Initializing data load...", 0);

		// Step 2) Load blast holes (0-25%)
		updateLoadingProgress(loadingDialog, "Loading blast holes from IndexedDB...", 5);
		await loadHolesFromDB();
		var holeCount = allBlastHoles ? allBlastHoles.length : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + holeCount + " blast holes", 25);

		// Step 3) Load KAD entities (25-40%)
		updateLoadingProgress(loadingDialog, "Loading KAD entities...", 30);
		await loadKADFromDB();
		var kadCount = allKADDrawingsMap ? allKADDrawingsMap.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + kadCount + " KAD entities", 40);

		// Step 4) Load surfaces (40-70%)
		updateLoadingProgress(loadingDialog, "Loading surfaces...", 45);
		await loadAllSurfacesIntoMemory();
		var surfaceCount = loadedSurfaces ? loadedSurfaces.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + surfaceCount + " surface(s)", 70);

		// Step 5) Load images (70-90%)
		updateLoadingProgress(loadingDialog, "Loading images...", 75);
		await loadAllImagesIntoMemory();
		var imageCount = loadedImages ? loadedImages.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + imageCount + " image(s)", 90);

		// Step 6) Complete
		updateLoadingProgress(loadingDialog, "Complete! All data loaded successfully", 100);
		console.log("üìä Data load complete: " + holeCount + " holes, " + kadCount + " KADs, " + surfaceCount + " surfaces, " + imageCount + " images");

		// Step 6a) Flag that 3D geometry needs rebuild after data load
		window.threeDataNeedsRebuild = true;

		// Step 7) Close dialog after brief delay
		setTimeout(function () {
			if (loadingDialog) {
				loadingDialog.close();
			}
		}, 800);
	} catch (error) {
		console.error("‚ùå Error loading data:", error);
		if (loadingDialog) {
			updateLoadingProgress(loadingDialog, "Error: " + error.message, 100, true);
			setTimeout(function () {
				if (loadingDialog) {
					loadingDialog.close();
				}
			}, 3000);
		}
	}
}

// Step 1) Show loading progress dialog for IndexedDB data reload
function showLoadingProgressDialog() {
	// Step 1) Create progress dialog content
	const progressContent = document.createElement("div");
	progressContent.style.textAlign = "center";
	progressContent.innerHTML = '<p>Loading saved data from IndexedDB</p><p>Please wait...</p><div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;"><div id="loadingProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div></div><p id="loadingProgressText">Initializing...</p>';

	var dialog = new FloatingDialog({
		title: "Reloading Data",
		content: progressContent,
		layoutType: "standard",
		width: 350,
		height: 250,
		showConfirm: false,
		showCancel: true,
		showDeny: false,
		draggable: false,
		resizable: false,
		closeOnOutsideClick: false,
		onCancel: function () {
			// Step 2) Handle Cancel button - abort loading
			console.log("‚úÖ User cancelled data loading");
			dialog.close();
		},
	});

	dialog.show();
	return dialog;
}

// Step 5) Update loading progress dialog
function updateLoadingProgress(dialog, message, percent, isError) {
	if (!dialog || !dialog.element) return;

	var progressText = dialog.element.querySelector("#loadingProgressText");
	var progressBar = dialog.element.querySelector("#loadingProgressBar");

	if (progressText) {
		if (isError) {
			progressText.innerHTML = '<span style="color: #f44336;">? ' + message + "</span>";
		} else {
			progressText.textContent = message;
		}
	}

	if (progressBar) {
		progressBar.style.width = percent + "%";
		if (isError) {
			progressBar.style.backgroundColor = "#f44336";
		}
	}
}

async function loadAllSurfacesIntoMemory() {
	try {
		if (!db) return;

		var transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		var store = transaction.objectStore(SURFACE_STORE_NAME);
		var request = store.getAll();

		return new Promise(function (resolve) {
			request.onsuccess = function () {
				var surfaces = request.result || [];
				var texturedSurfaceIds = [];

				surfaces.forEach(function (surfaceData, index) {
					// Step 1) Create base surface entry
					var surfaceEntry = {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						// Step 1a) CRITICAL: For textured meshes, ALWAYS use "texture" gradient (ignore saved gradient)
						// Textured meshes MUST show JPG textures, not color gradients like "cividis"
						gradient: surfaceData.isTexturedMesh ? "texture" : surfaceData.gradient || "default",
						transparency: surfaceData.transparency || 1.0,
						hillshadeColor: surfaceData.hillshadeColor || null, // Step 1b) Load hillshade color from DB
					};

					// Step 2) Check if this is a textured mesh
					if (surfaceData.isTexturedMesh) {
						surfaceEntry.isTexturedMesh = true;
						surfaceEntry.objContent = surfaceData.objContent || null;
						surfaceEntry.mtlContent = surfaceData.mtlContent || null;
						surfaceEntry.textureBlobs = surfaceData.textureBlobs || null;
						surfaceEntry.meshBounds = surfaceData.meshBounds || null;
						surfaceEntry.materialProperties = surfaceData.materialProperties || null;
						surfaceEntry.threeJSMesh = null; // Will be rebuilt

						if (surfaceEntry.materialProperties) {
							console.log("üßä Loaded material properties for surface: " + surfaceData.id);
						} else {
							console.warn("üö® No material properties found for textured mesh: " + surfaceData.id);
						}

						// Step 2a) Load flattened image from saved data if available
						if (surfaceData.flattenedImageDataURL) {
							surfaceEntry.flattenedImageDataURL = surfaceData.flattenedImageDataURL;
							surfaceEntry.flattenedImageBounds = surfaceData.flattenedImageBounds;
							surfaceEntry.flattenedImageDimensions = surfaceData.flattenedImageDimensions;
							console.log("üßä Loaded flattened image data from DB for: " + surfaceData.id);
						}

						// Track for later rebuilding
						texturedSurfaceIds.push(surfaceData.id);
					}

					loadedSurfaces.set(surfaceData.id, surfaceEntry);
				});

				console.log("üìä Loaded " + loadedSurfaces.size + " surfaces into memory");

				// Step 2a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
				var fullCentroid = calculateDataCentroid();
				emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

				// Step 3) Rebuild Three.js meshes for textured surfaces (staggered to avoid blocking)
				if (texturedSurfaceIds.length > 0) {
					console.log("üß± Rebuilding " + texturedSurfaceIds.length + " textured meshes...");

					texturedSurfaceIds.forEach(function (surfaceId, index) {
						setTimeout(function () {
							rebuildTexturedMesh(surfaceId);
						}, index * 50); // Stagger by 50ms to avoid blocking UI
					});
				}

				resolve();
			};
			request.onerror = function () {
				console.error("‚ùå Failed to load surfaces from IndexedDB");
				resolve();
			};
		});
	} catch (error) {
		console.error("Error loading surfaces:", error);
	}
}

function exportSurfaceToDXF(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		showModalMessage("Export Failed", "Surface not found", "error");
		return;
	}

	try {
		console.log("Exporting surface " + surface.name + " to DXF");

		// Create DXF content with header
		let dxfContent = "";
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "HEADER\n";
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// Start ENTITIES section
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "ENTITIES\n";

		// Export triangles as 3DFACE entities
		if (surface.triangles && surface.triangles.length > 0) {
			surface.triangles.forEach((triangle) => {
				if (triangle.length >= 3) {
					const p1 = triangle[0];
					const p2 = triangle[1];
					const p3 = triangle[2];

					dxfContent += "0\n";
					dxfContent += "3DFACE\n";
					dxfContent += "8\n";
					dxfContent += "SURFACE_" + surface.name + "\n";

					// First corner
					dxfContent += "10\n";
					dxfContent += p1[0] + "\n";
					dxfContent += "20\n";
					dxfContent += p1[1] + "\n";
					dxfContent += "30\n";
					dxfContent += p1[2] + "\n";

					// Second corner
					dxfContent += "11\n";
					dxfContent += p2[0] + "\n";
					dxfContent += "21\n";
					dxfContent += p2[1] + "\n";
					dxfContent += "31\n";
					dxfContent += p2[2] + "\n";

					// Third corner
					dxfContent += "12\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "22\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "32\n";
					dxfContent += p3[2] + "\n";

					// Fourth corner (same as third for triangle)
					dxfContent += "13\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "23\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "33\n";
					dxfContent += p3[2] + "\n";
				}
			});
		}

		// End ENTITIES section
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// End of file
		dxfContent += "0\n";
		dxfContent += "EOF\n";

		// Create and download the file
		const blob = new Blob([dxfContent], {
			type: "application/dxf",
		});
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = surface.name + "_surface.dxf";
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);

		showModalMessage("Export Successful", "Surface " + surface.name + " exported as DXF with " + surface.triangles.length + " 3D faces", "success");
	} catch (error) {
		console.error("Error exporting surface to DXF:", error);
		showModalMessage("Export Failed", "Error exporting surface: " + error.message, "error");
	}
}

// Surface visibility management
function setSurfaceVisibility(surfaceId, visible) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = visible;
		console.log("üëÅÔ∏è Surface " + surface.name + " visibility: " + visible);
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleSurfaceVisibility(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = !surface.visible;
		setSurfaceVisibility(surfaceId, surface.visible);
	}
}

// ? Function to remove hidden entities from current selections
function clearHiddenFromSelections() {
	// Clear hidden holes from single selection
	if (selectedHole && !isHoleVisible(selectedHole)) {
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
	}

	// Clear hidden holes from multiple selection
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles = selectedMultipleHoles.filter((hole) => isHoleVisible(hole));
		if (selectedMultipleHoles.length === 0) {
			selectedMultipleHoles = [];
		}
	}

	// Clear hidden KAD objects from selection
	if (selectedKADObject && !isEntityVisible(selectedKADObject.entityName)) {
		selectedKADObject = null;
	}

	// Clear hidden polygons from selection
	if (selectedKADPolygon && !isEntityVisible(selectedKADPolygon.entityName)) {
		selectedKADPolygon = null;
	}

	// Clear from fromHoleStore if hidden
	if (fromHoleStore && !isHoleVisible(fromHoleStore)) {
		fromHoleStore = null;
	}

	// Clear move tool selections
	if (moveToolSelectedHole && moveToolSelectedHole.length > 0) {
		moveToolSelectedHole = moveToolSelectedHole.filter((hole) => isHoleVisible(hole));
		if (moveToolSelectedHole.length === 0) {
			moveToolSelectedHole = null;
			isDraggingHole = false;
		}
	}
}

// ? Helper function to check if an entity/element is visible
function isEntityVisible(entityName, elementId = null) {
	// Check overall group visibility first
	if (!drawingsGroupVisible) return false;

	const entity = allKADDrawingsMap.get(entityName);
	if (!entity) return false;

	// Check entity-level visibility
	if (entity.visible === false) return false;

	// Check sub-group visibility based on entity type
	switch (entity.entityType) {
		case "point":
			if (!pointsGroupVisible) return false;
			break;
		case "line":
			if (!linesGroupVisible) return false;
			break;
		case "poly":
			if (!polygonsGroupVisible) return false;
			break;
		case "circle":
			if (!circlesGroupVisible) return false;
			break;
		case "text":
			if (!textsGroupVisible) return false;
			break;
	}

	// Check element-level visibility if specified
	if (elementId !== null && entity.data) {
		const element = entity.data.find((el) => el.pointID == elementId);
		if (element && element.visible === false) return false;
	}

	return true;
}

// ? Helper function to check if a hole is visible
function isHoleVisible(hole) {
	if (!blastGroupVisible) return false;
	if (hole.visible === false) return false;
	return true;
}

//=== KAD Drawing Visibility Management ===
function setKADEntityVisibility(entityName, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = visible;
		console.log("üëÅÔ∏è KAD Entity " + entityName + " visibility: " + visible);

		// ? Clear hidden entities from selections
		clearHiddenFromSelections();
		// TODO FIX THE REMOVAL OF ENTITIES FROM SELECTIONS
		//! Its not working you can still delete invisible entities. Which is undesirable.
		updateTreeViewVisibilityStates();

		drawData(allBlastHoles, selectedHole);
	}
}

function setKADElementVisibility(entityName, pointID, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity && entity.data) {
		const element = entity.data.find((el) => el.pointID == pointID);
		if (element) {
			element.visible = visible;
			console.log("üëÅÔ∏è KAD Element " + entityName + ":" + pointID + " visibility: " + visible);

			// ? Clear hidden entities from selections
			clearHiddenFromSelections();
			drawData(allBlastHoles, selectedHole);
			updateTreeViewVisibilityStates();
		}
	}
}

function toggleKADEntityVisibility(entityName) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = !entity.visible;
		setKADEntityVisibility(entityName, entity.visible);
	}
}

//=== Blast Hole Visibility Management ===
function setHoleVisibility(holeID, visible) {
	const hole = allBlastHoles.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = visible;
		console.log("üëÅÔ∏è Hole " + holeID + " visibility: " + visible);

		// ? Clear hidden entities from selections
		clearHiddenFromSelections();
		window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
		drawData(allBlastHoles, selectedHole);
	}
}

function setEntityVisibility(entityName, visible) {
	const entityHoles = allBlastHoles.filter((h) => h.entityName === entityName);
	entityHoles.forEach((hole) => {
		hole.visible = visible;
	});
	console.log("üëÅÔ∏è Entity " + entityName + " visibility: " + visible + " (affecting " + entityHoles.length + " holes)");

	// ? Clear hidden entities from selections
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);
}

function toggleHoleVisibility(holeID) {
	const hole = allBlastHoles.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = !hole.visible;
		setHoleVisibility(holeID, hole.visible);
	}
}
//=== Group Visibility Management ===
// ? ADD: Update all group visibility functions to call updateTreeViewVisibilityStates()
function setBlastGroupVisibility(visible) {
	blastGroupVisible = visible;
	console.log("üëÅÔ∏è Blast Group visibility: " + visible);
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setDrawingsGroupVisibility(visible) {
	drawingsGroupVisible = visible;
	console.log("üëÅÔ∏è Drawings Group visibility: " + visible);
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setSurfacesGroupVisibility(visible) {
	surfacesGroupVisible = visible;
	console.log("üëÅÔ∏è Surfaces Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setImagesGroupVisibility(visible) {
	imagesGroupVisible = visible;
	console.log("üëÅÔ∏è Images Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setPointsGroupVisibility(visible) {
	pointsGroupVisible = visible;
	console.log("üëÅÔ∏è Points Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setLinesGroupVisibility(visible) {
	linesGroupVisible = visible;
	console.log("üëÅÔ∏è Lines Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setPolygonsGroupVisibility(visible) {
	polygonsGroupVisible = visible;
	console.log("üëÅÔ∏è Polygons Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setCirclesGroupVisibility(visible) {
	circlesGroupVisible = visible;
	console.log("üëÅÔ∏è Circles Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setTextsGroupVisibility(visible) {
	textsGroupVisible = visible;
	console.log("üëÅÔ∏è Texts Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

// Delete surface from IndexedDB
async function deleteSurfaceFromDB(surfaceId) {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete surface - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.delete(surfaceId);

			request.onsuccess = () => {
				console.log("‚úÖ Surface " + surfaceId + " deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete surface " + surfaceId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("? Transaction failed for deleting surface " + surfaceId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting surface:", error);
		throw error;
	}
}

// Delete all surfaces from IndexedDB
async function deleteAllSurfacesFromDB() {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete surfaces - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				console.log("‚úÖ All surfaces deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete all surfaces:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all surfaces:", error);
		throw error;
	}
}

// REPLACE this function to accept imageId parameter:
async function saveImageToDB(imageId) {
	try {
		const image = loadedImages.get(imageId);
		if (!db || !image || !image.canvas) {
			throw new Error("Missing database or image data");
		}

		// Create blob from canvas
		const blob = await new Promise((resolve, reject) => {
			image.canvas.toBlob((result) => {
				if (result) resolve(result);
				else reject(new Error("Failed to create blob"));
			});
		});

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);

			const imageRecord = {
				id: imageId,
				name: image.name,
				type: image.type || "imagery",
				bbox: image.bbox,
				blob: blob,
				visible: image.visible,
				transparency: image.transparency,
				zElevation: image.zElevation !== undefined ? image.zElevation : window.drawingZLevel || 0,
				savedAt: new Date().toISOString(),
			};

			const request = store.put(imageRecord);
			request.onsuccess = () => {
				debouncedUpdateTreeView();
				resolve(imageRecord);
			};
			request.onerror = () => reject(request.error);
			transaction.onerror = () => reject(transaction.error);
		});
	} catch (error) {
		console.error("Error saving image:", error);
		throw error;
	}
}

// Load image from IndexedDB

// Load a specific image into the multi-image system
async function loadImageIntoMemory(imageId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.get(imageId);

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const imageData = request.result;
				if (imageData) {
					// Convert blob back to canvas
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					img.onload = () => {
						canvas.width = img.width;
						canvas.height = img.height;
						ctx.drawImage(img, 0, 0);

						loadedImages.set(imageId, {
							id: imageId,
							name: imageData.name,
							canvas: canvas,
							bbox: imageData.bbox,
							type: imageData.type,
							visible: imageData.visible !== false,
							transparency: imageData.transparency || 1.0,
							zElevation: imageData.zElevation !== undefined ? imageData.zElevation : window.drawingZLevel || 0,
						});

						console.log("‚úÖ Image " + imageData.name + " loaded into memory");
						resolve(imageData);
					};

					img.src = URL.createObjectURL(imageData.blob);
				} else {
					resolve(null);
				}
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading image into memory:", error);
		return null;
	}
}

// Replace your current loadAllImagesIntoMemory function with this:
async function loadAllImagesIntoMemory() {
	try {
		if (!db) return;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.getAll();

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const images = request.result || [];

				// Load each image into memory
				for (const imageData of images) {
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					await new Promise((imgResolve) => {
						img.onload = () => {
							canvas.width = img.width;
							canvas.height = img.height;
							ctx.drawImage(img, 0, 0);

							loadedImages.set(imageData.id, {
								id: imageData.id,
								name: imageData.name,
								canvas: canvas,
								bbox: imageData.bbox,
								type: imageData.type,
								visible: imageData.visible !== false,
								transparency: imageData.transparency || 1.0,
								zElevation: imageData.zElevation !== undefined ? imageData.zElevation : window.drawingZLevel || 0,
							});

							imgResolve();
						};
						img.onerror = () => imgResolve(); // Continue even if image fails
						img.src = URL.createObjectURL(imageData.blob);
					});
				}

				console.log("üñºÔ∏è Loaded " + loadedImages.size + " images into memory");
				resolve();
			};
			request.onerror = () => {
				console.error("Failed to load images from database");
				resolve();
			};
		});
	} catch (error) {
		console.error("Error loading images into memory:", error);
	}
}
// Image visibility management
function setImageVisibility(imageId, visible) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = visible;
		if (developerModeEnabled) {
			console.log("üëÅÔ∏è Image " + image.name + " visibility: " + visible);
		}
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleImageVisibility(imageId) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = !image.visible;
		setImageVisibility(imageId, image.visible);
	}
}

// Delete image from IndexedDB
async function deleteImageFromDB(imageId) {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete image - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.delete(imageId);

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log(`‚úÖ Image "${imageId}" deleted from IndexedDB`);
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete image " + imageId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("? Transaction failed for deleting image " + imageId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting image:", error);
		throw error;
	}
}
// Delete all images from IndexedDB (useful for cleanup)
async function deleteAllImagesFromDB() {
	try {
		if (!db) return;

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log("‚úÖ All images deleted from IndexedDB");
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete all images:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all images:", error);
		throw error;
	}
}

// Call in console if needed: deleteAllImagesFromDB()

// Debug function - add temporarily to check what's in the database
async function debugDatabaseContents() {
	try {
		if (!db) {
			console.log("Database not initialized");
			return;
		}

		// Check surfaces
		const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
		const surfaceRequest = surfaceStore.getAll();

		surfaceRequest.onsuccess = () => {
			console.log("üîç Surfaces in database:", surfaceRequest.result.length);
			surfaceRequest.result.forEach((surface) => {
				console.log("  - Surface:", surface.name, "Points:", surface.points?.length, "Triangles:", surface.triangles?.length);
			});
		};

		// Check images
		const imageTransaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const imageStore = imageTransaction.objectStore(IMAGE_STORE_NAME);
		const imageRequest = imageStore.getAll();

		imageRequest.onsuccess = () => {
			console.log("üîç Images in database:", imageRequest.result.length);
			imageRequest.result.forEach((image) => {
				console.log("  - Image:", image.name, "Type:", image.type, "Bbox:", image.bbox);
			});
		};
	} catch (error) {
		console.error("Error checking database contents:", error);
	}
}

function checkAndPromptForStoredData() {
	// Step 1) Fallback check for localStorage (for backward compatibility)
	const allBlastHolesDataLocalStorage = localStorage.getItem("kirraDataPoints");

	if (!db) {
		// Fallback for when DB fails to initialize
		if (allBlastHolesDataLocalStorage) showPopup(false);
		return;
	}

	// Step 2) Check for holes in IndexedDB
	const holesTransaction = db.transaction([BLASTHOLES_STORE_NAME], "readonly");
	const holesStore = holesTransaction.objectStore(BLASTHOLES_STORE_NAME);
	const holesRequest = holesStore.get("blastHolesData");

	holesRequest.onsuccess = (holesEvent) => {
		const holesData = holesEvent.target.result;
		const hasHolesInDB = holesData && holesData.data && Array.isArray(holesData.data) && holesData.data.length > 0;

		// Step 3) Check for KAD drawings
		const kadTransaction = db.transaction([STORE_NAME], "readonly");
		const kadStore = kadTransaction.objectStore(STORE_NAME);
		const kadRequest = kadStore.get("kadDrawingData");

		kadRequest.onsuccess = (event) => {
			const kadData = event.target.result;

			// Step 4) Check for surfaces
			const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
			const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
			const surfaceRequest = surfaceStore.getAll();

			surfaceRequest.onsuccess = (surfaceEvent) => {
				const surfaceData = surfaceEvent.target.result || [];

				// Step 5) Check for images
				const imageTransaction = db.transaction([IMAGE_STORE_NAME], "readonly");
				const imageStore = imageTransaction.objectStore(IMAGE_STORE_NAME);
				const imageRequest = imageStore.getAll();

				imageRequest.onsuccess = (imageEvent) => {
					const imageData = imageEvent.target.result || [];

					// Step 6) Show popup if ANY data exists: holes, KAD drawings, surfaces, OR images
					if (hasHolesInDB || allBlastHolesDataLocalStorage || (kadData && kadData.data && kadData.data.length > 0) || surfaceData.length > 0 || imageData.length > 0) {
						showPopup(true);
						debouncedUpdateTreeView();
					}
				};

				imageRequest.onerror = (event) => {
					console.error("Could not check for image data in IndexedDB.", event.target.error);
					// Still show popup if other data exists
					if (hasHolesInDB || allBlastHolesDataLocalStorage || (kadData && kadData.data && kadData.data.length > 0) || surfaceData.length > 0) {
						showPopup(true);
						debouncedUpdateTreeView();
					}
				};
			};
		};

		kadRequest.onerror = (event) => {
			console.error("Could not check for KAD data in IndexedDB.", event.target.error);
			// Still show popup if holes exist
			if (hasHolesInDB || allBlastHolesDataLocalStorage) {
				showPopup(true);
			}
		};
	};

	holesRequest.onerror = (event) => {
		console.error("Could not check for holes data in IndexedDB.", event.target.error);
		// Fallback to localStorage check
		if (allBlastHolesDataLocalStorage) {
			showPopup(false);
		}
	};
}
window.checkAndPromptForStoredData = checkAndPromptForStoredData; // Expose for dialog modules

async function showPopup(isDBReady) {
	console.log("showPopup called with isDBReady:", isDBReady);

	// Step 1) Determine text color based on dark mode
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	// Step 2) Create the HTML content for the dialog with proper styling
	const dialogContent = '<div style="text-align: center; padding: 10px 0;">' + '<div class="labelWhite18" style="margin-bottom: 15px; color: ' + textColor + '; font-weight: 500;">' + "Do you want to pick up from where you left off?" + "</div>" + '<div class="labelWhite15" style="margin-bottom: 10px; color: ' + textColor + '; opacity: 0.9;">' + "Your previous work is still available." + "</div>" + "</div>";

	// Step 3) Create promise to handle async dialog response
	return new Promise((resolve) => {
		// Step 4) Create the FloatingDialog instance
		const dialog = new FloatingDialog({
			title: "Welcome back to Kirra!",
			content: dialogContent,
			width: 480,
			height: 220,
			showConfirm: true,
			showCancel: false,
			showDeny: true,
			confirmText: "Continue Previous",
			denyText: "Start Fresh",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior - must click a button
			layoutType: "default",
			onConfirm: async () => {
				// Step 5) User chose to continue previous work
				console.log("User chose to continue previous work");

				// Step 5a) Load all data with progress dialog
				if (isDBReady) {
					try {
						await loadAllDataWithProgress();
					} catch (err) {
						console.error("Failed to load data from DB.", err);
					}
				} else {
					// Fallback to localStorage if DB not ready (shouldn't happen, but safety)
					allBlastHoles = loadHolesFromLocalStorage();
				}

				zoomToFitAll();
				debouncedUpdateTreeView();
				dialog.close();
				resolve("confirmed");
			},
			onDeny: async () => {
				// Step 6) User chose to start fresh
				console.log("User chose to start fresh");
				await clearLoadedData();
				debouncedUpdateTreeView();
				zoomToFitAll();
				dialog.close();
				resolve("denied");
			},
		});

		// Step 7) Override the create method to customize the dialog
		const originalCreate = dialog.create.bind(dialog);
		dialog.create = function () {
			originalCreate();

			// Hide the X close button for modal behavior
			const closeBtn = this.element.querySelector(".floating-dialog-header button");
			if (closeBtn) {
				closeBtn.style.display = "none";
			}

			// Step 8) Style the header
			const header = this.element.querySelector(".floating-dialog-header");
			if (header) {
				header.style.borderBottom = "2px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");
			}

			// Step 9) Add custom styling to buttons
			const footer = this.element.querySelector(".floating-dialog-footer");
			if (footer) {
				// Increase spacing between buttons
				footer.style.gap = "40px";
				footer.style.padding = "12px 20px";
				footer.style.borderTop = "1px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");

				const denyBtn = footer.querySelector(".floating-dialog-btn.deny");
				const confirmBtn = footer.querySelector(".floating-dialog-btn.confirm");

				if (denyBtn && confirmBtn) {
					// Step 10) Style the "Start Fresh" button (orange)
					denyBtn.style.backgroundColor = "#ff9d00";
					denyBtn.style.setProperty("color", "#000000", "important");
					denyBtn.style.borderColor = "#ff9d00";
					denyBtn.style.minWidth = "120px";
					denyBtn.style.padding = "8px 16px";
					denyBtn.style.fontSize = "12px";
					denyBtn.style.fontWeight = "500";
					denyBtn.style.borderRadius = "4px";
					denyBtn.style.transition = "all 0.2s ease";
					// denyBtn.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";

					// Hover effect for Start Fresh button
					denyBtn.onmouseover = function () {
						this.style.backgroundColor = "#e77a00";
						// this.style.boxShadow = "0 3px 6px rgba(255, 157, 0, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					denyBtn.onmouseout = function () {
						this.style.backgroundColor = "#ff9d00";
						// this.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";
						// this.style.transform = "translateY(0)";
					};

					// Step 11) Style the "Continue Previous Work" button (green)
					confirmBtn.style.backgroundColor = "#00771c";
					confirmBtn.style.setProperty("color", "#ffffff", "important");
					confirmBtn.style.borderColor = "#00a91c";
					confirmBtn.style.minWidth = "160px";
					confirmBtn.style.padding = "8px 16px";
					confirmBtn.style.fontSize = "12px";
					confirmBtn.style.fontWeight = "500";
					confirmBtn.style.borderRadius = "4px";
					confirmBtn.style.transition = "all 0.2s ease";
					// confirmBtn.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";

					// Hover effect for Continue button
					confirmBtn.onmouseover = function () {
						this.style.backgroundColor = "#008f17";
						// this.style.boxShadow = "0 3px 6px rgba(0, 169, 28, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					confirmBtn.onmouseout = function () {
						this.style.backgroundColor = "#00a91c";
						// this.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";
						// this.style.transform = "translateY(0)";
					};
				}
			}
		};

		// Step 12) Show the dialog
		dialog.show();
	});
}

// Listen for changes in the kirraDataPoints key
window.addEventListener("storage", function (event) {
	if (event.key === "kirraDataPoints") {
		console.log("kirraDataPoints changed");
	} else {
		console.log("kirraDataPoints not changed");
	}
});

// Replace the entire updateCentroids function with this simplified version:
function updateCentroids() {
	// Calculate centroid of allBlastholes
	let sumX = 0;
	let sumY = 0;
	let records = 0;

	// Include hole points
	if (allBlastHoles !== null) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			sumX += allBlastHoles[i].startXLocation;
			sumY += allBlastHoles[i].startYLocation;
			records++;
		}
	}

	// Include all KAD objects (everything is now in allKADDrawingsMap)
	if (allKADDrawingsMap.size > 0) {
		for (const entity of allKADDrawingsMap.values()) {
			for (const dataPoint of entity.data) {
				sumX += dataPoint.pointXLocation;
				sumY += dataPoint.pointYLocation;
				records++;
			}
		}
	}

	// Include surface points in centroid calculation
	if (loadedSurfaces.size > 0) {
		loadedSurfaces.forEach((surface) => {
			if (surface.points && surface.points.length > 0) {
				// Standard surface with points array
				for (const point of surface.points) {
					sumX += point.x;
					sumY += point.y;
					records++;
				}
			} else if (surface.isTexturedMesh && surface.meshBounds) {
				// Textured mesh (OBJ) - use mesh center
				sumX += (surface.meshBounds.minX + surface.meshBounds.maxX) / 2;
				sumY += (surface.meshBounds.minY + surface.meshBounds.maxY) / 2;
				records++;
			}
		});
	}

	if (records > 0) {
		centroidX = sumX / records;
		centroidY = sumY / records;
	}

	// Step 5) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
	var fullCentroid = calculateDataCentroid();
	emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);
}

const darkModeToggle = document.getElementById("dark-mode-toggle");
const body = document.body;
const sidenavLeft = document.getElementById("sidenavLeft");
const sidenavRight = document.getElementById("sidenavRight");
// Check if dark mode preference exists in local storage
const darkModePref = localStorage.getItem("darkMode");
if (darkModePref === "true") {
	body.classList.add("dark-mode");
	sidenavLeft.classList.add("dark-mode");
	sidenavRight.classList.add("dark-mode");
	canvas.classList.add("dark-canvas");
	darkModeToggle.checked = true;
}

darkModeToggle.addEventListener("change", () => {
	if (darkModeToggle.checked) {
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		sidenavRight.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
		localStorage.setItem("darkMode", "true");
	} else {
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		sidenavRight.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
		localStorage.setItem("darkMode", "false");
	}
	darkModeEnabled = document.body.classList.contains("dark-mode");
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "darkgrey" : "lightgrey";
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "cyan" : "blue";
	angleDipColor = darkModeEnabled ? "orange" : "darkorange";

	// Step 1) Update Three.js background color
	if (threeInitialized && threeRenderer) {
		threeRenderer.setBackgroundColor(darkModeEnabled);
	}

	// Step 1a) Update base canvas background color
	if (window.baseCanvas && window.baseCtx) {
		window.baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
		window.baseCtx.fillRect(0, 0, window.baseCanvas.width, window.baseCanvas.height);
	}

	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	drawData(allBlastHoles, selectedHole);
});

function endKadTools() {
	// Step 1) Check if any KAD drawing tool is active
	var anyKADToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked;

	if (anyKADToolActive) {
		// Step 2) Check if we're actively drawing (createNewEntity is false means we have started an entity)
		if (!createNewEntity) {
			// Step 2a) Actively drawing - just end the current entity, keep tool active
			createNewEntity = true;
			lastKADDrawPoint = null;
			entityName = null; // CRITICAL: Reset entityName so next click creates NEW entity
			clearCurrentDrawingEntity();

			// Step 2a.1) Additional state cleanup for leading lines and tool consistency
			currentDrawingEntityName = null;
			deleteKeyCount = 0;

			updateStatusMessage("Entity finished. Click to start new " + (isDrawingLine ? "line" : isDrawingPoly ? "polygon" : isDrawingCircle ? "circle" : isDrawingPoint ? "point" : "text"));
			setTimeout(function () {
				updateStatusMessage("");
			}, 2000);
			// Redraw to clear preview line
			drawData(allBlastHoles, selectedHole);

			// Step 2a.2) Force immediate redraw to clear any stale preview lines
			setTimeout(() => {
				drawData(allBlastHoles, selectedHole);
			}, 10);
		} else {
			// Step 2b) Not actively drawing (no points added yet) - turn off tool entirely
			addPointDraw.checked = false;
			addLineDraw.checked = false;
			addCircleDraw.checked = false;
			addPolyDraw.checked = false;
			addTextDraw.checked = false;

			// Reset states
			createNewEntity = true;
			lastKADDrawPoint = null;
			entityName = null; // Reset entityName

			// Step 2b.1) Additional state cleanup for leading lines and tool consistency
			currentDrawingEntityName = null;
			deleteKeyCount = 0;

			// Update drawing flags
			isDrawingPoint = false;
			isDrawingLine = false;
			isDrawingCircle = false;
			isDrawingPoly = false;
			isDrawingText = false;
			clearCurrentDrawingEntity();
			updateStatusMessage("Drawing tools cancelled");
			setTimeout(function () {
				updateStatusMessage("");
			}, 1500);

			// Redraw to clear any preview lines/indicators
			drawData(allBlastHoles, selectedHole);

			// Step 2b.2) Force immediate redraw to clear any stale preview lines
			setTimeout(() => {
				drawData(allBlastHoles, selectedHole);
			}, 10);
		}
	}

	// Step 3) Also handle polygon selection escape
	if (isPolygonSelectionActive) {
		polyPointsX = [];
		polyPointsY = [];
		updateStatusMessage("Polygon selection cancelled");
		setTimeout(function () {
			updateStatusMessage("");
		}, 1500);
		drawData(allBlastHoles, selectedHole);
	}
	
	// Step 4) Hide pattern tool HUD labels when switching tools
	hidePatternToolLabels();
	// Step 5) Hide drawingDistance panel when KAD tools end
	hideDrawingDistance();
}

function findClosestKadPoint(worldPoint, snapDistance) {
	let closestPoint = null;
	let minDistance = snapDistance;

	for (const [name, entity] of allKADDrawingsMap.entries()) {
		if (entity.entityType === "line" || entity.entityType === "poly") {
			for (let i = 0; i < entity.data.length; i++) {
				const pt = entity.data[i];
				const dx = pt.pointXLocation - worldPoint.x;
				const dy = pt.pointYLocation - worldPoint.y;
				const dist = Math.sqrt(dx * dx + dy * dy);

				if (dist < minDistance) {
					minDistance = dist;
					closestPoint = {
						entityName: name,
						pointIndex: i,
						point: pt,
					};
				}
			}
		}
	}
	return closestPoint;
}

/// VERY SURE THIS DOES NOT GET CALLED.
function handleKADModificationClick(event) {
	// Get the mouse position in world coordinates
	const [worldX, worldY] = canvasToWorld(event.offsetX, event.offsetY);

	// Find the closest KAD entity using our new unified function
	selectedKADPoint = getClickedKADEntity(worldX, worldY);

	if (selectedKADPoint) {
		const entity = selectedKADPoint.entity;
		console.log("DEBUG: entity object:", entity);
		console.log("DEBUG: entity.entityName:", entity.entityName);
		console.log("DEBUG: entity.entityType:", entity.entityType);
		console.log("DEBUG: entity.data:", entity.data);

		console.log("SUCCESS: Modification target found:", entity.entityName);
		updateStatusMessage("Selected entity: " + entity.entityName + " (Right-click to edit)");

		// For lines, points, circles, text - set selectedKADObject (used by highlighting)
		selectedKADObject = {
			entityName: entity.entityName,
			entityType: entity.entityType,
			pointXLocation: selectedKADPoint.clickedX,
			pointYLocation: selectedKADPoint.clickedY,
			// Add other properties as needed by existing code
			...entity.data[0], // Copy properties from first point
		};
		console.log("DEBUG: selectedKADObject created:", selectedKADObject);
		//selectedKADPolygon = null; // Clear the other variable
	} else {
		console.log("No modifiable KAD entity found at click location.");
		updateStatusMessage("");
		// Clear both legacy variables
		selectedKADPolygon = null;
		selectedKADObject = null;
	}

	// Redraw to show highlighting
	drawData(allBlastHoles, selectedHole);
}
/// VERY SURE THIS ABOVE DOES NOT GET CALLED.

window.onload = function () {
	// --- Dark Mode Setup ---
	darkModeEnabled = localStorage.getItem("darkMode") === "true";
	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}

	// --- HUD Overlay System Initialization ---
	// Step 1) Initialize the HUD overlay in the canvas container
	var canvasContainer = document.querySelector(".canvas-container");
	if (canvasContainer) {
		initHUD(canvasContainer);
		// Step 2) Set initial stats with version
		emitStats({ version: buildVersion });
		console.log("[Kirra] HUD overlay system initialized");
	} else {
		console.warn("[Kirra] Canvas container not found - HUD not initialized");
	}

	// ADD WELCOME MESAGES.
	const messages = ["Welcome to Kirra2D!", "Support the development.", "Buy Brent a coffee\nhttps://buymeacoffee.com/brentbuffham"];

	messages.forEach((msg, index) => {
		const delay = 1000 + index * 3000;

		setTimeout(() => {
			updateStatusMessage(msg);

			// ?? Clear the last message 4 seconds after it's shown
			if (index === messages.length - 1) {
				setTimeout(() => updateStatusMessage(""), 4000);
			}
		}, delay);
	});

	// --- Key Listeners ---
	document.addEventListener("keydown", (event) => {
		// Handle drawing key events (delete/backspace) when drawing tools are active
		// BUT only if user is not typing in an input field
		if ((isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText) && !event.target.matches('input, textarea, [contenteditable="true"]')) {
			handleDrawingKeyEvents(event);
		}

		// Escape Key to reset tools
		if (event.key === "Escape") {
			console.log("Escape pressed - resetting all");
			resetAllSelectedStores();
			endKadTools();
			selectedPoint = null;
			selectedHole = null;
			selectedPoint = null;
			selectedKADObject = null;
			selectedKADPolygon = null;
			selectedKADPoint = null;
			selectedKADLine = null;
			selectedKADCircle = null;
			selectedKADText = null;
			selectedMultipleHoles = [];
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			hasSelectedMultipleHoles = false;
			clearAllSelectionState();

			if (isPolygonSelectionActive) {
				polyPointsX = [];
				polyPointsY = [];
				updateStatusMessage("Polygon selection cleared - click to start new selection");
			}
			if (isPatternInPolygonActive) {
				selectedPolygon = null;
				patternStartPoint = null;
				patternEndPoint = null;
				patternReferencePoint = null;
				patternPolygonStep = 0;
				updateStatusMessage("Pattern tool reset - select polygon to start");
			} else if (isHolesAlongLineActive) {
				lineStartPoint = null;
				window.lineStartPoint = lineStartPoint; // Keep window in sync
				lineEndPoint = null;
				window.lineEndPoint = lineEndPoint; // Keep window in sync
				holesLineStep = 0;
				window.holesLineStep = holesLineStep; // Keep window in sync
				updateStatusMessage("Holes along line tool reset\nClick to set start point");
			} else if (isHolesAlongPolyLineActive) {
				selectedPolyline = null;
				polylineStartPoint = null;
				polylineEndPoint = null;
				polylineStep = 0;
				updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
			} else if (isRulerActive) {
				rulerStartPoint = null;
				rulerEndPoint = null;
				hideRulerPanel(); // Step #) Hide CSS ruler panel on ESC reset
				updateStatusMessage("Ruler tool reset\nClick to set start point");
			} else if (isRulerProtractorActive) {
				rulerProtractorPoints = [];
				hideProtractorPanel(); // Step #) Hide CSS protractor panel on ESC reset
				updateStatusMessage("Protractor tool reset\nClick to set center point");
			}
			selectedKADPolygon = null;
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			selectedMultipleHoles = [];
			drawData(allBlastHoles, selectedHole);
			syncCanvasToTreeView(); // Sync cleared selection to TreeView
		}

		// Delete Key for selected KAD objects/vertices
		if ((event.key === "Delete" || event.key === "Backspace") && !event.target.matches('input, textarea, [contenteditable="true"]')) {
			// Step 1) Check if we have KAD selections (not during drawing)
			const hasKADSelection = selectedKADObject || (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0);

			if (hasKADSelection && !isDrawingPoint && !isDrawingLine && !isDrawingPoly && !isDrawingCircle && !isDrawingText) {
				event.preventDefault();
				console.log("‚ùåüîë [DELETE KEY] Deleting selected KAD objects");

				// Step 2) Handle vertex deletion with confirmation
				if (selectedPoint && selectedKADObject) {
					const entity = allKADDrawingsMap.get(selectedKADObject.entityName);
					if (entity && entity.data) {
						const elementIndex = entity.data.findIndex(function (el) { return el.pointID === selectedPoint.pointID; });
						if (elementIndex !== -1) {
							// Show confirmation dialog asking vertex or entity
							const vertexText = selectedKADObject.entityType + " vertex " + selectedPoint.pointID;
							const entityText = selectedKADObject.entityType + " '" + selectedKADObject.entityName + "'";

							showConfirmationThreeDialog(
								"Delete Confirmation",
								"What would you like to delete?",
								"Vertex Only",
								"Cancel",
								"Entire Entity"
							).then(function (result) {
								if (result === 1) {
									// Delete vertex only - capture values before clearing
									const deletedPointID = selectedPoint.pointID;
									entity.data.splice(elementIndex, 1);
									console.log("‚ùåüîë [DELETE KEY] Deleted vertex:", deletedPointID);

									// Delete entity if empty
									if (entity.data.length === 0) {
										allKADDrawingsMap.delete(selectedKADObject.entityName);
										console.log("‚ùåüîë [DELETE KEY] Entity empty - deleted:", selectedKADObject.entityName);
									} else if (typeof renumberEntityPoints === "function") {
										renumberEntityPoints(entity);
									}

									// Clear selection
									selectedPoint = null;
									selectedKADObject = null;
									selectedMultipleKADObjects = [];

									if (typeof debouncedSaveKAD === "function") {
										debouncedSaveKAD();
									}
									drawData(allBlastHoles, selectedHole);
									syncCanvasToTreeView();
									updateTreeView();
									updateStatusMessage("Deleted vertex " + deletedPointID);
									setTimeout(function () { updateStatusMessage(""); }, 2000);
								} else if (result === 2) {
									// Delete entire entity - capture values before clearing
									const deletedEntityName = selectedKADObject.entityName;
									allKADDrawingsMap.delete(deletedEntityName);
									console.log("‚ùåüîë [DELETE KEY] Deleted entity:", deletedEntityName);

									selectedPoint = null;
									selectedKADObject = null;
									selectedMultipleKADObjects = [];

									if (typeof debouncedSaveKAD === "function") {
										debouncedSaveKAD();
									}
									drawData(allBlastHoles, selectedHole);
									syncCanvasToTreeView();
									updateTreeView();
									updateStatusMessage("Deleted entity '" + deletedEntityName + "'");
									setTimeout(function () { updateStatusMessage(""); }, 2000);
								}
								// If result === 0 (Cancel), do nothing
							});
						}
					}
				}
				// Step 3) Handle entity deletion with confirmation
				else if (selectedKADObject) {
					if (allKADDrawingsMap.has(selectedKADObject.entityName)) {
						showConfirmationDialog(
							"Delete Confirmation",
							"Are you sure you want to delete " + selectedKADObject.entityType + " '" + selectedKADObject.entityName + "'?",
							"Delete",
							"Cancel"
						).then(function (confirmed) {
							if (confirmed) {
								allKADDrawingsMap.delete(selectedKADObject.entityName);
								console.log("‚ùåüîë [DELETE KEY] Deleted entity:", selectedKADObject.entityName);

								selectedKADObject = null;
								selectedMultipleKADObjects = [];

								if (typeof debouncedSaveKAD === "function") {
									debouncedSaveKAD();
								}
								drawData(allBlastHoles, selectedHole);
								syncCanvasToTreeView();
								updateTreeView();
								updateStatusMessage("Deleted KAD entity");
								setTimeout(function () { updateStatusMessage(""); }, 2000);
							}
						});
					}
				}
				// Step 4) Handle multiple entity deletion with confirmation
				else if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
					const count = selectedMultipleKADObjects.length;
					showConfirmationDialog(
						"Delete Confirmation",
						"Are you sure you want to delete " + count + " KAD entities?",
						"Delete All",
						"Cancel"
					).then(function (confirmed) {
						if (confirmed) {
							selectedMultipleKADObjects.forEach(function (kadObj) {
								if (allKADDrawingsMap.has(kadObj.entityName)) {
									allKADDrawingsMap.delete(kadObj.entityName);
								}
							});
							console.log("‚ùåüîë [DELETE KEY] Deleted", count, "entities");

							selectedMultipleKADObjects = [];
							selectedKADObject = null;

							if (typeof debouncedSaveKAD === "function") {
								debouncedSaveKAD();
							}
							drawData(allBlastHoles, selectedHole);
							syncCanvasToTreeView();
							updateTreeView();
							updateStatusMessage("Deleted " + count + " KAD entities");
							setTimeout(function () { updateStatusMessage(""); }, 2000);
						}
					});
				}
			}
		}
		// Shift Key for multi-select
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = true;
			isMultiHoleSelectionEnabled = true;
		}
	});

	document.addEventListener("keyup", (event) => {
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = false;
			isMultiHoleSelectionEnabled = false;
		}
	});

	///-------CRITICAL IMPORTANT --------///
	// This code is critical and must be called before any other database operations.
	// It is responsible for initializing the database and loading the stored data.
	// If the database is not initialized, the application will not work correctly.
	// This code should be called only once during application initialization,
	// typically in window.onload or similar startup code, not inside event handlers.
	// This placement means the database initialization would run every time certain keys
	// are pressed, which is inefficient and could cause issues with multiple database
	initDB()
		.then((database) => {
			db = database; // ? Set the global db variable
			console.log("‚úÖ Database initialized successfully");
			updatePopup();
		})
		.catch((err) => {
			console.error("Failed to initialize database. Falling back to Local Storage.", err);
			if (localStorage.getItem("kirraDataPoints")) {
				updatePopup();
			}
		});

	updateColorsForDarkMode();
	clearCanvas();
};

// Add this helper function to centralize color updates
function updateColorsForDarkMode() {
	// Step 1) Update local color variables (must match initial declarations at lines 2941-2946)
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "darkgrey" : "lightgrey"; // FIXED: was backwards
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "cyan" : "blue"; // FIXED: was backwards (cyan for dark, blue for light)
	angleDipColor = darkModeEnabled ? "orange" : "darkorange"; // FIXED: was different from initial

	// Step 2) Update window globals so Three.js rendering uses correct colors
	window.textFillColor = textFillColor;
	window.depthColor = depthColor;
	window.angleDipColor = angleDipColor;
	window.darkModeEnabled = darkModeEnabled;

	console.log("üé® Colors updated for dark mode:", darkModeEnabled);
}

// Step 4) Add cleanup on page unload to prevent memory leaks
window.addEventListener("beforeunload", function () {
	cleanupAllResources();
	// Save holes immediately on page unload (don't use debounced save)
	if (db && allBlastHoles && allBlastHoles.length > 0) {
		saveHolesToDB(allBlastHoles);
	}
});

function getKADBoundaries() {
	let minX = Infinity;
	let maxX = -Infinity;
	let minY = Infinity;
	let maxY = -Infinity;

	if (allKADDrawingsMap.size === 0) {
		return null;
	}

	for (const entity of allKADDrawingsMap.values()) {
		if (entity.data && Array.isArray(entity.data)) {
			for (const point of entity.data) {
				if (point.pointXLocation < minX) minX = point.pointXLocation;
				if (point.pointXLocation > maxX) maxX = point.pointXLocation;
				if (point.pointYLocation < minY) minY = point.pointYLocation;
				if (point.pointYLocation > maxY) maxY = point.pointYLocation;
			}
		}
	}

	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

async function clearLoadedData() {
	// Step 1) Clear hole data from memory
	allBlastHoles = [];

	// Step 2) Clear ALL data from IndexedDB - not just KAD data
	if (db) {
		try {
			// Step 2a) Clear KAD data
			const kadTransaction = db.transaction([STORE_NAME], "readwrite");
			const kadStore = kadTransaction.objectStore(STORE_NAME);
			await new Promise((resolve, reject) => {
				const request = kadStore.clear();
				request.onsuccess = () => resolve();
				request.onerror = () => reject(request.error);
			});

			// Step 2b) Clear surface data
			await deleteAllSurfacesFromDB();

			// Step 2c) Clear image data
			await deleteAllImagesFromDB();

			// Step 2d) Clear holes data from IndexedDB
			const holesTransaction = db.transaction([BLASTHOLES_STORE_NAME], "readwrite");
			const holesStore = holesTransaction.objectStore(BLASTHOLES_STORE_NAME);
			await new Promise((resolve, reject) => {
				const request = holesStore.clear();
				request.onsuccess = () => resolve();
				request.onerror = () => reject(request.error);
			});

			console.log("‚úÖ All database data cleared");
		} catch (error) {
			console.error("? Error clearing database:", error);
		}
	}

	// Step 3) Clear localStorage (for backward compatibility)
	localStorage.removeItem("kirraDataPoints");
	console.log("‚úÖ localStorage cleared");

	// Step 4) Clear memory maps
	allKADDrawingsMap.clear();
	loadedSurfaces.clear();
	loadedImages.clear();

	// Step 5) Reset other states if necessary
	selectedHole = null;
	selectedPoint = null;
	selectedMultiplePoints = [];
	selectedKADObject = null;
	selectedKADPolygon = null;
	selectedMultipleKADObjects = [];
	window.selectedKADObject = null;

	// Step 6) Redraw the empty canvas
	drawData(allBlastHoles, selectedHole);

	console.log("‚úÖ All data cleared successfully");
}
window.addEventListener("resize", () => {
	if (htmlUIVersion === "1") {
		canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
		canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
	} else {
		//drawing will handle
	}
	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	debouncedSaveHoles(); // Auto-save holes to IndexedDB

	drawData(allBlastHoles, selectedHole);
});

let isMobile = false;
// Check if the device is a mobile device
//const isMobile = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isMobileQuery = window.matchMedia("(max-width: 768px)");
if (isMobileQuery.matches) {
	isMobile = true;
} else {
	isMobile = false;
}

document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("openNavLeftBtn").addEventListener("click", openNavLeft);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("openNavRightBtn").addEventListener("click", openNavRight);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("closeNavLeftBtn").addEventListener("click", closeNavLeft);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("closeNavRightBtn").addEventListener("click", closeNavRight);
});

function openNavLeft() {
	console.log(isMobile);
	const sidenavHeight = 350;
	const screenHeight = window.innerHeight;
	const margin = screenHeight - sidenavHeight;

	if (isMobile) {
		body.style.bottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "0px";
		sidenavLeft.style.top = "60%";
		sidenavLeft.style.width = "100%";
		sidenavLeft.style.height = "350px";
	} else {
		body.style.marginLeft = "315px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "300px";
		sidenavLeft.style.paddingLeft = "5px";
		sidenavLeft.style.paddingRight = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update toolbar position using ToolbarPanel class
	if (toolbarPanel) {
		console.log("Adding sidebar-open class to toolbar");
		console.log("toolbarPanel container:", toolbarPanel.container);
		console.log("Is mobile:", window.matchMedia("(max-width: 1024px)").matches);
		toolbarPanel.updateSidebarState(true);
		// Debug: Check if class was added
		const toolbar = document.getElementById("toolbarPanel");
		console.log("Toolbar classes:", toolbar.className);
	}
}
function closeNavLeft() {
	if (isMobile) {
		body.style.marginBottom = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "-5px";
		sidenavLeft.style.top = "-5px";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.height = "0px";
	} else {
		body.style.marginLeft = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.padding = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update floating toolbar position
	if (toolbarPanel) {
		toolbarPanel.updateSidebarState(false);
	}
}
function openNavRight() {
	if (isMobile) {
		const sidenavHeight = 350; // Change this value to match the actual height of the sidenav
		const screenHeight = window.innerHeight;
		const margin = screenHeight - sidenavHeight;

		body.style.marginBottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavRight.style.right = "0px";
		sidenavRight.style.top = "60%";
		sidenavRight.style.width = "100%";
		sidenavRight.style.height = "350px";
		//resize the timechart
		Plotly.relayout("timeChart", {
			width: 280,
		});
	} else {
		body.style.marginRight = "315px"; // Push body to the left
		body.style.transition = "0.5s";
		sidenavRight.style.width = "300px";
		sidenavRight.style.right = "0";
		sidenavRight.style.paddingLeft = "0px";
		sidenavRight.style.paddingRight = "5px";
		sidenavRight.style.margin = "0px";
		//resize the timechart
		timeChart();
		newWidthRight = 315;
		resizeChart();
	}
}
function closeNavRight() {
	if (isMobile) {
		body.style.marginBottom = "0%"; // Push body down
		body.style.transition = "0.5s";
		sidenavRight.style.right = "-5px";
		sidenavRight.style.top = "-5px";
		sidenavRight.style.width = "0px";
		sidenavRight.style.height = "0px";
	} else {
		body.style.marginRight = "0px"; // Reset the margin to default
		body.style.transition = "0.5s";
		sidenavRight.style.width = "0px";
		sidenavRight.style.padding = "0px";
		sidenavRight.style.margin = "0px";
	}
}

//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//
// ToolbarPanel is now imported
const toolbar = document.getElementById("toolbarPanel");

let isDraggingTools = false;
let offsetX, offsetY;

// Step 3) Initialize the new toolbar panel
let toolbarPanel;
// Step 2) Update the DOMContentLoaded section around line 21376
document.addEventListener("DOMContentLoaded", () => {
	toolbarPanel = new ToolbarPanel();
});

//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//

// Add event listeners for the floating toolbar buttons
const selectPointerTool = document.getElementById("selectPointer");
const selectByPolygonTool = document.getElementById("selectByPolygon");
const resetViewTool = document.getElementById("resetViewTool");
const moveToTool = document.getElementById("moveToTool");
const bearingTool = document.getElementById("bearingTool");
const rulerTool = document.getElementById("rulerTool");
const rulerProtractorTool = document.getElementById("rulerProtractorTool");

const selectHolesRadio = document.getElementById("selectHoles"); // Step 1) Radio: holes
const selectKADRadio = document.getElementById("selectKAD"); // Step 2) Radio: KAD

// Step 3) Radio change handlers - enforce exclusive selection type
selectHolesRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear KAD selections
		selectedKADObject = null;
		selectedKADPolygon = null;
		selectedMultipleKADObjects = [];
		updateStatusMessage("Selection mode: Holes only");
		drawData(allBlastHoles, selectedHole);
	}
});
selectKADRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear Hole selections
		selectedHole = null;
		selectedMultipleHoles = [];
		updateStatusMessage("Selection mode: KAD only");
		drawData(allBlastHoles, selectedHole);
	}
});

// Step 5) Add function to connect toolbar tools to their handlers
function initializeToolbarConnections() {
	// Connect radio buttons to their change handlers
	const selectHoles = document.getElementById("selectHoles");
	const selectKAD = document.getElementById("selectKAD");

	if (selectHoles) {
		selectHoles.addEventListener("change", function () {
			if (this.checked) {
				selectedKADObject = null;
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];
				updateStatusMessage("Selection mode: Holes only");
				drawData(allBlastHoles, selectedHole);
			}
		});
	}

	if (selectKAD) {
		selectKAD.addEventListener("change", function () {
			if (this.checked) {
				selectedHole = null;
				selectedMultipleHoles = [];
				updateStatusMessage("Selection mode: KAD only");
				drawData(allBlastHoles, selectedHole);
			}
		});
	}
}

//---------------MOVE TOOL---------------//
// --- Move Tool State ---

let isDraggingHole = false;
let dragStartX = 0,
	dragStartY = 0;
let dragStartWorldX = 0,
	dragStartWorldY = 0;
let dragInitialPositions = [];

// Store the previous tool state to restore it when move tool is deactivated
let previousToolState = {
	isSelectionPointerActive: false,
	isPolygonSelectionActive: false,
	selectionMode: false,
};
// Helper function to remove all canvas listeners
function removeAllCanvasListenersKeepDefault() {
	// Selection tool handlers
	canvas.removeEventListener("click", handleSelection);
	canvas.removeEventListener("touchstart", handleSelection);
	canvas.removeEventListener("click", selectInsidePolygon);
	canvas.removeEventListener("dblclick", completePolygonSelection);
	canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
	canvas.removeEventListener("mousemove", handlePolygonMouseMove);

	// Move tool handlers
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Bearing tool handlers
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);
}

//------------------------- MOVE TO TOOL START------------//
// --- Move Tool Activation ---
moveToTool.addEventListener("change", function () {
	if (this.checked) {
		// Step 1) Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;
		endKadTools();
		resetFloatingToolbarButtons("moveToTool");
		// DON'T remove all canvas listeners - keep the main mouse tracking
		removeAllCanvasListenersKeepDefault();

		// Step 2) Detect current mode using dimension2D-3DBtn checkbox
		const dimension2D3DBtn = document.getElementById("dimension2D-3DBtn");
		moveToolIn3DMode = dimension2D3DBtn && dimension2D3DBtn.checked;
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;

		if (!targetCanvas) {
			console.error("Move Tool: Target canvas not available");
			updateStatusMessage("Error: Canvas not available");
			this.checked = false;
			return;
		}

		// Store current state to restore later
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled,
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		// Step 3) Activate move tool and attach listeners to appropriate canvas
		isMoveToolActive = true;
		window.isMoveToolActive = true; // Expose to CameraControls
		moveToolSelectedHole = null;
		isDraggingHole = false;
		window.isDraggingHole = false; // Expose to CameraControls for pan blocking
		targetCanvas.addEventListener("mousedown", handleMoveToolMouseDown);
		targetCanvas.addEventListener("touchstart", handleMoveToolMouseDown);

		const modeText = moveToolIn3DMode ? "3D" : "2D";
		updateStatusMessage("Move Tool Activated (" + modeText + " mode)\nSelect a hole and drag to move");
		console.log("üëã Move Tool activated in " + modeText + " mode");
	} else {
		// Step 4) Deactivation - remove listeners from correct canvas based on mode
		resetFloatingToolbarButtons("none");

		// Determine which canvas was used
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;

		if (targetCanvas) {
			// Remove move tool listeners from the target canvas
			targetCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
			targetCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
			targetCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			targetCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		// Step 5) Clear move tool state
		isMoveToolActive = false;
		window.isMoveToolActive = false; // Clear from window
		isDraggingHole = false;
		window.isDraggingHole = false; // Clear from window
		moveToolSelectedHole = null;
		moveToolSelectedKAD = null;
		moveToolIn3DMode = false;
		dragPlaneZ = 0;

		// Step 6) Restore default canvas handlers (2D only)
		if (!onlyShowThreeJS) {
			// Remove and re-add default handlers to avoid conflicts
			canvas.removeEventListener("mousedown", handleMouseDown);
			canvas.removeEventListener("mouseup", handleMouseUp);
			canvas.removeEventListener("touchstart", handleTouchStart);
			canvas.removeEventListener("touchend", handleTouchEnd);

			canvas.addEventListener("mousedown", handleMouseDown);
			canvas.addEventListener("mouseup", handleMouseUp);
			canvas.addEventListener("touchstart", handleTouchStart);
			canvas.addEventListener("touchend", handleTouchEnd);
		}

		updateStatusMessage("");

		// Step 7) Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// Step 8) Restore ruler tools if they were active
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}

		// Step 9) Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}
		drawData(allBlastHoles, selectedHole);

		console.log(" Move Tool deactivated");
	}
});

// Handle move tool mouse down - start dragging if holes are selected
// Step 1) Move Tool Mouse Down Handler
// NOTE: This tool SUSPENDS normal panning/dragging behavior
// When Move tool is active, isDragging is not set and panning is disabled
// The tool handles its own dragging behavior for moving KAD vertices/holes
function handleMoveToolMouseDown(event) {
	// Step 1) Guard: Don't start move if connector tools are active
	if (isAddingConnector || isAddingMultiConnector) {
		console.log("üö´ [MOVE TOOL] Blocked - connector tool is active");
		return;
	}

	// Step 1a) Allow Alt+drag to pass through for camera orbit
	if (event.altKey) {
		// Don't block Alt+drag - let CameraControls handle it
		return;
	}

	// Step 2) Check if we're in 3D mode
	if (moveToolIn3DMode && threeRenderer && interactionManager) {
		// 3D Mode Logic
		const targetCanvas = threeRenderer.getCanvas();
		interactionManager.updateMousePosition(event, targetCanvas);

		// Step 2a) Respect radio selection mode
		const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
		const selectingKAD = selectKADRadio && selectKADRadio.checked;

		// Step 2b) Perform raycast once for both KAD and hole detection
		const intersects = interactionManager.raycast();
		console.log("üéØ [MOVE TOOL 3D] Raycast found " + intersects.length + " intersects, selectingKAD: " + selectingKAD + ", selectingHoles: " + selectingHoles);

		if (selectingKAD) {
			// Step 2b.1) Check if we have existing multiple selections
			if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0 && !event.shiftKey) {
				// Use existing multiple selections for dragging
				dragInitialKADPositions = selectedMultipleKADObjects.map(function (obj) {
					return {
						entityName: obj.entityName,
						elementIndex: obj.elementIndex,
						x: obj.pointXLocation,
						y: obj.pointYLocation,
						z: obj.pointZLocation
					};
				});

				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				dragPlaneZ = selectedMultipleKADObjects[0].pointZLocation || 0;
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during KAD drag");
					cameraControls.detachEvents();
				}

				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving " + selectedMultipleKADObjects.length + " KAD points (3D)");
				return;
			}

			// Step 2c) Try to find a KAD vertex in raycast intersects
			let foundKAD = null;

			// Traverse intersects looking for userData.kadId
			for (let i = 0; i < intersects.length; i++) {
				const obj = intersects[i].object;
				if (obj.userData && obj.userData.kadId) {
					// Parse kadId: "entityName:::vertexIndex" or similar
					const parts = obj.userData.kadId.split(":::");
					if (parts.length >= 2) {
						const entityName = parts[0];
						const elementIndex = parseInt(parts[1], 10);
						const entity = allKADDrawingsMap.get(entityName);

						if (entity && entity.data && entity.data[elementIndex]) {
							foundKAD = {
								entityName: entityName,
								elementIndex: elementIndex,
								dataPoint: entity.data[elementIndex],
							};
							break;
						}
					}
				}
			}

			if (foundKAD) {
				// Step 2c) Check if Shift key held for multiple selection
				const dataPoint = foundKAD.dataPoint;
				const entity = allKADDrawingsMap.get(foundKAD.entityName);

				if (event.shiftKey && selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
					// Step 2c.1) Shift+click: Add to existing selection
					const alreadySelected = selectedMultipleKADObjects.find(function (obj) {
						return obj.entityName === foundKAD.entityName && obj.elementIndex === foundKAD.elementIndex;
					});

					if (!alreadySelected) {
						// Add to selection
						const newKADObject = {
							entityName: foundKAD.entityName,
							entityType: entity.entityType,
							elementIndex: foundKAD.elementIndex,
							selectionType: "vertex",
							pointXLocation: dataPoint.pointXLocation,
							pointYLocation: dataPoint.pointYLocation,
							pointZLocation: dataPoint.pointZLocation,
						};
						selectedMultipleKADObjects.push(newKADObject);

						// Create highlight for newly added point
						if (typeof highlightSelectedKADPointThreeJS === "function") {
							highlightSelectedKADPointThreeJS(newKADObject, "multi");
						}
					}

					// Clear single selection
					selectedKADObject = null;
					selectedPoint = null;
				} else {
					// Step 2c.2) Single selection - clear others
					moveToolSelectedKAD = {
						entityName: foundKAD.entityName,
						elementIndex: foundKAD.elementIndex,
						initialX: dataPoint.pointXLocation,
						initialY: dataPoint.pointYLocation,
						initialZ: dataPoint.pointZLocation || 0,
					};
					dragPlaneZ = dataPoint.pointZLocation || 0;

					// Set selected KAD object for highlighting
					selectedKADObject = {
						entityName: foundKAD.entityName,
						entityType: entity.entityType,
						elementIndex: foundKAD.elementIndex,
						selectionType: "vertex",
						pointXLocation: dataPoint.pointXLocation,
						pointYLocation: dataPoint.pointYLocation,
						pointZLocation: dataPoint.pointZLocation,
					};
					selectedPoint = dataPoint;
					selectedKADPolygon = null;
					selectedMultipleKADObjects = [];

					// Step 2e) Create highlight IMMEDIATELY (don't call renderThreeJS - slow!)
					if (typeof highlightSelectedKADPointThreeJS === "function") {
						highlightSelectedKADPointThreeJS(selectedKADObject, "selected");
					}
				}

				// Step 2e.1) Quick render to show highlight(s)
				if (threeRenderer && threeRenderer.renderer) {
					threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
				}

				// Step 2f) Start dragging process
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during KAD drag");
					cameraControls.detachEvents();
				}

				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Move KAD point (3D) - drag to reposition");
				return;
			}
		}

		if (selectingHoles) {
			// Step 2g) Use existing hole selections or try to select a hole via raycasting
			if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
				// Use multiple selected holes
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				moveToolSelectedHole = selectedMultipleHoles;
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during hole drag");
					cameraControls.detachEvents();
				}

				dragPlaneZ = selectedMultipleHoles[0].startZLocation || 0;
				dragInitialPositions = selectedMultipleHoles.map(function (hole) {
					return {
						hole: hole,
						x: hole.startXLocation,
						y: hole.startYLocation,
					};
				});
				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving " + selectedMultipleHoles.length + " holes (3D)");
				return;
			} else if (selectedHole) {
				// Use single selected hole
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				moveToolSelectedHole = [selectedHole];
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during hole drag");
					cameraControls.detachEvents();
				}

				dragPlaneZ = selectedHole.startZLocation || 0;
				dragInitialPositions = [
					{
						hole: selectedHole,
						x: selectedHole.startXLocation,
						y: selectedHole.startYLocation,
					},
				];
				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving hole " + selectedHole.holeID + " (3D)");
				return;
			} else {
				// Step 2h) No existing selection - try to find a hole in raycast intersects
				const clickedHole = interactionManager.findClickedHole(intersects, allBlastHoles || []);
				console.log("üëã [MOVE TOOL 3D] findClickedHole result:", clickedHole);
				if (clickedHole) {
					console.log("üëã [MOVE TOOL 3D] Starting drag for hole: " + clickedHole.holeID + " in " + clickedHole.entityName);

					// Prevent camera pan during drag
					event.preventDefault();
					event.stopPropagation();

					selectedHole = clickedHole;
					moveToolSelectedHole = [clickedHole];
					isDraggingHole = true;
					window.isDraggingHole = true; // Expose to CameraControls

					// ? Suspend camera pan during drag
					if (cameraControls) {
						console.log("ü´∑ Suspending camera pan during hole drag");
						cameraControls.detachEvents();
					}

					dragPlaneZ = clickedHole.startZLocation || 0;
					dragInitialPositions = [
						{
							hole: clickedHole,
							x: clickedHole.startXLocation,
							y: clickedHole.startYLocation,
						},
					];
					targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
					targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
					targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
					targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);

					// Step 2h.1) Create highlight IMMEDIATELY (don't wait for renderThreeJS)
					if (typeof highlightSelectedHoleThreeJS === "function") {
						highlightSelectedHoleThreeJS(clickedHole, "selected");
					}

					// Step 2h.2) Quick render to show highlight
					if (threeRenderer && threeRenderer.renderer) {
						threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
					}

					updateStatusMessage("Moving hole " + clickedHole.holeID + " (3D)");
					return;
				} else {
					// Clicked empty space - clear selection AND remove highlights
					console.log("üí© [MOVE TOOL 3D] No hole found in intersects - clearing selection");
					clearAllSelectionState();
					selectedHole = null;
					selectedMultipleHoles = [];
					moveToolSelectedHole = null;

					// Remove ALL highlights from scene
					if (threeRenderer && threeRenderer.holesGroup) {
						const highlightsToRemove = [];
						threeRenderer.holesGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "selectionHighlight") {
								highlightsToRemove.push(child);
							}
						});
						highlightsToRemove.forEach(function (highlight) {
							threeRenderer.holesGroup.remove(highlight);
							if (highlight.geometry) highlight.geometry.dispose();
							if (highlight.material) highlight.material.dispose();
						});
					}

					// Call drawData with null to prevent highlight recreation (like Escape key does)
					if (typeof drawData === "function") {
						drawData(allBlastHoles, null);
					}
					return;
				}
			}
		}

		// If we reach here, nothing was selected
		return;
	}

	// Step 3) 2D Mode Logic (existing code)
	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	// Step A) Convert CSS pixels -> canvas pixels (fixes staccato/offset on HiDPI)
	const scaleX = canvas.width / rect.width;
	const scaleY = canvas.height / rect.height;
	// Use raw canvas coordinates like the ruler tool
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// Step 10) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	if (selectingKAD) {
		// Prefer moving a KAD vertex
		const clickedKAD = getClickedKADObject(clickX, clickY);
		if (clickedKAD) {
			// Step 3a) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			const entity = allKADDrawingsMap.get(clickedKAD.entityName);
			if (entity && entity.data && entity.data.length > 0) {
				// Resolve target index: vertex or nearest endpoint of segment
				let targetIndex = clickedKAD.elementIndex;
				if (clickedKAD.selectionType === "segment") {
					const worldClick = canvasToWorld(clickX, clickY);
					const i = clickedKAD.segmentIndex;
					const p1 = entity.data[i];
					const p2 = entity.data[(i + 1) % entity.data.length];
					const d1 = Math.hypot(worldClick[0] - p1.pointXLocation, worldClick[1] - p1.pointYLocation);
					const d2 = Math.hypot(worldClick[0] - p2.pointXLocation, worldClick[1] - p2.pointYLocation);
					targetIndex = d1 <= d2 ? i : (i + 1) % entity.data.length;
				}

				// Step 1) Store move target and highlight it
				moveToolSelectedKAD = {
					entityName: clickedKAD.entityName,
					elementIndex: targetIndex,
					// Add initial position storage like holes do
					initialX: entity.data[targetIndex].pointXLocation,
					initialY: entity.data[targetIndex].pointYLocation,
					initialZ: entity.data[targetIndex].pointZLocation,
				};
				moveToolKADOriginalZ = parseFloat(entity.data[targetIndex].pointZLocation) || 0;

				// Step 2) Set selected KAD object for highlighting
				selectedKADObject = {
					entityName: clickedKAD.entityName,
					entityType: entity.entityType,
					elementIndex: targetIndex,
					selectionType: "vertex",
					pointXLocation: entity.data[targetIndex].pointXLocation,
					pointYLocation: entity.data[targetIndex].pointYLocation,
					pointZLocation: entity.data[targetIndex].pointZLocation,
				};
				selectedPoint = entity.data[targetIndex];
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];

				// Step 3) Redraw to show the highlighted selection
				drawData(allBlastHoles, selectedHole);

				// Step 4) Start dragging process
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Move KAD point - drag to reposition");
				return;
			} else {
				// Step 5) Clicked empty space - clear any KAD selection
				moveToolSelectedKAD = null;
				selectedKADObject = null;
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];
				resetAllSelectedStores();
				drawData(allBlastHoles, selectedHole);
				return;
			}
		}
	}
	if (selectingHoles) {
		// First priority: Use existing selections without checking for clicked holes
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			// Step 3b) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			// Use multiple selected holes - start dragging immediately
			moveToolSelectedHole = selectedMultipleHoles;
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = selectedMultipleHoles.map((hole) => ({
				hole: hole,
				x: hole.startXLocation,
				y: hole.startYLocation,
			}));
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else if (selectedHole) {
			// Step 3c) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			// Use single selected hole - start dragging immediately
			moveToolSelectedHole = [selectedHole];
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = [
				{
					hole: selectedHole,
					x: selectedHole.startXLocation,
					y: selectedHole.startYLocation,
				},
			];
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else {
			// No existing selections - check if we clicked on a hole to select it
			const clickedHole = getClickedHole(clickX, clickY);

			if (clickedHole) {
				// Step 3d) Prevent default and stop propagation (starting drag)
				event.preventDefault();
				event.stopPropagation();

				// No holes selected but clicked on a hole - select it and start dragging
				selectedHole = clickedHole;
				moveToolSelectedHole = [clickedHole];
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				dragInitialPositions = [
					{
						hole: clickedHole,
						x: clickedHole.startXLocation,
						y: clickedHole.startYLocation,
					},
				];
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				drawData(allBlastHoles, selectedHole);
			} else {
				// Clicked empty space with no holes selected - clear selection
				selectedHole = null;
				selectedPoint = null;
				//selectedMultiplePoints = [];
				selectedMultipleHoles = [];
				moveToolSelectedHole = null;
				resetAllSelectedStores();
				drawData(allBlastHoles, selectedHole);
			}
		}
	}
}

// Add these listeners in your init function (e.g., DOMContentLoaded or initialize function)
document.addEventListener("keydown", (event) => {
	if (event.key && (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S")) {
		isSelfSnapEnabled = true;
	}
});

document.addEventListener("keyup", (event) => {
	if (event.key && (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S")) {
		isSelfSnapEnabled = false;
	}
});

// Handle move tool mouse move - move holes
function handleMoveToolMouseMove(event) {
	// Step 0) Guard: Don't continue if connector tools are active
	if (isAddingConnector || isAddingMultiConnector) {
		return;
	}

	console.log("üëã [MOVE TOOL MOUSEMOVE] Called - isDraggingHole:", isDraggingHole, "moveToolSelectedHole:", moveToolSelectedHole, "moveToolSelectedKAD:", moveToolSelectedKAD, "moveToolIn3DMode:", moveToolIn3DMode);
	if (!isDraggingHole || (!moveToolSelectedHole && !moveToolSelectedKAD)) {
		console.log("üëã [MOVE TOOL MOUSEMOVE] Early return - not dragging or no selection");
		return;
	}

	event.preventDefault();
	event.stopPropagation();

	// Step 4) Check if we're in 3D mode
	if (moveToolIn3DMode && threeRenderer && interactionManager) {
		// Step 4b) Update raycaster with current mouse position
		const targetCanvas = threeRenderer.getCanvas();
		interactionManager.updateMousePosition(event, targetCanvas);
		const raycaster = interactionManager.raycaster;

		// Step 4b.1) CRITICAL: Update raycaster ray with new mouse position
		const camera = threeRenderer.camera;
		raycaster.setFromCamera(interactionManager.mouse, camera);
		console.log("üëã [MOVE TOOL 3D MOVE] Mouse NDC: (", interactionManager.mouse.x.toFixed(3), interactionManager.mouse.y.toFixed(3), ")");

		// Step 4c) Declare position variables
		let worldX, worldY, worldZ;
		let snapResult = null;
		const snapRadiusPixels = 20; // Fixed pixel radius
		const snapRadiusWorld = getSnapRadiusInWorldUnits3D(snapRadiusPixels);

		// Step 4d) For HOLES: Use fixed Z plane (2D movement only)
		if (moveToolSelectedHole && dragInitialPositions) {
			// Step 4d.1) Create horizontal plane at object's Z elevation (screen-space following)
			const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -dragPlaneZ);

			// Step 4d.2) Intersect ray with plane to get screen-space position
			const intersectionPoint = new THREE.Vector3();
			const didIntersect = raycaster.ray.intersectPlane(plane, intersectionPoint);

			if (!didIntersect) {
				console.log("üëã [MOVE TOOL 3D MOVE] Ray didn't intersect plane at Z:", dragPlaneZ);
				return;
			}

			// Step 4d.3) Convert from local Three.js coords to world coords
			worldX = intersectionPoint.x + threeLocalOriginX;
			worldY = intersectionPoint.y + threeLocalOriginY;
			worldZ = dragPlaneZ; // Fixed Z for holes
			console.log("üëã [MOVE TOOL 3D MOVE HOLE] Position at:", worldX.toFixed(2), worldY.toFixed(2), worldZ.toFixed(2));

			// Step 4d.4) ONLY if snapping is enabled, override with snap position
			if (snapEnabled) {
				// Moving holes: snap to KAD and surfaces, NOT other holes
				snapResult = snapToNearestPointExcludingHolesWithRay(raycaster.ray.origin, raycaster.ray.direction, snapRadiusWorld);
				// Override screen-space position ONLY if snap found
				if (snapResult && snapResult.snapped) {
					worldX = snapResult.worldX;
					worldY = snapResult.worldY;
					// Keep Z fixed for holes (don't use snapResult.worldZ)
				}
			}
		}
		// Step 4e) For KAD: Use full 3D raycast (XYZ movement)
		else if (moveToolSelectedKAD || (dragInitialKADPositions && dragInitialKADPositions.length > 0)) {
			// Step 4e.1) Use 3D snap raycast to get full XYZ position (same as KAD drawing tools)
			// This allows movement in all 3 dimensions based on what the ray intersects
			snapResult = snapToNearestPointWithRay(raycaster.ray.origin, raycaster.ray.direction, snapRadiusWorld);

			if (snapResult && snapResult.snapped) {
				// Step 4e.2) Use snapped 3D position
				worldX = snapResult.worldX;
				worldY = snapResult.worldY;
				worldZ = snapResult.worldZ || dragPlaneZ; // Use snap Z if available, fallback to initial Z
				console.log("üëã [MOVE TOOL 3D MOVE KAD] Snapped to:", worldX.toFixed(2), worldY.toFixed(2), worldZ.toFixed(2), "from", snapResult.snapTarget.description);
			} else {
				// Step 4e.3) No snap found - use plane at initial Z as fallback (screen-space XY movement)
				const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -dragPlaneZ);
				const intersectionPoint = new THREE.Vector3();
				const didIntersect = raycaster.ray.intersectPlane(plane, intersectionPoint);

				if (!didIntersect) {
					console.log("üëã [MOVE TOOL 3D MOVE KAD] Ray didn't intersect fallback plane at Z:", dragPlaneZ);
					return;
				}

				worldX = intersectionPoint.x + threeLocalOriginX;
				worldY = intersectionPoint.y + threeLocalOriginY;
				worldZ = dragPlaneZ; // Keep initial Z if no snap
				console.log("üëã [MOVE TOOL 3D MOVE KAD] No snap - using plane intersection:", worldX.toFixed(2), worldY.toFixed(2), worldZ.toFixed(2));
			}
		} else {
			// Step 4e.4) No object selected - should not reach here
			console.log("üëã [MOVE TOOL 3D MOVE] No object selected");
			return;
		}
		// At this point, worldX, worldY, worldZ are set for either holes or KAD

		// Step 4h) Update object position (uses screen-space or snapped position)
		if (moveToolSelectedHole && dragInitialPositions) {
			// Update hole position(s)
			// Calculate reference delta from first hole's initial position
			const firstHole = dragInitialPositions[0];
			const deltaX = worldX - firstHole.x;
			const deltaY = worldY - firstHole.y;
			console.log("üëã [MOVE TOOL 3D] Moving", dragInitialPositions.length, "hole(s), deltaX:", deltaX.toFixed(2), "deltaY:", deltaY.toFixed(2));

			dragInitialPositions.forEach(function (item) {
				const hole = item.hole;
				const newX = parseFloat(item.x) + deltaX;
				const newY = parseFloat(item.y) + deltaY;
				console.log("  üëã Hole", hole.holeID, "from (", item.x.toFixed(2), item.y.toFixed(2), ") to (", newX.toFixed(2), newY.toFixed(2), ")");
				calculateHoleGeometry(hole, newX, 4); // Parameter 4 for X position
				calculateHoleGeometry(hole, newY, 5); // Parameter 5 for Y position

				// Step 4h.1) Update 3D hole position in real-time (without full re-render)
				if (threeRenderer) {
					var holeId = hole.entityName + ":::" + hole.holeID;

					// Step 4h.1a) Check if using instanced rendering
					if (threeRenderer.isUsingInstancedHoles && threeRenderer.isUsingInstancedHoles()) {
						// Use updateHolePosition() for instanced holes
						threeRenderer.updateHolePosition(holeId, newX, newY, hole.startZLocation || 0);

						// Also update highlight position
						var originalLocal = worldToThreeLocal(item.x, item.y);
						var newLocal = worldToThreeLocal(newX, newY);
						var deltaLocalX = newLocal.x - originalLocal.x;
						var deltaLocalY = newLocal.y - originalLocal.y;

						threeRenderer.holesGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "selectionHighlight" && child.userData.holeId === holeId) {
								child.position.set(deltaLocalX, deltaLocalY, 0);
							}
						});
					} else if (threeRenderer.holeMeshMap) {
						// Step 4h.1b) Use traditional holeMeshMap approach for non-instanced holes
						var holeGroup = threeRenderer.holeMeshMap.get(hole.holeID);
						if (holeGroup) {
							// CRITICAL: Calculate DELTA in local coords, not absolute position
							// Hole geometry is already positioned at original collar location
							// We need to OFFSET the group by the movement delta
							var originalLocal = worldToThreeLocal(item.x, item.y);
							var newLocal = worldToThreeLocal(newX, newY);
							var deltaLocalX = newLocal.x - originalLocal.x;
							var deltaLocalY = newLocal.y - originalLocal.y;

							console.log("    3D offset: delta (", deltaLocalX.toFixed(3), deltaLocalY.toFixed(3), ") - was at (", holeGroup.position.x.toFixed(3), holeGroup.position.y.toFixed(3), ")");

							// Update hole group position by DELTA (not absolute position)
							holeGroup.position.set(deltaLocalX, deltaLocalY, 0);

							// Step 4h.1c) Also update highlight position (find and move it)
							threeRenderer.holesGroup.children.forEach(function (child) {
								if (child.userData && child.userData.type === "selectionHighlight" && child.userData.holeId === holeId) {
									// Move highlight by same delta
									child.position.set(deltaLocalX, deltaLocalY, 0);
								}
							});

							// Mark that we need to update connectors/labels after drag completes
							holeGroup.userData.needsUpdate = true;
						}
					}
				}
			});

			// Step 4h.2) Trigger render without recreating geometry
			if (threeRenderer && threeRenderer.renderer) {
				threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
			}
		} else if (dragInitialKADPositions && dragInitialKADPositions.length > 0) {
			// Step 4i) Move multiple KAD points together (full 3D movement)
			const firstKAD = dragInitialKADPositions[0];
			const deltaX = worldX - firstKAD.x;
			const deltaY = worldY - firstKAD.y;
			const deltaZ = worldZ - (firstKAD.z || 0); // Full 3D delta
			console.log("üëã [MOVE TOOL 3D] Moving " + dragInitialKADPositions.length + " KAD points, delta: (" + deltaX.toFixed(2) + ", " + deltaY.toFixed(2) + ", " + deltaZ.toFixed(2) + ")");

			dragInitialKADPositions.forEach(function (item) {
				const entity = allKADDrawingsMap.get(item.entityName);
				if (entity && entity.data && item.elementIndex < entity.data.length) {
					const newX = item.x + deltaX;
					const newY = item.y + deltaY;
					const newZ = (item.z || 0) + deltaZ; // Calculate new Z

					entity.data[item.elementIndex].pointXLocation = newX;
					entity.data[item.elementIndex].pointYLocation = newY;
					entity.data[item.elementIndex].pointZLocation = newZ; // Full 3D update

					// Update visual for this KAD point (3D delta)
					const kadId = item.entityName + ":::" + item.elementIndex;
					const originalLocal = worldToThreeLocal(item.x, item.y);
					const newLocal = worldToThreeLocal(newX, newY);
					const deltaLocalX = newLocal.x - originalLocal.x;
					const deltaLocalY = newLocal.y - originalLocal.y;

					// Move the KAD point mesh with full 3D delta
					threeRenderer.kadGroup.children.forEach(function (child) {
						if (child.userData && child.userData.kadId === kadId) {
							child.position.set(deltaLocalX, deltaLocalY, deltaZ);
						}
					});

					// Move the highlight with full 3D delta
					threeRenderer.kadGroup.children.forEach(function (child) {
						if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
							child.position.set(deltaLocalX, deltaLocalY, deltaZ);
						}
					});
				}
			});

			// Quick render
			if (threeRenderer && threeRenderer.renderer) {
				threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
			}
		} else if (moveToolSelectedKAD) {
			// Step 4i) Update single KAD point position (full 3D movement)
			console.log("üëã [MOVE TOOL 3D] Moving KAD " + moveToolSelectedKAD.entityName + " point " + moveToolSelectedKAD.elementIndex + " to XYZ: (" + worldX.toFixed(2) + ", " + worldY.toFixed(2) + ", " + worldZ.toFixed(2) + ")");
			const entity = allKADDrawingsMap.get(moveToolSelectedKAD.entityName);
			if (entity && entity.data && moveToolSelectedKAD.elementIndex < entity.data.length) {
				const oldX = entity.data[moveToolSelectedKAD.elementIndex].pointXLocation;
				const oldY = entity.data[moveToolSelectedKAD.elementIndex].pointYLocation;
				const oldZ = entity.data[moveToolSelectedKAD.elementIndex].pointZLocation || 0;

				// Update to new 3D position
				entity.data[moveToolSelectedKAD.elementIndex].pointXLocation = worldX;
				entity.data[moveToolSelectedKAD.elementIndex].pointYLocation = worldY;
				entity.data[moveToolSelectedKAD.elementIndex].pointZLocation = worldZ; // Full 3D movement
				console.log("  üëã KAD point moved from (" + oldX.toFixed(2) + ", " + oldY.toFixed(2) + ", " + oldZ.toFixed(2) + ") to (" + worldX.toFixed(2) + ", " + worldY.toFixed(2) + ", " + worldZ.toFixed(2) + ")");

				// Keep highlight in sync while dragging
				if (selectedKADObject && selectedKADObject.entityName === moveToolSelectedKAD.entityName && selectedKADObject.elementIndex === moveToolSelectedKAD.elementIndex) {
					selectedKADObject.pointXLocation = worldX;
					selectedKADObject.pointYLocation = worldY;
					selectedKADObject.pointZLocation = worldZ; // Update Z in selection object
				}

				// Keep selectedPoint in sync while dragging
				selectedPoint = entity.data[moveToolSelectedKAD.elementIndex];

				// Step 4i.1) Update KAD visual in real-time (full 3D delta calculation)
				const kadId = moveToolSelectedKAD.entityName + ":::" + moveToolSelectedKAD.elementIndex;

				// Calculate delta from initial position (including Z)
				const originalLocal = worldToThreeLocal(moveToolSelectedKAD.initialX, moveToolSelectedKAD.initialY);
				const newLocal = worldToThreeLocal(worldX, worldY);
				const deltaLocalX = newLocal.x - originalLocal.x;
				const deltaLocalY = newLocal.y - originalLocal.y;
				const deltaZ = worldZ - (moveToolSelectedKAD.initialZ || 0); // Z delta in world space

				// Find and move the KAD point mesh in kadGroup (3D movement)
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.kadId === kadId) {
						// Move the mesh by full 3D delta
						child.position.set(deltaLocalX, deltaLocalY, deltaZ);
					}
				});

				// Step 4i.1a) Check if highlight exists - recreate if missing (prevents disappearing during drag)
				let highlightFound = false;
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
						highlightFound = true;
						// Move existing highlight by full 3D delta
						child.position.set(deltaLocalX, deltaLocalY, deltaZ);
					}
				});

				// Step 4i.1b) If highlight was removed (e.g. by drawData), recreate it
				if (!highlightFound) {
					console.log("üëã [MOVE TOOL 3D] Highlight missing - recreating for kadId:", kadId);
					if (typeof highlightSelectedKADPointThreeJS === "function" && selectedKADObject) {
						// Update selectedKADObject position to current location before recreating highlight
						selectedKADObject.pointXLocation = worldX;
						selectedKADObject.pointYLocation = worldY;
						selectedKADObject.pointZLocation = worldZ; // Use full 3D position
						highlightSelectedKADPointThreeJS(selectedKADObject, "selected");

						// Move the newly created highlight to the correct position
						threeRenderer.kadGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
								child.position.set(deltaLocalX, deltaLocalY, deltaZ);
							}
						});
					}
				}

				// Step 4i.2) Quick render to show visual update
				if (threeRenderer && threeRenderer.renderer) {
					threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
				}
			}
		}

		return;
	}

	// Step 5) 2D Mode Logic (existing code)
	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);
	// Calculate movement delta
	const deltaX = (clientX - dragStartX) / currentScale;
	const deltaY = -(clientY - dragStartY) / currentScale;

	// Step 12) KAD move branch
	if (moveToolSelectedKAD) {
		const entity = allKADDrawingsMap.get(moveToolSelectedKAD.entityName);
		if (entity && entity.data && moveToolSelectedKAD.elementIndex < entity.data.length) {
			const rect = canvas.getBoundingClientRect();
			const scaleX = canvas.width / rect.width;
			const scaleY = canvas.height / rect.height;
			const canvasX = (clientX - rect.left) * scaleX;
			const canvasY = (clientY - rect.top) * scaleY;

			// Convert to world coordinates first
			const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
			const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

			// Use the excluding snap function
			// Use regular snap (including self-snap) if 'S' is held; otherwise exclude
			let snapResult;
			if (isSelfSnapEnabled) {
				snapResult = snapToNearestPoint(rawWorldX, rawWorldY);
			} else {
				snapResult = snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, moveToolSelectedKAD.entityName, moveToolSelectedKAD.elementIndex);
			}

			entity.data[moveToolSelectedKAD.elementIndex].pointXLocation = snapResult.worldX;
			entity.data[moveToolSelectedKAD.elementIndex].pointYLocation = snapResult.worldY;
			entity.data[moveToolSelectedKAD.elementIndex].pointZLocation = snapResult.snapped && snapResult.worldZ ? snapResult.worldZ : moveToolSelectedKAD.initialZ || 0;

			// Keep highlight in sync while dragging
			if (selectedKADObject && selectedKADObject.entityName === moveToolSelectedKAD.entityName && selectedKADObject.elementIndex === moveToolSelectedKAD.elementIndex) {
				selectedKADObject.pointXLocation = snapResult.worldX;
				selectedKADObject.pointYLocation = snapResult.worldY;
				selectedKADObject.pointZLocation = entity.data[moveToolSelectedKAD.elementIndex].pointZLocation;
			}

			// Keep selectedPoint in sync while dragging
			selectedPoint = entity.data[moveToolSelectedKAD.elementIndex];
		}
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Move all selected holes
	dragInitialPositions.forEach(({ hole, x, y }) => {
		calculateHoleGeometry(hole, parseFloat(x) + deltaX, 4); // Parameter 4 for X position
		calculateHoleGeometry(hole, parseFloat(y) + deltaY, 5); // Parameter 5 for Y position
	});

	// Throttle contour recalculation for better performance
	let disableContourThrottling = false; // Temporary flag to disable throttling
	if (disableContourThrottling || !contourUpdatePending) {
		if (!disableContourThrottling) {
			contourUpdatePending = true;
		}

		const updateContours = () => {
			if (allBlastHoles.length > 0) {
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, 0, 0);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				timeChart();
			}
			if (!disableContourThrottling) {
				contourUpdatePending = false;
			}
		};

		if (disableContourThrottling) {
			updateContours();
		} else {
			requestAnimationFrame(updateContours);
		}
	}

	drawData(allBlastHoles, selectedHole);
}
// Handle move tool mouse up - stop dragging
function handleMoveToolMouseUp(event) {
	if (isDraggingHole) {
		// Prevent other handlers from running (like 3D click handler)
		event.preventDefault();
		event.stopPropagation();

		isDraggingHole = false;
		window.isDraggingHole = false; // Clear from window

		// Step 6) Determine which canvas to remove listeners from
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;
		if (targetCanvas) {
			targetCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			targetCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		} else {
			// Fallback: remove from both canvases to be safe
			canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		// Step 7) Check if we're in 3D mode
		if (moveToolIn3DMode) {
			// ? Re-enable camera pan after drag completes
			if (cameraControls) {
				console.log("üé• Restoring camera pan after drag complete");
				cameraControls.resetPanState(); // Clear any stuck states
				cameraControls.attachEvents(); // Re-enable pan/orbit
			}

			// Step 7a) 3D Mode: Clear drag plane Z
			dragPlaneZ = 0;

			// Step 7b) Persist KAD changes if applicable
			if (moveToolSelectedKAD || dragInitialKADPositions) {
				debouncedSaveKAD();
				debouncedUpdateTreeView();
				moveToolSelectedKAD = null;
				dragInitialKADPositions = null;
			}

			// Step 7c) Save hole changes
			if (moveToolSelectedHole) {
				debouncedSaveHoles(); // Auto-save holes to IndexedDB
			}

			// Step 7d) Clear selections AND drag state (BEFORE removing highlights!)
			clearAllSelectionState();
			selectedHole = null;
			selectedPoint = null;
			selectedMultipleHoles = [];
			moveToolSelectedHole = null;
			dragInitialPositions = null; // CRITICAL: Clear to prevent wrong hole moving next time

			// Step 7e) Remove ALL hole highlights from scene
			if (threeRenderer && threeRenderer.holesGroup) {
				const highlightsToRemove = [];
				threeRenderer.holesGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "selectionHighlight") {
						highlightsToRemove.push(child);
					}
				});
				highlightsToRemove.forEach(function (highlight) {
					threeRenderer.holesGroup.remove(highlight);
					if (highlight.geometry) highlight.geometry.dispose();
					if (highlight.material) highlight.material.dispose();
				});
				console.log("üëã [MOVE TOOL] Removed " + highlightsToRemove.length + " hole highlights from scene");
			}

			// Step 7e.1) Remove ALL KAD highlights from scene
			if (threeRenderer && threeRenderer.kadGroup) {
				const kadHighlightsToRemove = [];
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "kadHighlight") {
						kadHighlightsToRemove.push(child);
					}
				});
				kadHighlightsToRemove.forEach(function (highlight) {
					threeRenderer.kadGroup.remove(highlight);
					if (highlight.geometry) highlight.geometry.dispose();
					if (highlight.material) highlight.material.dispose();
				});
				console.log("üëã [MOVE TOOL] Removed " + kadHighlightsToRemove.length + " KAD highlights from scene");
			}

			// Step 7f) Call drawData with null to prevent highlight recreation (like Escape key does)
			// This ensures no other code recreates highlights after we remove them
			if (typeof drawData === "function") {
				drawData(allBlastHoles, null);
			}

			// Step 7g) Set flag to prevent click event from re-selecting the hole
			justFinishedDragging = true;
			setTimeout(function () {
				justFinishedDragging = false;
			}, 100); // Clear flag after 100ms

			console.log("üëã Move Tool mouseup (3D mode) - changes saved");
			return;
		}

		// Step 8) 2D Mode Logic (existing code)
		// Step 13) Persist KAD changes if applicable
		if (moveToolSelectedKAD) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			moveToolSelectedKAD = null;
		}

		// Save changes and recalculate everything
		if (moveToolSelectedHole) {
			debouncedSaveHoles(); // Auto-save holes to IndexedDB

			// Recalculate everything after holes are moved
			if (allBlastHoles.length > 0) {
				// Recalculate triangulation
				if (displayContours.checked || displayRelief.checked || displayFirstMovements.checked) {
					const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

					// Recalculate hole times
					holeTimes = calculateTimes(allBlastHoles);

					// Recalculate contours
					const result = recalculateContours(allBlastHoles, 0, 0);
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}
			}
		}
		// Clear single selection and multiple selection AND drag state
		clearAllSelectionState();
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		moveToolSelectedHole = null;
		dragInitialPositions = null; // CRITICAL: Clear to prevent wrong hole moving next time
		drawData(allBlastHoles, selectedHole);
	}
}
//---------------END OF MOVE TOOL---------------//

//---------------BEARING TOOL---------------//
// Add event listener for the bearing tool
bearingTool.addEventListener("change", function () {
	if (this.checked) {
		// Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;

		resetFloatingToolbarButtons("bearingTool");
		removeAllCanvasListenersKeepDefault();

		// ? ADD: Store current state to restore later (was missing!)
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled,
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		isBearingToolActive = true;
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
		canvas.addEventListener("mousedown", handleBearingToolMouseDown);
		canvas.addEventListener("touchstart", handleBearingToolMouseDown);
		updateStatusMessage("Bearing Tool Activated\nSelect a hole and drag to rotate\nHold 'F' for focus mode");
		// Add keydown listener for F key
		document.addEventListener("keydown", handleBearingToolKeyDown);
		document.addEventListener("keyup", handleBearingToolKeyUp);
	} else {
		resetFloatingToolbarButtons("none");

		// Remove bearing tool listeners
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Remove key listeners
		document.removeEventListener("keydown", handleBearingToolKeyDown);
		document.removeEventListener("keyup", handleBearingToolKeyUp);

		// ? ADD: Clear bearing tool state
		isBearingToolActive = false;
		isDraggingBearing = false;
		bearingToolSelectedHole = null;

		// ? ADD: Clear the focus mode flag
		isFocusModeActive = false;

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);

		// Restore default canvas handlers so other tools work properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ? ADD: Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// ? ADD: Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}

		// Restore ruler protractor click handler if it was active
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Track F key state
let isFocusModeActive = false;

// Handle F key press for focus mode
function handleBearingToolKeyDown(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = true;
	}
}

function handleBearingToolKeyUp(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = false;
	}
}

// Handle bearing tool mouse down - start dragging if holes are selected
// Step 1) Bearing Tool Mouse Down Handler
// NOTE: This tool SUSPENDS normal panning/dragging behavior
// When Bearing tool is active, isDragging is not set and panning is disabled
// The tool handles its own dragging behavior for rotating holes
function handleBearingToolMouseDown(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// First priority: Use existing selections without checking for clicked holes
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// Use multiple selected holes - start dragging immediately
		bearingToolSelectedHole = selectedMultipleHoles;
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else if (selectedHole) {
		// Use single selected hole - start dragging immediately
		bearingToolSelectedHole = [selectedHole];
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else {
		// No existing selections - check if we clicked on a hole to select it
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole) {
			// No holes selected but clicked on a hole - select it and start dragging
			selectedHole = clickedHole;
			bearingToolSelectedHole = [clickedHole];
			isDraggingBearing = true;
			canvas.addEventListener("mousemove", handleBearingToolMouseMove);
			canvas.addEventListener("touchmove", handleBearingToolMouseMove);
			canvas.addEventListener("mouseup", handleBearingToolMouseUp);
			canvas.addEventListener("touchend", handleBearingToolMouseUp);
			drawData(allBlastHoles, selectedHole);
		} else {
			// Clicked empty space with no holes selected - clear selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			bearingToolSelectedHole = null;
			drawData(allBlastHoles, selectedHole);
		}
	}
}
// Handle bearing tool mouse move - rotate bearing
function handleBearingToolMouseMove(event) {
	if (!isDraggingBearing || !bearingToolSelectedHole) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isFocusModeActive) {
		// Focus mode: Each hole points to mouse location (original behavior)
		bearingToolSelectedHole.forEach((hole) => {
			const eastingDiff = worldX - parseFloat(hole.startXLocation);
			const northingDiff = worldY - parseFloat(hole.startYLocation);

			let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
			if (newBearing < 0) newBearing += 360;

			calculateHoleGeometry(hole, newBearing, 3);
		});
	} else {
		// Default mode: All holes get same bearing based on first hole
		const firstHole = bearingToolSelectedHole[0];
		const eastingDiff = worldX - parseFloat(firstHole.startXLocation);
		const northingDiff = worldY - parseFloat(firstHole.startYLocation);

		let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
		if (newBearing < 0) newBearing += 360;

		// Apply the same bearing to all selected holes
		bearingToolSelectedHole.forEach((hole) => {
			calculateHoleGeometry(hole, newBearing, 3);
		});
	}

	drawData(allBlastHoles, selectedHole);
}

// Handle bearing tool mouse up - stop dragging
function handleBearingToolMouseUp(event) {
	if (isDraggingBearing) {
		isDraggingBearing = false;
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Save changes
		if (bearingToolSelectedHole) {
			debouncedSaveHoles(); // Auto-save holes to IndexedDB
		}
		// Clear single selection and he multiple selection
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}
}

//---------------END OF BEARING TOOL---------------//

//---------------SELECTION TOOLS---------------//
selectPointerTool.addEventListener("change", function () {
	if (this.checked) {
		isSelectionPointerActive = true;
		isPolygonSelectionActive = false;
		isMultiHoleSelectionEnabled = false;
		//selectedKADPolygon = null;

		// Step X) Disable 3D polygon selection if active
		// Fixes QUIRK 3: SelectPointer and SelectPolygon should turn each other off
		if (onlyShowThreeJS && window.polygonSelection3D) {
			window.polygonSelection3D.disable();
			selectByPolygonTool.checked = false;
			if (developerModeEnabled) {
				console.log("‚ùåüî∂ Disabled 3D polygon selection (SelectPointer activated)");
			}
		}

		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectPointerTool");
		clearAllSelectionState();
		endKadTools();
		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Enable point selection mode
		canvas.addEventListener("click", handleSelection);
		canvas.addEventListener("touchstart", handleSelection);
		updateStatusMessage("Point selection mode enabled\nShift to select multiple.\n Escape to clear selection.");
		drawData(allBlastHoles, selectedHole);
	} else {
		isSelectionPointerActive = false;
		isMultiHoleSelectionEnabled = false;
		// Disable point selection mode
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Update the function to properly check and handle KAD tools
// MOVED TO ContextMenuManager.js - This function is now loaded from external module
// END OF MOVED FUNCTION - kadContextMenu now loaded from ContextMenuManager.js
///-----------------------------RIGHT CLICK STUFF GOES HERE-----------------------------//
// MOVED TO ContextMenuManager.js - This function is now loaded from external module
// END OF MOVED FUNCTION - closeAllContextMenus now loaded from ContextMenuManager.js
// Step 1) 2D context menu event listener - now using ContextMenuManager
// Step 1) 2D context menu event listener - now using ContextMenuManager
canvas.addEventListener("contextmenu", function (e) {
	// Delegate to the centralized context menu manager
	window.handle2DContextMenu(e);
});

function isClickOnSelectedPolygon(worldX, worldY, selectedPolygon) {
	if (!selectedPolygon || !allKADDrawingsMap.has(selectedPolygon.entityName)) {
		return null;
	}

	const entity = allKADDrawingsMap.get(selectedPolygon.entityName);
	const points = entity.data;
	const tolerance = getSnapToleranceInWorldUnits(); // Adjust click tolerance based on zoom

	// Check if click is on any point of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		const dx = worldX - point.pointXLocation;
		const dy = worldY - point.pointYLocation;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance) {
			// Return the clicked point with metadata - USE DYNAMIC VALUES
			return {
				...point,
				mapType: "allKADDrawingsMap", // ? Use unified map name
				entityType: entity.entityType, // ? Use actual entity type from data
				entityName: entity.entityName, // ? Add entity name for consistency
			};
		}
	}

	// Check if click is on any segment of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point1 = points[i];
		const point2 = points[(i + 1) % points.length]; // Wrap around to first point

		// Calculate distance from click point to line segment
		const segmentDistance = distanceToLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

		if (segmentDistance <= tolerance) {
			// Return the first point of the segment with metadata - USE DYNAMIC VALUES
			return {
				...point1,
				mapType: "allKADDrawingsMap", // ? Use unified map name
				entityType: entity.entityType, // ? Use actual entity type from data
				entityName: entity.entityName, // ? Add entity name for consistency
			};
		}
	}

	return null;
}

// Helper function to calculate distance from point to line segment
function distanceToLineSegment(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;
	const length = dx * dx + dy * dy;

	if (length === 0) {
		// Points are the same, return distance to point
		const dpx = px - x1;
		const dpy = py - y1;
		return Math.sqrt(dpx * dpx + dpy * dpy);
	}

	// Calculate parameter t for closest point on line segment
	const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / length));

	// Calculate closest point on segment
	const closestX = x1 + t * dx;
	const closestY = y1 + t * dy;

	// Return distance to closest point
	const dcx = px - closestX;
	const dcy = py - closestY;
	return Math.sqrt(dcx * dcx + dcy * dcy);
}

// ENHANCED: Fix getClickedKADObject to return specific element information
function getClickedKADObject(clickX, clickY) {
	const worldX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(clickY - canvas.height / 2) / currentScale + centroidY;

	if (developerModeEnabled) {
		console.log("‚¨áÔ∏è [getClickedKADObject] Click at canvas:", clickX, clickY, "| world:", worldX, worldY);
	}


	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		const tolerance = getSnapToleranceInWorldUnits();
		if (developerModeEnabled) {
			console.log("üéØ Snap tolerance:", tolerance, "| Total entities:", allKADDrawingsMap.size);
		}
		let closestMatch = null;
		let minDistance = tolerance;

		// Iterate through all entities
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			// ? CHECK VISIBILITY FIRST - Skip hidden entities
			if (!isEntityVisible(entityName)) {
				if (developerModeEnabled) {
					console.log("  üëª  Skipping hidden entity:", entityName);
				}
				continue;
			}
			if (developerModeEnabled) {
				console.log("  üîç Checking entity:", entityName, "| Type:", entity.entityType, "| Elements:", entity.data.length);
			}

			// For single-point entities (points, circles, text)
			if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
				for (let i = 0; i < entity.data.length; i++) {
					const point = entity.data[i];
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));
					if (developerModeEnabled) {
						console.log("    üìç Element", i, "distance:", distance.toFixed(2), "| tolerance:", tolerance.toFixed(2));
					}

					if (distance <= tolerance && distance < minDistance) {
						if (developerModeEnabled) {
							console.log("    ‚úÖ MATCH FOUND! Entity:", entityName, "Type:", entity.entityType, "Element:", i);
						}
						closestMatch = {
							...point,
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i,
							selectionType: "vertex", // Changed from "point" to "vertex" to match ContextMenuManager expectations
						};
						minDistance = distance;
					}
				}
			}
			// For multi-point entities (lines and polygons) - prioritize SEGMENTS over vertices
			else if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length < 2) continue;

				// FIRST: Check segments (higher priority than vertices)
				const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

				for (let i = 0; i < numSegments; i++) {
					const point1 = points[i];
					const point2 = points[(i + 1) % points.length]; // Wrap for polygons

					// Calculate distance from click to line segment
					const segmentDistance = pointToLineSegmentDistance(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

					if (segmentDistance <= tolerance && segmentDistance < minDistance) {
						// Find the closest point on the segment for the clicked location
						const closestPoint = getClosestPointOnLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

						closestMatch = {
							...point1, // Use first point's properties as base
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i, // This is the specific segment clicked
							selectionType: "segment",
							clickedX: closestPoint.x,
							clickedY: closestPoint.y,
						};
						minDistance = segmentDistance;
					}
				}

				// SECOND: Check vertices (lower priority, only if no segment found)
				if (!closestMatch) {
					for (let i = 0; i < points.length; i++) {
						const point = points[i];
						const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));

						if (distance <= tolerance && distance < minDistance) {
							closestMatch = {
								...point,
								mapType: "allKADDrawingsMap",
								entityName: entityName,
								entityType: entity.entityType,
								elementIndex: i,
								segmentIndex: i,
								selectionType: "vertex",
							};
							minDistance = distance;
						}
					}
				}
			}
		}

		if (developerModeEnabled) {
			console.log("ü§å [getClickedKADObject] Final result:", closestMatch ? closestMatch.entityType + " - " + closestMatch.entityName : "null");
		}
		return closestMatch;
	}

	if (developerModeEnabled) {
		console.log("ü§å [getClickedKADObject] No entities available or empty map");
	}
	return null;
}

// Step 13j.1) Get clicked KAD object in 3D mode (mimics 2D getClickedKADObject)
function getClickedKADObject3D(intersects, clickX, clickY) {
	if (developerModeEnabled) {
		console.log("ü§å 3D [getClickedKADObject3D] Starting - Intersects:", intersects ? intersects.length : 0, "| Click:", clickX, clickY);
	}

	if (!intersects || intersects.length === 0) {
		if (developerModeEnabled) {
			console.log("ü§å 3D [getClickedKADObject3D] No intersects - raycast missed everything");
		}
		return null;
	}

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		if (developerModeEnabled) {
			console.log("ü§å 3D [getClickedKADObject3D] No KAD entities in map");
		}
		return null;
	}

	// Step 13j.1a) Find the first KAD object from raycast intersects
	if (developerModeEnabled) {
		console.log("ü§å 3D Inspecting " + intersects.length + " intersects:");
	}
	for (let i = 0; i < Math.min(5, intersects.length); i++) {
		const userData = intersects[i].object.userData;
		if (developerModeEnabled) {
			console.log("  [" + i + "] distance:", intersects[i].distance.toFixed(2), "| userData:", userData);
		}
	}

	let clickedKADMesh = null;
	for (const intersect of intersects) {
		const userData = intersect.object.userData;
		if (userData && userData.type && userData.type.startsWith("kad") && userData.kadId) {
			clickedKADMesh = intersect.object;
			if (developerModeEnabled) {
				console.log("üëÄ 3D ? Found KAD mesh! Type:", userData.type, "| kadId:", userData.kadId);
			}
			break;
		}
	}

	if (!clickedKADMesh) {
		if (developerModeEnabled) {
			console.log("üßä 3D ‚ùå No KAD mesh in raycast results");
		}
		return null;
	}

	const userData = clickedKADMesh.userData;
	const entityName = userData.kadId; // kadId is the entityName
	const entity = allKADDrawingsMap.get(entityName);
	if (!entity) return null;

	// Step 13j.1b) Check entity visibility
	if (!isEntityVisible(entityName)) return null;

	// Step 13j.1c) Get world position from raycast for distance calculations
	const worldPos = interactionManager.getMouseWorldPositionOnPlane();
	if (!worldPos) return null;

	const tolerance = getSnapToleranceInWorldUnits();

	// Step 13j.1d) Handle single-point entities (points, circles, text)
	if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
		// Step 13j.1d.1) Find closest point within tolerance
		let closestMatch = null;
		let minDistance = tolerance;

		for (let i = 0; i < entity.data.length; i++) {
			const point = entity.data[i];
			const distance = Math.sqrt(Math.pow(point.pointXLocation - worldPos.x, 2) + Math.pow(point.pointYLocation - worldPos.y, 2));

			if (distance <= tolerance && distance < minDistance) {
				closestMatch = {
					...point, // Include all point properties (pointXLocation, pointYLocation, color, etc.)
					mapType: "allKADDrawingsMap",
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: i,
					segmentIndex: i,
					selectionType: "vertex", // Changed from "point" to "vertex" to match 2D and ContextMenuManager
				};
				minDistance = distance;
			}
		}

		return closestMatch;
	}

	// Step 13j.1e) Handle multi-point entities (lines and polygons)
	if (entity.entityType === "line" || entity.entityType === "poly") {
		const points = entity.data;
		if (points.length < 2) return null;

		// Step 13j.1e.1) Determine segment index from userData or by finding closest segment
		let segmentIndex = userData.segmentIndex;
		if (segmentIndex === undefined) {
			// Step 13j.1e.1a) Find closest segment to clicked position
			const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;
			let closestSegment = null;
			let minSegmentDistance = tolerance;

			for (let i = 0; i < numSegments; i++) {
				const point1 = points[i];
				const point2 = points[(i + 1) % points.length]; // Wrap for polygons

				// Calculate distance from click to line segment
				const segmentDistance = pointToLineSegmentDistance(worldPos.x, worldPos.y, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

				if (segmentDistance <= tolerance && segmentDistance < minSegmentDistance) {
					closestSegment = i;
					minSegmentDistance = segmentDistance;
				}
			}

			if (closestSegment !== null) {
				segmentIndex = closestSegment;
			} else {
				// Step 13j.1e.1b) If no segment found, check vertices
				let closestVertex = null;
				let minVertexDistance = tolerance;

				for (let i = 0; i < points.length; i++) {
					const point = points[i];
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldPos.x, 2) + Math.pow(point.pointYLocation - worldPos.y, 2));

					if (distance <= tolerance && distance < minVertexDistance) {
						closestVertex = i;
						minVertexDistance = distance;
					}
				}

				if (closestVertex !== null) {
					// Return vertex selection
					const point = points[closestVertex];
					return {
						...point,
						mapType: "allKADDrawingsMap",
						entityName: entityName,
						entityType: entity.entityType,
						elementIndex: closestVertex,
						segmentIndex: closestVertex,
						selectionType: "vertex",
					};
				}

				return null;
			}
		}

		// Step 13j.1e.2) Return segment selection
		const point1 = points[segmentIndex];
		const closestPoint = getClosestPointOnLineSegment(worldPos.x, worldPos.y, point1.pointXLocation, point1.pointYLocation, points[(segmentIndex + 1) % points.length].pointXLocation, points[(segmentIndex + 1) % points.length].pointYLocation);

		return {
			...point1, // Use first point's properties as base
			mapType: "allKADDrawingsMap",
			entityName: entityName,
			entityType: entity.entityType,
			elementIndex: segmentIndex,
			segmentIndex: segmentIndex,
			selectionType: "segment",
			clickedX: closestPoint.x,
			clickedY: closestPoint.y,
		};
	}

	return null;
}

// Helper function to check if a clicked KAD object is currently selected
function isKADObjectSelected(clickedObject) {
	if (!clickedObject) return false;

	// Check against selectedKADObject
	if (selectedKADObject) {
		return selectedKADObject.entityName === clickedObject.entityName && selectedKADObject.elementIndex === clickedObject.elementIndex && selectedKADObject.entityType === clickedObject.entityType;
	}

	// Check against selectedKADPolygon (backward compatibility)
	if (selectedKADPolygon && clickedObject.entityType === "poly") {
		return selectedKADPolygon.entityName === clickedObject.entityName;
	}

	return false;
}

// ENHANCED: Unified KAD Property Editor with FloatingDialog and hide functionality
// MOVED TO KADContextMenu.js - These functions are now loaded from external module
// showKADPropertyEditorPopup, showMultipleKADPropertyEditor, convertLinePolyType, updateKADObjectProperties
/*
// Step 1) Function removed - now implemented in src/dialog/contextMenu/KADContextMenu.js
// Step 2) Original implementation: 209 lines (28276-28485) - had template literals and no Delete button
// Step 3) New implementation in src/dialog/contextMenu/KADContextMenu.js (line 7-309) has:
//         - Delete button with auto-renumbering
//         - Proper segment endpoint handling
//         - No template literal violations
//         - Better edge case handling
// Step 4) KADContextMenu.js exposes it globally as: window.showKADPropertyEditorPopup = showKADPropertyEditorPopup
// Step 5) All calls to showKADPropertyEditorPopup() in kirra.js (lines 1997, 40745) automatically use the global version
// Step 6) No wrapper needed - function is already globally available

// New function to show property editor for multiple KAD objects
function showMultipleKADPropertyEditor(kadObjects) {
	if (!kadObjects || kadObjects.length === 0) return;

	// Create form content
	const formContent = document.createElement("div");

	// Common properties that can be edited for all polygons
	const fields = [
		{
			label: "Color",
			name: "editKADColor",
			type: "color",
			value: kadObjects[0].data?.[0]?.color || "#FF0000",
		},
		{
			label: "Line Width",
			name: "editLineWidth",
			type: "number",
			value: kadObjects[0].data?.[0]?.lineWidth || "2",
			step: "0.5",
			min: "0.5",
			max: "10",
		},
		{
			label: "Z Elevation",
			name: "editZLocation",
			type: "number",
			value: "0",
			step: "0.1",
		},
	];

	// Create form fields
	fields.forEach((field) => {
		const fieldDiv = document.createElement("div");
		fieldDiv.className = "form-field";
		fieldDiv.style.marginBottom = "10px";

		const label = document.createElement("label");
		label.textContent = field.label + ":";
		label.style.display = "inline-block";
		label.style.width = "100px";
		fieldDiv.appendChild(label);

		const input = document.createElement("input");
		input.type = field.type;
		input.name = field.name;
		input.value = field.value;

		if (field.type === "number") {
			input.step = field.step || "1";
			if (field.min) input.min = field.min;
			if (field.max) input.max = field.max;
		}

		if (field.type === "color") {
			input.className = "jscolor";
			input.setAttribute("data-jscolor", "{}");
		}

		fieldDiv.appendChild(input);
		formContent.appendChild(fieldDiv);
	});

	// Add note about multiple selection
	const noteDiv = document.createElement("div");
	noteDiv.style.marginTop = "15px";
	noteDiv.style.fontSize = "12px";
	noteDiv.style.color = "#666";
	noteDiv.innerHTML = "Editing " + kadObjects.length + " polygon(s)";
	formContent.appendChild(noteDiv);

	// Create dialog
	const dialog = new FloatingDialog({
		title: "Edit Multiple Polygons",
		content: formContent,
		layoutType: "default",
		width: 350,
		height: 250,
		showConfirm: true,
		showCancel: true,
		confirmText: "Apply",
		cancelText: "Cancel",
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			// Apply changes to all selected polygons
			kadObjects.forEach((kadObj) => {
				const entity = allKADDrawingsMap.get(kadObj.entityName);
				if (entity) {
					// Update all points in the polygon
					entity.data.forEach((point) => {
						if (formData.editKADColor) {
							point.color = formData.editKADColor;
						}
						if (formData.editLineWidth) {
							point.lineWidth = parseFloat(formData.editLineWidth);
						}
						if (formData.editZLocation) {
							point.pointZLocation = parseFloat(formData.editZLocation);
						}
					});
				}
			});

			// Save and redraw
			debouncedSaveKAD();
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
			updateStatusMessage("Updated " + kadObjects.length + " polygon(s)");
			setTimeout(() => updateStatusMessage(""), 2000);
		},
		onCancel: () => {
			// Just close
			clearAllSelectionState();
			drawData(allBlastHoles, selectedHole);
		},
	});

	dialog.show();

	// Initialize color picker if present
	if (typeof jscolor !== "undefined") {
		jscolor.install();
	}
}

// NEW: Function to convert between line and poly
function convertLinePolyType(kadObject, newType) {
	const entity = getEntityFromKADObject(kadObject);
	if (!entity) return;

	// Update entity type
	entity.entityType = newType;

	// Update all data points to reflect the new type
	entity.data.forEach((point) => {
		point.entityType = newType;
		if (newType === "poly") {
			point.closed = true;
		} else {
			point.closed = false;
		}
	});

	updateStatusMessage(`Converted ${kadObject.entityName} to ${newType}`);
	debouncedUpdateTreeView(); // ? ADDED: Update tree view swatches
	setTimeout(() => updateStatusMessage(""), 2000);
}

function updateKADObjectProperties(kadObject, newProperties, scope = "all") {
	const map = allKADDrawingsMap;
	const entity = map.get(kadObject.entityName);

	if (entity) {
		const onlyZ = newProperties.onlyZ;
		if (scope === "element") {
			// Only this point
			const elementIndex = kadObject.elementIndex;
			if (elementIndex !== undefined && elementIndex < entity.data.length) {
				const item = entity.data[elementIndex];
				if (newProperties.color) item.color = newProperties.color;
				if (newProperties.lineWidth) item.lineWidth = parseFloat(newProperties.lineWidth);
				if (newProperties.radius) item.radius = parseFloat(newProperties.radius);
				if (newProperties.text) item.text = newProperties.text;

				if (onlyZ) {
					if (newProperties.pointZLocation !== undefined) item.pointZLocation = parseFloat(newProperties.pointZLocation);
				} else {
					if (newProperties.pointXLocation !== undefined) item.pointXLocation = parseFloat(newProperties.pointXLocation);
					if (newProperties.pointYLocation !== undefined) item.pointYLocation = parseFloat(newProperties.pointYLocation);
					if (newProperties.pointZLocation !== undefined) item.pointZLocation = parseFloat(newProperties.pointZLocation);
				}
				updateStatusMessage("Updated element " + (elementIndex + 1) + " of " + kadObject.entityType + " " + kadObject.entityName);
			}
		} else {
			// All points
			const elementIndex = kadObject.elementIndex;
			const item = entity.data[elementIndex];
			let dx = 0,
				dy = 0,
				dz = 0;
			if (!onlyZ && item) {
				if (newProperties.pointXLocation !== undefined) dx = parseFloat(newProperties.pointXLocation) - item.pointXLocation;
				if (newProperties.pointYLocation !== undefined) dy = parseFloat(newProperties.pointYLocation) - item.pointYLocation;
				if (newProperties.pointZLocation !== undefined) dz = parseFloat(newProperties.pointZLocation) - item.pointZLocation;
			}
			entity.data.forEach((pt) => {
				if (newProperties.color) pt.color = newProperties.color;
				if (newProperties.lineWidth) pt.lineWidth = parseFloat(newProperties.lineWidth);
				if (newProperties.radius) pt.radius = parseFloat(newProperties.radius);
				if (newProperties.text) pt.text = newProperties.text;
				if (newProperties.pointDiameter) pt.pointDiameter = parseFloat(newProperties.pointDiameter);

				if (onlyZ) {
					if (newProperties.pointZLocation !== undefined) pt.pointZLocation = parseFloat(newProperties.pointZLocation);
				} else {
					if (newProperties.pointXLocation !== undefined) pt.pointXLocation += dx;
					if (newProperties.pointYLocation !== undefined) pt.pointYLocation += dy;
					if (newProperties.pointZLocation !== undefined) pt.pointZLocation += dz;
				}
			});
			updateStatusMessage("Updated all elements in " + kadObject.entityType + " " + kadObject.entityName);
		}
		drawData(allBlastHoles, selectedHole);
		debouncedUpdateTreeView();
		setTimeout(() => updateStatusMessage(""), 2000);
	} else {
		console.error("Entity not found:", kadObject.entityName, "in unified map");
	}
}
*/
// END OF MOVED FUNCTIONS - KAD functions now loaded from KADContextMenu.js

// Helper to update KAD object in map
function updateKADObjectInMap(kadObject) {
	const map = window[kadObject.mapType]; // Get the map (, etc.)
	const entity = map.get(kadObject.entityName);

	if (entity) {
		// Find and update the specific object
		const objectIndex = entity.data.findIndex((item) => item.pointID === kadObject.pointID && item.pointXLocation === kadObject.pointXLocation && item.pointYLocation === kadObject.pointYLocation);

		if (objectIndex !== -1) {
			entity.data[objectIndex] = kadObject;
		}
	}
}

// MOVED TO SurfacesContextMenu.js - This function is now loaded from external module
/*
// Step 1) Surface Context Menu using FloatingDialog for consistent styling
function showSurfaceContextMenu(x, y, surfaceId = null) {
	// Step 2) Get the specific surface if ID provided, otherwise first visible surface
	var surface = surfaceId
		? loadedSurfaces.get(surfaceId)
		: Array.from(loadedSurfaces.values()).find(function (s) {
				return s.visible;
		  });
	if (!surface) return;

	// Step 3) Store reference for dialog callbacks
	var currentSurface = surface;
	var dialogInstance = null;

	// Step 4) Define gradient options - include texture option for textured meshes
	var gradientOptions = [
		{ value: "default", text: "Default" },
		{ value: "hillshade", text: "Hillshade" },
		{ value: "viridis", text: "Viridis" },
		{ value: "turbo", text: "Turbo" },
		{ value: "parula", text: "Parula" },
		{ value: "cividis", text: "Cividis" },
		{ value: "terrain", text: "Terrain" },
	];

	// Step 4a) Add texture option if this is a textured mesh
	if (currentSurface.isTexturedMesh) {
		gradientOptions.unshift({ value: "texture", text: "Texture (Original)" });
	}

	// Step 5) Create content builder function
	var contentBuilder = function (dialog) {
		var container = document.createElement("div");
		container.style.display = "flex";
		container.style.flexDirection = "column";
		container.style.gap = "12px";
		container.style.padding = "12px";

		// Step 6) Create action buttons section with full-width buttons
		var buttonsSection = document.createElement("div");
		buttonsSection.style.display = "flex";
		buttonsSection.style.flexDirection = "column";
		buttonsSection.style.gap = "8px";
		buttonsSection.style.marginBottom = "16px";

		// Step 6a) Helper function to create styled full-width button
		var createActionButton = function (text, onClick) {
			var btn = document.createElement("button");
			btn.className = "floating-dialog-btn";
			btn.textContent = text;
			btn.style.width = "100%";
			btn.style.padding = "10px 16px";
			btn.style.fontSize = "13px";
			btn.style.cursor = "pointer";
			btn.style.borderRadius = "4px";
			btn.style.border = "1px solid #ccc";
			btn.style.backgroundColor = "#f5f5f5";
			btn.style.color = "#333";
			btn.style.transition = "background-color 0.2s";
			btn.onmouseover = function () {
				btn.style.backgroundColor = "#e0e0e0";
			};
			btn.onmouseout = function () {
				btn.style.backgroundColor = "#f5f5f5";
			};
			btn.onclick = onClick;
			return btn;
		};

		// Step 7) Toggle visibility button
		buttonsSection.appendChild(
			createActionButton(currentSurface.visible ? "Hide Surface" : "Show Surface", function () {
				setSurfaceVisibility(currentSurface.id, !currentSurface.visible);
				drawData(allBlastHoles, selectedHole);
				if (dialogInstance) dialogInstance.close();
			})
		);

		// Step 8) Remove surface button
		buttonsSection.appendChild(
			createActionButton("Remove Surface", function () {
				deleteSurfaceFromDB(currentSurface.id)
					.then(function () {
						loadedSurfaces.delete(currentSurface.id);
						drawData(allBlastHoles, selectedHole);
						debouncedUpdateTreeView();
						console.log("Surface removed from both memory and database");
					})
					.catch(function (error) {
						console.error("Error removing surface:", error);
						loadedSurfaces.delete(currentSurface.id);
						drawData(allBlastHoles, selectedHole);
					});
				if (dialogInstance) dialogInstance.close();
			})
		);

		// Step 9) Delete all surfaces button
		buttonsSection.appendChild(
			createActionButton("Delete All Surfaces", function () {
				deleteAllSurfacesFromDB()
					.then(function () {
						loadedSurfaces.clear();
						drawData(allBlastHoles, selectedHole);
						console.log("All surfaces deleted from database and memory");
					})
					.catch(function (error) {
						console.error("Error deleting all surfaces:", error);
					});
				if (dialogInstance) dialogInstance.close();
			})
		);

		container.appendChild(buttonsSection);

		// Step 10) Create transparency slider section with proper styling
		var sliderSection = document.createElement("div");
		sliderSection.style.marginBottom = "12px";

		var sliderLabel = document.createElement("div");
		sliderLabel.textContent = "Transparency:";
		sliderLabel.style.fontSize = "13px";
		sliderLabel.style.marginBottom = "8px";
		sliderLabel.style.color = "#333";
		sliderSection.appendChild(sliderLabel);

		// Step 10a) Create styled range slider matching app theme
		var sliderContainer = document.createElement("div");
		sliderContainer.style.display = "flex";
		sliderContainer.style.alignItems = "center";
		sliderContainer.style.gap = "12px";

		var slider = document.createElement("input");
		slider.type = "range";
		slider.min = "0";
		slider.max = "100";
		slider.value = Math.round((currentSurface.transparency || 1.0) * 100);
		slider.style.flex = "1";
		slider.style.height = "6px";
		slider.style.cursor = "pointer";
		slider.style.appearance = "none";
		slider.style.webkitAppearance = "none";
		slider.style.background = "linear-gradient(to right, #ff0000 0%, #ff0000 " + slider.value + "%, #ddd " + slider.value + "%, #ddd 100%)";
		slider.style.borderRadius = "3px";
		slider.style.outline = "none";

		var sliderValue = document.createElement("span");
		sliderValue.textContent = slider.value + "%";
		sliderValue.style.minWidth = "45px";
		sliderValue.style.fontSize = "12px";
		sliderValue.style.color = "#666";
		sliderValue.style.textAlign = "right";

		// Step 10b) Update slider appearance and value on input
		slider.oninput = function () {
			var val = parseInt(slider.value);
			sliderValue.textContent = val + "%";
			slider.style.background = "linear-gradient(to right, #ff0000 0%, #ff0000 " + val + "%, #ddd " + val + "%, #ddd 100%)";
			var newTransparency = val / 100;
			currentSurface.transparency = newTransparency;
			saveSurfaceToDB(currentSurface.id).catch(function (err) {
				console.error("Failed to save surface transparency:", err);
			});
			drawData(allBlastHoles, selectedHole);
		};

		sliderContainer.appendChild(slider);
		sliderContainer.appendChild(sliderValue);
		sliderSection.appendChild(sliderContainer);
		container.appendChild(sliderSection);

		// Step 11) Create gradient select section
		var gradientSection = document.createElement("div");
		gradientSection.style.marginBottom = "12px";

		var gradientLabel = document.createElement("div");
		gradientLabel.textContent = "Color Gradient:";
		gradientLabel.style.fontSize = "13px";
		gradientLabel.style.marginBottom = "8px";
		gradientLabel.style.color = "#333";
		gradientSection.appendChild(gradientLabel);

		var gradientSelect = document.createElement("select");
		gradientSelect.style.width = "100%";
		gradientSelect.style.padding = "8px 12px";
		gradientSelect.style.fontSize = "13px";
		gradientSelect.style.borderRadius = "4px";
		gradientSelect.style.border = "1px solid #ccc";
		gradientSelect.style.backgroundColor = "#fff";
		gradientSelect.style.cursor = "pointer";

		gradientOptions.forEach(function (opt) {
			var option = document.createElement("option");
			option.value = opt.value;
			option.textContent = opt.text;
			if (opt.value === (currentSurface.gradient || "default")) {
				option.selected = true;
			}
			gradientSelect.appendChild(option);
		});

		gradientSelect.onchange = function () {
			currentSurface.gradient = gradientSelect.value;
			saveSurfaceToDB(currentSurface.id).catch(function (err) {
				console.error("Failed to save surface gradient:", err);
			});
			console.log("Updated gradient for surface '" + (currentSurface.name || currentSurface.id) + "' to: " + gradientSelect.value);
			drawData(allBlastHoles, selectedHole);
		};

		gradientSection.appendChild(gradientSelect);
		container.appendChild(gradientSection);

		// Step 12) Create legend checkbox section
		var legendSection = document.createElement("div");
		legendSection.style.display = "flex";
		legendSection.style.alignItems = "center";
		legendSection.style.gap = "8px";

		var legendCheckbox = document.createElement("input");
		legendCheckbox.type = "checkbox";
		legendCheckbox.checked = showSurfaceLegend;
		legendCheckbox.style.width = "16px";
		legendCheckbox.style.height = "16px";
		legendCheckbox.style.cursor = "pointer";

		var legendLabel = document.createElement("label");
		legendLabel.textContent = "Show Legend";
		legendLabel.style.fontSize = "13px";
		legendLabel.style.color = "#333";
		legendLabel.style.cursor = "pointer";
		legendLabel.onclick = function () {
			legendCheckbox.click();
		};

		legendCheckbox.onchange = function () {
			showSurfaceLegend = legendCheckbox.checked;
			drawData(allBlastHoles, selectedHole);
		};

		legendSection.appendChild(legendCheckbox);
		legendSection.appendChild(legendLabel);
		container.appendChild(legendSection);

		return container;
	};

	// Step 13) Create and show the FloatingDialog
	dialogInstance = new FloatingDialog({
		title: currentSurface.name || "Surface Properties",
		content: contentBuilder,
		width: 340,
		height: 420,
		showConfirm: false,
		showCancel: false,
		draggable: true,
		resizable: false,
		closeOnOutsideClick: true,
		layoutType: "compact",
	});

	dialogInstance.show();

	// Step 14) Position dialog near click location (adjusted for viewport bounds)
	if (dialogInstance.element) {
		var dialogWidth = 340;
		var dialogHeight = 420;
		var posX = Math.min(x, window.innerWidth - dialogWidth - 20);
		var posY = Math.min(y, window.innerHeight - dialogHeight - 20);
		posX = Math.max(10, posX);
		posY = Math.max(10, posY);
		dialogInstance.element.style.left = posX + "px";
		dialogInstance.element.style.top = posY + "px";
	}
}
*/
// END OF MOVED FUNCTION - showSurfaceContextMenu now loaded from SurfacesContextMenu.js

// Add this helper function near your other menu functions
function safeRemoveMenu(menu) {
	try {
		if (menu && document.body.contains(menu)) {
			document.body.removeChild(menu);
		}
	} catch (error) {
		// Menu already removed or not found - ignore
		console.log("Menu already removed");
	}
}

// Update the polygon tool event listener to properly handle conflicts
selectByPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		// Step 1) Check if in 3D mode - use 3D polygon selection
		if (onlyShowThreeJS) {
			console.log("üî∂ Enabling 3D polygon selection mode");

			// Step 1a.1) Reset other tool buttons (mutual exclusion)
			// Fixes QUIRK 3: SelectPointer and SelectPolygon should turn each other off
			resetFloatingToolbarButtons("selectByPolygonTool");

			// Step 1a.2) Explicitly disable Select Pointer tool
			isSelectionPointerActive = false;
			selectPointerTool.checked = false;

			// Step 1b) Initialize 3D polygon selection if needed
			if (!window.polygonSelection3D) {
				window.polygonSelection3D = new PolygonSelection3D(threeRenderer);
			}

			// Step 1c) Enable 3D polygon selection
			window.polygonSelection3D.enable();

			// Step 1d) Update status message
			updateStatusMessage("3D Polygon selection mode enabled\nClick to add vertices.\nDouble-click to complete selection.");

			return;
		}

		// Step 2) 2D polygon selection mode (EXISTING CODE)
		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectByPolygonTool");
		endKadTools();
		clearAllSelectionState();
		isPolygonSelectionActive = true;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		isDraggingHole = false;

		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectByPolygonTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Add polygon selection listeners
		canvas.addEventListener("click", selectInsidePolygon);
		canvas.addEventListener("dblclick", completePolygonSelection);
		canvas.addEventListener("touchstart", selectInsidePolygonTouch);
		canvas.addEventListener("mousemove", handlePolygonMouseMove);

		// Clear any existing selection
		polyPointsX = [];
		polyPointsY = [];
		selectedMultipleHoles = [];
		updateStatusMessage("Polygon selection mode enabled\nClick to encircle holes.\nDouble-click to complete selection.");
	} else {
		// Step 3) Disable polygon selection
		if (onlyShowThreeJS && window.polygonSelection3D) {
			// Disable 3D polygon selection
			window.polygonSelection3D.disable();
			updateStatusMessage("");
		} else {
			// Disable 2D polygon selection (EXISTING CODE)
			isPolygonSelectionActive = false;

			// Remove polygon listeners
			canvas.removeEventListener("click", selectInsidePolygon);
			canvas.removeEventListener("dblclick", completePolygonSelection);
			canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
			canvas.removeEventListener("mousemove", handlePolygonMouseMove);

			// Clear polygon points
			polyPointsX = [];
			polyPointsY = [];
			drawData(allBlastHoles, selectedHole);
			updateStatusMessage("");
		}
	}
});

function selectInsidePolygon(event) {
	if (!isPolygonSelectionActive) return;

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Remove right-click completion - now handled by double-click

	// Left click - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Improved point-in-polygon test
//! NOW USES THE UNIFIED ISPOINTINPOLYGON FUNCTION
function isPointInPolygon(x, y, polyX, polyY) {
	let inside = false;
	const nvert = polyX.length;

	for (let i = 0, j = nvert - 1; i < nvert; j = i++) {
		// Convert polygon coordinates to match hole coordinates
		if (polyY[i] > y != polyY[j] > y && x < ((polyX[j] - polyX[i]) * (y - polyY[i])) / (polyY[j] - polyY[i]) + polyX[i]) {
			inside = !inside;
		}
	}

	return inside;
}

// Create a new touch handler for polygon selection
function selectInsidePolygonTouch(event) {
	if (!isPolygonSelectionActive) return;

	event.preventDefault(); // Prevent default touch behavior

	const rect = canvas.getBoundingClientRect();
	const touch = event.touches[0] || event.changedTouches[0];
	const clickX = touch.clientX - rect.left;
	const clickY = touch.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Two finger tap to finish polygon and select holes
	if (event.touches.length >= 2) {
		if (polyPointsX.length >= 3) {
			// Clear existing selection
			selectedMultipleHoles = [];

			// Check ALL holes against the polygon
			allBlastHoles.forEach((hole) => {
				if (!hole) return;

				// Get hole coordinates
				const holeX = hole.startXLocation;
				const holeY = hole.startYLocation;

				// console.log("Checking hole:", point.holeID, "at:", holeX, holeY, "against polygon with points:", polyPointsX.length);

				if (isPointInPolygon(holeX, holeY, polyPointsX, polyPointsY)) {
					selectedMultipleHoles.push(hole);
					// console.log("Selected hole:", hole.holeID);
				}
			});

			// Update averages and sliders after selection
			if (selectedMultipleHoles.length > 0) {
				updateSelectionAveragesAndSliders(selectedMultipleHoles);
			}

			console.log("Total holes selected:", selectedMultipleHoles.length);
		}

		// Clear the polygon after selection
		polyPointsX = [];
		polyPointsY = [];
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Single finger tap - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Add mouse move handler for live polygon preview
function handlePolygonMouseMove(event) {
	if (!isPolygonSelectionActive || polyPointsX.length === 0) return;

	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Convert mouse coordinates to world coordinates
	const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

	// Update the last point (moving point)
	if (polyPointsX.length > 0) {
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
		drawData(allBlastHoles, selectedHole);
	}
}

//use the same function for the resetView in the resetViewTool
resetViewTool.addEventListener("change", function () {
	if (this.checked) {
		resetZoom();
		drawData(allBlastHoles, selectedHole);
		resetViewTool.checked = false;
	}
});

// #region CUSTOM CSV
//---------------- CUSTOM STRUCTURED CSV IMPORTER - FLOATING DIALOG ONLY ----------------//
fileInputCustomCSV.addEventListener("change", function () {
	const file = this.files[0];
	if (file && file.name.toLowerCase().endsWith(".csv")) {
		Papa.parse(file, {
			skipEmptyLines: true,
			complete: (results) => showCsvImportModal(results.data, file.name),
			error: (error) => {
				const errorDialog = new FloatingDialog({
					title: "Error",
					content: "Could not parse the CSV file: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false,
				});
				errorDialog.show();
			},
		});
	} else if (file) {
		const warningDialog = new FloatingDialog({
			title: "Invalid File",
			content: "Please select a valid .csv file.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false,
		});
		warningDialog.show();
		this.value = "";
	}
});

// ===================================================================
// FIELD MAPPING STRUCTURE
// ===================================================================

const HOLE_FIELD_MAPPING = {
	entityName: {
		property: "entityName",
		type: "string",
		default: "Imported_Blast",
		required: false,
		validation: function (value) {
			return true;
		},
	},
	holeID: {
		property: "holeID",
		type: "string",
		required: true,
		validation: function (value) {
			return value && value.trim().length > 0;
		},
	},
	startXLocation: {
		property: "startXLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	startYLocation: {
		property: "startYLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	startZLocation: {
		property: "startZLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	endXLocation: {
		property: "endXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	endYLocation: {
		property: "endYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	endZLocation: {
		property: "endZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeXLocation: {
		property: "gradeXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeYLocation: {
		property: "gradeYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeZLocation: {
		property: "gradeZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	holeDiameter: {
		property: "holeDiameter",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	holeAngle: {
		property: "holeAngle",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= -90 && parseFloat(value) <= 90);
		},
	},
	holeBearing: {
		property: "holeBearing",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0 && parseFloat(value) < 360);
		},
	},
	holeLengthCalculated: {
		property: "holeLengthCalculated",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	subdrillAmount: {
		property: "subdrillAmount",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	benchHeight: {
		property: "benchHeight",
		type: "number",
		default: 10,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	holeType: {
		property: "holeType",
		type: "string",
		default: "Production",
		validation: function (value) {
			return true;
		},
	},
	rowID: {
		property: "rowID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		},
	},
	posID: {
		property: "posID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		},
	},
	fromHoleID: {
		property: "fromHoleID",
		type: "string",
		default: null,
		validation: function (value) {
			return true;
		},
	},
	timingDelayMilliseconds: {
		property: "timingDelayMilliseconds",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	initiationTime: {
		property: "initiationTime",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	colorHexDecimal: {
		property: "colorHexDecimal",
		type: "string",
		default: "red",
		validation: function (value) {
			return true;
		},
	},
	measuredLength: {
		property: "measuredLength",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	measuredMass: {
		property: "measuredMass",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	measuredComment: {
		property: "measuredComment",
		type: "string",
		default: "None",
		validation: function (value) {
			return true;
		},
	},
};

/**
 * Enhanced updateHoleFromCsvData function that properly calculates geometry
 */
function updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit) {
	// Update basic properties first
	Object.keys(HOLE_FIELD_MAPPING).forEach(function (fieldName) {
		const mapping = HOLE_FIELD_MAPPING[fieldName];
		const rawValue = getValue(fieldName);

		// Skip if no value provided and not required
		if ((rawValue === undefined || rawValue === null || rawValue === "") && !mapping.required) {
			if (hole[mapping.property] === undefined && mapping.default !== null) {
				hole[mapping.property] = mapping.default;
			}
			return;
		}

		// Validate the value
		if (!mapping.validation(rawValue)) {
			console.warn("Invalid value for field " + fieldName + ": " + rawValue);
			if (mapping.required) {
				throw new Error("Invalid value for required field " + fieldName + ": " + rawValue);
			}
			return;
		}

		// Convert and assign the value
		let convertedValue;
		switch (mapping.type) {
			case "number":
				convertedValue = parseFloat(rawValue);
				// Handle diameter units
				if (fieldName === "holeDiameter" && !isNaN(convertedValue)) {
					switch (diameterUnit) {
						case "m":
							convertedValue = convertedValue * 1000;
							break;
						case "in":
							convertedValue = convertedValue * 25.4;
							break;
					}
				}
				// Handle angle convention
				if (fieldName === "holeAngle" && !isNaN(convertedValue)) {
					if (angleConvention === "dip") {
						convertedValue = 90 - convertedValue;
					}
				}
				break;
			case "integer":
				convertedValue = parseInt(rawValue);
				break;
			default:
				convertedValue = String(rawValue).trim();
				break;
		}

		hole[mapping.property] = convertedValue;
	});

	// Ensure all required properties exist
	setHoleDefaults(hole);

	// Step 3) Set timingDelayMilliseconds to initiationTime
	// This ensures imported holes use initiation time as their delay
	if (hole.initiationTime !== undefined && !isNaN(hole.initiationTime)) {
		hole.timingDelayMilliseconds = hole.initiationTime;
	}

	// Calculate missing geometry - this is the key fix
	calculateMissingGeometry(hole);
}

// function calculateMissingGeometry(hole) {
//     const hasEndCoords = hole.endXLocation !== hole.startXLocation || hole.endYLocation !== hole.startYLocation || hole.endZLocation !== hole.startZLocation;

//     if (hasEndCoords && (hole.holeAngle === 0 || hole.holeBearing === 0 || hole.holeLengthCalculated === 0)) {
//         // Calculate from end coordinates - FIXED CALCULATIONS
//         const dx = hole.endXLocation - hole.startXLocation;
//         const dy = hole.endYLocation - hole.startYLocation;
//         const dz = hole.endZLocation - hole.startZLocation; // Note: should be negative for downward holes

//         const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

//         if (length > 0) {
//             hole.holeLengthCalculated = length;

//             // FIXED: Proper bearing calculation
//             // 0? = North, 90? = East, 180? = South, 270? = West
//             let bearing = Math.atan2(dx, dy) * (180 / Math.PI);
//             if (bearing < 0) bearing += 360;
//             hole.holeBearing = bearing;

//             // FIXED: Proper angle calculation
//             // 0? = vertical down, 90? = horizontal
//             const horizontalDistance = Math.sqrt(dx * dx + dy * dy);
//             if (horizontalDistance > 0) {
//                 hole.holeAngle = Math.atan2(horizontalDistance, Math.abs(dz)) * (180 / Math.PI);
//             } else {
//                 hole.holeAngle = 0; // Vertical
//             }
//         }
//     } else if (!hasEndCoords || hole.holeLengthCalculated === 0) {
//         // Calculate from angle/bearing/length or set defaults
//         if (hole.holeLengthCalculated === 0) {
//             const benchHeight = hole.benchHeight || 10;
//             const subdrillAmount = hole.subdrillAmount || 1;
//             hole.holeLengthCalculated = benchHeight + subdrillAmount;
//         }

//         // FIXED: Proper coordinate calculation from angle and bearing
//         calculateHoleEndCoordinates(hole);
//     }
// }
// GEOMETRY CONFLICT RESOLUTION - Priority-based calculation
// Priority 1: CollarXYZ + ToeXYZ (coordinates take precedence - IGNORE L/A/B if provided)
// Priority 2: CollarXYZ + L/A/B + Subdrill (forward calculation)
// Priority 3: ToeXYZ + L/A/B + Subdrill (REVERSE calculation - back-calculate CollarXYZ)
// Priority 4: CollarXYZ + ToeXYZ (no subdrill - calculate L/A/B, estimate subdrill)
// Priority 5: CollarXYZ only (use defaults)
function calculateMissingGeometry(hole) {
	// Step 1) Determine what data we have
	var hasCollarXYZ = isValidCoordinate(hole.startXLocation) &&
		isValidCoordinate(hole.startYLocation) &&
		isValidCoordinate(hole.startZLocation);

	var hasToeXYZ = isValidCoordinate(hole.endXLocation) &&
		isValidCoordinate(hole.endYLocation) &&
		isValidCoordinate(hole.endZLocation) &&
		coordsDifferFromCollar(hole, "end");

	var hasLAB = (hole.holeLengthCalculated > 0) &&
		(hole.holeAngle !== undefined && hole.holeAngle !== null) &&
		(hole.holeBearing !== undefined && hole.holeBearing !== null);

	// Step 1b) Subdrill can be positive, zero, OR negative - all are valid
	var hasSubdrill = hole.subdrillAmount !== undefined &&
		hole.subdrillAmount !== null &&
		!isNaN(hole.subdrillAmount);

	// Step 2) PRIORITY 1: CollarXYZ + ToeXYZ (coordinates take precedence - IGNORE L/A/B)
	if (hasCollarXYZ && hasToeXYZ) {
		console.log("CSV Import: PRIORITY 1 - Using CollarXYZ + ToeXYZ (ignoring L/A/B if provided)");
		calculateFromCollarAndToe(hole, hasSubdrill);
		return;
	}

	// Step 3) PRIORITY 2: CollarXYZ + L/A/B + Subdrill (forward calculation)
	if (hasCollarXYZ && hasLAB && hasSubdrill) {
		console.log("CSV Import: PRIORITY 2 - Using CollarXYZ + L/A/B + Subdrill");
		calculateFromDesignParams(hole);
		return;
	}

	// Step 4) PRIORITY 3: ToeXYZ + L/A/B + Subdrill (REVERSE calculation)
	if (!hasCollarXYZ && hasToeXYZ && hasLAB && hasSubdrill) {
		console.log("CSV Import: PRIORITY 3 - REVERSE CALC - ToeXYZ + L/A/B -> CollarXYZ");
		calculateCollarFromToe(hole);
		return;
	}

	// Step 5) PRIORITY 4: CollarXYZ + L/A/B (no subdrill - calculate with default subdrill)
	if (hasCollarXYZ && hasLAB && !hasSubdrill) {
		console.log("CSV Import: PRIORITY 4 - Using CollarXYZ + L/A/B (default subdrill)");
		hole.subdrillAmount = 1; // Default subdrill
		calculateFromDesignParams(hole);
		return;
	}

	// Step 6) PRIORITY 5: CollarXYZ only (use defaults)
	if (hasCollarXYZ) {
		console.log("CSV Import: PRIORITY 5 - Using CollarXYZ only (applying defaults)");
		applyDefaultGeometry(hole);
		calculateFromDesignParams(hole);
		return;
	}

	// Step 7) No valid data - cannot calculate
	console.warn("CSV Import: No valid geometry data found for hole " + hole.holeID);
}

// Step 8) Helper: Check if coordinate is valid (not NaN, not undefined)
function isValidCoordinate(value) {
	return value !== undefined && value !== null && !isNaN(value);
}

// Step 9) Helper: Check if end/grade coordinates differ from collar
function coordsDifferFromCollar(hole, type) {
	if (type === "end") {
		return (hole.endXLocation !== hole.startXLocation ||
			hole.endYLocation !== hole.startYLocation ||
			hole.endZLocation !== hole.startZLocation);
	}
	return false;
}

// Step 10) Calculate Length, Angle, Bearing from CollarXYZ and ToeXYZ
function calculateFromCollarAndToe(hole, hasSubdrill) {
	var dx = hole.endXLocation - hole.startXLocation;
	var dy = hole.endYLocation - hole.startYLocation;
	var dz = hole.startZLocation - hole.endZLocation; // Positive = down

	// Step 10a) Calculate Length
	hole.holeLengthCalculated = Math.sqrt(dx * dx + dy * dy + dz * dz);

	if (hole.holeLengthCalculated > 0) {
		// Step 10b) Calculate Bearing: 0=North, 90=East (clockwise)
		var bearing = Math.atan2(dx, dy) * (180 / Math.PI);
		if (bearing < 0) bearing += 360;
		hole.holeBearing = bearing;

		// Step 10c) Calculate Angle: 0=vertical, 90=horizontal
		var horizontalDist = Math.sqrt(dx * dx + dy * dy);
		if (horizontalDist > 0) {
			hole.holeAngle = Math.atan2(horizontalDist, dz) * (180 / Math.PI);
		} else {
			hole.holeAngle = 0; // Vertical hole
		}

		// Step 10d) Calculate GradeXYZ from subdrill
		if (hasSubdrill) {
			// Step 10d-i) Use provided subdrill (respects 0, positive, AND negative values)
			calculateGradeFromSubdrill(hole);
		} else {
			// Step 10d-ii) No subdrill provided - estimate as 10% of length or 1m, whichever is smaller
			hole.subdrillAmount = Math.min(hole.holeLengthCalculated * 0.1, 1);
			calculateGradeFromSubdrill(hole);
		}

		// Step 10e) Calculate BenchHeight
		hole.benchHeight = hole.startZLocation - hole.gradeZLocation;
	}
}

// Step 11) Calculate GradeXYZ from ToeXYZ and Subdrill
function calculateGradeFromSubdrill(hole) {
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);
	var subdrill = hole.subdrillAmount || 0;

	// Step 11a) subdrill is the VERTICAL distance (gradeZ - toeZ)
	// Calculate horizontal displacement using tan(angle)
	var subdrillVertical = subdrill;
	var subdrillHorizontal = subdrill * Math.tan(angleRad);

	hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.sin(bearingRad);
	hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.cos(bearingRad);
	hole.gradeZLocation = hole.endZLocation + subdrillVertical;
}

// Step 12) Calculate ToeXYZ and GradeXYZ from design parameters (CollarXYZ + L/A/B + Subdrill)
function calculateFromDesignParams(hole) {
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);

	// Step 12a) Calculate horizontal and vertical components
	var horizontalDist = hole.holeLengthCalculated * Math.sin(angleRad);
	var verticalDist = hole.holeLengthCalculated * Math.cos(angleRad);

	// Step 12b) Calculate ToeXYZ (end coordinates)
	hole.endXLocation = hole.startXLocation + horizontalDist * Math.sin(bearingRad);
	hole.endYLocation = hole.startYLocation + horizontalDist * Math.cos(bearingRad);
	hole.endZLocation = hole.startZLocation - verticalDist; // Going down

	// Step 12c) Calculate GradeXYZ from subdrill
	calculateGradeFromSubdrill(hole);

	// Step 12d) Calculate BenchHeight
	hole.benchHeight = hole.startZLocation - hole.gradeZLocation;
}

// Step 13) Apply default geometry values
function applyDefaultGeometry(hole) {
	if (!hole.holeLengthCalculated || hole.holeLengthCalculated <= 0) {
		var benchHeight = hole.benchHeight || 10;
		var subdrill = hole.subdrillAmount || 1;
		hole.holeLengthCalculated = benchHeight + subdrill;
	}
	if (hole.holeAngle === undefined || hole.holeAngle === null) {
		hole.holeAngle = 0; // Vertical
	}
	if (hole.holeBearing === undefined || hole.holeBearing === null) {
		hole.holeBearing = 0; // North
	}
	if (hole.subdrillAmount === undefined || hole.subdrillAmount === null) {
		hole.subdrillAmount = 1;
	}
}

// Step 14) REVERSE GEOMETRY: Calculate CollarXYZ from ToeXYZ + Length + Angle + Bearing + Subdrill
// This is used when importing data that only has toe coordinates (end of hole)
function calculateCollarFromToe(hole) {
	var length = hole.holeLengthCalculated;
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);
	var subdrill = hole.subdrillAmount || 0;

	// Step 14a) Calculate horizontal and vertical components
	var horizontalDist = length * Math.sin(angleRad);
	var verticalDist = length * Math.cos(angleRad);

	// Step 14b) Back-calculate CollarXYZ from ToeXYZ (reverse direction)
	// Toe is at the END (endXYZ), Collar is at the START (startXYZ)
	// Collar = Toe - (direction vector)
	// Direction is: start -> end = (horizontal * sin(bearing), horizontal * cos(bearing), -vertical)
	// So reverse: Collar = Toe - direction = Toe - (horizontal * sin(bearing), horizontal * cos(bearing), -vertical)
	hole.startXLocation = hole.endXLocation - horizontalDist * Math.sin(bearingRad);
	hole.startYLocation = hole.endYLocation - horizontalDist * Math.cos(bearingRad);
	hole.startZLocation = hole.endZLocation + verticalDist; // Up from toe (add because going up)

	// Step 14c) Calculate GradeXYZ (subdrill amount above toe along hole direction)
	// subdrill is the VERTICAL distance (gradeZ - toeZ)
	var subdrillVertical = subdrill;
	var subdrillHorizontal = subdrill * Math.tan(angleRad);

	hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.sin(bearingRad);
	hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.cos(bearingRad);
	hole.gradeZLocation = hole.endZLocation + subdrillVertical;

	// Step 14d) Calculate BenchHeight = CollarZ - GradeZ
	hole.benchHeight = hole.startZLocation - hole.gradeZLocation;

	console.log("Reverse geometry calculated: CollarZ=" + hole.startZLocation.toFixed(2) +
		", GradeZ=" + hole.gradeZLocation.toFixed(2) +
		", ToeZ=" + hole.endZLocation.toFixed(2) +
		", BenchHeight=" + hole.benchHeight.toFixed(2));
}

function calculateHoleEndCoordinates(hole) {
	const angleRad = hole.holeAngle * (Math.PI / 180);
	const bearingRad = hole.holeBearing * (Math.PI / 180);

	// FIXED: Proper bearing to direction calculation
	// Bearing: 0? = North (positive Y), 90? = East (positive X)
	const horizontalDistance = hole.holeLengthCalculated * Math.sin(angleRad);
	const verticalDistance = hole.holeLengthCalculated * Math.cos(angleRad);

	// Calculate end coordinates
	hole.endXLocation = hole.startXLocation + horizontalDistance * Math.sin(bearingRad);
	hole.endYLocation = hole.startYLocation + horizontalDistance * Math.cos(bearingRad);
	hole.endZLocation = hole.startZLocation - verticalDistance; // Going down

	// Calculate grade coordinates
	// Step 1) Calculate actual bench height: total length minus subdrill
	const subdrillAmount = hole.subdrillAmount || 0;
	const actualBenchHeight = hole.holeLengthCalculated - subdrillAmount;

	// ALTERATION: Fixed grade coordinate calculation to use sin/cos instead of tan
	// This matches the calculation pattern used for end coordinates and ensures consistency
	// Previous code used Math.tan() which was incorrect - grade should use same trig functions as end coordinates
	// Step 2) Calculate grade coordinates at the actual bench height
	const gradeAngleRad = hole.holeAngle * (Math.PI / 180);
	const gradeHorizontalDistance = actualBenchHeight * Math.sin(gradeAngleRad);
	const gradeVerticalDistance = actualBenchHeight * Math.cos(gradeAngleRad);

	hole.gradeXLocation = hole.startXLocation + gradeHorizontalDistance * Math.sin(bearingRad);
	hole.gradeYLocation = hole.startYLocation + gradeHorizontalDistance * Math.cos(bearingRad);
	hole.gradeZLocation = hole.startZLocation - gradeVerticalDistance;
}

/**
 * Set default properties and ensure all required fields are populated
 */
function setHoleDefaults(hole) {
	hole.entityType = "hole";
	if (hole.visible === undefined) hole.visible = true;
	if (!hole.fromHoleID || hole.fromHoleID === null) {
		hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
	}
	if (!hole.measuredLengthTimeStamp) hole.measuredLengthTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredMassTimeStamp) hole.measuredMassTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredCommentTimeStamp) hole.measuredCommentTimeStamp = "09/05/1975 00:00:00";

	// Ensure numeric properties are valid
	const numericProps = ["startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeLengthCalculated", "holeAngle", "holeBearing", "holeDiameter", "subdrillAmount", "benchHeight", "timingDelayMilliseconds", "initiationTime", "measuredLength", "measuredMass"];

	numericProps.forEach(function (prop) {
		if (isNaN(hole[prop])) {
			switch (prop) {
				case "startXLocation":
				case "startYLocation":
				case "startZLocation":
					throw new Error("Invalid coordinates for hole " + hole.holeID);
				case "endXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "endYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "endZLocation":
					hole[prop] = hole.startZLocation;
					break;
				case "gradeXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "gradeYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "gradeZLocation":
					hole[prop] = hole.startZLocation - 10;
					break;
				case "holeLengthCalculated":
					hole[prop] = 10;
					break;
				case "benchHeight":
					hole[prop] = 10;
					break;
				default:
					hole[prop] = 0;
					break;
			}
		}
	});
}

/**
 * Main CSV processing function
 */
function processCsvData(data, columnOrder, fileName) {
	const entityName = fileName.split(".")[0] || "Imported_Blast_" + Math.floor(Math.random() * 16777215).toString(16);
	const headerRows = parseInt(columnOrder.headerRows, 10) || 0;
	const angleConvention = columnOrder.angle_convention || "angle";
	const diameterUnit = columnOrder.diameter_unit || "mm";
	const duplicateHandling = columnOrder.duplicate_handling || "update-blast-hole";

	const addedHoles = [];
	const updatedHoles = [];

	// Process each data row
	data.slice(headerRows).forEach(function (row, index) {
		const getValue = function (colName) {
			const colIndex = columnOrder[colName];
			if (colIndex !== undefined && colIndex !== null && colIndex !== "" && colIndex !== "0") {
				const val = row[parseInt(colIndex, 10) - 1];
				return val !== undefined && val !== null ? String(val).trim() : undefined;
			}
			return undefined;
		};

		// Validate mandatory fields
		const holeID = getValue("holeID");
		const startX = parseFloat(getValue("startXLocation"));
		const startY = parseFloat(getValue("startYLocation"));
		const startZ = parseFloat(getValue("startZLocation"));

		if (!holeID || isNaN(startX) || isNaN(startY) || isNaN(startZ)) {
			console.warn("Skipping row " + (index + headerRows + 1) + ": Missing mandatory fields");
			return;
		}

		const holeEntityName = getValue("entityName") || entityName;
		let rowID = getValue("rowID");
		let posID = getValue("posID");

		//Add all the undeclared values.
		let burden = getValue("burden");
		let spacing = getValue("spacing");
		let connectorCurve = getValue("connectorCurve");
		let measuredLength = getValue("measuredLength");
		let measuredMass = getValue("measuredMass");
		let measuredComment = getValue("measuredComment");
		let measuredLengthTimeStamp = getValue("measuredLengthTimeStamp");
		let measuredMassTimeStamp = getValue("measuredMassTimeStamp");
		let measuredCommentTimeStamp = getValue("measuredCommentTimeStamp");
		let colorHexDecimal = getValue("colorHexDecimal");
		let initiationTime = getValue("initiationTime");
		let timingDelayMilliseconds = getValue("timingDelayMilliseconds");
		let fromHoleID = getValue("fromHoleID");
		let holeType = getValue("holeType");
		let holeLengthCalculated = getValue("holeLengthCalculated");
		let holeAngle = getValue("holeAngle");
		let holeBearing = getValue("holeBearing");
		let holeDiameter = getValue("holeDiameter");
		let subdrillAmount = getValue("subdrillAmount");
		let subdrillLength = getValue("subdrillLength");
		let benchHeight = getValue("benchHeight");

		if (rowID && !isNaN(rowID)) rowID = parseInt(rowID);
		else rowID = null;
		if (posID && !isNaN(posID)) posID = parseInt(posID);
		else posID = null;

		// Check for duplicates
		let existingHoleIndex = -1;
		let isUpdate = false;
		let hole = null;

		if (duplicateHandling === "update-blast-hole") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return h.entityName === holeEntityName && h.holeID === holeID;
			});
		} else if (duplicateHandling === "update-location") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return Math.abs(h.startXLocation - startX) <= 0.01 && Math.abs(h.startYLocation - startY) <= 0.01;
			});
		}

		if (existingHoleIndex !== -1 && duplicateHandling !== "skip") {
			hole = allBlastHoles[existingHoleIndex];
			isUpdate = true;
		} else if (existingHoleIndex !== -1 && duplicateHandling === "skip") {
			return;
		} else {
			// Create new hole
			hole = {
				entityName: holeEntityName,
				entityType: "hole",
				holeID: holeID,
				startXLocation: startX,
				startYLocation: startY,
				startZLocation: startZ,
				endXLocation: startX,
				endYLocation: startY,
				endZLocation: startZ,
				gradeXLocation: startX,
				gradeYLocation: startY,
				gradeZLocation: startZ - 10,
				subdrillAmount: subdrillAmount || 0,
				subdrillLength: subdrillLength || 0,
				benchHeight: benchHeight || 10,
				holeDiameter: holeDiameter || 0,
				holeType: holeType || "Production",
				fromHoleID: fromHoleID || holeEntityName + ":::" + holeID,
				timingDelayMilliseconds: timingDelayMilliseconds || 0,
				colorHexDecimal: colorHexDecimal || "red",
				holeLengthCalculated: holeLengthCalculated || 0,
				holeAngle: holeAngle || 0,
				holeBearing: holeBearing || 0,
				initiationTime: initiationTime || 0,
				measuredLength: measuredLength || 0,
				measuredLengthTimeStamp: measuredLengthTimeStamp || "09/05/1975 00:00:00",
				measuredMass: measuredMass || 0,
				measuredMassTimeStamp: measuredMassTimeStamp || "09/05/1975 00:00:00",
				measuredComment: measuredComment || "None",
				measuredCommentTimeStamp: measuredCommentTimeStamp || "09/05/1975 00:00:00",
				visible: true,
				rowID: rowID,
				posID: posID,
				burden: burden || 0,
				spacing: spacing || 0,
				connectorCurve: connectorCurve || 0,
			};
		}

		// Update hole properties
		try {
			updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit);
		} catch (error) {
			console.error("Error updating hole " + holeID + ":", error);
			return;
		}

		// Add to tracking arrays
		if (isUpdate) {
			updatedHoles.push(hole);
		} else {
			allBlastHoles.push(hole);
			addedHoles.push(hole);
		}
	});

	const importedHoles = addedHoles.concat(updatedHoles);
	console.log("CSV Import Results: added=" + addedHoles.length + ", updated=" + updatedHoles.length);

	return importedHoles;
}

/**
 * FloatingDialog CSV Import Modal with Aesthetic Groupings and Two Tables
 */
function showCsvImportModal(csvData, fileName) {
	if (!csvData || csvData.length === 0) {
		const errorDialog = new FloatingDialog({
			title: "Empty File",
			content: "The selected CSV file is empty or could not be read.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false,
		});
		errorDialog.show();
		return;
	}

	const headerRowForPreview = csvData[0];
	const columnOptions = headerRowForPreview
		.map(function (header, index) {
			return '<option value="' + (index + 1) + '">Col ' + (index + 1) + ": " + header + "</option>";
		})
		.join("");
	const ignoreOption = '<option value="0">-- calculate --</option>';

	// Define field groups for aesthetic organization
	const fieldGroups = [
		{
			title: "Hole Identifiers",
			fields: [
				{ name: "entityName", label: "Blast Name", required: false },
				{ name: "holeID", label: "Hole ID*", required: true },
				{ name: "holeType", label: "Hole Type", required: false },
				{ name: "rowID", label: "Row ID", required: false },
				{ name: "posID", label: "Position ID", required: false },
			],
		},
		{
			title: "Hole Location - Collar",
			fields: [
				{ name: "startXLocation", label: "Start X(mE)*", required: true },
				{ name: "startYLocation", label: "Start Y(mN)*", required: true },
				{ name: "startZLocation", label: "Start Z(mRL)*", required: true },
			],
		},
		{
			title: "Hole Location - End/Toe",
			fields: [
				{ name: "endXLocation", label: "End X(mE)", required: false },
				{ name: "endYLocation", label: "End Y(mN)", required: false },
				{ name: "endZLocation", label: "End Z(mRL)", required: false },
			],
		},
		{
			title: "Hole Location - Grade",
			fields: [
				{ name: "gradeXLocation", label: "Grade X(mE)", required: false },
				{ name: "gradeYLocation", label: "Grade Y(mN)", required: false },
				{ name: "gradeZLocation", label: "Grade Z(mRL)", required: false },
			],
		},
		{
			title: "Hole Geometry",
			fields: [
				{ name: "holeAngle", label: "Hole Angle/Dip", required: false },
				{ name: "holeBearing", label: "Hole Bearing", required: false },
				{ name: "holeLengthCalculated", label: "Hole Length", required: false },
				{ name: "benchHeight", label: "Bench Height(m)", required: false },
				{ name: "subdrillAmount", label: "Subdrill(m)", required: false },
				{ name: "holeDiameter", label: "Diameter", required: false },
			],
		},
		{
			title: "Timing & Connections",
			fields: [
				{ name: "fromHoleID", label: "From Hole ID", required: false },
				{
					name: "timingDelayMilliseconds",
					label: "Timing Delay",
					required: false,
				},
				{ name: "colorHexDecimal", label: "Tie Color", required: false },
				{ name: "initiationTime", label: "Initiation Time", required: false },
			],
		},
		{
			title: "Measured Values",
			fields: [
				{ name: "measuredLength", label: "Measured Length", required: false },
				{ name: "measuredMass", label: "Measured Mass", required: false },
				{ name: "measuredComment", label: "Measured Comment", required: false },
			],
		},
	];

	// Create main content container
	const mainContainer = document.createElement("div");
	mainContainer.style.display = "flex";
	mainContainer.style.flexDirection = "column";
	mainContainer.style.height = "100%";

	// Header section with file info and basic settings
	const headerSection = document.createElement("div");
	headerSection.style.padding = "10px";
	headerSection.style.borderBottom = "1px solid var(--light-mode-border)";
	headerSection.className = "button-container-2col";

	headerSection.innerHTML =
		'<label class="labelWhite15"><strong>File:</strong> ' +
		fileName +
		"</label>" +
		"<div></div>" +
		'<label class="labelWhite15"><strong>Rows:</strong> ' +
		csvData.length +
		"</label>" +
		'<label class="labelWhite15"><strong>Columns:</strong> ' +
		csvData[0].length +
		"</label>" +
		'<label class="labelWhite12">Header rows to skip:</label>' +
		'<input type="number" id="csv-header-rows" value="1" min="0" max="10">' +
		'<label class="labelWhite12">Column Detection:</label>' +
		'<select id="csv-column-detection">' +
		'<option value="auto">Auto detect columns</option>' +
		'<option value="last-used">Use last used column order</option>' +
		'<option value="manual">Manual - don\'t detect columns</option>' +
		"</select>" +
		'<label class="labelWhite12">Auto-detect spatial rows:</label>' +
		'<input type="checkbox" id="csv-auto-detect-rows" checked>' +
		'<label class="labelWhite12">Duplicate Handling:</label>' +
		"<div>" +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-blast-hole" checked> Update by Blast+ID</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-location"> Update by location</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="skip"> Skip duplicates</label>' +
		"</div>" +
		'<label class="labelWhite12">Angle Convention:</label>' +
		'<select id="csv-angle-convention">' +
		'<option value="angle">Angle (0? = vertical)</option>' +
		'<option value="dip">Dip (0? = horizontal)</option>' +
		"</select>" +
		'<label class="labelWhite12">Diameter Units:</label>' +
		'<select id="csv-diameter-unit">' +
		'<option value="mm">mm</option>' +
		'<option value="m">m</option>' +
		'<option value="in">inches</option>' +
		"</select>";

	// Content area with three panels: mapping, original data, mapped data
	const contentArea = document.createElement("div");
	contentArea.style.flex = "1";
	contentArea.style.display = "flex";
	contentArea.style.overflow = "hidden";

	// Left panel - Field mapping with groups
	const leftPanel = document.createElement("div");
	leftPanel.style.width = "40%";
	leftPanel.style.padding = "10px";
	leftPanel.style.overflowY = "auto";
	leftPanel.style.borderRight = "1px solid var(--light-mode-border)";

	const mappingTitle = document.createElement("h3");
	mappingTitle.textContent = "Column Mapping";
	mappingTitle.className = "labelWhite15";
	mappingTitle.style.margin = "0 0 10px 0";
	leftPanel.appendChild(mappingTitle);

	// Add field groups to left panel
	fieldGroups.forEach(function (group) {
		const groupDiv = document.createElement("div");
		groupDiv.style.marginBottom = "15px";
		groupDiv.style.border = "1px solid var(--light-mode-border)";
		groupDiv.style.borderRadius = "4px";
		groupDiv.style.padding = "8px";

		const groupTitle = document.createElement("h4");
		groupTitle.textContent = group.title;
		groupTitle.className = "labelWhite12";
		groupTitle.style.margin = "0 0 8px 0";
		groupTitle.style.fontWeight = "bold";
		groupTitle.style.borderBottom = "1px solid var(--light-mode-border)";
		groupTitle.style.paddingBottom = "4px";
		groupDiv.appendChild(groupTitle);

		const fieldsContainer = document.createElement("div");
		fieldsContainer.className = "button-container-2col";

		group.fields.forEach(function (field) {
			const label = document.createElement("label");
			label.textContent = field.label;
			label.className = "labelWhite12";

			const select = document.createElement("select");
			select.id = "csv-col-" + field.name;
			select.name = field.name;

			if (!field.required) {
				select.innerHTML = ignoreOption + columnOptions;
			} else {
				select.innerHTML = columnOptions;
			}

			fieldsContainer.appendChild(label);
			fieldsContainer.appendChild(select);
		});

		groupDiv.appendChild(fieldsContainer);
		leftPanel.appendChild(groupDiv);
	});

	// Right panel - Data previews
	const rightPanel = document.createElement("div");
	rightPanel.style.width = "60%";
	rightPanel.style.padding = "10px";
	rightPanel.style.overflowY = "auto";
	rightPanel.style.display = "flex";
	rightPanel.style.flexDirection = "column";

	// Original data table
	const originalTitle = document.createElement("h4");
	originalTitle.textContent = "Original Data Preview";
	originalTitle.className = "labelWhite12";
	originalTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(originalTitle);

	const originalTableContainer = document.createElement("div");
	originalTableContainer.style.maxHeight = "200px";
	originalTableContainer.style.overflow = "auto";
	originalTableContainer.style.border = "1px solid var(--light-mode-border)";
	originalTableContainer.style.marginBottom = "15px";

	const originalTable = document.createElement("table");
	originalTable.style.width = "100%";
	originalTable.style.borderCollapse = "collapse";
	originalTable.style.fontSize = "10px";

	const originalThead = document.createElement("thead");
	const originalTbody = document.createElement("tbody");
	originalThead.id = "csv-original-headers";
	originalTbody.id = "csv-original-body";

	originalTable.appendChild(originalThead);
	originalTable.appendChild(originalTbody);
	originalTableContainer.appendChild(originalTable);
	rightPanel.appendChild(originalTableContainer);

	// Mapped data table
	const mappedTitle = document.createElement("h4");
	mappedTitle.textContent = "Mapped Data Preview";
	mappedTitle.className = "labelWhite12";
	mappedTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(mappedTitle);

	const mappedTableContainer = document.createElement("div");
	mappedTableContainer.style.maxHeight = "200px";
	mappedTableContainer.style.overflow = "auto";
	mappedTableContainer.style.border = "1px solid var(--light-mode-border)";
	mappedTableContainer.style.marginBottom = "10px";

	const mappedTable = document.createElement("table");
	mappedTable.style.width = "100%";
	mappedTable.style.borderCollapse = "collapse";
	mappedTable.style.fontSize = "10px";

	const mappedThead = document.createElement("thead");
	const mappedTbody = document.createElement("tbody");
	mappedThead.id = "csv-mapped-headers";
	mappedTbody.id = "csv-mapped-body";

	mappedTable.appendChild(mappedThead);
	mappedTable.appendChild(mappedTbody);
	mappedTableContainer.appendChild(mappedTable);
	rightPanel.appendChild(mappedTableContainer);

	// Assemble main container
	mainContainer.appendChild(headerSection);
	contentArea.appendChild(leftPanel);
	contentArea.appendChild(rightPanel);
	mainContainer.appendChild(contentArea);

	// Create the dialog
	const dialog = new FloatingDialog({
		title: "Import CSV: Map Columns",
		content: mainContainer,
		layoutType: "wide",
		width: 1200,
		height: 700,
		showConfirm: true,
		showCancel: true,
		confirmText: "Import",
		cancelText: "Cancel",
		onConfirm: function () {
			try {
				const columnOrder = getColumnOrderFromForm();
				const importedHoles = processCsvData(csvData, columnOrder, fileName);

				if (importedHoles && importedHoles.length > 0) {
					// CRITICAL: Recalculate everything after import like existing code does
					let sumX = 0,
						sumY = 0;
					allBlastHoles.forEach(function (hole) {
						sumX += hole.startXLocation;
						sumY += hole.startYLocation;
					});
					centroidX = sumX / allBlastHoles.length;
					centroidY = sumY / allBlastHoles.length;

					// Step 0a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
					var fullCentroid = calculateDataCentroid();
					emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

					// Step 1) Apply smart row detection to imported holes
					const entitiesForRowDetection = new Map();
					importedHoles.forEach(function (hole) {
						if (!entitiesForRowDetection.has(hole.entityName)) {
							entitiesForRowDetection.set(hole.entityName, []);
						}
						entitiesForRowDetection.get(hole.entityName).push(hole);
					});

					// Step 2) Run smart row detection for each entity
					entitiesForRowDetection.forEach(function (holes, entityName) {
						improvedSmartRowDetection(holes, entityName);
					});

					// Step 3) Auto-assign rowID/posID for holes that still don't have them
					const unassignedHoles = importedHoles.filter(function (hole) {
						return hole.rowID === null || hole.rowID === 0 || hole.posID === null || hole.posID === 0;
					});
					unassignedHoles.forEach(function (hole) {
						if (!hole.rowID || hole.rowID === 0) {
							hole.rowID = getNextRowID(hole.entityName);
						}
						if (!hole.posID || hole.posID === 0) {
							hole.posID = 1;
						}
					});

					// Recalculate dependent data structures - ESSENTIAL for proper display
					if (allBlastHoles.length > 0) {
						const triangleResult = delaunayTriangles(allBlastHoles, maxEdgeLength);
						holeTimes = calculateTimes(allBlastHoles);

						// Recalculate contours
						const contourResult = recalculateContours(allBlastHoles, deltaX, deltaY);
						contourLinesArray = contourResult.contourLinesArray;
						directionArrows = contourResult.directionArrows;
					}

					// Update displays
					timeChart();
					drawData(allBlastHoles, null);

					// Update tree view if available
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}

					const successDialog = new FloatingDialog({
						title: "Successful Import",
						content: "Imported " + importedHoles.length + " holes successfully.",
						layoutType: "default",
						width: 300,
						height: 120,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false,
					});
					successDialog.show();
				} else {
					const errorDialog = new FloatingDialog({
						title: "Failed Import",
						content: "No valid holes could be imported. Please check your column mapping and file format.",
						layoutType: "default",
						width: 400,
						height: 140,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false,
					});
					errorDialog.show();
				}
			} catch (error) {
				console.error("Import error:", error);
				const errorDialog = new FloatingDialog({
					title: "Import Error",
					content: "An error occurred during import: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false,
				});
				errorDialog.show();
			}

			// Step 4) Save imported holes to IndexedDB
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}

			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		},
		onCancel: function () {
			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		},
	});

	// Show the dialog
	dialog.show();

	// Set up event listeners and auto-detection after dialog is shown
	setupCsvDialogEventListeners(csvData, fieldGroups);
}

// Helper function to set up event listeners
function setupCsvDialogEventListeners(csvData, fieldGroups) {
	// Get saved column order from localStorage
	let savedColumnOrder = {};
	try {
		savedColumnOrder = JSON.parse(localStorage.getItem("csvColumnOrder") || "{}");
	} catch (e) {
		console.warn("Error parsing saved column order:", e);
		savedColumnOrder = {};
	}

	// Auto-mapping keywords
	const mappingKeywords = {
		entityName: ["blast", "pattern", "blast name", "pattern name", "blastid"],
		holeID: ["id", "holeid", "holeno", "name", "holename", "pointid", "no", "hole id"],
		startXLocation: ["x", "cx", "easting", "collar x", "startx", "start easting", "start east", "start x"],
		startYLocation: ["y", "cy", "northing", "collar y", "starty", "start northing", "start north", "start y"],
		startZLocation: ["z", "cz", "rl", "collar z", "elevation", "zcoord", "startz", "start elevation", "start z"],
		endXLocation: ["endx", "toex", "end easting", "end east", "tx", "end x", "toe x"],
		endYLocation: ["endy", "toey", "end northing", "end north", "ty", "end y", "toe y"],
		endZLocation: ["endz", "toez", "toerl", "end elevation", "tz", "end z", "toe z"],
		gradeXLocation: ["gradex", "grade easting", "grade east", "gx", "grade x"],
		gradeYLocation: ["gradey", "grade northing", "grade north", "gy", "grade y"],
		gradeZLocation: ["gradez", "grade elevation", "gz", "grade z"],
		holeDiameter: ["diameter", "dia", "diam", "holediameter", "hole diameter"],
		subdrillAmount: ["subdrill", "subdrill amount", "sub drill amount", "sub drill"],
		benchHeight: ["bench", "benchheight", "bench height"],
		holeType: ["type", "holetype", "hole type", "material type", "materialtype"],
		holeLengthCalculated: ["length", "holelength", "hole length"],
		holeBearing: ["bearing", "azimuth", "azi", "bea", "heading", "holebearing", "hole bearing"],
		holeAngle: ["angle", "dip", "mast angle", "holeangle", "hole angle"],
		rowID: ["rowid", "row id", "row", "echelon", "rowno", "row number"],
		posID: ["posid", "pos id", "position", "pos", "position id", "pos number", "posno"],
		initiationTime: ["initiation", "initiationtime", "initiation time", "firing time", "firingtime"],
		fromHoleID: ["from", "fromhole", "from hole", "tie from", "tiefrom"],
		timingDelayMilliseconds: ["delay", "timing", "timingdelay", "timing delay", "ms", "milliseconds"],
		colorHexDecimal: ["color", "colour", "tie color", "tiecolor"],
		measuredLength: ["measured length", "measuredlength", "actual length", "actuallength"],
		measuredMass: ["measured mass", "measuredmass", "actual mass", "actualmass", "kg", "weight"],
		measuredComment: ["comment", "comments", "note", "notes", "measured comment"],
	};

	const headerRow = csvData[0].map(function (h) {
		return String(h || "")
			.toLowerCase()
			.replace(/[^a-z0-9]/g, "");
	});

	// Function to update both data previews
	const updateBothPreviews = function () {
		updateOriginalPreview();
		updateMappedPreview();
	};

	// Function to update original data preview
	const updateOriginalPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-original-headers");
		const previewBody = document.getElementById("csv-original-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Add headers
		if (csvData.length > 0) {
			csvData[0].forEach(function (header, index) {
				const th = document.createElement("th");
				th.textContent = "Col " + (index + 1) + ": " + header;
				th.style.padding = "4px 6px";
				th.style.border = "1px solid var(--light-mode-border)";
				th.style.backgroundColor = "rgba(50,50,50,0.3)";
				th.style.fontSize = "10px";
				th.className = "labelWhite12";
				previewHeaders.appendChild(th);
			});
		}

		// Add preview rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			row.forEach(function (cell) {
				const td = document.createElement("td");
				td.textContent = cell || "";
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";
				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});
	};

	// Function to update mapped data preview
	const updateMappedPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-mapped-headers");
		const previewBody = document.getElementById("csv-mapped-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Get current mapping
		const mappedFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				const selectEl = document.getElementById("csv-col-" + field.name);
				if (selectEl && selectEl.value !== "0") {
					mappedFields.push({
						name: field.name,
						label: field.label,
						columnIndex: parseInt(selectEl.value) - 1,
						required: field.required,
					});
				}
			});
		});

		// Add mapped headers
		mappedFields.forEach(function (field) {
			const th = document.createElement("th");
			th.textContent = field.label + (field.required ? " *" : "");
			th.style.padding = "4px 6px";
			th.style.border = "1px solid var(--light-mode-border)";
			th.style.backgroundColor = "rgba(50,50,50,0.3)";
			th.style.fontSize = "10px";
			th.className = "labelWhite12";
			if (field.required) {
				th.style.fontWeight = "bold";
			}
			previewHeaders.appendChild(th);
		});

		// Add mapped data rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			mappedFields.forEach(function (field) {
				const td = document.createElement("td");
				const cellValue = row[field.columnIndex] || "";
				td.textContent = cellValue;
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";

				// Highlight missing required fields
				if (field.required && (!cellValue || cellValue.trim() === "")) {
					td.style.backgroundColor = "rgba(255, 107, 107, 0.3)";
				}

				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});

		// Show message if no fields are mapped
		if (mappedFields.length === 0) {
			const tr = document.createElement("tr");
			const td = document.createElement("td");
			td.colSpan = 1;
			td.textContent = "No fields mapped. Please select columns for the required fields.";
			td.style.textAlign = "center";
			td.style.fontStyle = "italic";
			td.style.padding = "10px";
			td.className = "labelWhite12";
			tr.appendChild(td);
			previewBody.appendChild(tr);
		}
	};

	// Function to apply auto-detection
	const applyAutoDetection = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			const keywords = mappingKeywords[field.name] || [];
			const colIndex = headerRow.findIndex(function (header) {
				return keywords.some(function (kw) {
					return header.includes(kw);
				});
			});

			if (colIndex !== -1) {
				selectEl.value = (colIndex + 1).toString();
			} else {
				selectEl.value = "0";
			}
		});

		updateMappedPreview();
	};

	// Function to apply last used settings
	const applyLastUsed = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			if (savedColumnOrder[field.name]) {
				selectEl.value = savedColumnOrder[field.name];
			}
		});

		// Apply saved settings for other fields
		if (savedColumnOrder.angle_convention) {
			const angleEl = document.getElementById("csv-angle-convention");
			if (angleEl) angleEl.value = savedColumnOrder.angle_convention;
		}

		if (savedColumnOrder.diameter_unit) {
			const diameterEl = document.getElementById("csv-diameter-unit");
			if (diameterEl) diameterEl.value = savedColumnOrder.diameter_unit;
		}

		updateMappedPreview();
	};

	// Set up column detection dropdown listener
	const columnDetectionSelect = document.getElementById("csv-column-detection");
	if (columnDetectionSelect) {
		columnDetectionSelect.addEventListener("change", function (e) {
			if (e.target.value === "auto") {
				applyAutoDetection();
			} else if (e.target.value === "last-used") {
				applyLastUsed();
			}
			// For "manual", do nothing - let user set manually
		});
	}

	// Set up header rows input listener
	const headerRowsEl = document.getElementById("csv-header-rows");
	if (headerRowsEl) {
		headerRowsEl.addEventListener("input", updateBothPreviews);
	}

	// Set up listeners for all select dropdowns to update mapped preview
	fieldGroups.forEach(function (group) {
		group.fields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (selectEl) {
				selectEl.addEventListener("change", updateMappedPreview);
			}
		});
	});

	// Initialize both previews and apply initial detection
	updateBothPreviews();
	applyAutoDetection();
}

// Helper function to get column order from form
function getColumnOrderFromForm() {
	const headerRowsEl = document.getElementById("csv-header-rows");
	const angleConventionEl = document.getElementById("csv-angle-convention");
	const diameterUnitEl = document.getElementById("csv-diameter-unit");
	const autoDetectRowsEl = document.getElementById("csv-auto-detect-rows");

	const order = {
		headerRows: headerRowsEl ? headerRowsEl.value : "1",
		angle_convention: angleConventionEl ? angleConventionEl.value : "angle",
		diameter_unit: diameterUnitEl ? diameterUnitEl.value : "mm",
		auto_detect_rows: autoDetectRowsEl ? autoDetectRowsEl.checked : true,
	};

	// Get duplicate handling option
	const duplicateHandling = document.querySelector('input[name="csv-duplicate-handling"]:checked');
	order.duplicate_handling = duplicateHandling ? duplicateHandling.value : "update-blast-hole";

	// Get all field mappings
	const allFieldNames = ["entityName", "holeID", "startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeDiameter", "subdrillAmount", "benchHeight", "holeType", "holeLengthCalculated", "holeBearing", "holeAngle", "rowID", "posID", "initiationTime", "fromHoleID", "timingDelayMilliseconds", "colorHexDecimal", "measuredLength", "measuredMass", "measuredComment"];

	allFieldNames.forEach(function (fieldName) {
		const selectEl = document.getElementById("csv-col-" + fieldName);
		order[fieldName] = selectEl ? selectEl.value : "0";
	});

	// Save the column order to localStorage for future use
	try {
		localStorage.setItem("csvColumnOrder", JSON.stringify(order));
	} catch (e) {
		console.warn("Error saving column order to localStorage:", e);
	}

	return order;
}

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// ===================================================================
// CONSOLIDATED SMART ROW DETECTION FUNCTIONS
// ===================================================================
// #region HDBSCAN-ROW-DETECTION

/**
 * SEQUENCE-BASED ROW DETECTION
 *
 * This function attempts to detect rows based on the naming/numbering pattern of hole IDs.
 * It analyzes the hole ID patterns and determines the best approach for grouping holes into rows.
 *
 * HOLE ID PATTERN ANALYSIS:
 * - Pure numeric (1, 2, 3, 4...) - Sequential numbered holes
 * - Alphanumeric (A1, A2, B1, B2...) - Letter+number combinations
 * - Mixed patterns - Combination of both
 * - Other patterns - Random text, symbols, etc.
 *
 * @param {Array} holesData - Array of hole objects with holeID properties
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection occurred, false if should fall back to spatial detection
 *
 * DETECTION CASES:
 * 1. All alphanumeric: Analyzes if letters represent rows (A1,A2,B1,B2) or types (I1,I2,B1,B2)
 * 2. Mixed numeric/alphanumeric: Sorts and applies spatial detection algorithms
 * 3. Pure numeric sequential: Applies geometric line-fitting or RDP algorithms
 */
function trySequenceBasedDetection(holesData, entityName) {
	// Initialize counters for different hole ID patterns
	let numericCount = 0; // Pure numbers: "1", "2", "123"
	let alphaNumericCount = 0; // Letter+number: "A1", "BUF5", "I23"
	let otherCount = 0; // Everything else: "Hole-A", "X", symbols

	// Analyze each hole ID to determine its pattern type
	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			// Regex matches pure numeric strings
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			// Regex matches one or more letters followed by one or more digits
			alphaNumericCount++;
		} else {
			// Everything that doesn't fit the above patterns
			otherCount++;
		}
	});

	// Log the pattern analysis for debugging
	console.log("Hole ID pattern analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
	});

	// CASE 1: ALL ALPHANUMERIC PATTERNS (A1, A2, B1, B2, etc.)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		// Delegate to specialized function that determines if letters are rows or hole types
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: MIXED NUMERIC AND ALPHANUMERIC PATTERNS
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");

		// Create a unified sequence for spatial detection since numbering is inconsistent
		// Give each hole a sequential number for geometric analysis
		const allHoles = holesData
			.map((hole, index) => ({ hole, num: index + 1 }))
			.sort((a, b) => {
				// Custom sort: pure numbers first (in numeric order), then alphanumeric (alphabetically)
				const aIsNum = /^\d+$/.test(a.hole.holeID);
				const bIsNum = /^\d+$/.test(b.hole.holeID);

				if (aIsNum && bIsNum) {
					// Both are numeric - sort numerically
					return parseInt(a.hole.holeID) - parseInt(b.hole.holeID);
				}
				if (aIsNum && !bIsNum) return -1; // Numeric comes before alphanumeric
				if (!aIsNum && bIsNum) return 1; // Alphanumeric comes after numeric
				// Both alphanumeric - sort alphabetically
				return a.hole.holeID.localeCompare(b.hole.holeID);
			});

		// Use spatial detection algorithms since sequence-based logic won't work reliably
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}

	// CASE 3: PURE NUMERIC SEQUENTIAL PATTERNS (1, 2, 3, 4...)
	// Convert hole IDs to numbers and sort them
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num)) // Remove any that couldn't be parsed as numbers
		.sort((a, b) => a.num - b.num); // Sort numerically

	// Validate that we have enough holes and all were numeric
	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		// Not all holes were numeric, or too few holes for pattern detection
		return false;
	}

	// Check if the sequence is continuous (1,2,3,4... with no gaps)
	const firstNum = numericHoles[0].num;
	const isSequential = numericHoles.every((item, index) => item.num === firstNum + index);

	if (!isSequential) {
		// Numbers have gaps (like 1,2,4,7...) - not suitable for sequence-based detection
		return false;
	}

	// Choose geometric algorithm based on developer mode setting
	if (developerModeEnabled) {
		console.log("Using OPTION 2: Modified RDP Algorithm");
		return detectRowsUsingRDP(numericHoles, entityName);
	} else {
		console.log("Using OPTION 1: Sequential Line Fitting Algorithm");
		return detectRowsUsingLineFitting(numericHoles, entityName);
	}
}
/**
 * ALPHANUMERIC HOLE PATTERN HANDLER
 *
 * This function specifically handles holes with alphanumeric IDs (like A1, A2, B1, B2, or I1, I2, B1, B2).
 * It must determine whether the letters represent:
 * 1. ROW IDENTIFIERS (A=row1, B=row2, C=row3...) - Common in mining software
 * 2. HOLE TYPE PREFIXES (I=infill, B=buffer, P=production...) - Also common in mining
 *
 * DECISION LOGIC:
 * - If letters are sequential single characters (A,B,C,D...) ? Likely rows
 * - If letters are multi-character codes (INF,BUF,PRD...) ? Likely hole types
 * - If mixed pattern ? Fall back to spatial detection
 *
 * @param {Array} holesData - Array of hole objects with alphanumeric holeIDs
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection, false to fall back to spatial
 *
 * EXAMPLES:
 * Row pattern: A1,A2,A3,B1,B2,B3,C1,C2 ? A=row1, B=row2, C=row3
 * Type pattern: I1,I2,B1,B2,P1,P2 ? Use spatial detection instead
 */
function handleAlphaNumericHoles(holesData, entityName) {
	// Map to group holes by their letter prefix
	const rowGroups = new Map();

	// Array to store parsed hole information
	const parsedHoles = [];

	// Parse each hole ID to extract letter prefix and numeric suffix
	holesData.forEach((hole) => {
		// Regex: ^([A-Z]+)(\d+)$ - captures letter(s) + number(s)
		// Examples: "A1"?["A","1"], "INF23"?["INF","23"], "B5"?["B","5"]
		const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
		if (match) {
			const letter = match[1].toUpperCase(); // Letter prefix (A, B, INF, etc.)
			const number = parseInt(match[2]); // Numeric suffix (1, 2, 23, etc.)

			// Store parsed information for analysis
			parsedHoles.push({
				hole: hole,
				letter: letter,
				number: number,
			});

			// Group holes by their letter prefix
			if (!rowGroups.has(letter)) {
				rowGroups.set(letter, []);
			}
			rowGroups.get(letter).push({
				hole: hole,
				letter: letter,
				number: number,
			});
		}
	});

	// Extract all unique letter prefixes for analysis
	const letterGroups = Array.from(rowGroups.keys());
	console.log("Found letter groups:", letterGroups.join(", "));

	// HEURISTIC ANALYSIS: Determine if letters represent rows or hole types
	//
	// INDICATORS FOR ROW USAGE:
	// 1. Single letters (A, B, C) are more likely rows than multi-letter codes
	// 2. Sequential single letters (A, B, C, D) strongly suggest row naming
	// 3. Consistent pattern across all holes
	//
	// INDICATORS FOR TYPE USAGE:
	// 1. Multi-letter codes (INF, BUF, PRD) suggest hole type abbreviations
	// 2. Non-sequential letters (A, I, B, P) suggest different types
	// 3. Mixed single/multi letter combinations

	const singleLetters = letterGroups.filter((l) => l.length === 1).sort();
	const multiLetters = letterGroups.filter((l) => l.length > 1);

	// Check if single letters form a sequential pattern (A, B, C, D...)
	let isSequentialRows = false;
	if (singleLetters.length >= 2) {
		isSequentialRows = singleLetters.every((letter, index) => {
			if (index === 0) return true; // First letter is always valid
			// Check if each letter is exactly 1 ASCII value higher than previous
			// A=65, B=66, C=67... so B-A=1, C-B=1, etc.
			return letter.charCodeAt(0) - singleLetters[index - 1].charCodeAt(0) === 1;
		});
	}

	// DECISION CRITERIA: Use letters as row identifiers if:
	// 1. All letters are sequential single characters (A,B,C,D...)
	// 2. We have at least 3 different letters (need multiple rows)
	// 3. No multi-letter codes present (pure single-letter pattern)
	const useLettersAsRows = isSequentialRows && singleLetters.length >= 3 && multiLetters.length === 0;

	if (useLettersAsRows) {
		console.log("Letters appear to represent rows (A, B, C pattern)");

		// TREAT LETTERS AS ROW IDENTIFIERS
		// Each letter prefix becomes a separate row, numbered sequentially
		const startingRowID = getNextRowID(entityName);

		singleLetters.forEach((rowLetter, rowIndex) => {
			const row = rowGroups.get(rowLetter);
			// Sort holes within each row by their numeric suffix (A1, A2, A3...)
			row.sort((a, b) => a.number - b.number);

			const rowID = startingRowID + rowIndex;

			// Assign row and position IDs to each hole in this letter group
			row.forEach((item, index) => {
				item.hole.rowID = rowID;
				item.hole.posID = index + 1; // Position within row (1, 2, 3...)
			});

			console.log("Row " + rowLetter + " ‚Üí rowID " + rowID + " with " + row.length + " holes");
		});

		return true; // Successfully used letter-based row detection
	} else {
		console.log("Letters appear to be hole type prefixes (I=infill, B=buffer, etc.)");
		console.log("Falling back to spatial detection for mixed alphanumeric pattern");

		// TREAT LETTERS AS HOLE TYPE PREFIXES
		// Since letters don't represent rows, we need to use spatial detection
		// Convert to format expected by geometric line fitting algorithms
		const allHoles = [];
		let counter = 1;

		// Create a logical ordering for spatial analysis:
		// Sort letter groups alphabetically, then sort holes within each group numerically
		letterGroups.sort().forEach((letter) => {
			const group = rowGroups.get(letter);
			group.sort((a, b) => a.number - b.number); // I1, I2, I3... then B1, B2, B3...
			group.forEach((item) => {
				allHoles.push({
					hole: item.hole,
					num: counter++, // Give sequential numbers for geometric analysis
				});
			});
		});

		// Apply spatial detection algorithms since hole naming doesn't indicate rows
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}
}
/**
 * OPTION 1: SEQUENTIAL LINE FITTING ALGORITHM (Main Geometric Algorithm)
 *
 * This is the primary geometric algorithm for detecting rows in blast patterns.
 * It works by finding the longest sequences of holes that can be fit to straight lines,
 * using a tolerance based on hole diameter.
 *
 * ALGORITHM CONCEPT:
 * 1. For each hole, try to build the longest possible straight line of consecutive holes
 * 2. Use geometric line fitting to ensure holes are truly aligned
 * 3. Tolerance is based on hole diameter (2x diameter distance allowed from line)
 * 4. Process holes in order, marking used holes to avoid duplication
 *
 * STRENGTHS:
 * - Works well for regular drilling patterns
 * - Respects hole sequence (numbered 1,2,3,4...)
 * - Good for straight or slightly curved rows
 *
 * WEAKNESSES:
 * - Can break up rows if there are small alignment irregularities
 * - Requires sequential hole numbering to work optimally
 * - May create too many single-hole rows in irregular patterns
 *
 * @param {Array} numericHoles - Array of {hole, num} objects sorted by hole number
 * @param {string} entityName - Blast entity name for generating row IDs
 * @returns {boolean} - true if detection was successful
 */
function detectRowsUsingLineFitting(numericHoles, entityName) {
	// Need at least 2 holes to form any meaningful pattern
	if (numericHoles.length < 2) return false;

	// Calculate tolerance based on hole diameter
	// Default 115mm diameter if not specified (typical blast hole size)
	const holeDiameter = numericHoles[0].hole.holeDiameter || 115; // mm
	const tolerance = (holeDiameter * 2) / 1000; // Convert to meters (2x diameter)

	console.log("Line fitting tolerance:", tolerance.toFixed(3) + "m (2x diameter)");

	// Arrays to store detected rows and track which holes have been used
	const rows = [];
	const used = new Set(); // Set of hole indices that have been assigned to rows

	// MAIN ALGORITHM: Try to build rows starting from each unused hole
	// Process holes in sequence order (1, 2, 3, 4...) to maintain logical flow
	for (let startIdx = 0; startIdx < numericHoles.length; startIdx++) {
		if (used.has(startIdx)) continue; // Skip holes already assigned to rows

		// Find the longest sequence of consecutive holes that form a straight line
		const row = findLongestLineSequence(numericHoles, startIdx, tolerance, used);

		if (row.length >= 2) {
			// Only accept sequences with at least 2 holes as valid rows
			rows.push(row);

			// Mark all holes in this row as used
			row.forEach((hole) => used.add(numericHoles.indexOf(hole)));

			console.log("Found row with", row.length, "holes:", row.map((h) => h.num).join(","));
		}
	}

	// CLEANUP: Handle single holes that didn't fit into any row
	// These become individual single-hole rows (may indicate outliers or edge holes)
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
			console.log("Single hole row:", numericHoles[i].num);
		}
	}

	// ASSIGNMENT: Give each detected row a unique ID and assign positions within rows
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1; // Position within row (1, 2, 3...)
		});
	});

	console.log("Line fitting detected", rows.length, "rows");
	return rows.length > 0;
}

/**
 * FIND LONGEST LINE SEQUENCE HELPER
 *
 * Starting from a given hole, this function extends forward through consecutive holes
 * to build the longest possible sequence that forms a straight line within tolerance.
 *
 * ALGORITHM:
 * 1. Start with the given hole as the first point in the sequence
 * 2. Try adding each subsequent consecutive hole to the sequence
 * 3. Test if the extended sequence still forms a valid straight line
 * 4. Stop when adding the next hole would break the line constraint
 * 5. Return the longest valid sequence found
 *
 * KEY BEHAVIOR:
 * - Only looks FORWARD in the hole sequence (maintains drilling order)
 * - Stops at first hole that doesn't fit (ensures continuous sequences)
 * - Skips holes already used by previous rows
 *
 * @param {Array} numericHoles - All holes sorted by sequence number
 * @param {number} startIdx - Index of hole to start sequence from
 * @param {number} tolerance - Maximum distance allowed from line (meters)
 * @param {Set} used - Set of hole indices already assigned to other rows
 * @returns {Array} - Longest sequence of holes forming a straight line
 */
function findLongestLineSequence(numericHoles, startIdx, tolerance, used) {
	// Start sequence with the given hole
	const sequence = [numericHoles[startIdx]];

	// Try to extend the sequence by finding consecutive holes that fit the line
	// Only look FORWARD to maintain hole sequence order (drilling progression)
	for (let nextIdx = startIdx + 1; nextIdx < numericHoles.length; nextIdx++) {
		if (used.has(nextIdx)) continue; // Skip holes already used by other rows

		// Test if adding this hole would still form a valid straight line
		const testSequence = [...sequence, numericHoles[nextIdx]];

		if (sequenceFitsLine(testSequence, tolerance)) {
			// Hole fits the line - add it to the sequence and continue
			sequence.push(numericHoles[nextIdx]);
		} else {
			// Hole doesn't fit the line - stop extending sequence
			// This ensures rows are continuous (no gaps in hole sequence)
			break;
		}
	}

	return sequence;
}

/**
 * SEQUENCE LINE FITTING VALIDATOR
 *
 * Tests whether a sequence of holes can be considered to form a straight line
 * within the specified tolerance. Uses simple linear regression approach.
 *
 * GEOMETRIC METHOD:
 * 1. Define line using first and last points in sequence
 * 2. Calculate perpendicular distance from each intermediate point to this line
 * 3. If any point is farther than tolerance from line, sequence fails
 * 4. If all points are within tolerance, sequence passes
 *
 * ASSUMPTIONS:
 * - Uses first and last points to define the "ideal" line
 * - Assumes drilling follows a reasonably straight path
 * - Tolerance accounts for small drilling irregularities and survey errors
 *
 * @param {Array} sequence - Array of hole objects to test for linearity
 * @param {number} tolerance - Maximum allowed distance from line (meters)
 * @returns {boolean} - true if sequence forms a valid straight line
 */
function sequenceFitsLine(sequence, tolerance) {
	// Single hole or pair always forms a valid "line"
	if (sequence.length < 2) return true;

	// Extract coordinate points from hole objects
	const points = sequence.map((item) => ({
		x: item.hole.startXLocation,
		y: item.hole.startYLocation,
	}));

	// Define line using first and last points (endpoints of sequence)
	// This represents the "ideal" straight line the holes should follow
	const start = points[0];
	const end = points[points.length - 1];

	// Test all intermediate points (exclude endpoints since they define the line)
	for (let i = 1; i < points.length - 1; i++) {
		const distance = distancePointToLine(points[i], start, end);
		if (distance > tolerance) {
			// Found a point too far from the line - sequence is not straight enough
			return false;
		}
	}

	// All intermediate points are within tolerance - sequence is acceptably straight
	return true;
}

/**
 * POINT-TO-LINE DISTANCE CALCULATOR
 *
 * Calculates the perpendicular (shortest) distance from a point to a line segment.
 * Uses the standard point-to-line distance formula from analytic geometry.
 *
 * MATHEMATICAL FORMULA:
 * For line defined by points (x1,y1) and (x2,y2), and test point (x0,y0):
 * distance = |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)? + (x2-x1)?)
 *
 * SPECIAL CASES:
 * - If line endpoints are identical (zero length), distance is 0
 * - Formula gives perpendicular distance, not diagonal distance
 *
 * @param {Object} point - Point to test {x, y}
 * @param {Object} lineStart - Line start point {x, y}
 * @param {Object} lineEnd - Line end point {x, y}
 * @returns {number} - Perpendicular distance from point to line (meters)
 */
function distancePointToLine(point, lineStart, lineEnd) {
	// Calculate line vector components
	const dx = lineEnd.x - lineStart.x;
	const dy = lineEnd.y - lineStart.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);

	// Handle degenerate case where line endpoints are identical
	if (lineLength === 0) return 0; // Start and end are the same point

	// Apply point-to-line distance formula
	// |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)? + (x2-x1)?)
	const distance = Math.abs((dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x) / lineLength);

	return distance;
}

/**
 * HDBSCAN-BASED ROW DETECTION (RECOMMENDED APPROACH)
 *
 * This algorithm uses hierarchical density-based clustering to detect rows
 * in blast hole patterns. It's superior to the existing algorithms because:
 * - No need to specify number of rows beforehand
 * - Handles varying row densities automatically
 * - Robust to noise and irregular patterns
 * - Works with any hole naming convention
 */

function detectRowsUsingHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using HDBSCAN for row detection on " + holesData.length + " holes");

	// Extract coordinates for clustering
	const points = holesData.map((hole) => [hole.startXLocation, hole.startYLocation]);

	// Calculate minimum cluster size based on expected holes per row
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20)); // Estimate 20 rows max

	// Since we don't have HDBSCAN library, we'll implement a simplified version
	// In production, use: import { HDBSCAN } from 'hdbscan-js';
	const clusters = simplifiedHDBSCAN(points, minClusterSize);

	// Convert clusters to row assignments
	assignClustersToRows(holesData, clusters, entityName);

	console.log("HDBSCAN detected " + clusters.length + " rows");
	return clusters.length > 0;
}

/**
 * SIMPLIFIED HDBSCAN IMPLEMENTATION
 *
 * This is a simplified version for demonstration. In production,
 * use a proper HDBSCAN library like hdbscan-js or sklearn in Python
 */
function simplifiedHDBSCAN(points, minClusterSize) {
	// Step 1: Calculate distance matrix
	const distances = calculateDistanceMatrix(points);

	// Step 2: Build minimum spanning tree based on mutual reachability
	const mst = buildMinimumSpanningTree(points, distances, minClusterSize);

	// Step 3: Build cluster hierarchy
	const hierarchy = buildClusterHierarchy(mst);

	// Step 4: Extract stable clusters
	const clusters = extractStableClusters(hierarchy, minClusterSize);

	return clusters;
}

/**
 * SIMPLIFIED HDBSCAN WITH DISTANCE MATRIX
 *
 * This function runs HDBSCAN clustering using a pre-calculated distance matrix
 * instead of calculating distances from point coordinates.
 *
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n?n distance matrix
 * @param {number} minClusterSize - Minimum number of points required to form a cluster
 * @returns {Array<Array<number>>} Array of clusters, where each cluster is an array of point indices
 */
function simplifiedHDBSCANWithDistanceMatrix(distanceMatrix, minClusterSize) {
	// Step 2) Validate input parameters
	if (!distanceMatrix || !Array.isArray(distanceMatrix) || distanceMatrix.length === 0) {
		console.warn("Invalid distance matrix provided to simplifiedHDBSCANWithDistanceMatrix");
		return [];
	}

	const n = distanceMatrix.length;

	// Step 3) Validate that distance matrix is square
	if (distanceMatrix.some((row) => !Array.isArray(row) || row.length !== n)) {
		console.warn("Distance matrix is not square or properly formatted");
		return [];
	}

	console.log("Running HDBSCAN with pre-calculated " + n + "√ó" + n + " distance matrix");

	// Step 4) Build minimum spanning tree using the provided distance matrix
	const mst = buildMinimumSpanningTreeFromMatrix(distanceMatrix, minClusterSize);

	// Step 5) Build cluster hierarchy using existing function
	const hierarchy = buildClusterHierarchy(mst);

	// Step 6) Extract stable clusters using existing function
	const clusters = extractStableClusters(hierarchy, minClusterSize);

	console.log("HDBSCAN with distance matrix detected " + clusters.length + " clusters");
	return clusters;
}

/**
 * BUILD MINIMUM SPANNING TREE FROM DISTANCE MATRIX
 *
 * Step 1) This is a variant of the existing buildMinimumSpanningTree function
 * that works with a pre-calculated distance matrix instead of calculating distances.
 *
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n?n distance matrix
 * @param {number} minPts - Minimum points parameter for core distance calculation
 * @returns {Array<Object>} Minimum spanning tree edges with {from, to, weight} structure
 */
function buildMinimumSpanningTreeFromMatrix(distanceMatrix, minPts) {
	const n = distanceMatrix.length;
	const edges = [];

	// Step 2) Calculate core distances (distance to k-th nearest neighbor)
	const coreDistances = [];
	for (let i = 0; i < n; i++) {
		// Step 3) Get all distances for point i and sort them
		const dists = distanceMatrix[i].slice(); // Copy the row
		dists.sort((a, b) => a - b);

		// Step 4) Use k-th nearest neighbor distance as core distance
		// Ensure we don't exceed array bounds
		const kIndex = Math.min(minPts, dists.length - 1);
		coreDistances[i] = dists[kIndex];
	}

	// Step 5) Calculate mutual reachability distances and create edges
	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			// Step 6) Mutual reachability is the maximum of:
			// - Core distance of point i
			// - Core distance of point j
			// - Direct distance between points i and j
			const mutualReachability = Math.max(coreDistances[i], coreDistances[j], distanceMatrix[i][j]);

			edges.push({
				from: i,
				to: j,
				weight: mutualReachability,
			});
		}
	}

	// Step 7) Sort edges by weight (Kruskal's algorithm)
	edges.sort((a, b) => a.weight - b.weight);

	// Step 8) Build MST using Union-Find algorithm
	const parent = Array(n)
		.fill()
		.map((_, i) => i);
	const mst = [];

	// Step 9) Union-Find helper functions
	function find(x) {
		if (parent[x] !== x) {
			parent[x] = find(parent[x]); // Path compression
		}
		return parent[x];
	}

	function union(x, y) {
		const px = find(x);
		const py = find(y);
		if (px !== py) {
			parent[px] = py;
			return true;
		}
		return false;
	}

	// Step 10) Build MST by adding edges that don't create cycles
	for (const edge of edges) {
		if (union(edge.from, edge.to)) {
			mst.push(edge);
			// Step 11) Stop when we have n-1 edges (complete spanning tree)
			if (mst.length === n - 1) break;
		}
	}

	console.log("Built MST from distance matrix with " + mst.length + " edges");
	return mst;
}

function calculateDistanceMatrix(points) {
	const n = points.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const dx = points[i][0] - points[j][0];
			const dy = points[i][1] - points[j][1];
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances[i][j] = distances[j][i] = dist;
		}
	}

	return distances;
}

function buildMinimumSpanningTree(points, distances, minPts) {
	const n = points.length;
	const edges = [];

	// Calculate core distances (distance to k-th nearest neighbor)
	const coreDistances = points.map((point, i) => {
		const dists = distances[i].slice();
		dists.sort((a, b) => a - b);
		return dists[minPts]; // k-th nearest neighbor distance
	});

	// Calculate mutual reachability distances and create edges
	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const mutualReachability = Math.max(coreDistances[i], coreDistances[j], distances[i][j]);
			edges.push({ from: i, to: j, weight: mutualReachability });
		}
	}

	// Sort edges by weight (Kruskal's algorithm)
	edges.sort((a, b) => a.weight - b.weight);

	// Build MST using Union-Find
	const parent = Array(n)
		.fill()
		.map((_, i) => i);
	const mst = [];

	function find(x) {
		if (parent[x] !== x) {
			parent[x] = find(parent[x]);
		}
		return parent[x];
	}

	function union(x, y) {
		const px = find(x);
		const py = find(y);
		if (px !== py) {
			parent[px] = py;
			return true;
		}
		return false;
	}

	for (const edge of edges) {
		if (union(edge.from, edge.to)) {
			mst.push(edge);
			if (mst.length === n - 1) break;
		}
	}

	return mst;
}

function buildClusterHierarchy(mst) {
	// Sort MST edges by weight (reverse order for hierarchy building)
	const sortedEdges = mst.slice().sort((a, b) => b.weight - a.weight);

	const hierarchy = [];
	const components = new Map();
	let nextClusterId = 0;

	// Initialize each point as its own component
	for (const edge of mst) {
		if (!components.has(edge.from)) components.set(edge.from, [edge.from]);
		if (!components.has(edge.to)) components.set(edge.to, [edge.to]);
	}

	// Build hierarchy by merging components
	for (const edge of sortedEdges) {
		const comp1 = components.get(edge.from);
		const comp2 = components.get(edge.to);

		if (comp1 && comp2 && comp1 !== comp2) {
			const merged = [...comp1, ...comp2];
			const clusterId = nextClusterId++;

			hierarchy.push({
				id: clusterId,
				points: merged,
				distance: edge.weight,
				children: [comp1, comp2],
			});

			// Update component references
			for (const point of merged) {
				components.set(point, merged);
			}
		}
	}

	return hierarchy;
}

function extractStableClusters(hierarchy, minClusterSize) {
	// Simplified cluster extraction - select clusters with good stability
	const clusters = [];
	const processed = new Set();

	// Sort by cluster size and distance for stability
	const candidates = hierarchy
		.filter((cluster) => cluster.points.length >= minClusterSize)
		.sort((a, b) => {
			// Prefer larger clusters with smaller distances (more stable)
			const stabilityA = a.points.length / (1 + a.distance);
			const stabilityB = b.points.length / (1 + b.distance);
			return stabilityB - stabilityA;
		});

	for (const candidate of candidates) {
		// Check if any points are already assigned to a cluster
		if (!candidate.points.some((point) => processed.has(point))) {
			clusters.push(candidate.points);
			for (const point of candidate.points) {
				processed.add(point);
			}
		}
	}

	return clusters;
}

/**
 * ENHANCED GRID-BASED CLUSTERING (ALTERNATIVE APPROACH)
 *
 * This algorithm uses an adaptive grid structure to detect rows,
 * inspired by spatial co-location pattern mining techniques
 */
function detectRowsUsingAdaptiveGrid(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Adaptive Grid clustering for row detection");

	// Calculate bounding box and optimal grid size
	const bounds = calculateBounds(holesData);
	const gridSize = estimateOptimalGridSize(holesData, bounds);

	// Create adaptive grid
	const grid = createAdaptiveGrid(holesData, bounds, gridSize);

	// Find connected components in grid
	const components = findGridComponents(grid);

	// Convert components to rows
	const rows = componentsToRows(components, holesData);

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, index) => {
		const rowID = startingRowID + index;
		row.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});

	console.log("Adaptive Grid detected " + rows.length + " rows");
	return rows.length > 0;
}

function calculateBounds(holesData) {
	const xs = holesData.map((h) => h.startXLocation);
	const ys = holesData.map((h) => h.startYLocation);

	return {
		minX: Math.min(...xs),
		maxX: Math.max(...xs),
		minY: Math.min(...ys),
		maxY: Math.max(...ys),
	};
}

function estimateOptimalGridSize(holesData, bounds) {
	// Estimate grid size based on average hole spacing
	const distances = [];

	for (let i = 0; i < holesData.length; i++) {
		for (let j = i + 1; j < holesData.length; j++) {
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances.push(dist);
		}
	}

	distances.sort((a, b) => a - b);

	// Use median of shortest 10% of distances as grid size
	const shortDistances = distances.slice(0, Math.floor(distances.length * 0.1));
	const medianSpacing = shortDistances[Math.floor(shortDistances.length / 2)];

	return medianSpacing * 1.5; // 1.5x median spacing for grid size
}

function createAdaptiveGrid(holesData, bounds, gridSize) {
	const grid = new Map();

	holesData.forEach((hole, index) => {
		const cellX = Math.floor((hole.startXLocation - bounds.minX) / gridSize);
		const cellY = Math.floor((hole.startYLocation - bounds.minY) / gridSize);
		const key = cellX + "," + cellY;

		if (!grid.has(key)) {
			grid.set(key, []);
		}
		grid.get(key).push({ hole, index });
	});

	return grid;
}

function findGridComponents(grid) {
	const visited = new Set();
	const components = [];

	for (const [cellKey, holes] of grid) {
		if (!visited.has(cellKey) && holes.length > 0) {
			const component = [];
			const queue = [cellKey];
			visited.add(cellKey);

			while (queue.length > 0) {
				const currentKey = queue.shift();
				const currentHoles = grid.get(currentKey) || [];
				component.push(...currentHoles);

				// Check adjacent cells
				const [x, y] = currentKey.split(",").map(Number);
				const neighbors = [
					[x - 1, y],
					[x + 1, y],
					[x, y - 1],
					[x, y + 1], // 4-connected
					[x - 1, y - 1],
					[x - 1, y + 1],
					[x + 1, y - 1],
					[x + 1, y + 1], // 8-connected
				];

				for (const [nx, ny] of neighbors) {
					const neighborKey = nx + "," + ny;
					if (grid.has(neighborKey) && !visited.has(neighborKey)) {
						visited.add(neighborKey);
						queue.push(neighborKey);
					}
				}
			}

			if (component.length > 0) {
				components.push(component);
			}
		}
	}

	return components;
}

function componentsToRows(components, holesData) {
	return components.map((component) => {
		// Sort holes within component by position along dominant axis
		const holes = component.map((item) => item.hole);

		// Determine dominant direction for sorting
		const direction = estimateRowDirection(holes);

		// Sort holes along the row direction
		holes.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		return holes;
	});
}

function estimateRowDirection(holes) {
	if (holes.length < 2) return 0;

	// Use PCA to find principal direction
	const meanX = holes.reduce((sum, h) => sum + h.startXLocation, 0) / holes.length;
	const meanY = holes.reduce((sum, h) => sum + h.startYLocation, 0) / holes.length;

	let covarXX = 0,
		covarXY = 0,
		covarYY = 0;

	holes.forEach((hole) => {
		const dx = hole.startXLocation - meanX;
		const dy = hole.startYLocation - meanY;
		covarXX += dx * dx;
		covarXY += dx * dy;
		covarYY += dy * dy;
	});

	// Calculate principal direction (eigenvector of covariance matrix)
	const trace = covarXX + covarYY;
	const det = covarXX * covarYY - covarXY * covarXY;
	const eigenvalue1 = (trace + Math.sqrt(trace * trace - 4 * det)) / 2;

	// Principal direction angle
	if (Math.abs(covarXY) > 1e-10) {
		return Math.atan2(eigenvalue1 - covarXX, covarXY);
	} else {
		return covarXX > covarYY ? 0 : Math.PI / 2;
	}
}

// Helper function to assign clusters to rows
function assignClustersToRows(holesData, clusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	clusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;
		const rowHoles = cluster.map((pointIndex) => holesData[pointIndex]);

		// Sort holes within row by spatial position
		const direction = estimateRowDirection(rowHoles);
		rowHoles.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		// Assign row and position IDs
		rowHoles.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});
}

/**
 * UPDATED SMART ROW DETECTION WITH SEQUENCE PRIORITY
 *
 * This maintains the priority of sequential hole numbering while using
 * better algorithms when sequence-based detection fails
 */
function improvedSmartRowDetection(holesData, entityName) {
	if (!holesData || holesData.length === 0) return;

	console.log("Improved smart row detection for " + holesData.length + " holes in entity: " + entityName);

	// METHOD 1: ALWAYS TRY SEQUENCE-BASED DETECTION FIRST (HIGHEST PRIORITY)
	// This respects the drilling order and numbered patterns which are most reliable
	if (trySequenceBasedDetection(holesData, entityName)) {
		console.log("Used sequence-based row detection (PRIORITY METHOD)");
		return;
	}

	// METHOD 2: Enhanced spatial detection with sequence weighting
	// Use HDBSCAN but weight points based on sequence proximity
	if (detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName)) {
		console.log("Used sequence-weighted HDBSCAN row detection");
		return;
	}

	// METHOD 3: Try pure spatial HDBSCAN (when sequence is completely random)
	if (detectRowsUsingHDBSCAN(holesData, entityName)) {
		console.log("Used pure spatial HDBSCAN row detection");
		return;
	}

	// METHOD 4: Try Adaptive Grid clustering
	if (detectRowsUsingAdaptiveGrid(holesData, entityName)) {
		console.log("Used Adaptive Grid row detection");
		return;
	}

	// METHOD 5: Fallback to your existing bearing-based detection
	useBearingBasedDetection(holesData, entityName);
	console.log("Used bearing-based spatial detection as fallback");
}

/**
 * SEQUENCE-WEIGHTED HDBSCAN
 *
 * This combines the power of HDBSCAN with respect for hole numbering sequence.
 * Points that are close in sequence get a distance penalty reduction, making
 * them more likely to cluster together even if slightly farther apart spatially.
 */
function detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Sequence-Weighted HDBSCAN for row detection");

	// First, try to extract numeric sequence from hole IDs
	const sequenceInfo = extractSequenceInformation(holesData);

	if (!sequenceInfo.hasValidSequence) {
		console.log("No valid sequence found, falling back to pure spatial HDBSCAN");
		return false;
	}

	// Create distance matrix that considers both spatial and sequence proximity
	const weightedDistances = calculateSequenceWeightedDistances(holesData, sequenceInfo);

	// Run HDBSCAN with the weighted distances
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20));
	const clusters = simplifiedHDBSCANWithDistanceMatrix(weightedDistances, minClusterSize);

	// Post-process clusters to respect sequence order within rows
	const orderedClusters = orderClustersbySequence(clusters, holesData, sequenceInfo);

	// Assign to rows
	assignOrderedClustersToRows(holesData, orderedClusters, entityName);

	console.log("Sequence-Weighted HDBSCAN detected " + orderedClusters.length + " rows");
	return orderedClusters.length > 0;
}

/**
 * EXTRACT SEQUENCE INFORMATION
 *
 * Analyzes hole IDs to determine if there's a meaningful sequence that should
 * be preserved during clustering
 */
function extractSequenceInformation(holesData) {
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;
	const sequenceMap = new Map(); // Maps holeID to sequence number

	// Analyze hole ID patterns (same as your existing logic)
	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
			sequenceMap.set(hole.holeID, parseInt(hole.holeID));
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
			// For alphanumeric, use the numeric part as sequence
			const match = hole.holeID.match(/(\d+)$/);
			if (match) {
				sequenceMap.set(hole.holeID, parseInt(match[1]));
			}
		} else {
			otherCount++;
			// For other patterns, use index as sequence
			sequenceMap.set(hole.holeID, index);
		}
	});

	// Determine if we have a valid sequence
	const hasValidSequence =
		numericCount > holesData.length * 0.7 || // 70% numeric
		alphaNumericCount > holesData.length * 0.7; // 70% alphanumeric

	console.log("Sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
		hasValidSequence: hasValidSequence,
	});

	return {
		hasValidSequence,
		sequenceMap,
		totalHoles: holesData.length,
	};
}

/**
 * CALCULATE SEQUENCE-WEIGHTED DISTANCES
 *
 * Modifies spatial distances to give preference to holes that are close
 * in the numbering sequence, making them more likely to cluster together
 */
function calculateSequenceWeightedDistances(holesData, sequenceInfo) {
	const n = holesData.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	// Get sequence numbers for all holes
	const sequences = holesData.map((hole) => sequenceInfo.sequenceMap.get(hole.holeID) || 0);
	const maxSequenceDiff = Math.max(...sequences) - Math.min(...sequences);

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			// Calculate spatial distance
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const spatialDistance = Math.sqrt(dx * dx + dy * dy);

			// Calculate sequence distance (normalized)
			const sequenceDiff = Math.abs(sequences[i] - sequences[j]);
			const normalizedSequenceDiff = sequenceDiff / maxSequenceDiff;

			// SEQUENCE WEIGHTING FORMULA:
			// - If holes are close in sequence (low sequenceDiff), reduce distance
			// - If holes are far in sequence (high sequenceDiff), increase distance
			// - Weight factor controls how much sequence matters vs spatial distance
			const sequenceWeight = 0.3; // 30% influence from sequence
			const sequencePenalty = 1 + sequenceWeight * normalizedSequenceDiff;
			const sequenceBonus = Math.max(0.5, 1 - sequenceWeight * Math.exp(-sequenceDiff / 5));

			// Apply sequence weighting
			let weightedDistance;
			if (sequenceDiff <= 3) {
				// Holes very close in sequence get a distance bonus
				weightedDistance = spatialDistance * sequenceBonus;
			} else {
				// Holes far in sequence get a distance penalty
				weightedDistance = spatialDistance * sequencePenalty;
			}

			distances[i][j] = distances[j][i] = weightedDistance;
		}
	}

	return distances;
}

/**
 * ORDER CLUSTERS BY SEQUENCE
 *
 * After clustering, ensure holes within each cluster are ordered by sequence
 */
function orderClustersbySequence(clusters, holesData, sequenceInfo) {
	return clusters.map((cluster) => {
		// Get holes in this cluster
		const clusterHoles = cluster.map((index) => ({
			hole: holesData[index],
			index: index,
			sequence: sequenceInfo.sequenceMap.get(holesData[index].holeID) || 0,
		}));

		// Sort by sequence number
		clusterHoles.sort((a, b) => a.sequence - b.sequence);

		return clusterHoles.map((item) => item.index);
	});
}

/**
 * ASSIGN ORDERED CLUSTERS TO ROWS
 *
 * Assigns cluster results to rows while preserving sequence order
 */
function assignOrderedClustersToRows(holesData, orderedClusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	orderedClusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;

		cluster.forEach((holeIndex, positionInRow) => {
			const hole = holesData[holeIndex];
			hole.rowID = rowID;
			hole.posID = positionInRow + 1; // Position respects sequence order
		});

		console.log("Row " + rowID + " has " + cluster.length + " holes in sequence order");
	});
}

/**
 * ENHANCED SEQUENCE-BASED DETECTION (REPLACES YOUR EXISTING VERSION)
 *
 * This improves your existing trySequenceBasedDetection with better algorithms
 * while maintaining the priority of sequential numbering
 */
function enhancedSequenceBasedDetection(holesData, entityName) {
	// Same pattern analysis as your original code
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;

	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
		} else {
			otherCount++;
		}
	});

	console.log("Enhanced sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
	});

	// CASE 1: All alphanumeric (keep your existing logic)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: Mixed patterns - improved handling
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");
		return handleMixedSequencePattern(holesData, entityName);
	}

	// CASE 3: Pure numeric - enhanced algorithms
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num))
		.sort((a, b) => a.num - b.num);

	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		return false; // Not suitable for sequence-based detection
	}

	// Check sequence continuity with gap tolerance
	const gaps = analyzeSequenceGaps(numericHoles);

	if (gaps.hasReasonablePattern) {
		console.log("Using enhanced sequence-based detection with gap tolerance");
		return enhancedSequentialDetection(numericHoles, entityName, gaps);
	}

	return false; // Fall back to spatial detection
}

/**
 * ANALYZE SEQUENCE GAPS
 *
 * Determines if the numeric sequence has a reasonable pattern even with gaps
 */
function analyzeSequenceGaps(numericHoles) {
	const numbers = numericHoles.map((item) => item.num);
	const gaps = [];

	for (let i = 1; i < numbers.length; i++) {
		gaps.push(numbers[i] - numbers[i - 1]);
	}

	// Analyze gap pattern
	const gapCounts = {};
	gaps.forEach((gap) => {
		gapCounts[gap] = (gapCounts[gap] || 0) + 1;
	});

	const uniqueGaps = Object.keys(gapCounts)
		.map(Number)
		.sort((a, b) => a - b);
	const mostCommonGap = uniqueGaps.reduce((a, b) => (gapCounts[a] > gapCounts[b] ? a : b));
	const gapVariability = uniqueGaps.length;

	// Consider pattern reasonable if:
	// - Most common gap is 1 (consecutive numbering)
	// - OR gaps are small and consistent (like 1,2,1,2,1...)
	// - OR large gaps but very consistent (like 10,10,10... for every 10th hole)
	const hasReasonablePattern =
		mostCommonGap === 1 || // Mostly consecutive
		(gapVariability <= 3 && Math.max(...uniqueGaps) <= 5) || // Small, consistent gaps
		(gapVariability === 1 && gaps.length > 5); // Very consistent larger gaps

	console.log("Gap analysis:", {
		gaps: gaps.slice(0, 10), // First 10 gaps
		mostCommonGap,
		gapVariability,
		hasReasonablePattern,
	});

	return {
		hasReasonablePattern,
		mostCommonGap,
		gaps,
		gapVariability,
	};
}

/**
 * ENHANCED SEQUENTIAL DETECTION
 *
 * Uses improved algorithms while respecting sequence order
 */
function enhancedSequentialDetection(numericHoles, entityName, gapInfo) {
	// Choose algorithm based on gap pattern
	if (gapInfo.mostCommonGap === 1 && gapInfo.gapVariability <= 2) {
		// Mostly consecutive - use improved line fitting
		console.log("Using improved sequential line fitting");
		return improvedSequentialLineFitting(numericHoles, entityName);
	} else if (gapInfo.gapVariability === 1) {
		// Consistent gaps - use pattern-based detection
		console.log("Using pattern-based detection for consistent gaps");
		return patternBasedSequentialDetection(numericHoles, entityName, gapInfo.mostCommonGap);
	} else {
		// Irregular gaps - use sequence-aware spatial clustering
		console.log("Using sequence-aware spatial clustering for irregular gaps");
		return sequenceAwareSpatialClustering(numericHoles, entityName);
	}
}

/**
 * PATTERN-BASED SEQUENTIAL DETECTION
 *
 * For holes with consistent gaps (like every 5th hole: 5,10,15,20...)
 */
function patternBasedSequentialDetection(numericHoles, entityName, pattern) {
	const tolerance = calculateAdaptiveTolerance(numericHoles);
	const rows = [];
	const used = new Set();

	// Group holes by their position in the pattern cycle
	const patternGroups = new Map();

	numericHoles.forEach((item, index) => {
		const patternPosition = item.num % pattern;
		if (!patternGroups.has(patternPosition)) {
			patternGroups.set(patternPosition, []);
		}
		patternGroups.get(patternPosition).push({ item, index });
	});

	// Process each pattern group as potential rows
	for (const [position, group] of patternGroups) {
		if (group.length >= 2) {
			// Test if this group forms good spatial rows
			const groupItems = group.map((g) => g.item);
			const spatialRows = detectSpatialRowsInGroup(groupItems, tolerance);

			spatialRows.forEach((row) => {
				if (row.length >= 2) {
					rows.push(row);
					row.forEach((hole) => {
						const originalIndex = numericHoles.indexOf(hole);
						if (originalIndex !== -1) used.add(originalIndex);
					});
				}
			});
		}
	}

	// Handle remaining holes
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
		}
	}

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1;
		});
	});

	console.log("Pattern-based detection found " + rows.length + " rows");
	return rows.length > 0;
}

/**
 * HANDLE MIXED SEQUENCE PATTERNS
 *
 * Better handling for mixed numeric/alphanumeric patterns while preserving sequence
 */
function handleMixedSequencePattern(holesData, entityName) {
	console.log("Enhanced mixed pattern handling");

	// Create unified sequence that preserves the original intent
	const sequencedHoles = createUnifiedSequence(holesData);

	// Try to detect patterns in the unified sequence
	if (sequencedHoles.hasValidPattern) {
		return enhancedSequentialDetection(sequencedHoles.holes, entityName, sequencedHoles.gapInfo);
	}

	// If no valid pattern, use sequence-weighted spatial clustering
	console.log("No clear pattern, using sequence-weighted spatial clustering");
	return detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName);
}

function createUnifiedSequence(holesData) {
	// Separate holes by type and create logical ordering
	const numericHoles = [];
	const alphaNumericHoles = [];
	const otherHoles = [];

	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericHoles.push({
				hole,
				num: parseInt(hole.holeID),
				originalIndex: index,
			});
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
			if (match) {
				alphaNumericHoles.push({
					hole,
					letter: match[1],
					num: parseInt(match[2]),
					originalIndex: index,
				});
			}
		} else {
			otherHoles.push({ hole, num: index, originalIndex: index });
		}
	});

	// Create unified sequence
	let unifiedSequence = [];
	let counter = 1;

	// Add numeric holes first (sorted)
	numericHoles.sort((a, b) => a.num - b.num);
	numericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add alphanumeric holes (sorted by letter then number)
	alphaNumericHoles.sort((a, b) => {
		if (a.letter !== b.letter) {
			return a.letter.localeCompare(b.letter);
		}
		return a.num - b.num;
	});
	alphaNumericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add other holes last
	otherHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Analyze the unified sequence
	const gapInfo = analyzeSequenceGaps(unifiedSequence);

	return {
		holes: unifiedSequence,
		hasValidPattern: gapInfo.hasReasonablePattern,
		gapInfo,
	};
}

// #endregion HDBSCAN-ROW-DETECTION

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// #endregion CUSTOM CSV

//---------------- START RULER TOOL ----------------//
// Add these global variables for ruler functionality (around line 80)

// Helper function to format numbers to 2 decimal places
function formatTo2Decimals(num) {
	return parseFloat(num).toFixed(2);
}

// Helper function to format numbers to 1 decimal place
function formatTo1Decimal(num) {
	return parseFloat(num).toFixed(1);
}

function drawRuler(startX, startY, startZ, endX, endY, endZ) {
	// Handle undefined/null Z values - use 0 as fallback
	const safeStartZ = startZ || 0;
	const safeEndZ = endZ || 0;

	// Calculate differences (following your formula exactly)
	const deltaX = endX - startX; // ‚çôX
	const deltaY = endY - startY; // ‚çôY
	const deltaZ = safeEndZ - safeStartZ; // ‚çôZ

	// Calculate 2D plan distance (horizontal distance, hypotenuse of blue triangle D)
	// Plan Length = v(?X? + ?Y?)
	const planDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

	// Calculate true 3D distance (hypotenuse of purple triangle C)
	// Total Length = v(‚çôX + ‚çôY + ‚çôZ)
	const totalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

	// Calculate bearing angle (horizontal direction)
	const lineAngle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;

	// Calculate elevation angle A (green angle from horizontal plane)
	// Angle A = arctan(|‚çôZ| / Plan Length)
	const elevationAngle = planDistance > 0 ? (Math.atan(Math.abs(deltaZ) / planDistance) * 180) / Math.PI : 0;

	// Calculate slope percentage for additional context
	const slopePercent = planDistance > 0 ? (Math.abs(deltaZ) / planDistance) * 100 : 0;

	// Convert world coordinates to canvas coordinates
	const canvasStartX = (startX - centroidX) * currentScale + canvas.width / 2;
	const canvasStartY = -(startY - centroidY) * currentScale + canvas.height / 2;
	const canvasEndX = (endX - centroidX) * currentScale + canvas.width / 2;
	const canvasEndY = -(endY - centroidY) * currentScale + canvas.height / 2;

	// Draw main ruler line
	ctx.beginPath();
	ctx.moveTo(canvasStartX, canvasStartY);
	ctx.lineTo(canvasEndX, canvasEndY);
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 2;
	ctx.stroke();

	// Step #) Emit ruler measurements to CSS HUD panel (instead of drawing on ctx)
	// The CSS panel follows the mouse automatically via RulerPanel.js
	showRulerPanel({
		z1: safeStartZ,
		z2: safeEndZ,
		planDistance: planDistance,
		totalDistance: totalDistance,
		deltaZ: deltaZ,
		elevationAngle: elevationAngle,
		slopePercent: slopePercent,
		// Pass canvas position for panel positioning near ruler end
		mouseX: canvasEndX,
		mouseY: canvasEndY
	});

	// Draw meter increments (perpendicular tick marks) - use plan distance for tick spacing
	if (planDistance > 0) {
		for (let i = 0; i <= Math.floor(planDistance); i++) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.2m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.2 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.2 * Math.sin(perpAngle);
			const tick2X = tickX - 0.2 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.2 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}

		// Draw half-meter increments (shorter tick marks)
		for (let i = 0.5; i < planDistance; i += 1) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.1m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.1 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.1 * Math.sin(perpAngle);
			const tick2X = tickX - 0.1 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.1 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			// Draw tick mark
			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}
	}
}
// Convert the Java paintAngleMeasure function
function drawProtractor(p1X, p1Y, p2X, p2Y, p3X, p3Y) {
	// Don't draw anything if p2 and p3 are the same as p1 (first click only)
	if (p2X === p1X && p2Y === p1Y && p3X === p1X && p3Y === p1Y) {
		return;
	}

	// Calculate distances
	const d1 = Math.sqrt(Math.pow(p2X - p1X, 2) + Math.pow(p2Y - p1Y, 2));
	const d2 = Math.sqrt(Math.pow(p3X - p1X, 2) + Math.pow(p3Y - p1Y, 2));

	// Calculate bearings (North = 0?, East = 90?)
	const bearing1 = (90 - (Math.atan2(p2Y - p1Y, p2X - p1X) * 180) / Math.PI + 360) % 360;
	const bearing2 = (90 - (Math.atan2(p3Y - p1Y, p3X - p1X) * 180) / Math.PI + 360) % 360;

	// Calculate angle between the two lines
	let angle = Math.abs(bearing1 - bearing2);
	if (angle > 180) angle = 360 - angle;

	// Convert to canvas coordinates
	const canvasP1X = (p1X - centroidX) * currentScale + canvas.width / 2;
	const canvasP1Y = -(p1Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP2X = (p2X - centroidX) * currentScale + canvas.width / 2;
	const canvasP2Y = -(p2Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP3X = (p3X - centroidX) * currentScale + canvas.width / 2;
	const canvasP3Y = -(p3Y - centroidY) * currentScale + canvas.height / 2;

	// Draw lines
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 1;

	// First line (center to p2)
	if (d1 > 0) {
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP2X, canvasP2Y);
		ctx.stroke();

		// Step #) Show CSS panel with first leg data only (if second leg not yet set)
		if (d2 === 0 || (p3X === p1X && p3Y === p1Y)) {
			showProtractorPanel({
				d1: d1,
				bearing1: bearing1,
				mouseX: canvasP2X,
				mouseY: canvasP2Y
			});
		}
	}

	// Second line (center to p3) - only if p3 is different from p1
	if (d2 > 0 && !(p3X === p1X && p3Y === p1Y)) {
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP3X, canvasP3Y);
		ctx.stroke();

		// Step #) Emit protractor measurements to CSS HUD panel
		showProtractorPanel({
			d1: d1,
			d2: d2,
			bearing1: bearing1,
			bearing2: bearing2,
			innerAngle: angle,
			outerAngle: 360 - angle,
			mouseX: canvasP1X,
			mouseY: canvasP1Y
		});

		// Draw arc between the lines
		const arcRadius = (Math.min(d1, d2) / 3) * currentScale;
		if (arcRadius > 5) {
			// Calculate the actual angles of the lines in canvas coordinates
			const angle1 = Math.atan2(canvasP2Y - canvasP1Y, canvasP2X - canvasP1X);
			const angle2 = Math.atan2(canvasP3Y - canvasP1Y, canvasP3X - canvasP1X);

			// Calculate the difference between angles
			let angleDiff = angle2 - angle1;

			// Normalize to [-p, p]
			while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
			while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

			// Always draw the smaller arc (interior angle)
			let startAngle, endAngle, counterClockwise;

			if (Math.abs(angleDiff) <= Math.PI) {
				// The direct path is the smaller arc
				startAngle = angle1;
				endAngle = angle2;
				counterClockwise = angleDiff > 0;
			} else {
				// The direct path is the larger arc, so we need to go the other way
				startAngle = angle2;
				endAngle = angle1;
				counterClockwise = angleDiff < 0;
			}

			ctx.beginPath();
			ctx.arc(canvasP1X, canvasP1Y, arcRadius, startAngle, endAngle, counterClockwise);
			ctx.strokeStyle = "#FF0000"; // Red for arc
			ctx.lineWidth = 2;
			ctx.stroke();
		}
	}
}
// Add event listeners for the ruler tools
rulerTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerActive = true;
		rulerStartPoint = null;
		rulerEndPoint = null;
		canvas.addEventListener("click", handleRulerClick);
		updateStatusMessage("Ruler Tool Activated\nSelect 2 points to measure distance\nChange tool to remove.");
	} else {
		isRulerActive = false;
		rulerStartPoint = null;
		rulerEndPoint = null;
		hideRulerPanel(); // Step #) Hide CSS ruler panel when toggled off
		canvas.removeEventListener("click", handleRulerClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});
//Protractor Tool addlistener
rulerProtractorTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerProtractorTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerProtractorActive = true;
		rulerProtractorPoints = [];
		canvas.addEventListener("click", handleRulerProtractorClick);
		updateStatusMessage("Protractor Tool Activated\nSelect 3 points to measure bearing\nChange tool to remove.");
	} else {
		isRulerProtractorActive = false;
		rulerProtractorPoints = [];
		hideProtractorPanel(); // Step #) Hide CSS protractor panel when toggled off
		canvas.removeEventListener("click", handleRulerProtractorClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Handle ruler clicks
function handleRulerClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (!rulerStartPoint) {
		// First click - set start point, ruler will now follow mouse
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
		rulerEndPoint = null;
	} else if (!rulerEndPoint) {
		// Second click - lock in the end point, measurement is complete
		rulerEndPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
	} else {
		// Third click - start new measurement
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
		rulerEndPoint = null;
	}
	drawData(allBlastHoles, selectedHole);
}
// Handle ruler bearing clicks (3 points)
function handleRulerProtractorClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	rulerProtractorPoints.push({
		x: worldX,
		y: worldY,
	});

	if (rulerProtractorPoints.length > 3) {
		// Start new measurement after 3 points
		rulerProtractorPoints = [
			{
				x: worldX,
				y: worldY,
			},
		];
	}

	drawData(allBlastHoles, selectedHole);
}

//----------------- END RULER TOOLS --------------------//
// Add these tool references after the existing ones
const patternInPolygonTool = document.getElementById("patternInPolygonTool");
const holesAlongLineTool = document.getElementById("holesAlongLineTool");
const holesAlongPolyLineTool = document.getElementById("holesAlongPolyLineTool");

// Add state variables for the new tools
let isPatternInPolygonActive = false;
let isHolesAlongLineActive = false;
let isHolesAlongPolyLineActive = false;

// Pattern in Polygon Tool state
let patternPolygonStep = 0; // 0=select polygon, 1=select start point, 2=select end point, 3=select reference point
let selectedPolygon = null;
let patternStartPoint = null;
let patternEndPoint = null;
let patternReferencePoint = null;
// KAD Polygon selection for editing

// Holes Along Line Tool state
let holesLineStep = 0; // 0=select start point, 1=select end point
let lineStartPoint = null;
let lineEndPoint = null;

// Holes Along PolyLine Tool state
let lastClickTime = null;
// Add state variables for the polyline tool
let polylineStep = 0; // 0=select line/polygon, 1=select start point, 2=select end point
let selectedPolyline = null;
let polylineStartPoint = null;
let polylineEndPoint = null;

// Add this wherever I finish clipping holes to polygon boundaries
function finalizePatternInPolygon(entityName) {
	// After clipping operations are complete
	renumberPatternAfterClipping(entityName);

	// Recalculate times and redraw
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, 0, 0);
	if (result) {
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
	}

	drawData(allBlastHoles, selectedHole);
	updateTreeView(); // Update the tree to show new numbering
}

//---------------PATTERN IN POLYGON TOOL---------------//
patternInPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("patternInPolygonTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["patternInPolygonTool", "selectPointerTool", "defaultListeners"]);

		endKadTools();
		isPatternInPolygonActive = true;
		patternPolygonStep = 0;
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;

		canvas.addEventListener("click", handlePatternInPolygonClick);
		canvas.addEventListener("touchstart", handlePatternInPolygonClick);

		updateStatusMessage("Step 1: Click on a polygon to select it");
	} else {
		resetFloatingToolbarButtons("none");
		isPatternInPolygonActive = false;
		patternPolygonStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;
		// Clear both local and window selectedKADObject to remove polygon highlight in 3D
		selectedKADObject = null;
		selectedKADPolygon = null;
		window.selectedKADObject = null;

		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handlePatternInPolygonClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (patternPolygonStep) {
		case 0: // Select polygon
			// The equivalent 3D(ThreeJS) Mode Selection function is handlePatternInPolygonClick3D or similar.
			const clickedEntityInfo = getClickedKADEntity(worldX, worldY);
			if (clickedEntityInfo && clickedEntityInfo.entity.entityType === "poly") {
				selectedPolygon = clickedEntityInfo.entity; // ? Extract just the entity
				// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
				selectedKADObject = clickedEntityInfo;
				selectedKADPolygon = clickedEntityInfo; // Backward compatibility
				// REUSE: Set window.selectedKADObject so highlightSelectedKADThreeJS() handles highlight in 3D
				window.selectedKADObject = clickedEntityInfo;
				patternPolygonStep = 1;
				updateStatusMessage("Step 2: Click to select pattern start point");
			} else {
				updateStatusMessage("No polygon found.\nStep 1: Click on a polygon to select it");
			}
			break;

		case 1: // Select start point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var startZ = window.worldZ;
			if (startZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				startZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternStartPoint = {
				x: worldX,
				y: worldY,
				z: startZ
			};
			patternPolygonStep = 2;
			updateStatusMessage("Step 3: Click to select pattern\nend point (for orientation)");
			console.log("Pattern start point set to:", worldX.toFixed(2), worldY.toFixed(2), startZ?.toFixed(2));
			break;

		case 2: // Select end point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var endZ = window.worldZ;
			if (endZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				endZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternEndPoint = {
				x: worldX,
				y: worldY,
				z: endZ
			};
			patternPolygonStep = 3;
			updateStatusMessage("Step 4: Click to select reference point");
			console.log("Pattern end point set to:", worldX.toFixed(2), worldY.toFixed(2), endZ?.toFixed(2));
			break;

		case 3: // Select reference point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var refZ = window.worldZ;
			if (refZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				refZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternReferencePoint = {
				x: worldX,
				y: worldY,
				z: refZ
			};
			updateStatusMessage("Reference point selected");
			console.log("Pattern reference point set to:", worldX.toFixed(2), worldY.toFixed(2));
			showPatternInPolygonPopup();
			// Dont deactivate the tool here - let the popup handle it
			// patternInPolygonTool.checked = false;
			// patternInPolygonTool.dispatchEvent(new Event("change")); // ? THIS IS THE PROBLEM!
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
//---------------HOLES ALONG POLYLINE TOOL---------------//
holesAlongPolyLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongPolyLineTool");

		endKadTools();
		isHolesAlongPolyLineActive = true;
		polylineStep = 0;
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.addEventListener("click", handleHolesAlongPolyLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Set cursor to indicate selection mode
		canvas.style.cursor = "crosshair";

		updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongPolyLineActive = false;
		polylineStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});
// Updated click handler with multi-step process
function handleHolesAlongPolyLineClick(event) {
	if (!isHolesAlongPolyLineActive) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (polylineStep) {
		case 0: // Select line/polygon
			// Use the same robust selection method as the select pointer tool
			const clickedKADObject = getClickedKADObject(clickX, clickY);


			if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
				var entity = allKADDrawingsMap.get(clickedKADObject.entityName);
				selectedPolyline = {
					type: clickedKADObject.entityType === "line" ? "line" : "polygon",
					vertices: entity.data.map((point) => ({
						x: point.pointXLocation,
						y: point.pointYLocation,
						z: point.pointZLocation || point.z || dataCentroidZ || 0, // FIX: Include Z values
					})),
					entity: entity,
				};
				// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
				selectedKADObject = clickedKADObject;
				window.selectedKADObject = clickedKADObject; // Set for highlighting
				// FIX: Also set selectedKADPolygon for backward compatibility
				selectedKADPolygon = clickedKADObject;
				polylineStep = 1;
				updateStatusMessage("Step 2: Click on a vertex or point along the " + selectedPolyline.type + " to set the start point.");
				console.log("Selected " + selectedPolyline.type + " with", selectedPolyline.vertices.length, "vertices");
				break;
			}

			updateStatusMessage("No line or polygon found. Step 1: Click on an existing line, polyline, or polygon edge.");
			break;

		case 1: // Select start point
			polylineStartPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineStartPoint) {
				polylineStep = 2;
				updateStatusMessage("Step 3: Click on another vertex along the line to set the end point.");
				console.log("Start point set at:", polylineStartPoint);
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;

		case 2: // Select end point
			polylineEndPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineEndPoint) {
				console.log("End point set at:", polylineEndPoint);

				// Create path from start to end point - now with polygon awareness
				const isPolygon = selectedPolyline.type === "polygon";
				const pathVertices = createPathBetweenVertices(selectedPolyline.vertices, polylineStartPoint, polylineEndPoint, isPolygon);

				if (pathVertices.length >= 2) {
					// Pass the polygon type and original vertices to the popup for reverse handling
					window.showHolesAlongPolylinePopup(pathVertices, selectedPolyline);
				} else {
					updateStatusMessage("Invalid path between selected points. Please try again.");
					polylineStep = 1;
					polylineStartPoint = null;
					polylineEndPoint = null;
				}

				// DON'T deactivate the tool here - let the popup handle it
				// holesAlongPolyLineTool.checked = false;
				// holesAlongPolyLineTool.dispatchEvent(new Event("change"));
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
// Expose handleHolesAlongPolyLineClick globally for PatternGenerationDialogs.js
window.handleHolesAlongPolyLineClick = handleHolesAlongPolyLineClick;
// Expose handleHolesAlongLineClick globally for PatternGenerationDialogs.js
window.handleHolesAlongLineClick = handleHolesAlongLineClick;
//---------------HOLES ALONG LINE TOOL---------------//
holesAlongLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongLineTool");

		endKadTools();
		isHolesAlongLineActive = true;
		holesLineStep = 0;
		window.holesLineStep = holesLineStep; // Keep window in sync
		lineStartPoint = null;
		window.lineStartPoint = lineStartPoint; // Keep window in sync
		lineEndPoint = null;
		window.lineEndPoint = lineEndPoint; // Keep window in sync

		canvas.addEventListener("click", handleHolesAlongLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongLineClick);

		updateStatusMessage("Step 1: Click to select line start point");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongLineActive = false;
		holesLineStep = 0;
		window.holesLineStep = holesLineStep; // Keep window in sync

		// Clear line points to remove visual feedback
		lineStartPoint = null;
		window.lineStartPoint = lineStartPoint; // Keep window in sync
		lineEndPoint = null;
		window.lineEndPoint = lineEndPoint; // Keep window in sync

		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// 		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handleHolesAlongLineClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (holesLineStep) {
		case 0: // Select start point
			lineStartPoint = {
				x: worldX,
				y: worldY,
			};
			window.lineStartPoint = lineStartPoint; // Keep window in sync
			holesLineStep = 1;
			window.holesLineStep = holesLineStep; // Keep window in sync
			updateStatusMessage("Step 2: Click to select line end point");
			break;

		case 1: // Select end point
			lineEndPoint = {
				x: worldX,
				y: worldY,
			};
			window.lineEndPoint = lineEndPoint; // Keep window in sync
			window.showHolesAlongLinePopup();
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
// Helper function to update status messages
function updateStatusMessage(message) {
	// You can display this in a status bar or console
	//console.log(message);
	statusMessage = message;
	// If you have a status element in your HTML, update it:
	// document.getElementById("statusMessage").textContent = message;
}
// Enhanced snapping function for CAD vertices and hole points
function findNearestSnapPoint(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	let closestPoint = null;
	let minDistance = tolerance;
	let snapType = null;

	console.log("Searching for snap points near:", worldX.toFixed(2), worldY.toFixed(2), "tolerance:", tolerance);

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "polygons for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Polygon", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Polygon vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY,
						};
						snapType = "CAD Polygon Vertex";
						console.log("Found closer CAD polygon vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "lines for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Line", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Line vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY,
						};
						snapType = "CAD Line Vertex";
						console.log("Found closer CAD line vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search hole collar allBlastHoles
	if (allBlastHoles && allBlastHoles.length > 0) {
		console.log("Searching", allBlastHoles.length, "holes for snap allBlastHoles");
		allBlastHoles.forEach((hole, holeIndex) => {
			// Collar point
			if (hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
				const collarDistance = Math.sqrt(Math.pow(worldX - hole.startXLocation, 2) + Math.pow(worldY - hole.startYLocation, 2));
				if (collarDistance < minDistance) {
					minDistance = collarDistance;
					closestPoint = {
						x: hole.startXLocation,
						y: hole.startYLocation,
					};
					snapType = "Hole Collar (" + hole.holeID + ")";
					console.log("Found closer hole collar, distance:", collarDistance.toFixed(2));
				}
			}

			// Grade point (if exists)
			if (hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
				const gradeDistance = Math.sqrt(Math.pow(worldX - hole.gradeXLocation, 2) + Math.pow(worldY - hole.gradeYLocation, 2));
				if (gradeDistance < minDistance) {
					minDistance = gradeDistance;
					closestPoint = {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
					};
					snapType = "Hole Grade (" + hole.holeID + ")";
					console.log("Found closer hole grade, distance:", gradeDistance.toFixed(2));
				}
			}

			// Toe point (calculated from hole geometry)
			if (hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
				const toeDistance = Math.sqrt(Math.pow(worldX - hole.endXLocation, 2) + Math.pow(worldY - hole.endYLocation, 2));
				if (toeDistance < minDistance) {
					minDistance = toeDistance;
					closestPoint = {
						x: hole.endXLocation,
						y: hole.endYLocation,
					};
					snapType = "Hole Toe (" + hole.holeID + ")";
					console.log("Found closer hole toe, distance:", toeDistance.toFixed(2));
				}
			}
		});
	} else {
		console.log("No holes found or allBlastHoles array is empty");
	}

	if (closestPoint) {
		console.log("SNAP FOUND:", snapType, "at", closestPoint.x.toFixed(2), closestPoint.y.toFixed(2), "distance:", minDistance.toFixed(2));
	} else {
		console.log("No snap allBlastHoles found within tolerance");
	}

	return closestPoint
		? {
			point: closestPoint,
			type: snapType,
			distance: minDistance,
		}
		: null;
}
// Helper function to find the closest vertex to a click point (keep original for compatibility)
function findClosestVertex(clickX, clickY, vertices, tolerance = getSnapToleranceInWorldUnits()) {
	let closestVertex = null;
	let minDistance = tolerance;

	vertices.forEach((vertex, index) => {
		const distance = Math.sqrt(Math.pow(clickX - vertex.x, 2) + Math.pow(clickY - vertex.y, 2));
		if (distance < minDistance) {
			minDistance = distance;
			closestVertex = {
				...vertex,
				index: index,
			};
		}
	});

	return closestVertex;
}
// Helper function to create a path between two vertices
// Now properly handles polygons as closed shapes
function createPathBetweenVertices(vertices, startVertex, endVertex, isPolygon = false) {
	const startIndex = startVertex.index;
	const endIndex = endVertex.index;

	if (startIndex === endIndex) {
		return [startVertex];
	}

	let pathVertices = [];

	if (!isPolygon) {
		// For open polylines/lines - original logic
		if (startIndex < endIndex) {
			for (let i = startIndex; i <= endIndex; i++) {
				pathVertices.push(vertices[i]);
			}
		} else {
			for (let i = startIndex; i >= endIndex; i--) {
				pathVertices.push(vertices[i]);
			}
		}
	} else {
		// For polygons - handle as closed loop
		const totalVertices = vertices.length;

		// Calculate forward path distance (going from start to end in forward direction)
		let forwardDistance;
		if (endIndex >= startIndex) {
			forwardDistance = endIndex - startIndex;
		} else {
			forwardDistance = totalVertices - startIndex + endIndex;
		}

		// Calculate backward path distance (going from start to end in backward direction)
		let backwardDistance;
		if (startIndex >= endIndex) {
			backwardDistance = startIndex - endIndex;
		} else {
			backwardDistance = startIndex + (totalVertices - endIndex);
		}

		// Choose the shorter path by default (can be overridden by reverse option)
		let useForwardPath = forwardDistance <= backwardDistance;

		if (useForwardPath) {
			// Forward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex + 1) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		} else {
			// Backward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex - 1 + totalVertices) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		}

		console.log("Polygon path created:", {
			startIndex: startIndex,
			endIndex: endIndex,
			forwardDistance: forwardDistance,
			backwardDistance: backwardDistance,
			usedForwardPath: useForwardPath,
			pathLength: pathVertices.length,
		});
	}

	return pathVertices;
}

function toRadians(degrees) {
	return (degrees * Math.PI) / 180;
}

function toDegrees(radians) {
	return (radians * 180) / Math.PI;
}

function toBearing(degrees) {
	return (degrees + 90) % 360;
}
// ADDED ROWID AND POSID
function generatePatternInPolygon(patternSettings) {
	if (!selectedPolygon || !patternStartPoint || !patternEndPoint || !patternReferencePoint) {
		console.error("Missing pattern data");
		return;
	}

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	console.log("Generating pattern in polygon. REF X:[" + patternReferencePoint.x + ", " + patternReferencePoint.y + "]");

	// Extract pattern settings
	const { blastName, burden, spacing, spacingOffset, collarZ, gradeZ, subdrill, angle, bearing, diameter, type, startNumber, nameTypeIsNumerical, useGradeZ, length, patternType } = patternSettings;

	// Calculate the orientation angle from start to end point
	const dx = patternEndPoint.x - patternStartPoint.x;
	const dy = patternEndPoint.y - patternStartPoint.y;

	// Calculate orientation (bearing from first to second point)
	let orientation = ((Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;

	console.log("Line bearing (Start to End):", orientation.toFixed(2) + "¬∞");

	// Get polygon vertices
	const polygonVertices = selectedPolygon.data.map((point) => ({
		x: point.pointXLocation,
		y: point.pointYLocation,
	}));

	console.log("Polygon vertices:", polygonVertices.length);

	// Find polygon bounds
	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;
	polygonVertices.forEach((vertex) => {
		const x = vertex.x;
		const y = vertex.y;
		minX = Math.min(minX, x);
		maxX = Math.max(maxX, x);
		minY = Math.min(minY, y);
		maxY = Math.max(maxY, y);
	});

	const polygonWidth = maxX - minX;
	const polygonHeight = maxY - minY;
	const polygonDiagonal = Math.sqrt(polygonWidth * polygonWidth + polygonHeight * polygonHeight);

	// Use the reference point as pattern origin
	const patternOriginX = patternReferencePoint.x;
	const patternOriginY = patternReferencePoint.y;
	console.log("Pattern in polygon. ORIGIN  X:[" + patternOriginX + ", " + patternOriginY + "]");

	// Store original holes count to identify new holes
	const originalHolesCount = allBlastHoles.length;

	// Generate the pattern grid
	const rowBearing = orientation;
	const columnBearing = (orientation + 90) % 360;

	console.log("Row bearing:", rowBearing.toFixed(2) + "¬∞");
	console.log("Column bearing:", columnBearing.toFixed(2) + "¬∞");

	const rowRadians = toRadians(rowBearing);
	const columnRadians = toRadians(columnBearing);

	// Calculate grid extents based on polygon size
	const bufferFactor = 10.0;
	const maxDistance = polygonDiagonal * bufferFactor;

	const numRows = Math.ceil(maxDistance / burden);
	const numCols = Math.ceil(maxDistance / spacing);

	const halfRows = Math.floor(numRows / 2);
	const halfCols = Math.floor(numCols / 2);

	// Find the grid point closest to (0,0)
	let centerGridX = 0;
	let centerGridY = 0;
	let minDistToCenter = Infinity;

	for (let i = -1; i <= 1; i++) {
		for (let k = -1; k <= 1; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const gridX = colOffset;
			const gridY = i * burden;
			const distToCenter = Math.sqrt(gridX * gridX + gridY * gridY);

			if (distToCenter < minDistToCenter) {
				minDistToCenter = distToCenter;
				centerGridX = gridX;
				centerGridY = gridY;
			}
		}
	}

	const gridXOffset = -centerGridX;
	const gridYOffset = -centerGridY;

	console.log("Grid adjustment: Found center grid point at (" + centerGridX.toFixed(2) + ", " + centerGridY.toFixed(2) + "), applying offset (" + gridXOffset.toFixed(2) + ", " + gridYOffset.toFixed(2) + ")");

	// Collect all holes that will be inside the polygon WITH their original grid coordinates
	const holesInPolygon = [];

	// Generate grid of holes - collect valid holes first
	for (let i = -halfRows; i <= halfRows; i++) {
		for (let k = -halfCols; k <= halfCols; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const adjustedColOffset = colOffset + gridXOffset;
			const adjustedRowOffset = i * burden + gridYOffset;

			// Calculate position using row and column bearings
			const yFromColumn = adjustedRowOffset * Math.sin(columnRadians);
			const xFromColumn = adjustedRowOffset * Math.cos(columnRadians);
			const yFromRow = adjustedColOffset * Math.sin(rowRadians);
			const xFromRow = adjustedColOffset * Math.cos(rowRadians);

			const holeX = patternOriginX + xFromColumn + xFromRow;
			const holeY = patternOriginY + yFromColumn + yFromRow;

			// Check if hole is inside polygon
			if (isPointInPolygonVertices(holeX, holeY, polygonVertices)) {
				holesInPolygon.push({
					x: holeX,
					y: holeY,
					originalGridRow: i,
					originalGridCol: k,
					isStaggered: isStaggered && i % 2 !== 0,
				});
			}
		}
	}

	// Group holes by their ORIGINAL GRID ROW
	const uniqueGridRows = [...new Set(holesInPolygon.map((hole) => hole.originalGridRow))];
	uniqueGridRows.sort((a, b) => a - b);

	console.log("Unique grid rows found:", uniqueGridRows);

	const rows = [];
	uniqueGridRows.forEach((gridRowIndex) => {
		const holesInThisGridRow = holesInPolygon.filter((hole) => hole.originalGridRow === gridRowIndex);

		const rowBearingRadians = (90 - orientation) * (Math.PI / 180);
		holesInThisGridRow.forEach((hole) => {
			hole.spacingProjection = hole.x * Math.cos(rowBearingRadians) + hole.y * Math.sin(rowBearingRadians);
		});

		holesInThisGridRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
		rows.push(holesInThisGridRow);
	});

	// Determine the actual grid ranges
	let minActualRow = Math.min(...uniqueGridRows);
	let maxActualRow = Math.max(...uniqueGridRows);
	let minActualCol = Infinity;
	let maxActualCol = -Infinity;

	holesInPolygon.forEach((hole) => {
		minActualCol = Math.min(minActualCol, hole.originalGridCol);
		maxActualCol = Math.max(maxActualCol, hole.originalGridCol);
	});

	console.log("Actual grid range: rows " + minActualRow + " to " + maxActualRow + ", cols " + minActualCol + " to " + maxActualCol);

	// Get the starting rowID for this pattern (first row will get this rowID)
	const startingRowID = getNextRowID(blastName);
	console.log("Starting rowID for polygon pattern:", startingRowID);

	let holeCounter = startNumber;

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	// Process rows from first (lowest row letter) to last (highest row letter)
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		// Check for cancellation before each row
		if (window.holeGenerationCancelled) {
			console.log("Pattern generation cancelled by user");
			break;
		}

		const row = rows[rowIndex];

		// Each row in the pattern gets its own rowID
		const currentRowID = startingRowID + rowIndex;

		// Calculate actual row letter based on the row's original grid position
		const actualRowGridIndex = row[0].originalGridRow;
		const rowLetterIndex = actualRowGridIndex - minActualRow;

		let rowLetter = "A";
		for (let l = 0; l < rowLetterIndex; l++) {
			rowLetter = incrementLetter(rowLetter);
		}

		// Process holes in this row
		for (let colIndex = 0; colIndex < row.length; colIndex++) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user");
				break;
			}

			const hole = row[colIndex];

			let holeID;
			if (nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				const actualColGridIndex = hole.originalGridCol;
				let colNumber = actualColGridIndex - minActualCol + 1;

				// Apply offset logic based on spacingOffset value and row position
				if (spacingOffset <= -1) {
					colNumber = colNumber + rowLetterIndex;
				} else if (spacingOffset > -1 && spacingOffset < 1) {
					// colNumber stays the same
				} else if (spacingOffset >= 1) {
					// colNumber stays the same
				}

				holeID = rowLetter + colNumber;
			}

			// Position ID is sequential for each hole in this row (starts at 1 for each row)
			const posID = colIndex + 1;

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Polygon pattern generation cancelled by user - stopping hole addition");
				break;
			}

			// Add hole using existing addHole function with rowID and posID
			addHole(true, useGradeZ, blastName, holeID, hole.x, hole.y, collarZ, gradeZ, diameter, type, length, subdrill, angle, bearing, currentRowID, posID, burden, spacing);
		}
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled polygon pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalHolesCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Polygon pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated pattern in polygon with " + holesAdded + " holes across " + rows.length + " rows (rowIDs " + startingRowID + "-" + (startingRowID + rows.length - 1) + ")");

		//! REDO with the FloatingDialog class
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated in the polygon. Please check your pattern settings and polygon shape.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog
		// else {
		// 	showModalMessage("Pattern Generated", "Successfully generated " + holesAdded + " holes in the polygon across " + rows.length + " rows (Rows " + startingRowID + "-" + (startingRowID + rows.length - 1) + ").", "success");
		// }
	}

	// Update display
	drawData(allBlastHoles, selectedHole);
	if (!window.holeGenerationCancelled) {
		debouncedSaveHoles(); // Auto-save holes to IndexedDB (only if not cancelled, since we already saved above)
	}
}

// Expose generatePatternInPolygon globally for PatternGenerationDialogs.js
window.generatePatternInPolygon = generatePatternInPolygon;

// Step 1) Converted to FloatingDialog class
// Function to show holes along line popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
// Update the generateHolesAlongLine function to correctly apply the bearing:
// Update the generateHolesAlongLine function to use rowID/posID:
function generateHolesAlongLine(params) {
	//! REDO with the FloatingDialog class
	if (!lineStartPoint || !lineEndPoint) {
		console.error("Missing line points");
		return;
	}

	console.log("Generating holes along line...");
	console.log("Start:", lineStartPoint);
	console.log("End:", lineEndPoint);
	console.log("Parameters:", params);

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
		console.log("Initialized empty allBlastHoles array");
	}

	// Calculate line length and direction
	const dx = lineEndPoint.x - lineStartPoint.x;
	const dy = lineEndPoint.y - lineStartPoint.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);
	const unitX = dx / lineLength;
	const unitY = dy / lineLength;

	// Calculate line bearing in world coordinates
	const lineBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;
	console.log("Line bearing:", lineBearing.toFixed(2) + "¬∞");

	// Generate holes along the line
	const numHoles = Math.floor(lineLength / params.spacing) + 1;
	const entityName = params.blastName || "LinePattern_" + Date.now();
	const originalHolesCount = allBlastHoles.length;

	// Calculate hole bearing based on user preference
	const holeBearing = params.useLineBearing ? (lineBearing + 90) % 360 : params.bearing;
	console.log("Using hole bearing:", holeBearing.toFixed(2) + "¬∞");

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for line pattern");

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	// Generate holes starting from the first point
	for (let i = 0; i < numHoles; i++) {
		// Check for cancellation before each hole
		if (window.holeGenerationCancelled) {
			console.log("Hole generation cancelled by user");
			break;
		}

		const distanceAlongLine = i * params.spacing;
		const holeX = lineStartPoint.x + unitX * distanceAlongLine;
		const holeY = lineStartPoint.y + unitY * distanceAlongLine;

		// Calculate hole ID
		let holeID;
		if (params.nameTypeIsNumerical) {
			holeID = params.startNumber + i;
		} else {
			// Use alphabetical naming like A1, A2, etc.
			const letter = String.fromCharCode(65 + Math.floor(i / 26));
			const number = (i % 26) + 1;
			holeID = letter + number;
		}

		// Position ID is sequential for each hole in this row
		const posID = i + 1;

		// Check for cancellation right before adding hole
		if (window.holeGenerationCancelled) {
			console.log("Line pattern generation cancelled by user - stopping hole addition");
			break;
		}

		// Add hole to points array with rowID and posID
		addHole(
			true, // useCustomHoleID - always true for pattern generation
			params.useGradeZ, // useGradeZ from params
			entityName,
			holeID, // holeID
			holeX, // startX
			holeY, // startY
			params.collarZ, // startZ
			params.gradeZ, // gradeZ
			params.diameter, // diameter
			params.type, // holeType
			params.length, // length
			params.subdrill, // subdrill
			params.angle, // angle
			holeBearing, // bearing - use calculated bearing perpendicular to line if useLineBearing is true
			rowID, // rowID - all holes in this line get the same rowID
			posID, // posID - sequential position in the row
			params.burden, // burden - Need to add to the show dialog popup for every hole add.
			params.spacing // spacing
		);
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled line pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Redraw
	debouncedUpdateTreeView(); // Use debounced version
	drawData(allBlastHoles, selectedHole);

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalHolesCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Line pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated " + holesAdded + " holes along line with rowID " + rowID);
		debouncedSaveHoles(); // Auto-save holes to IndexedDB

		//! REDO with the FloatingDialog class
		// Show success/failure message with custom styling
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated along the line. Please check your line and spacing settings.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog 
		// else {
		// 	showModalMessage("Line Pattern Generated", `Successfully generated ${holesAdded} holes along the line (Row ${rowID}).`, "success");
		// }
	}
}
// Expose generateHolesAlongLine globally for PatternGenerationDialogs.js
window.generateHolesAlongLine = generateHolesAlongLine;
// Expose global variables for PatternGenerationDialogs.js
window.holesAlongLineTool = holesAlongLineTool;
window.lineStartPoint = lineStartPoint;
window.lineEndPoint = lineEndPoint;
window.holesLineStep = holesLineStep;
/**
 * Finds the KAD entity (line or poly) closest to a world coordinate click.
 * This function unifies the logic for selecting both open and closed polylines.
 * @param {number} worldX The x-coordinate of the click in world units.
 * @param {number} worldY The y-coordinate of the click in world units.
 * @returns {object|null} The selected entity object or null if nothing is found.
 */
function getClickedKADEntity(worldX, worldY) {
	if (allKADDrawingsMap.size === 0) return null;

	const tolerance = getSnapToleranceInWorldUnits();
	const candidateEntities = [];

	// Check each line or poly entity
	for (const [name, entity] of allKADDrawingsMap.entries()) {
		// ? CHECK VISIBILITY FIRST - Skip hidden entities
		if (!isEntityVisible(name)) continue;

		const points = entity.data;
		if (points.length < 1) continue;

		let minDistance = Infinity;
		let clickedVertex = null;
		let clickedSegment = null;
		const isClosed = entity.entityType === "poly";

		// For single-point entities (points, circles, text), only check the point
		if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
			const point = points[0]; // These entities have only one point
			const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));

			if (distance <= tolerance) {
				candidateEntities.push({
					entity: entity,
					minDistance: distance,
					selectionType: "point",
					clickedVertex: {
						index: 0,
						x: point.pointXLocation,
						y: point.pointYLocation,
						distance: distance,
					},
					clickedSegment: null,
				});
			}
			continue; // Skip to next entity
		}
		if (entity.entityType === "line") {
			// For lines, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}
		if (entity.entityType === "poly") {
			// For polygons, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}

		// If no vertex found, check segments
		if (!clickedVertex) {
			const numSegments = isClosed ? points.length : points.length - 1;
			for (let i = 0; i < numSegments; i++) {
				const p1 = points[i];
				const p2 = points[(i + 1) % points.length]; // Wraps around for closed polys

				const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

				if (distance <= tolerance && distance < minDistance) {
					minDistance = distance;
					clickedSegment = {
						startIndex: i,
						endIndex: (i + 1) % points.length,
						startPoint: {
							x: p1.pointXLocation,
							y: p1.pointYLocation,
						},
						endPoint: {
							x: p2.pointXLocation,
							y: p2.pointYLocation,
						},
						distance: distance,
					};
				}
			}
		}

		// If we found a vertex or segment, add this entity as a candidate
		if (clickedVertex || clickedSegment) {
			candidateEntities.push({
				entity: entity,
				minDistance: minDistance,
				selectionType: clickedVertex ? "vertex" : "segment",
				clickedVertex: clickedVertex,
				clickedSegment: clickedSegment,
			});
		}
	}

	if (candidateEntities.length === 0) {
		console.log("No KAD entities found near click location");
		return null;
	}

	// Sort by distance (closest first)
	candidateEntities.sort((a, b) => a.minDistance - b.minDistance);
	const selected = candidateEntities[0];

	console.log("Found", candidateEntities.length, "entities near click.");
	console.log("Selected entity:", selected.entity.entityName, "by", selected.selectionType, "at distance:", selected.minDistance.toFixed(3));

	// Determine the snap point
	let snappedX = worldX;
	let snappedY = worldY;

	if (selected.clickedVertex) {
		snappedX = selected.clickedVertex.x;
		snappedY = selected.clickedVertex.y;
	} else if (selected.clickedSegment) {
		const seg = selected.clickedSegment;
		const closestPoint = getClosestPointOnLineSegment(worldX, worldY, seg.startPoint.x, seg.startPoint.y, seg.endPoint.x, seg.endPoint.y);
		snappedX = closestPoint.x;
		snappedY = closestPoint.y;
	}

	return {
		entity: selected.entity,
		clickedX: snappedX,
		clickedY: snappedY,
		selectionType: selected.selectionType,
		clickedVertex: selected.clickedVertex,
		clickedSegment: selected.clickedSegment,
	};
}
// Helper function to get interpolation parameter (0 to 1) for Z interpolation
function getInterpolationParameter(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;

	if (Math.abs(dx) > Math.abs(dy)) {
		return (px - x1) / dx;
	} else if (dy !== 0) {
		return (py - y1) / dy;
	} else {
		return 0; // Line segment is a point
	}
}
// Enhanced helper function to get closest point on line segment (add Z support)
function getClosestPointOnLineSegment(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		return {
			x: x1,
			y: y1,
			z: z1,
		};
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const result = {
		x: x1 + t * C,
		y: y1 + t * D,
	};

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		result.z = z1 + t * (z2 - z1);
	}

	return result;
}
//Add this helper function for point-in-polygon detection
function isPointInPolygonVertices(x, y, vertices) {
	let inside = false;
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		if (vertices[i].y > y !== vertices[j].y > y && x < ((vertices[j].x - vertices[i].x) * (y - vertices[i].y)) / (vertices[j].y - vertices[i].y) + vertices[i].x) {
			inside = !inside;
		}
	}
	return inside;
}
// Add this new function to detect clicked lines
function getClickedLine(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	if (allKADDrawingsMap.size === 0) return null;

	// Check each line entity
	for (const entity of allKADDrawingsMap.values()) {
		const linePoints = entity.data;
		if (linePoints.length < 2) continue; // Need at least 2 points for a line

		// Check each line segment
		for (let i = 0; i < linePoints.length - 1; i++) {
			const p1 = linePoints[i];
			const p2 = linePoints[i + 1];

			// Calculate distance from click point to line segment
			const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

			if (distance <= tolerance) {
				console.log("Found line:", entity);
				return {
					entity: entity,
					points: linePoints,
					segmentIndex: i,
					startPoint: {
						x: p1.pointXLocation,
						y: p1.pointYLocation,
					},
					endPoint: {
						x: p2.pointXLocation,
						y: p2.pointYLocation,
					},
				};
			}
		}
	}

	return null;
}
// Enhanced helper function for point-to-line-segment distance (add Z support)
function pointToLineSegmentDistance(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		// Line segment is actually a point
		return Math.sqrt(A * A + B * B);
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const projection_x = x1 + t * C;
	const projection_y = y1 + t * D;

	const dx = px - projection_x;
	const dy = py - projection_y;

	const distance = Math.sqrt(dx * dx + dy * dy);

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		const interpolatedZ = z1 + t * (z2 - z1);
		return {
			distance: distance,
			z: interpolatedZ,
		};
	}

	return distance;
}

// Add this new function for the pattern in polygon popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
function showPatternInPolygonPopup() {
	window.showPatternDialog("polygon_pattern", null, null);
}

function drawPatternInPolygonVisual() {
	if (!isPatternInPolygonActive) {
		// Hide overlay labels when tool is not active
		hidePatternToolLabels();
		return;
	}

	// Prepare overlay label data
	var overlayData = {
		toolType: "polygon"
	};

	// Draw selected polygon outline in bright color
	if (selectedPolygon) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		const polygonPoints = selectedPolygon.data; // ? Just use .data, not .points || .data
		if (polygonPoints && polygonPoints.length > 0) {
			ctx.beginPath();
			polygonPoints.forEach((point, index) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);

				if (index === 0) {
					ctx.moveTo(canvasX, canvasY);
				} else {
					ctx.lineTo(canvasX, canvasY);
				}
			});
			ctx.closePath();
			ctx.stroke();

			// Draw vertices as small circles
			polygonPoints.forEach((point) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);
				ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
				ctx.beginPath();
				ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
				ctx.fill();
			});
		}
	}

	// Draw start point (bright green)
	if (patternStartPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.startPoint = patternStartPoint;
		overlayData.startCanvasX = startX + canvas.getBoundingClientRect().left;
		overlayData.startCanvasY = startY + canvas.getBoundingClientRect().top;

		// Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!patternEndPoint) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);

			// Calculate preview distance
			const dx = currentMouseWorldX - patternStartPoint.x;
			const dy = currentMouseWorldY - patternStartPoint.y;
			const lineLength = Math.sqrt(dx * dx + dy * dy);

			// Add preview distance to overlay
			if (lineLength > 5) {
				const midX = (startX + currentMouseCanvasX) / 2;
				const midY = (startY + currentMouseCanvasY) / 2;
				overlayData.distance = lineLength;
				overlayData.midCanvasX = midX + canvas.getBoundingClientRect().left;
				overlayData.midCanvasY = midY + canvas.getBoundingClientRect().top;

				// Normalized line direction vector
				const dirX = dx / lineLength;
				const dirY = -dy / lineLength;

				// Perpendicular vector (-90¬∞ from line direction)
				const perpX = dirY;
				const perpY = -dirX;

				const arrowLength = 50;
				const arrowWidth = 24;
				const arrowOffset = 40;

				// Base point of the arrow (center of base)
				const baseX = midX + perpX * arrowOffset;
				const baseY = midY + perpY * arrowOffset;

				// Tip of the arrow (move further left)
				const tipX = baseX + perpX * arrowLength;
				const tipY = baseY + perpY * arrowLength;

				// Perpendicular to arrow direction (same as line dir!)
				const sideX = dirX * (arrowWidth / 2);
				const sideY = dirY * (arrowWidth / 2);

				// Base left/right points
				const leftX = baseX + sideX;
				const leftY = baseY + sideY;
				const rightX = baseX - sideX;
				const rightY = baseY - sideY;

				// Draw arrow (direction indicator)
				ctx.beginPath();
				ctx.moveTo(tipX, tipY); // Tip
				ctx.lineTo(leftX, leftY); // Left corner of base
				ctx.lineTo(rightX, rightY); // Right corner of base
				ctx.closePath();

				ctx.fillStyle = "#00ff00";
				ctx.globalAlpha = 0.3;
				ctx.fill();
				ctx.lineWidth = 2;
				ctx.strokeStyle = "#009900";
				ctx.globalAlpha = 1.0;
				ctx.stroke();
			}
		}
	}

	// Draw end point (bright red)
	if (patternEndPoint) {
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.endPoint = patternEndPoint;
		overlayData.endCanvasX = endX + canvas.getBoundingClientRect().left;
		overlayData.endCanvasY = endY + canvas.getBoundingClientRect().top;
	}

	// Draw reference point (magenta)
	if (patternReferencePoint) {
		const [refX, refY] = worldToCanvas(patternReferencePoint.x, patternReferencePoint.y);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.beginPath();
		ctx.arc(refX, refY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.refPoint = patternReferencePoint;
		overlayData.refCanvasX = refX + canvas.getBoundingClientRect().left;
		overlayData.refCanvasY = refY + canvas.getBoundingClientRect().top;
	}

	// Draw line from start to end to show spacing direction
	if (patternStartPoint && patternEndPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);

		// Draw the main line
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 1;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Calculate line length for overlay
		const dx = patternEndPoint.x - patternStartPoint.x;
		const dy = patternEndPoint.y - patternStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		// Set distance at midpoint for overlay
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		overlayData.distance = lineLength;
		overlayData.midCanvasX = midX + canvas.getBoundingClientRect().left;
		overlayData.midCanvasY = midY + canvas.getBoundingClientRect().top;
	}

	// Update overlay labels (moved from canvas text to HUD overlay)
	showPatternToolLabels(overlayData);
}

// 3D Visual feedback for Pattern in Polygon tool
// NOTE: The polygon itself is drawn by the main KAD drawing loop - we only draw markers and arrow here
function drawPatternInPolygon3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isPatternInPolygonActive || !threeInitialized || !threeRenderer) {
		if (window.patternTool3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.patternTool3DGroup);
			window.patternTool3DGroup = null;
		}
		// Step 0.1) Hide HUD labels and clear leading line when tool is inactive
		hidePatternToolLabels();
		clearKADLeadingLineThreeJS();
		return;
	}

	// Step 0a) Clear previous pattern tool 3D objects
	if (window.patternTool3DGroup) {
		threeRenderer.scene.remove(window.patternTool3DGroup);
		window.patternTool3DGroup = null;
	}

	// Step 0b) Create new group for pattern tool visuals
	window.patternTool3DGroup = new THREE.Group();
	window.patternTool3DGroup.name = "patternTool3DVisuals";

	// Step 0c) Get Z elevation from polygon's actual point data (Phase 4 fix)
	var drawZ = dataCentroidZ || 0;
	if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
		var firstPt = selectedPolygon.data[0];
		drawZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
	}
	drawZ += 0.5; // Slight offset above polygon

	// NOTE: Polygon highlight is now handled by highlightSelectedKADThreeJS() via window.selectedKADObject
	// We only draw markers, direction line, and arrow here

	// Step 1) Draw start point as billboard point (bright green)
	if (patternStartPoint) {
		var startLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		// Use polygon's Z if available, otherwise use drawZ
		var startZ = drawZ;
		if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			startZ = (firstPt.pointZLocation || firstPt.z || drawZ) + 0.2;
		} else {
			startZ = drawZ + 0.2;
		}
		var startPoint = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, startZ, 0.8, "rgba(0, 255, 0, 1.0)");
		window.patternTool3DGroup.add(startPoint);
	}

	// Step 2) Draw end point as billboard point (bright red)
	if (patternEndPoint) {
		var endLocal = worldToThreeLocal(patternEndPoint.x, patternEndPoint.y);
		// Use polygon's Z if available, otherwise use drawZ
		var endZ = drawZ;
		if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			endZ = (firstPt.pointZLocation || firstPt.z || drawZ) + 0.2;
		} else {
			endZ = drawZ + 0.2;
		}
		var endPoint = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 1.0)");
		window.patternTool3DGroup.add(endPoint);
	}

	// Step 3) Draw reference point as billboard point (magenta)
	if (patternReferencePoint) {
		var refLocal = worldToThreeLocal(patternReferencePoint.x, patternReferencePoint.y);
		// Use polygon's Z if available, otherwise use drawZ
		var refZ = drawZ;
		if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			refZ = (firstPt.pointZLocation || firstPt.z || drawZ) + 0.2;
		} else {
			refZ = drawZ + 0.2;
		}
		var refPoint = GeometryFactory.createKADPointHighlight(refLocal.x, refLocal.y, refZ, 0.8, "rgba(255, 0, 255, 1.0)");
		window.patternTool3DGroup.add(refPoint);
	}

	// Step 4) Draw direction line from start to end (or start to mouse) with perpendicular arrow
	var sLocal = null;
	var eLocal = null;
	var dx = 0;
	var dy = 0;
	var lineLength = 0;
	
	if (patternStartPoint && patternEndPoint) {
		// Full line from start to end
		sLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		eLocal = worldToThreeLocal(patternEndPoint.x, patternEndPoint.y);
		dx = patternEndPoint.x - patternStartPoint.x;
		dy = patternEndPoint.y - patternStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
		
		// Step 4a) Draw dashed line using cheap THREE.LineDashedMaterial (like drawKADLeadingLineThreeJS)
		// Use polygon's Z for line elevation
		var lineZ = drawZ;
		if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			lineZ = (firstPt.pointZLocation || firstPt.z || drawZ) + 0.1;
		} else {
			lineZ = drawZ + 0.1;
		}
		var linePoints = [
			new THREE.Vector3(sLocal.x, sLocal.y, lineZ),
			new THREE.Vector3(eLocal.x, eLocal.y, lineZ)
		];
		var lineGeom = new THREE.BufferGeometry().setFromPoints(linePoints);
		var lineMat = new THREE.LineDashedMaterial({
			color: 0x00ff00, // Green
			dashSize: 1.0,
			gapSize: 0.5,
			transparent: true,
			opacity: 0.7
		});
		var dirLine = new THREE.Line(lineGeom, lineMat);
		dirLine.computeLineDistances(); // Required for dashed lines
		window.patternTool3DGroup.add(dirLine);
	} else if (patternStartPoint && !patternEndPoint && currentMouseWorldX && currentMouseWorldY) {
		// Preview line to mouse cursor - handled by drawKADLeadingLineThreeJS in handle3DMouseMove
		// Just calculate values for arrow positioning
		sLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		eLocal = worldToThreeLocal(currentMouseWorldX, currentMouseWorldY);
		dx = currentMouseWorldX - patternStartPoint.x;
		dy = currentMouseWorldY - patternStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
	}

	// Step 5) Draw square pyramid arrow at exact midpoint of leading line
	// PatternInPolygon: Points toward END (increasing hole numbers), base parallel to line,
	// apex perpendicular to line, lies on side in XY plane
	if (sLocal && eLocal && lineLength > 1) {
		// Step 5a) Calculate line direction vector
		var dirX = dx / lineLength;
		var dirY = dy / lineLength;
		var dirZ = 0; // Line is in XY plane

		// Step 5b) Calculate exact midpoint of line using Vector3.lerp
		var startVec = new THREE.Vector3(sLocal.x, sLocal.y, drawZ);
		var endVec = new THREE.Vector3(eLocal.x, eLocal.y, drawZ);
		var midPoint = new THREE.Vector3().lerpVectors(startVec, endVec, 0.5);

		// Step 5c) Get polygon's Z elevation for correct positioning
		if (selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			var polygonZ = (firstPt.pointZLocation || firstPt.z || drawZ);
			midPoint.z = polygonZ; // Position at polygon's Z elevation
		}

		// Step 5d) Create flat triangle extruded 200mm (0.2 units) instead of pyramid
		// Triangle points perpendicular to direction line (burden direction)
		// Calculate perpendicular direction (90¬∞ clockwise from line direction)
		var perpX = dirY; // Perpendicular X (90¬∞ counter-clockwise)
		var perpY = -dirX;  // Perpendicular Y (90¬∞ counter-clockwise)
		var perpAngle = Math.atan2(perpY, perpX); // Angle of perpendicular direction
		
		// Create triangle shape: equilateral triangle, 2 units wide, pointing in perpendicular direction
		var triangleSize = 3.0; // Size of triangle base
		var triangleShape = new THREE.Shape();
		// Triangle vertices: point at top (0, triangleSize), base corners at (-triangleSize/2, 0) and (triangleSize/2, 0)
		triangleShape.moveTo(0, triangleSize);
		triangleShape.lineTo(-triangleSize / 2, 0);
		triangleShape.lineTo(triangleSize / 2, 0);
		triangleShape.lineTo(0, triangleSize); // Close triangle
		
		// Extrude settings: depth 0.2 (200mm), no bevel
		var extrudeSettings = {
			depth: 0.2, // 200mm extrusion
			bevelEnabled: false
		};
		
		// Create extruded triangle geometry
		var triangleGeom = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
		var triangleMat = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.6,
			side: THREE.DoubleSide
		});
		var triangle = new THREE.Mesh(triangleGeom, triangleMat);
		
		// Step 5e) Position triangle at exact midpoint
		triangle.position.copy(midPoint);
		
		// Step 5f) Orient triangle: lay flat on XY plane, point in perpendicular direction
		// IMPORTANT: PatternInPolygon triangle should be rotated 90¬∞ clockwise around Z axis
		// Triangle is created in XY plane (pointing up in +Y), rotate to point perpendicular to line
		triangle.rotation.z = perpAngle + Math.PI / 2; // Rotate 90¬∞ clockwise around Z to point perpendicular to line
		// Triangle is already flat on XY plane (no X rotation needed)

		window.patternTool3DGroup.add(triangle);

		// Step 5g) Add wireframe edge for visibility
		var edgeGeom = new THREE.EdgesGeometry(triangleGeom);
		var edgeMat = new THREE.LineBasicMaterial({ color: 0x008800 });
		var edges = new THREE.LineSegments(edgeGeom, edgeMat);
		edges.position.copy(triangle.position);
		edges.rotation.copy(triangle.rotation);
		window.patternTool3DGroup.add(edges);
	}

	// Step 6) Add group to scene
	threeRenderer.scene.add(window.patternTool3DGroup);
	
	// Step 8) Build overlay data for HUD labels (consistent with 2D)
	var overlayData = { toolType: "polygon" };
	
	// Step 8a) Add start point label
	if (patternStartPoint) {
		// FIX: Use actual Z from patternStartPoint or polygon
		var startZ = patternStartPoint.z;
		if (startZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			startZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
		}
		var screenStart = worldToScreen(patternStartPoint.x, patternStartPoint.y, startZ || dataCentroidZ || 0);
		if (screenStart) {
			overlayData.startPoint = patternStartPoint;
			overlayData.startCanvasX = screenStart.x;
			overlayData.startCanvasY = screenStart.y;
		}
	}
	
	// Step 8b) Add end point label
	if (patternEndPoint) {
		// FIX: Use actual Z from patternEndPoint or polygon
		var endZ = patternEndPoint.z;
		if (endZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			endZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
		}
		var screenEnd = worldToScreen(patternEndPoint.x, patternEndPoint.y, endZ || dataCentroidZ || 0);
		if (screenEnd) {
			overlayData.endPoint = patternEndPoint;
			overlayData.endCanvasX = screenEnd.x;
			overlayData.endCanvasY = screenEnd.y;
		}
	}
	
	// Step 8c) Add reference point label
	if (patternReferencePoint) {
		// FIX: Use actual Z from patternReferencePoint or polygon
		var refZ = patternReferencePoint.z;
		if (refZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
			var firstPt = selectedPolygon.data[0];
			refZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
		}
		var screenRef = worldToScreen(patternReferencePoint.x, patternReferencePoint.y, refZ || dataCentroidZ || 0);
		if (screenRef) {
			overlayData.refPoint = patternReferencePoint;
			overlayData.refCanvasX = screenRef.x;
			overlayData.refCanvasY = screenRef.y;
		}
	}
	
	// Step 8d) Add distance label
	if (patternStartPoint && patternEndPoint) {
		var dx = patternEndPoint.x - patternStartPoint.x;
		var dy = patternEndPoint.y - patternStartPoint.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		var midWorldX = (patternStartPoint.x + patternEndPoint.x) / 2;
		var midWorldY = (patternStartPoint.y + patternEndPoint.y) / 2;
		var screenMid = worldToScreen(midWorldX, midWorldY, dataCentroidZ || 0);
		if (screenMid) {
			overlayData.distance = distance;
			overlayData.midCanvasX = screenMid.x;
			overlayData.midCanvasY = screenMid.y;
		}
	}
	
	// Step 8e) Show HUD overlay labels
	showPatternToolLabels(overlayData);
}

// 3D Visual feedback for Holes Along Line tool
// Uses fat lines and billboard points to match 2D aesthetic and multiple KAD selection style
function drawHolesAlongLine3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isHolesAlongLineActive || !threeInitialized || !threeRenderer) {
		if (window.holesAlongLine3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.holesAlongLine3DGroup);
			window.holesAlongLine3DGroup = null;
		}
		// Step 0.1) Hide HUD labels when tool is inactive
		hidePatternToolLabels();
		return;
	}

	// Step 0a) Clear previous 3D objects
	if (window.holesAlongLine3DGroup) {
		threeRenderer.scene.remove(window.holesAlongLine3DGroup);
		window.holesAlongLine3DGroup = null;
	}

	// Step 0b) Create new group for tool visuals
	window.holesAlongLine3DGroup = new THREE.Group();
	window.holesAlongLine3DGroup.name = "holesAlongLine3DVisuals";

	// Step 0c) Get Z elevation for 3D drawing (slightly above surface)
	var drawZ = (dataCentroidZ || 0) + 0.5;

	// Step 0d) Get resolution for fat lines
	var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);

	// Step 1) Draw start point as billboard point (bright green)
	if (lineStartPoint) {
		var startLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		// FIX: Use actual Z from lineStartPoint
		var startZ = (lineStartPoint.z || drawZ) + 0.2;
		var startPoint = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, startZ, 0.8, "rgba(0, 255, 0, 0.8)");
		window.holesAlongLine3DGroup.add(startPoint);
	}

	// Step 2) Draw end point as billboard point (bright red)
	if (lineEndPoint) {
		var endLocal = worldToThreeLocal(lineEndPoint.x, lineEndPoint.y);
		// FIX: Use actual Z from lineEndPoint
		var endZ = (lineEndPoint.z || drawZ) + 0.2;
		var endPoint = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 0.8)");
		window.holesAlongLine3DGroup.add(endPoint);
	}

	// Step 3) Draw direction line and arrow - works for both completed line and preview
	var sLocal = null;
	var eLocal = null;
	var dx = 0;
	var dy = 0;
	var lineLength = 0;

	if (lineStartPoint && lineEndPoint) {
		// Full line from start to end
		sLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		eLocal = worldToThreeLocal(lineEndPoint.x, lineEndPoint.y);
		dx = lineEndPoint.x - lineStartPoint.x;
		dy = lineEndPoint.y - lineStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);

		// Step 3a) Draw dashed line using cheap THREE.LineDashedMaterial
		var lineZ = drawZ;
		if (lineStartPoint.z !== undefined) {
			lineZ = lineStartPoint.z + 0.1;
		} else if (lineEndPoint.z !== undefined) {
			lineZ = lineEndPoint.z + 0.1;
		}
		var linePoints = [
			new THREE.Vector3(sLocal.x, sLocal.y, lineZ),
			new THREE.Vector3(eLocal.x, eLocal.y, lineZ)
		];
		var lineGeom = new THREE.BufferGeometry().setFromPoints(linePoints);
		var lineMat = new THREE.LineDashedMaterial({
			color: 0x00ff00, // Green
			dashSize: 1.0,
			gapSize: 0.5,
			transparent: true,
			opacity: 0.7
		});
		var dirLine = new THREE.Line(lineGeom, lineMat);
		dirLine.computeLineDistances(); // Required for dashed lines
		window.holesAlongLine3DGroup.add(dirLine);
	} else if (lineStartPoint && !lineEndPoint && currentMouseWorldX && currentMouseWorldY) {
		// Preview line to mouse cursor - calculate values for arrow and label
		sLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		eLocal = worldToThreeLocal(currentMouseWorldX, currentMouseWorldY);
		dx = currentMouseWorldX - lineStartPoint.x;
		dy = currentMouseWorldY - lineStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
	}

	// Step 3b) Draw triangle arrow at midpoint (works for both completed and preview)
	if (sLocal && eLocal && lineLength > 1) {
		var dirX = dx / lineLength;
		var dirY = dy / lineLength;

		// Step 3c) Calculate midpoint
		var lineZ = drawZ;
		if (lineStartPoint.z !== undefined) {
			lineZ = lineStartPoint.z + 0.1;
		}
		var startVec = new THREE.Vector3(sLocal.x, sLocal.y, lineZ);
		var endVec = new THREE.Vector3(eLocal.x, eLocal.y, lineZ);
		var midPoint = new THREE.Vector3().lerpVectors(startVec, endVec, 0.5);

		// Step 3d) Create flat triangle extruded 200mm (0.2 units) pointing along line direction
		var triangleSize = 2.0;
		var triangleShape = new THREE.Shape();
		triangleShape.moveTo(0, triangleSize);
		triangleShape.lineTo(-triangleSize / 2, 0);
		triangleShape.lineTo(triangleSize / 2, 0);
		triangleShape.lineTo(0, triangleSize);

		var extrudeSettings = {
			depth: 0.2,
			bevelEnabled: false
		};

		var triangleGeom = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
		var triangleMat = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.6,
			side: THREE.DoubleSide
		});
		var triangle = new THREE.Mesh(triangleGeom, triangleMat);

		// Step 3e) Position triangle at exact midpoint
		triangle.position.copy(midPoint);

		// Step 3f) Orient triangle to point toward end
		var lineAngle = Math.atan2(dirY, dirX);
		triangle.rotation.z = lineAngle + Math.PI / 2 + Math.PI;

		window.holesAlongLine3DGroup.add(triangle);

		// Step 3g) Add wireframe edge for visibility
		var edgeGeom = new THREE.EdgesGeometry(triangleGeom);
		var edgeMat = new THREE.LineBasicMaterial({ color: 0x008800 });
		var edges = new THREE.LineSegments(edgeGeom, edgeMat);
		edges.position.copy(triangle.position);
		edges.rotation.copy(triangle.rotation);
		window.holesAlongLine3DGroup.add(edges);
	}

	// Step 4) Leading line from start to mouse is handled in handle3DMouseMove() (same as PatternInPolygon)
	// This ensures live updates as mouse moves

	// Step 5) Add group to scene
	threeRenderer.scene.add(window.holesAlongLine3DGroup);
	
	// Step 6) Build overlay data for HUD labels (consistent with 2D)
	var overlayData = { toolType: "line" };
	
	// Step 6a) Add start point label
	if (lineStartPoint) {
		var screenStart = worldToScreen(lineStartPoint.x, lineStartPoint.y, dataCentroidZ || 0);
		if (screenStart) {
			overlayData.startPoint = lineStartPoint;
			overlayData.startCanvasX = screenStart.x;
			overlayData.startCanvasY = screenStart.y;
		}
	}
	
	// Step 6b) Add end point label
	if (lineEndPoint) {
		var screenEnd = worldToScreen(lineEndPoint.x, lineEndPoint.y, dataCentroidZ || 0);
		if (screenEnd) {
			overlayData.endPoint = lineEndPoint;
			overlayData.endCanvasX = screenEnd.x;
			overlayData.endCanvasY = screenEnd.y;
		}
	}
	
	// Step 6c) Add distance label (works for both completed line and preview)
	if (lineStartPoint && (lineEndPoint || (currentMouseWorldX && currentMouseWorldY))) {
		// Use end point if it exists, otherwise use mouse position for preview
		var endX = lineEndPoint ? lineEndPoint.x : currentMouseWorldX;
		var endY = lineEndPoint ? lineEndPoint.y : currentMouseWorldY;

		var dx = endX - lineStartPoint.x;
		var dy = endY - lineStartPoint.y;
		var distance = Math.sqrt(dx * dx + dy * dy);
		// Calculate bearing: North = 0¬∞, East = 90¬∞ (clockwise)
		var bearing = (90 - (Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;
		var midWorldX = (lineStartPoint.x + endX) / 2;
		var midWorldY = (lineStartPoint.y + endY) / 2;
		var screenMid = worldToScreen(midWorldX, midWorldY, dataCentroidZ || 0);
		if (screenMid) {
			overlayData.distance = distance;
			overlayData.bearing = bearing;
			overlayData.midCanvasX = screenMid.x;
			overlayData.midCanvasY = screenMid.y;
		}
	}

	// Step 6d) Show HUD overlay labels
	showPatternToolLabels(overlayData);
}

// Add this function to draw poly line selection visuals
function drawPatternOnPolylineVisual() {
	if (!isHolesAlongPolyLineActive) return;

	// Add safety checks
	if (!selectedPolyline || !selectedPolyline.vertices || !Array.isArray(selectedPolyline.vertices)) {
		console.log("Can't draw along Polyline as there is no selectedPolyline, vertices or array");
		return;
	}

	// Step 1) Build overlay data for HUD labels (consistent with patternInPolygon)
	var overlayData = { toolType: "polyline" };
	var canvasRect = canvas.getBoundingClientRect();

	// Step 2) Draw selected polyline in bright color
	if (selectedPolyline) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		ctx.beginPath();
		selectedPolyline.vertices.forEach((vertex, index) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});

		// Close polygon if it's a polygon type
		if (selectedPolyline.type === "polygon") {
			ctx.closePath();
		}

		ctx.stroke();

		// Step 2a) Draw vertices as small circles
		selectedPolyline.vertices.forEach((vertex) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});

		// Step 2b) Highlight active segment (where holes will be placed) in cyan
		if (polylineStartPoint && polylineEndPoint) {
			// Find the segment indices for START and END
			var startIdx = -1;
			var endIdx = -1;
			for (var i = 0; i < selectedPolyline.vertices.length; i++) {
				var v = selectedPolyline.vertices[i];
				if (Math.abs(v.x - polylineStartPoint.x) < 0.01 && Math.abs(v.y - polylineStartPoint.y) < 0.01) {
					startIdx = i;
				}
				if (Math.abs(v.x - polylineEndPoint.x) < 0.01 && Math.abs(v.y - polylineEndPoint.y) < 0.01) {
					endIdx = i;
				}
			}
			
			// Draw active segments in cyan with thicker line
			if (startIdx !== -1 && endIdx !== -1 && startIdx !== endIdx) {
				ctx.strokeStyle = "#00FFFF"; // Cyan for active segment
				ctx.lineWidth = 5;
				ctx.setLineDash([]);
				ctx.beginPath();
				
				var minIdx = Math.min(startIdx, endIdx);
				var maxIdx = Math.max(startIdx, endIdx);
				
				for (var j = minIdx; j <= maxIdx; j++) {
					var vertex = selectedPolyline.vertices[j];
					const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
					if (j === minIdx) {
						ctx.moveTo(canvasX, canvasY);
					} else {
						ctx.lineTo(canvasX, canvasY);
					}
				}
				ctx.stroke();
			}
		}
	}

	// Step 3) Draw start point (bright green)
	if (polylineStartPoint) {
		const [startX, startY] = worldToCanvas(polylineStartPoint.x, polylineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 3a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.startPoint = polylineStartPoint;
		overlayData.startCanvasX = startX + canvasRect.left;
		overlayData.startCanvasY = startY + canvasRect.top;
	}

	// Step 4) Draw end point (bright red)
	if (polylineEndPoint) {
		const [endX, endY] = worldToCanvas(polylineEndPoint.x, polylineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 4a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.endPoint = polylineEndPoint;
		overlayData.endCanvasX = endX + canvasRect.left;
		overlayData.endCanvasY = endY + canvasRect.top;
	}

	// Step 5) Calculate total distance along polyline path if both points selected
	if (polylineStartPoint && polylineEndPoint && selectedPolyline && selectedPolyline.vertices) {
		var totalDist = 0;
		var startIdx = -1;
		var endIdx = -1;
		
		// Find indices
		for (var i = 0; i < selectedPolyline.vertices.length; i++) {
			var v = selectedPolyline.vertices[i];
			if (Math.abs(v.x - polylineStartPoint.x) < 0.01 && Math.abs(v.y - polylineStartPoint.y) < 0.01) {
				startIdx = i;
			}
			if (Math.abs(v.x - polylineEndPoint.x) < 0.01 && Math.abs(v.y - polylineEndPoint.y) < 0.01) {
				endIdx = i;
			}
		}
		
		if (startIdx !== -1 && endIdx !== -1) {
			var minIdx = Math.min(startIdx, endIdx);
			var maxIdx = Math.max(startIdx, endIdx);
			
			for (var j = minIdx; j < maxIdx; j++) {
				var v1 = selectedPolyline.vertices[j];
				var v2 = selectedPolyline.vertices[j + 1];
				var dx = v2.x - v1.x;
				var dy = v2.y - v1.y;
				totalDist += Math.sqrt(dx * dx + dy * dy);
			}
			
			// Calculate midpoint in canvas coords
			var midVertex = selectedPolyline.vertices[Math.floor((minIdx + maxIdx) / 2)];
			var [midX, midY] = worldToCanvas(midVertex.x, midVertex.y);
			overlayData.distance = totalDist;
			overlayData.midCanvasX = midX + canvasRect.left;
			overlayData.midCanvasY = midY + canvasRect.top;
		}
	}

	// Step 6) Update HUD overlay labels (consistent styling with patternInPolygon)
	showPatternToolLabels(overlayData);
}

// 3D Visual feedback for Holes Along Polyline tool
// Matches the clean, minimal 2D aesthetic with thin lines and small markers
function drawHolesAlongPolyline3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isHolesAlongPolyLineActive || !threeInitialized || !threeRenderer) {
		if (window.holesAlongPolyline3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.holesAlongPolyline3DGroup);
			window.holesAlongPolyline3DGroup = null;
		}
		// Step 0.1) Hide HUD labels when tool is inactive
		hidePatternToolLabels();
		return;
	}

	// Step 0a) Safety checks
	if (!selectedPolyline || !selectedPolyline.vertices || !Array.isArray(selectedPolyline.vertices)) {
		return;
	}

	// Step 0b) Clear previous 3D objects
	if (window.holesAlongPolyline3DGroup) {
		threeRenderer.scene.remove(window.holesAlongPolyline3DGroup);
		window.holesAlongPolyline3DGroup = null;
	}

	// Step 0c) Create new group for tool visuals
	window.holesAlongPolyline3DGroup = new THREE.Group();
	window.holesAlongPolyline3DGroup.name = "holesAlongPolyline3DVisuals";

	// Step 0d) Get Z elevation from selected polyline's actual Z values
	var drawZ = (dataCentroidZ || 0) + 0.5;
	// FIX: Use actual Z from selected polyline if available
	if (selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
		var firstVtx = selectedPolyline.vertices[0];
		drawZ = (firstVtx.z || dataCentroidZ || 0) + 0.5;
	}

	// Step 0e) Get resolution for fat lines
	var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);

	// NOTE: We do NOT draw the polyline outline here - it's already drawn by the main KAD drawing loop
	// The polyline is displayed in its original color from the KAD entity

	// Step 1) Highlight active segment (where holes will be placed) in cyan using fat lines
	if (polylineStartPoint && polylineEndPoint && selectedPolyline) {
		// Step 1a) Find the segment indices for START and END
		// FIX: Use entity.data to find indices (same as what we use for segments) for perfect alignment
		var startIdx = -1;
		var endIdx = -1;
		var searchPoints = selectedPolyline.entity && selectedPolyline.entity.data ? selectedPolyline.entity.data : selectedPolyline.vertices;
		
		for (var k = 0; k < searchPoints.length; k++) {
			var pt = searchPoints[k];
			var ptX = pt.pointXLocation || pt.x;
			var ptY = pt.pointYLocation || pt.y;
			if (Math.abs(ptX - polylineStartPoint.x) < 0.01 && Math.abs(ptY - polylineStartPoint.y) < 0.01) {
				startIdx = k;
				// FIX: Ensure polylineStartPoint has Z value from point
				var ptZ = pt.pointZLocation || pt.z;
				if (ptZ !== undefined && ptZ !== null && polylineStartPoint.z === undefined) {
					polylineStartPoint.z = ptZ;
				}
			}
			if (Math.abs(ptX - polylineEndPoint.x) < 0.01 && Math.abs(ptY - polylineEndPoint.y) < 0.01) {
				endIdx = k;
				// FIX: Ensure polylineEndPoint has Z value from point
				var ptZ = pt.pointZLocation || pt.z;
				if (ptZ !== undefined && ptZ !== null && polylineEndPoint.z === undefined) {
					polylineEndPoint.z = ptZ;
				}
			}
		}
		
		// Step 2b) Draw active segments in cyan using fat lines (thicker than green outline)
		if (startIdx !== -1 && endIdx !== -1 && startIdx !== endIdx) {
			var minIdx = Math.min(startIdx, endIdx);
			var maxIdx = Math.max(startIdx, endIdx);
			// Track if we're going from high index to low (reversed direction)
			var isReversed = startIdx > endIdx;
			
			// Step 2c) Collect cyan segments for active path
			// FIX: Use actual entity geometry (entity.data) instead of vertices array to ensure perfect alignment
			// This matches how drawKADEntityHighlight() works - uses entity.data directly
			var cyanSegments = [];
			if (selectedPolyline.entity && selectedPolyline.entity.data) {
				// Use entity.data directly (same as highlight function) for perfect geometry match
				var entityPoints = selectedPolyline.entity.data;
				var isClosedShape = selectedPolyline.type === "polygon";
				var numSegments = isClosedShape ? entityPoints.length : entityPoints.length - 1;
				
				for (var m = minIdx; m < maxIdx && m < numSegments; m++) {
					var point1 = entityPoints[m];
					var point2 = isClosedShape ? entityPoints[(m + 1) % entityPoints.length] : entityPoints[m + 1];
					
					var segLocal1 = worldToThreeLocal(point1.pointXLocation, point1.pointYLocation);
					var segLocal2 = worldToThreeLocal(point2.pointXLocation, point2.pointYLocation);
					
					// Use actual Z from entity points (same as highlight function)
					var cyanZ1 = (point1.pointZLocation || dataCentroidZ || 0) + 0.2;
					var cyanZ2 = (point2.pointZLocation || dataCentroidZ || 0) + 0.2;
					
					cyanSegments.push({
						x1: segLocal1.x, y1: segLocal1.y, z1: cyanZ1,
						x2: segLocal2.x, y2: segLocal2.y, z2: cyanZ2
					});
				}
			} else {
				// Fallback to vertices if entity.data not available
				for (var m = minIdx; m < maxIdx; m++) {
					var segVertex1 = selectedPolyline.vertices[m];
					var segVertex2 = selectedPolyline.vertices[m + 1];
					var segLocal1 = worldToThreeLocal(segVertex1.x, segVertex1.y);
					var segLocal2 = worldToThreeLocal(segVertex2.x, segVertex2.y);
					var cyanZ1 = (segVertex1.z !== undefined && segVertex1.z !== null) ? segVertex1.z + 0.2 : drawZ + 0.2;
					var cyanZ2 = (segVertex2.z !== undefined && segVertex2.z !== null) ? segVertex2.z + 0.2 : drawZ + 0.2;
					cyanSegments.push({
						x1: segLocal1.x, y1: segLocal1.y, z1: cyanZ1,
						x2: segLocal2.x, y2: segLocal2.y, z2: cyanZ2
					});
				}
			}
			
			// Step 2d) Create cyan fat lines for active segment (slightly thicker)
			if (cyanSegments.length > 0) {
				var cyanLines = GeometryFactory._createHighlightLinesBatch(cyanSegments, 5, resolution, "rgba(0, 255, 255, 1.0)");

				if (cyanLines) {
					window.holesAlongPolyline3DGroup.add(cyanLines);
				}
			}
			
			// Step 2e) Add small pyramid arrow at midpoint of active segment
			if (cyanSegments.length >= 1) {
				// Step 2f) Calculate midpoint and direction along active segment path
				var totalLength = 0;
				var segLengths = [];
				for (var n = 0; n < cyanSegments.length; n++) {
					var seg = cyanSegments[n];
					var dx = seg.x2 - seg.x1;
					var dy = seg.y2 - seg.y1;
					var len = Math.sqrt(dx * dx + dy * dy);
					segLengths.push(len);
					totalLength += len;
				}
				
				// Step 2g) Find midpoint along path
				var halfLength = totalLength / 2;
				var accumulated = 0;
				var midX = 0, midY = 0, dirX = 0, dirY = 0;
				for (var p = 0; p < cyanSegments.length; p++) {
					if (accumulated + segLengths[p] >= halfLength) {
						// Midpoint is on this segment
						var t = (halfLength - accumulated) / segLengths[p];
						var seg2 = cyanSegments[p];
						midX = seg2.x1 + t * (seg2.x2 - seg2.x1);
						midY = seg2.y1 + t * (seg2.y2 - seg2.y1);
						// Direction is along this segment toward end
						var segDx = seg2.x2 - seg2.x1;
						var segDy = seg2.y2 - seg2.y1;
						var segLen = Math.sqrt(segDx * segDx + segDy * segDy);
						if (segLen > 0) {
							dirX = segDx / segLen;
							dirY = segDy / segLen;
						}
						break;
					}
					accumulated += segLengths[p];
				}
				
				// Removed pyramid from HolesAlongPolyLine tool as per user requirements
			}
		}
	}

	// Step 3) Draw start point as billboard point (bright green)
	if (polylineStartPoint) {
		var startLocal = worldToThreeLocal(polylineStartPoint.x, polylineStartPoint.y);
		// FIX: Use actual Z from polylineStartPoint (check for undefined/null, not falsy)
		var startZ = (polylineStartPoint.z !== undefined && polylineStartPoint.z !== null) ? polylineStartPoint.z + 0.2 : drawZ + 0.2;
		var startPoint = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, startZ, 0.8, "rgba(0, 255, 0, 1.0)");
		window.holesAlongPolyline3DGroup.add(startPoint);
	}

	// Step 4) Draw end point as billboard point (bright red)
	if (polylineEndPoint) {
		var endLocal = worldToThreeLocal(polylineEndPoint.x, polylineEndPoint.y);
		// FIX: Use actual Z from polylineEndPoint (check for undefined/null, not falsy)
		var endZ = (polylineEndPoint.z !== undefined && polylineEndPoint.z !== null) ? polylineEndPoint.z + 0.2 : drawZ + 0.2;
		var endPoint = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 1.0)");
		window.holesAlongPolyline3DGroup.add(endPoint);
	}

	// Step 5) Add group to scene
	threeRenderer.scene.add(window.holesAlongPolyline3DGroup);
	
	// Step 6) Build overlay data for HUD labels (consistent with 2D)
	var overlayData = { toolType: "polyline" };
	
	// Step 6a) Add start point label
	if (polylineStartPoint) {
		// FIX: Use actual Z from polylineStartPoint or selected polyline
		var startZ = polylineStartPoint.z;
		if (!startZ && selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
			// Find matching vertex Z
			for (var vIdx = 0; vIdx < selectedPolyline.vertices.length; vIdx++) {
				var vtx = selectedPolyline.vertices[vIdx];
				if (Math.abs(vtx.x - polylineStartPoint.x) < 0.01 && Math.abs(vtx.y - polylineStartPoint.y) < 0.01) {
					startZ = vtx.z || dataCentroidZ || 0;
					break;
				}
			}
		}
		var screenStart = worldToScreen(polylineStartPoint.x, polylineStartPoint.y, startZ || dataCentroidZ || 0);
		if (screenStart) {
			overlayData.startPoint = polylineStartPoint;
			overlayData.startCanvasX = screenStart.x;
			overlayData.startCanvasY = screenStart.y;
		}
	}
	
	// Step 6b) Add end point label
	if (polylineEndPoint) {
		// FIX: Use actual Z from polylineEndPoint or selected polyline
		var endZ = polylineEndPoint.z;
		if (!endZ && selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
			// Find matching vertex Z
			for (var vIdx = 0; vIdx < selectedPolyline.vertices.length; vIdx++) {
				var vtx = selectedPolyline.vertices[vIdx];
				if (Math.abs(vtx.x - polylineEndPoint.x) < 0.01 && Math.abs(vtx.y - polylineEndPoint.y) < 0.01) {
					endZ = vtx.z || dataCentroidZ || 0;
					break;
				}
			}
		}
		var screenEnd = worldToScreen(polylineEndPoint.x, polylineEndPoint.y, endZ || dataCentroidZ || 0);
		if (screenEnd) {
			overlayData.endPoint = polylineEndPoint;
			overlayData.endCanvasX = screenEnd.x;
			overlayData.endCanvasY = screenEnd.y;
		}
	}
	
	// Step 6c) Add distance label if both points selected
	if (polylineStartPoint && polylineEndPoint && selectedPolyline && selectedPolyline.vertices) {
		// Calculate total distance along polyline path
		var startIdx = -1;
		var endIdx = -1;
		for (var idx = 0; idx < selectedPolyline.vertices.length; idx++) {
			var vtx = selectedPolyline.vertices[idx];
			if (Math.abs(vtx.x - polylineStartPoint.x) < 0.01 && Math.abs(vtx.y - polylineStartPoint.y) < 0.01) {
				startIdx = idx;
			}
			if (Math.abs(vtx.x - polylineEndPoint.x) < 0.01 && Math.abs(vtx.y - polylineEndPoint.y) < 0.01) {
				endIdx = idx;
			}
		}
		
		if (startIdx !== -1 && endIdx !== -1) {
			var totalDist = 0;
			var minI = Math.min(startIdx, endIdx);
			var maxI = Math.max(startIdx, endIdx);
			for (var dIdx = minI; dIdx < maxI; dIdx++) {
				var v1 = selectedPolyline.vertices[dIdx];
				var v2 = selectedPolyline.vertices[dIdx + 1];
				var ddx = v2.x - v1.x;
				var ddy = v2.y - v1.y;
				totalDist += Math.sqrt(ddx * ddx + ddy * ddy);
			}
			
			// Get midpoint along active segment
			var midVertex = selectedPolyline.vertices[Math.floor((minI + maxI) / 2)];
			var screenMid = worldToScreen(midVertex.x, midVertex.y, midVertex.z || dataCentroidZ || 0);
			if (screenMid) {
				overlayData.distance = totalDist;
				overlayData.midCanvasX = screenMid.x;
				overlayData.midCanvasY = screenMid.y;
			}
		}
	}
	
	// Step 6d) Show HUD overlay labels
	showPatternToolLabels(overlayData);
}

// Function to draw KAD polygon selection visuals
function drawKADPolygonHighlightSelectedVisuals() {
	if (!selectedKADPolygon || !isSelectionPointerActive) return;

	// Draw selected polygon outline in bright color
	ctx.strokeStyle = "#00FF00"; // Bright green like pattern tool
	ctx.lineWidth = 3;
	ctx.setLineDash([]);

	const polygonPoints = selectedKADPolygon.points || selectedKADPolygon.data;
	if (polygonPoints && polygonPoints.length > 0) {
		ctx.beginPath();
		polygonPoints.forEach((point, index) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);

			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});
		ctx.closePath();
		ctx.stroke();

		// Draw vertices as small red circles like pattern tool
		polygonPoints.forEach((point) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});
	}
}
// Step 1) Helper function moved to canvas2DDrawSelection.js module
// drawKADHighlightSelectionVisuals is now imported from module

function getEntityFromKADObject(kadObject) {
	// Everything is now in the unified map
	return allKADDrawingsMap.get(kadObject.entityName);
}

function drawHolesAlongLineVisuals() {
	// Only draw visuals if holes along line tool is active
	if (!isHolesAlongLineActive) return;

	// Step 1) Build overlay data for HUD labels (consistent with patternInPolygon)
	var overlayData = { toolType: "line" };
	var canvasRect = canvas.getBoundingClientRect();

	// Step 2) Draw start point (bright green) when selected
	if (lineStartPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 2a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.startPoint = lineStartPoint;
		overlayData.startCanvasX = startX + canvasRect.left;
		overlayData.startCanvasY = startY + canvasRect.top;

		// Step 2b) Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!lineEndPoint && holesLineStep === 1) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);

			// Step 2c) Calculate preview distance for HUD overlay
			const dx = currentMouseWorldX - lineStartPoint.x;
			const dy = currentMouseWorldY - lineStartPoint.y;
			const previewLength = Math.sqrt(dx * dx + dy * dy);

			if (previewLength > 5) {
				const midX = (startX + currentMouseCanvasX) / 2;
				const midY = (startY + currentMouseCanvasY) / 2;
				overlayData.distance = previewLength;
				overlayData.midCanvasX = midX + canvasRect.left;
				overlayData.midCanvasY = midY + canvasRect.top;
			}
		}
	}

	// Step 3) Draw end point (bright red) when selected
	if (lineEndPoint) {
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 3a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.endPoint = lineEndPoint;
		overlayData.endCanvasX = endX + canvasRect.left;
		overlayData.endCanvasY = endY + canvasRect.top;
	}

	// Step 4) Draw line connecting start and end points when both are selected
	if (lineStartPoint && lineEndPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);

		// Step 4a) Draw the main line (dashed green)
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 2;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Step 4b) Calculate line length and set distance for HUD overlay
		const dx = lineEndPoint.x - lineStartPoint.x;
		const dy = lineEndPoint.y - lineStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		overlayData.distance = lineLength;
		overlayData.midCanvasX = midX + canvasRect.left;
		overlayData.midCanvasY = midY + canvasRect.top;
	}

	// Step 5) Update HUD overlay labels (consistent styling with patternInPolygon)
	showPatternToolLabels(overlayData);
}
// Add this new function to generate holes along a polyline or polygon edge
// ADDED ROWID AND POSID
function generateHolesAlongPolyline(params, vertices) {
	if (!vertices || vertices.length < 2) {
		console.error("Not enough vertices to generate holes");
		return;
	}

	console.log("Generating holes along polyline with", vertices.length, "vertices");
	console.log("Parameters:", params);

	// Initialize points array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	const entityName = params.blastName || "PolylinePattern_" + Date.now();
	const originalPointsCount = allBlastHoles.length;
	let holeCounter = params.startNumber || 1;
	let currentLetter = "A";

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for polyline pattern");

	// Initialize cancellation flag for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern

	// Calculate total length of the polyline for progress tracking
	let totalLength = 0;
	for (let i = 0; i < vertices.length - 1; i++) {
		const dx = vertices[i + 1].x - vertices[i].x;
		const dy = vertices[i + 1].y - vertices[i].y;
		totalLength += Math.sqrt(dx * dx + dy * dy);
	}

	// Process each segment of the polyline
	let accumulatedLength = 0;
	let nextHoleDistance = 0;
	let positionCounter = 1; // Track position within the row

	for (let i = 0; i < vertices.length - 1; i++) {
		// Check for cancellation before each segment
		if (window.holeGenerationCancelled) {
			console.log("Hole generation cancelled by user");
			break;
		}
		const startPoint = vertices[i];
		const endPoint = vertices[i + 1];

		// Calculate segment properties
		const dx = endPoint.x - startPoint.x;
		const dy = endPoint.y - startPoint.y;
		const segmentLength = Math.sqrt(dx * dx + dy * dy);
		const unitX = dx / segmentLength;
		const unitY = dy / segmentLength;

		// Calculate segment bearing in world coordinates
		const segmentBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;

		// Calculate hole bearing based on user preference
		const holeBearing = params.useLineBearing ? (segmentBearing + 90) % 360 : params.bearing;

		// Place holes along this segment
		let distanceAlongSegment = nextHoleDistance;

		while (distanceAlongSegment < segmentLength) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Hole generation cancelled by user");
				break;
			}

			// Calculate hole position
			const holeX = startPoint.x + unitX * distanceAlongSegment;
			const holeY = startPoint.y + unitY * distanceAlongSegment;

			// Calculate hole ID
			let holeID;
			if (params.nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				// Use alphabetical naming like A1, A2, etc.
				const number = holeCounter % 26 || 26;
				if (number === 1 && holeCounter > 1) {
					// Increment letter when we wrap around
					if (currentLetter === "Z") {
						currentLetter = "AA";
					} else if (currentLetter.endsWith("Z")) {
						currentLetter = currentLetter.substring(0, currentLetter.length - 1) + "AA";
					} else {
						currentLetter = String.fromCharCode(currentLetter.charCodeAt(currentLetter.length - 1) + 1);
					}
				}
				holeID = currentLetter + number;
				holeCounter++;
			}

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Polyline pattern generation cancelled by user - stopping hole addition");
				break;
			}

			// Add hole with rowID and posID
			addHole(
				true, // useCustomHoleID
				params.useGradeZ, // useGradeZ
				entityName,
				holeID,
				holeX,
				holeY,
				params.collarZ,
				params.gradeZ,
				params.diameter,
				params.type,
				params.length,
				params.subdrill,
				params.angle,
				holeBearing,
				rowID, // All holes in this polyline get the same rowID
				positionCounter, // Sequential position along the polyline
				params.burden, // burden TODO: Add to the show dialog popup for every hole add.
				params.spacing // spacing TODO: Add to the show dialog popup for every hole add.
			);

			positionCounter++; // Increment position counter
			// Move to next hole position
			distanceAlongSegment += params.spacing;
		}

		// Calculate remaining distance for the next segment
		nextHoleDistance = distanceAlongSegment - segmentLength;
		accumulatedLength += segmentLength;
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled polyline pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Redraw
	drawData(allBlastHoles, selectedHole);

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalPointsCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Polyline pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated " + holesAdded + " holes along polyline with rowID " + rowID);
		debouncedSaveHoles(); // Auto-save holes to IndexedDB

		// Show success/failure message with custom styling
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated along the polyline. Please check your settings.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog
		// else if (holesAdded > 0) {
		// 	showModalMessage("Polyline Pattern Generated", "Successfully generated " + holesAdded + " holes along the polyline (Row " + rowID + ").", "success");
		// }
	}
}
// Expose generateHolesAlongPolyline globally for PatternGenerationDialogs.js
window.generateHolesAlongPolyline = generateHolesAlongPolyline;
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js

///----------------- ASSIGN HOLE START Z TO A SURFACE TOOL and ASSIGN HOLE GRADE Z to a surface -----------------///
// WITH this multi-surface system:
let loadedSurfaces = new Map(); // Map<surfaceId, {id, name, points, triangles, visible, gradient}>

// Step 0) Surface 2D rendering cache - stores pre-rendered surface images for performance
// Cache is invalidated when: surface properties change, zoom changes beyond threshold, or surface is modified
let surface2DCache = new Map(); // Map<surfaceId, {canvas, ctx, zoom, centroidX, centroidY, bounds, gradient, minLimit, maxLimit, transparency}>
const SURFACE_CACHE_ZOOM_THRESHOLD = 1.5; // Re-render if zoom changes by more than 50%
const SURFACE_CACHE_OVERSAMPLE = 1.0; // Render at 1x resolution (can increase for quality)

// Step 0a) Check if surface cache is valid for current view
function isSurfaceCacheValid(surfaceId, surface) {
	var cache = surface2DCache.get(surfaceId);
	if (!cache) return false;

	// Step 0b) Check if surface properties changed
	if (cache.gradient !== (surface.gradient || "default")) return false;
	if (cache.minLimit !== surface.minLimit) return false;
	if (cache.maxLimit !== surface.maxLimit) return false;
	if (cache.transparency !== (surface.transparency || 1.0)) return false;
	if (cache.hillshadeColor !== (surface.hillshadeColor || null)) return false;

	// Step 0c) Check if zoom changed too much
	var zoomRatio = currentScale / cache.zoom;
	if (zoomRatio > SURFACE_CACHE_ZOOM_THRESHOLD || zoomRatio < (1 / SURFACE_CACHE_ZOOM_THRESHOLD)) {
		return false;
	}

	return true;
}

// Step 0d) Render surface to off-screen canvas cache
function renderSurfaceToCache(surfaceId, surface, surfaceMinZ, surfaceMaxZ) {
	// Step 1) Calculate surface bounds in world coordinates
	var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
	surface.points.forEach(function (point) {
		if (point.x < minX) minX = point.x;
		if (point.x > maxX) maxX = point.x;
		if (point.y < minY) minY = point.y;
		if (point.y > maxY) maxY = point.y;
	});

	// Step 2) Add padding to bounds (5% each side)
	var padX = (maxX - minX) * 0.05;
	var padY = (maxY - minY) * 0.05;
	minX -= padX; maxX += padX;
	minY -= padY; maxY += padY;

	// Step 3) Calculate canvas size based on world bounds and current scale
	var worldWidth = maxX - minX;
	var worldHeight = maxY - minY;
	var cacheWidth = Math.ceil(worldWidth * currentScale * SURFACE_CACHE_OVERSAMPLE);
	var cacheHeight = Math.ceil(worldHeight * currentScale * SURFACE_CACHE_OVERSAMPLE);

	// Step 4) Limit max cache size to prevent memory issues
	var maxCacheSize = 4096;
	if (cacheWidth > maxCacheSize || cacheHeight > maxCacheSize) {
		var scaleDown = maxCacheSize / Math.max(cacheWidth, cacheHeight);
		cacheWidth = Math.ceil(cacheWidth * scaleDown);
		cacheHeight = Math.ceil(cacheHeight * scaleDown);
	}

	// Step 5) Create or reuse off-screen canvas
	var cacheCanvas = document.createElement("canvas");
	cacheCanvas.width = cacheWidth;
	cacheCanvas.height = cacheHeight;
	var cacheCtx = cacheCanvas.getContext("2d");

	// Step 6) Set up transform to map world coords to cache canvas
	// Cache canvas origin is at (minX, maxY) in world coords (Y flipped)
	var cacheScale = cacheWidth / worldWidth;

	// Step 7) Clear and set up context
	cacheCtx.clearRect(0, 0, cacheWidth, cacheHeight);

	// Step 8) Draw each triangle to cache canvas
	var gradient = surface.gradient || "default";
	var transparency = surface.transparency || 1.0;

	surface.triangles.forEach(function (triangle) {
		var p1 = triangle.vertices[0];
		var p2 = triangle.vertices[1];
		var p3 = triangle.vertices[2];

		// Convert world coords to cache canvas coords
		var x1 = (p1.x - minX) * cacheScale;
		var y1 = (maxY - p1.y) * cacheScale; // Y flipped
		var x2 = (p2.x - minX) * cacheScale;
		var y2 = (maxY - p2.y) * cacheScale;
		var x3 = (p3.x - minX) * cacheScale;
		var y3 = (maxY - p3.y) * cacheScale;

		var z1 = p1.z;
		var z2 = p2.z;
		var z3 = p3.z;

		// Draw triangle with solid color (average elevation)
		var avgZ = (z1 + z2 + z3) / 3;

		cacheCtx.globalAlpha = transparency;
		cacheCtx.beginPath();
		cacheCtx.moveTo(x1, y1);
		cacheCtx.lineTo(x2, y2);
		cacheCtx.lineTo(x3, y3);
		cacheCtx.closePath();

		// Handle hillshade specially
		if (gradient === "hillshade") {
			var aspectData = getTriangleAspect(triangle);
			var hillshadeColor = getHillshadeColor(aspectData.aspect, aspectData.slope, aspectData.isFlat, lightBearing, lightElevation, surface.hillshadeColor || null);
			cacheCtx.fillStyle = hillshadeColor;
		} else {
			cacheCtx.fillStyle = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, surface.minLimit, surface.maxLimit);
		}
		cacheCtx.fill();
	});

	// Step 9) Store cache entry
	surface2DCache.set(surfaceId, {
		canvas: cacheCanvas,
		zoom: currentScale,
		bounds: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
		gradient: gradient,
		minLimit: surface.minLimit,
		maxLimit: surface.maxLimit,
		transparency: transparency,
		hillshadeColor: surface.hillshadeColor || null
	});

	if (developerModeEnabled) {
		console.log("üì¶ Surface cache created for " + surfaceId + ": " + cacheWidth + "x" + cacheHeight + " at zoom " + currentScale.toFixed(2));
	}

	return surface2DCache.get(surfaceId);
}

// Step 0e) Draw cached surface to main canvas
function drawCachedSurface(cache) {
	if (!cache || !cache.canvas) return false;

	// Step 1) Calculate where to draw the cached image on main canvas
	var topLeft = worldToCanvas(cache.bounds.minX, cache.bounds.maxY);
	var bottomRight = worldToCanvas(cache.bounds.maxX, cache.bounds.minY);

	var destX = topLeft[0];
	var destY = topLeft[1];
	var destWidth = bottomRight[0] - topLeft[0];
	var destHeight = bottomRight[1] - topLeft[1];

	// Step 2) Draw the cached canvas image
	ctx.drawImage(cache.canvas, destX, destY, destWidth, destHeight);

	return true;
}

// Step 0f) Invalidate surface cache (call when surface properties change)
function invalidateSurfaceCache(surfaceId) {
	if (surfaceId) {
		surface2DCache.delete(surfaceId);
	} else {
		// Invalidate all caches
		surface2DCache.clear();
	}
}

// Step 0g) Export invalidate function for use in context menu
window.invalidateSurfaceCache = invalidateSurfaceCache;

const assignSurfaceToHolesTool = document.getElementById("assignSurfaceTool");
const assignGradeTool = document.getElementById("assignGradeTool");
let showSurfaceLegend = true; // Add legend visibility control
let currentGradient = "default"; // Default gradient
// Add these variables near your other surface variables
let surfaceTransparency = 1.0; // Default fully opaque (same as image.transparency pattern)

//IMPORTANT - THIS IS THE FUNCTION THAT ASSIGNS THE HOLE TO THE SURFACE
function assignHoleToSurface(hole) {
	const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation);
	if (surfaceZ !== null) {
		hole.startZLocation = surfaceZ;
		hole.gradeZLocation = surfaceZ + hole.length; // Adjust grade accordingly
		// console.log("Assigned hole: " + hole.holeID + " to surface elevation: " + surfaceZ.toFixed(2) + "m");
	}
}
// NEW: Check if click point is actually on a surface triangle
function isPointInSurface(x, y) {
	// Check all loaded surfaces
	if (loadedSurfaces.size === 0) {
		return null; // Changed from false to null
	}

	// Convert canvas coordinates to world coordinates
	const worldX = (x - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(y - canvas.height / 2) / currentScale + centroidY;

	// Check if point is inside any triangle of any visible surface
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		// Check if point is inside any triangle
		for (let triangle of surface.triangles) {
			if (isPointInTriangle(worldX, worldY, triangle.vertices)) {
				return surfaceId; // Return the specific surface ID
			}
		}
	}

	return null; // Changed from false to null
}
// Determines if a point is inside a triangle using barycentric coordinates.
function isPointInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a >= 0 && b >= 0 && c >= 0;
}
// Interpolates the Z value of a point inside a triangle using barycentric coordinates.
function interpolateZInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a * v0.z + b * v1.z + c * v2.z;
}

// Interpolates the Z value of a point on the surface.
function interpolateZFromSurface(x, y, surfaceId = null) {
	// If surfaceId is specified, only check that surface
	if (surfaceId) {
		const surface = loadedSurfaces.get(surfaceId);
		if (surface && surface.visible && surface.triangles && surface.triangles.length > 0) {
			for (const triangle of surface.triangles) {
				if (isPointInTriangle(x, y, triangle.vertices)) {
					return interpolateZInTriangle(x, y, triangle.vertices);
				}
			}
		}
		return null; // Point not on specified surface
	}

	// Original behavior: Find triangle containing point (x, y) from all loaded surfaces
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		for (const triangle of surface.triangles) {
			if (isPointInTriangle(x, y, triangle.vertices)) {
				return interpolateZInTriangle(x, y, triangle.vertices);
			}
		}
	}
	return null; // Point not on surface
}

// Loads a point cloud file and processes it.
function loadPointCloudFile(file) {
	var fileExtension = file.name.split(".").pop().toLowerCase();

	// Step 1) OBJ files should use the textured mesh loader with auto-discovery
	if (fileExtension === "obj") {
		loadOBJWithAutoDiscovery(file);
		return;
	}

	// Step 2) All other point cloud formats - standard loading
	var reader = new FileReader();

	// Show loading progress
	updateStatusMessage("Loading surface file: " + file.name + "...");

	reader.onload = function (e) {
		var content = e.target.result;
		var points;

		try {
			switch (fileExtension) {
				case "xyz":
					points = parseXYZFile(content);
					break;
				case "asc":
					points = parseASCFile(content);
					break;
				case "txt":
					points = parseTXTFile(content);
					break;
				case "csv":
					points = parseCSVPointCloud(content);
					break;
				case "ply":
					points = parsePLYFile(content);
					break;
				case "pts":
					points = parsePTSFile(content);
					break;
				default:
					// Default to the existing parser for backward compatibility
					points = parsePointCloudData(content);
			}

			if (points && points.length > 0) {
				// Check if decimation is needed for performance
				if (points.length > 10000) {
					showDecimationWarning(points, file.name);
				} else {
					processSurfacePoints(points, file.name);
				}
			} else {
				updateStatusMessage("No valid points found in: " + file.name);
			}
		} catch (error) {
			console.error("Error parsing surface file:", error);
			updateStatusMessage("Error loading surface file: " + error.message);
		}
	};
	reader.readAsText(file);
}

// Step 1) Auto-discover companion MTL/texture files for OBJ
async function loadOBJWithAutoDiscovery(objFile) {
	try {
		updateStatusMessage("Loading OBJ: " + objFile.name + " (searching for MTL/textures...)");

		var objContent = await readFileAsText(objFile);
		var baseName = objFile.name.replace(/\.obj$/i, "");

		// Step 2) Parse OBJ to check for material library reference
		var objData = parseOBJFile(objContent, null);

		// Step 3) Try to auto-discover companion files using File System Access API
		var mtlContent = null;
		var textureBlobs = {};
		var companionFilesFound = false;

		// Step 4) Check if browser supports File System Access API and file has handle
		if (objFile.handle && objFile.handle.getParent) {
			// We have directory access - can auto-discover
			try {
				var dirHandle = await objFile.handle.getParent();
				var result = await discoverCompanionFiles(dirHandle, baseName);
				mtlContent = result.mtlContent;
				textureBlobs = result.textureBlobs;
				companionFilesFound = result.found;
			} catch (err) {
				console.log("üß≠ Directory access not available, trying alternative method");
			}
		}

		// Step 5) If no companion files found via directory access, try URL-based discovery
		if (!companionFilesFound && objData.materialLibrary) {
			// Check if we're running locally with file:// protocol or have server access
			try {
				var result = await discoverCompanionFilesViaFetch(objFile, baseName, objData.materialLibrary);
				mtlContent = result.mtlContent;
				textureBlobs = result.textureBlobs;
				companionFilesFound = result.found;
			} catch (err) {
				console.log("üß≠ Fetch-based discovery not available");
			}
		}

		// Step 6) If companion files found, use textured mesh loader
		if (companionFilesFound && mtlContent && Object.keys(textureBlobs).length > 0) {
			console.log("üîé Found companion files - loading as textured mesh");
			updateStatusMessage("Found MTL and textures - loading textured mesh...");

			// Update objData with mtlContent
			objData.mtlContent = mtlContent;

			await loadOBJWithTextureThreeJS(objFile.name, objContent, mtlContent, textureBlobs, objData);
		}
		// Step 7) If MTL found but no textures, still try textured loading
		else if (companionFilesFound && mtlContent) {
			console.log("üîé Found MTL file - loading with materials (no textures)");
			updateStatusMessage("Found MTL - loading with materials...");

			objData.mtlContent = mtlContent;
			await loadOBJWithTextureThreeJS(objFile.name, objContent, mtlContent, textureBlobs, objData);
		}
		// Step 8) No companion files - check if OBJ has faces, use appropriate method
		else if (objData.hasFaces && objData.triangles.length > 0) {
			console.log("üßä OBJ has faces - loading as surface with original topology");
			updateStatusMessage("Loading OBJ surface: " + objFile.name);

			// Use the parsed triangles directly (preserves original mesh topology)
			createSurfaceFromOBJData(objData, objFile.name);
		}
		// Step 9) Fallback - no faces, use as point cloud
		else {
			console.log("üßä OBJ has no faces - loading as point cloud");
			updateStatusMessage("Loading OBJ as point cloud: " + objFile.name);

			if (objData.points && objData.points.length > 0) {
				if (objData.points.length > 10000) {
					showDecimationWarning(objData.points, objFile.name, objData);
				} else {
					processSurfacePoints(objData.points, objFile.name, objData);
				}
			} else {
				updateStatusMessage("No valid points found in: " + objFile.name);
			}
		}
	} catch (error) {
		console.error("‚ùå Error in loadOBJWithAutoDiscovery:", error);
		updateStatusMessage("Error loading OBJ: " + error.message);
	}
}

// Step 1) Discover companion files via directory handle (File System Access API)
async function discoverCompanionFiles(dirHandle, baseName) {
	var mtlContent = null;
	var textureBlobs = {};
	var found = false;

	try {
		// Step 2) Iterate through directory entries
		for await (var entry of dirHandle.values()) {
			if (entry.kind !== "file") continue;

			var fileName = entry.name;
			var fileNameLower = fileName.toLowerCase();
			var baseNameLower = baseName.toLowerCase();

			// Step 3) Check for MTL file
			if (fileNameLower === baseNameLower + ".mtl") {
				var mtlFile = await entry.getFile();
				mtlContent = await mtlFile.text();
				found = true;
				console.log("üîé Found MTL: " + fileName);
			}

			// Step 4) Check for texture files (same base name or referenced in MTL)
			var ext = fileName.split(".").pop().toLowerCase();
			if (ext === "jpg" || ext === "jpeg" || ext === "png" || ext === "gif" || ext === "bmp") {
				// Check if it starts with base name or is commonly used
				if (fileNameLower.startsWith(baseNameLower) || fileNameLower.includes(baseNameLower) || fileNameLower === "texture." + ext || fileNameLower === "diffuse." + ext) {
					var texFile = await entry.getFile();
					textureBlobs[fileName] = await texFile.arrayBuffer().then(function (buf) {
						return new Blob([buf], { type: texFile.type });
					});
					found = true;
					console.log("üîé Found texture: " + fileName);
				}
			}
		}
	} catch (err) {
		console.warn("Error discovering companion files:", err);
	}

	return { mtlContent: mtlContent, textureBlobs: textureBlobs, found: found };
}

// Step 1) Discover companion files via fetch (for server-hosted files)
async function discoverCompanionFilesViaFetch(objFile, baseName, materialLibrary) {
	var mtlContent = null;
	var textureBlobs = {};
	var found = false;

	// Step 2) This only works if we have URL access to the files
	// For local file:// URLs, this won't work due to CORS
	// For http:// URLs, it might work if same-origin

	try {
		// Step 3) Get the base URL from the file
		var fileURL = "";
		if (objFile.path) {
			// Electron or similar - has path
			var pathParts = objFile.path.split(/[/\\]/);
			pathParts.pop(); // Remove filename
			fileURL = pathParts.join("/") + "/";
		} else if (objFile.webkitRelativePath) {
			// Directory upload
			var pathParts = objFile.webkitRelativePath.split("/");
			pathParts.pop();
			fileURL = pathParts.join("/") + "/";
		}

		if (!fileURL) {
			return { mtlContent: null, textureBlobs: {}, found: false };
		}

		// Step 4) Try to fetch MTL
		var mtlFileName = materialLibrary || baseName + ".mtl";
		try {
			var mtlResponse = await fetch(fileURL + mtlFileName);
			if (mtlResponse.ok) {
				mtlContent = await mtlResponse.text();
				found = true;
				console.log("üîé Fetched MTL: " + mtlFileName);

				// Step 5) Parse MTL to find texture references
				var textureRefs = extractTextureRefsFromMTL(mtlContent);

				// Step 6) Fetch each texture
				for (var i = 0; i < textureRefs.length; i++) {
					var texName = textureRefs[i];
					try {
						var texResponse = await fetch(fileURL + texName);
						if (texResponse.ok) {
							var blob = await texResponse.blob();
							textureBlobs[texName] = blob;
							console.log("üîé Fetched texture: " + texName);
						}
					} catch (texErr) {
						console.warn("Could not fetch texture: " + texName);
					}
				}
			}
		} catch (mtlErr) {
			console.warn("Could not fetch MTL: " + mtlFileName);
		}
	} catch (err) {
		console.warn("Error in fetch-based discovery:", err);
	}

	return { mtlContent: mtlContent, textureBlobs: textureBlobs, found: found };
}

// Step 1) Extract texture file references from MTL content
function extractTextureRefsFromMTL(mtlContent) {
	var textureRefs = [];
	var lines = mtlContent.split("\n");

	lines.forEach(function (line) {
		var trimmed = line.trim();
		// Look for map_Kd (diffuse texture), map_Ka (ambient), map_Ks (specular), etc.
		if (trimmed.startsWith("map_Kd ") || trimmed.startsWith("map_Ka ") || trimmed.startsWith("map_Ks ") || trimmed.startsWith("map_Bump ") || trimmed.startsWith("bump ")) {
			var parts = trimmed.split(/\s+/);
			if (parts.length >= 2) {
				var texFile = parts[parts.length - 1]; // Last part is usually the filename
				if (textureRefs.indexOf(texFile) === -1) {
					textureRefs.push(texFile);
				}
			}
		}
	});

	return textureRefs;
}

// Step 1a) Extract material properties from MTL content (serializable for IndexedDB)
function extractMaterialProperties(mtlContent) {
	var materialProperties = {};
	var lines = mtlContent.split("\n");
	var currentMaterial = null;

	lines.forEach(function (line) {
		var trimmed = line.trim();

		// Skip empty lines and comments
		if (!trimmed || trimmed.startsWith("#")) {
			return;
		}

		var parts = trimmed.split(/\s+/);
		var command = parts[0];

		// New material definition
		if (command === "newmtl") {
			currentMaterial = parts.slice(1).join(" ").trim();
			materialProperties[currentMaterial] = {
				name: currentMaterial,
				Ka: [0, 0, 0], // Ambient color (default black)
				Kd: [1, 1, 1], // Diffuse color (default white)
				Ks: [0, 0, 0], // Specular color (default black)
				Ns: 0, // Shininess (default 0)
				map_Kd: null, // Diffuse texture filename
				map_Ka: null, // Ambient texture filename
				map_Ks: null, // Specular texture filename
				illum: 2, // Illumination model (default 2)
			};
		}
		// Ambient color
		else if (command === "Ka" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Ka = [parseFloat(parts[1]) || 0, parseFloat(parts[2]) || 0, parseFloat(parts[3]) || 0];
		}
		// Diffuse color
		else if (command === "Kd" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Kd = [parseFloat(parts[1]) || 1, parseFloat(parts[2]) || 1, parseFloat(parts[3]) || 1];
		}
		// Specular color
		else if (command === "Ks" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Ks = [parseFloat(parts[1]) || 0, parseFloat(parts[2]) || 0, parseFloat(parts[3]) || 0];
		}
		// Shininess
		else if (command === "Ns" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].Ns = parseFloat(parts[1]) || 0;
		}
		// Diffuse texture map
		else if (command === "map_Kd" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Kd = parts.slice(1).join(" ").trim();
		}
		// Ambient texture map
		else if (command === "map_Ka" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Ka = parts.slice(1).join(" ").trim();
		}
		// Specular texture map
		else if (command === "map_Ks" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Ks = parts.slice(1).join(" ").trim();
		}
		// Illumination model
		else if (command === "illum" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].illum = parseInt(parts[1]) || 2;
		}
	});

	return materialProperties;
}

// Step 1b) Create THREE.Material from stored properties + texture (already loaded THREE.Texture object)
function createMaterialFromProperties(materialProps, texture, textureName) {
	if (!materialProps) {
		// Fallback: create default material
		materialProps = {
			Kd: [1, 1, 1],
			Ns: 0,
			map_Kd: textureName,
		};
	}

	var material = new THREE.MeshStandardMaterial({
		color: new THREE.Color(materialProps.Kd[0] || 1, materialProps.Kd[1] || 1, materialProps.Kd[2] || 1),
		shininess: materialProps.Ns || 0,
		side: THREE.DoubleSide,
		transparent: false,
		opacity: 1.0,
	});

	// Apply texture if available (texture is already a THREE.Texture object)
	if (texture && texture instanceof THREE.Texture) {
		material.map = texture;
		material.needsUpdate = true;
	}

	return material;
}

// Step 1) Create surface from parsed OBJ data (preserves original faces)
function createSurfaceFromOBJData(objData, fileName) {
	var surfaceId = fileName;

	// Step 2) Use triangles from OBJ parser (preserves original mesh topology)
	var triangles = objData.triangles;

	if (!triangles || triangles.length === 0) {
		console.warn("No triangles in OBJ data, falling back to Delaunator");
		createSurfaceFromPoints(objData.points, fileName, true);
		return;
	}

	// Step 3) Add to loadedSurfaces
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: fileName,
		points: objData.points,
		triangles: triangles,
		visible: true,
		gradient: "default",
		transparency: 1.0,
		isTexturedMesh: false,
	});

	console.log("üßä Surface created from OBJ: " + fileName + " (" + objData.points.length + " points, " + triangles.length + " triangles)");

	// Step 4) Save to database
	saveSurfaceToDB(surfaceId)
		.then(function () {
			console.log("‚úÖ OBJ surface saved to database: " + surfaceId);
		})
		.catch(function (err) {
			console.error("‚ùå Failed to save OBJ surface:", err);
		});

	// Step 5) Update UI
	updateCentroids();
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();
	updateStatusMessage("Loaded OBJ surface: " + fileName + " (" + triangles.length + " triangles)");
}

// Process surface points with progress indication
function processSurfacePoints(points, fileName) {
	updateStatusMessage("Creating surface from " + points.length.toLocaleString() + " points...");

	// Use setTimeout to allow UI update before processing
	setTimeout(async () => {
		// Make this async
		try {
			createSurfaceFromPoints(points, fileName, false);

			// ADD SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName || "surface_" + Date.now());
				// console.log("üíæ Surface saved from processSurfacePoints:", fileName);
			} catch (saveError) {
				console.error("‚ùå Failed to save surface from processSurfacePoints:", saveError);
			}

			updateStatusMessage("Surface loaded: " + fileName + " (" + points.length.toLocaleString() + " points)");
		} catch (error) {
			console.error("Error creating surface:", error);
			updateStatusMessage("Error creating surface: " + error.message);
		}
	}, 100);
}
// Step 1) Enhanced OBJ parser - extracts vertices, faces, UVs, normals, and material references
function parseOBJFile(content, mtlContent) {
	// Step 2) Initialize data structures
	const vertices = []; // Vertex positions (v lines)
	const uvs = []; // Texture coordinates (vt lines)
	const normals = []; // Vertex normals (vn lines)
	const faces = []; // Face indices (f lines)
	let materialLibrary = ""; // MTL file reference (mtllib line)
	let currentMaterial = ""; // Current material name (usemtl line)
	const materialGroups = []; // Track which faces use which material

	// Step 3) Parse OBJ content line by line
	const lines = content.split("\n");

	lines.forEach(function (line) {
		const trimmedLine = line.trim();

		// Step 4) Skip empty lines and comments
		if (!trimmedLine || trimmedLine.startsWith("#")) {
			return;
		}

		const parts = trimmedLine.split(/\s+/);
		const command = parts[0];

		// Step 5) Parse vertex positions (v x y z)
		if (command === "v" && parts.length >= 4) {
			const x = parseFloat(parts[1]);
			const y = parseFloat(parts[2]);
			const z = parseFloat(parts[3]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				vertices.push({ x: x, y: y, z: z });
			}
		}
		// Step 6) Parse texture coordinates (vt u v)
		else if (command === "vt" && parts.length >= 3) {
			const u = parseFloat(parts[1]);
			const v = parseFloat(parts[2]);

			if (!isNaN(u) && !isNaN(v)) {
				uvs.push({ u: u, v: v });
			}
		}
		// Step 7) Parse vertex normals (vn x y z)
		else if (command === "vn" && parts.length >= 4) {
			const nx = parseFloat(parts[1]);
			const ny = parseFloat(parts[2]);
			const nz = parseFloat(parts[3]);

			if (!isNaN(nx) && !isNaN(ny) && !isNaN(nz)) {
				normals.push({ x: nx, y: ny, z: nz });
			}
		}
		// Step 8) Parse faces (f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3 ...)
		else if (command === "f" && parts.length >= 4) {
			var faceVertices = [];
			var faceUVs = [];
			var faceNormals = [];

			// Step 9) Parse each vertex reference in the face
			for (var i = 1; i < parts.length; i++) {
				var indices = parts[i].split("/");

				// Vertex index (1-based in OBJ, convert to 0-based)
				var vIdx = parseInt(indices[0], 10) - 1;
				if (!isNaN(vIdx)) {
					faceVertices.push(vIdx);
				}

				// UV index (optional)
				if (indices.length > 1 && indices[1] !== "") {
					var uvIdx = parseInt(indices[1], 10) - 1;
					if (!isNaN(uvIdx)) {
						faceUVs.push(uvIdx);
					}
				}

				// Normal index (optional)
				if (indices.length > 2 && indices[2] !== "") {
					var nIdx = parseInt(indices[2], 10) - 1;
					if (!isNaN(nIdx)) {
						faceNormals.push(nIdx);
					}
				}
			}

			// Step 10) Triangulate faces with more than 3 vertices (fan triangulation)
			if (faceVertices.length >= 3) {
				for (var j = 1; j < faceVertices.length - 1; j++) {
					var triangle = {
						vertices: [faceVertices[0], faceVertices[j], faceVertices[j + 1]],
						uvs: [],
						normals: [],
						material: currentMaterial,
					};

					if (faceUVs.length >= faceVertices.length) {
						triangle.uvs = [faceUVs[0], faceUVs[j], faceUVs[j + 1]];
					}

					if (faceNormals.length >= faceVertices.length) {
						triangle.normals = [faceNormals[0], faceNormals[j], faceNormals[j + 1]];
					}

					faces.push(triangle);
				}
			}
		}
		// Step 11) Parse material library reference (mtllib filename.mtl)
		else if (command === "mtllib") {
			materialLibrary = parts.slice(1).join(" ");
		}
		// Step 12) Parse material usage (usemtl materialname)
		else if (command === "usemtl") {
			currentMaterial = parts.slice(1).join(" ");
			materialGroups.push({
				name: currentMaterial,
				startFace: faces.length,
			});
		}
	});

	// Step 13) Create points array for backward compatibility (same as vertices)
	var points = vertices.map(function (v) {
		return { x: v.x, y: v.y, z: v.z };
	});

	// Step 14) Build triangles array for surface rendering (Kirra format)
	var triangles = [];
	faces.forEach(function (face) {
		if (face.vertices.length === 3) {
			var v0 = vertices[face.vertices[0]];
			var v1 = vertices[face.vertices[1]];
			var v2 = vertices[face.vertices[2]];

			if (v0 && v1 && v2) {
				var minZ = Math.min(v0.z, v1.z, v2.z);
				var maxZ = Math.max(v0.z, v1.z, v2.z);

				triangles.push({
					vertices: [
						{ x: v0.x, y: v0.y, z: v0.z },
						{ x: v1.x, y: v1.y, z: v1.z },
						{ x: v2.x, y: v2.y, z: v2.z },
					],
					minZ: minZ,
					maxZ: maxZ,
					uvs: face.uvs.length === 3 ? [uvs[face.uvs[0]], uvs[face.uvs[1]], uvs[face.uvs[2]]] : null,
					material: face.material,
				});
			}
		}
	});

	// Step 15) Determine if this OBJ has texture data
	var hasTexture = uvs.length > 0 && materialLibrary !== "";
	var hasFaces = faces.length > 0;

	console.log("üßä OBJ Parser: " + vertices.length + " vertices, " + faces.length + " faces, " + uvs.length + " UVs, " + normals.length + " normals, hasTexture: " + hasTexture);

	// Step 16) Return enhanced data structure
	return {
		// For backward compatibility
		points: points,

		// Enhanced data
		vertices: vertices,
		faces: faces,
		uvs: uvs,
		normals: normals,
		triangles: triangles,

		// Material information
		materialLibrary: materialLibrary,
		materialGroups: materialGroups,

		// Flags
		hasTexture: hasTexture,
		hasFaces: hasFaces,

		// Raw content for persistence
		objContent: content,
		mtlContent: mtlContent || null,
	};
}
// XYZ parser (space-delimited X Y Z format)
function parseXYZFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		const parts = line.trim().split(/\s+/);
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z,
				});
			}
		}
	});

	return points;
}
// ASC parser (ASCII grid format, commonly used in GIS)
function parseASCFile(content) {
	const lines = content.split("\n");
	const points = [];

	// Parse header information
	let ncols, nrows, xllcorner, yllcorner, cellsize, nodata_value;
	let headerLines = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim().toLowerCase();
		if (line.startsWith("ncols")) {
			ncols = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nrows")) {
			nrows = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("xllcorner") || line.startsWith("xllcenter")) {
			xllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("yllcorner") || line.startsWith("yllcenter")) {
			yllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("cellsize")) {
			cellsize = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nodata_value")) {
			nodata_value = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.length > 0 && !isNaN(parseFloat(line.split(/\s+/)[0]))) {
			break; // End of header, start of data
		}
	}

	// Parse elevation data
	for (let row = 0; row < nrows; row++) {
		const lineIndex = headerLines + row;
		if (lineIndex < lines.length) {
			const values = lines[lineIndex].trim().split(/\s+/);
			for (let col = 0; col < ncols && col < values.length; col++) {
				const z = parseFloat(values[col]);
				if (!isNaN(z) && z !== nodata_value) {
					const x = xllcorner + col * cellsize;
					const y = yllcorner + (nrows - 1 - row) * cellsize; // Flip Y coordinate
					points.push({
						x,
						y,
						z,
					});
				}
			}
		}
	}

	return points;
}
// PLY parser (ASCII format)
function parsePLYFile(content) {
	const lines = content.split("\n");
	const points = [];
	let inHeader = true;
	let vertexCount = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim();

		if (inHeader) {
			if (line.startsWith("element vertex")) {
				vertexCount = parseInt(line.split(" ")[2]);
			} else if (line === "end_header") {
				inHeader = false;
			}
		} else if (vertexCount > 0) {
			const parts = line.split(/\s+/);
			if (parts.length >= 3) {
				const x = parseFloat(parts[0]);
				const y = parseFloat(parts[1]);
				const z = parseFloat(parts[2]);

				if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
					points.push({
						x,
						y,
						z,
					});
					vertexCount--;
				}
			}
		}
	}

	return points;
}
// PTS parser (point count + XYZ + intensity)
function parsePTSFile(content) {
	const lines = content.split("\n");
	const points = [];

	// First line might be point count
	let startIndex = 0;
	if (lines[0] && !isNaN(parseInt(lines[0].trim()))) {
		startIndex = 1;
	}

	for (let i = startIndex; i < lines.length; i++) {
		const parts = lines[i].trim().split(/\s+/);
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z,
				});
			}
		}
	}

	return points;
}
// TXT parser (flexible text format)
function parseTXTFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		// Skip comment lines and empty lines
		const trimmedLine = line.trim();
		if (trimmedLine.length === 0 || trimmedLine.startsWith("#") || trimmedLine.startsWith("//")) {
			return;
		}

		// Try different delimiters: space, tab, comma
		let parts = trimmedLine.split(/\s+/);
		if (parts.length < 3) {
			parts = trimmedLine.split("\t");
		}
		if (parts.length < 3) {
			parts = trimmedLine.split(",");
		}

		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z,
				});
			}
		}
	});

	return points;
}
// CSV parser specifically for point clouds
function parseCSVPointCloud(content) {
	const lines = content.split("\n");
	const points = [];
	let hasHeader = false;

	// Check if first line looks like a header
	const firstLine = lines[0].trim();
	if (firstLine.toLowerCase().includes("x") || firstLine.toLowerCase().includes("y") || firstLine.toLowerCase().includes("z")) {
		hasHeader = true;
	}

	const startIndex = hasHeader ? 1 : 0;

	for (let i = startIndex; i < lines.length; i++) {
		const parts = lines[i].trim().split(",");
		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z,
				});
			}
		}
	}

	return points;
}
// Add this to track the current surface name
window.currentSurfaceName = null;

function createSurfaceFromPoints(points, surfaceName = null, autoSave = true) {
	const surfaceId = surfaceName || "surface_" + Date.now();

	// Create triangles in LOCAL variable (not global)
	const triangles = [];
	const coords = points.flatMap((p) => [p.x, p.y]);
	const delaunay = new Delaunator(coords);

	for (let i = 0; i < delaunay.triangles.length; i += 3) {
		const p1 = points[delaunay.triangles[i]];
		const p2 = points[delaunay.triangles[i + 1]];
		const p3 = points[delaunay.triangles[i + 2]];

		// ? Push to LOCAL triangles array
		triangles.push({
			vertices: [p1, p2, p3],
			minZ: Math.min(p1.z, p2.z, p3.z),
			maxZ: Math.max(p1.z, p2.z, p3.z),
		});
	}

	// ? Add complete surface to the Map
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: surfaceName || surfaceId,
		points: points,
		triangles: triangles,
		visible: true,
		gradient: "default",
	});

	updateCentroids();
	drawData(allBlastHoles, selectedHole);

	if (autoSave) {
		saveSurfaceToDB(surfaceId).catch((err) => console.error("Failed to save surface:", err));
	}
}
// Keep the decimation warning (optional enhancement)
function showDecimationWarning(points, fileName) {
	const pointCount = points.length;

	Swal.fire({
		title: "Large Point Cloud Detected",
		showCancelButton: true,
		confirmButtonText: "Load All",
		cancelButtonText: "Decimate",
		icon: "warning",
		html: `
            <div style="text-align: center;">
                <label class="labelWhite16"><strong>${fileName}</strong></label><br>
                <label class="labelWhite14">Contains ${pointCount.toLocaleString()} points</label><br><br>
                <label class="labelWhite12">?? Large point clouds may cause performance issues</label><br>
                <label class="labelWhite12">Recommended: Decimate to ~5,000 points for better performance</label>
            </div>
        `,
		customClass: {
			container: "custom-popup-container",
			title: "swal2-title",
			confirmButton: "confirm",
			cancelButton: "cancel",
			content: "swal2-content",
			htmlContainer: "swal2-html-container",
			icon: "swal2-icon",
		},
	}).then(async (result) => {
		// Make this async
		if (result.isConfirmed) {
			createSurfaceFromPoints(points, fileName, false);

			// ADD SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName || "surface_full_" + Date.now());
				// console.log("üíæ Full surface saved from decimation dialog:", fileName);
			} catch (saveError) {
				console.error("‚ùå Failed to save full surface:", saveError);
			}
		} else if (result.dismiss === Swal.DismissReason.cancel) {
			const decimatedPoints = decimatePointCloud(points, 5000);
			createSurfaceFromPoints(decimatedPoints, fileName, false);

			// ADD DECIMATED SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName ? fileName + "_decimated" : "surface_decimated_" + Date.now());
				// console.log("üßä Decimated surface saved from decimation dialog:", fileName);
			} catch (saveError) {
				console.error("‚ùå Failed to save decimated surface:", saveError);
			}
		}
	});
}

function decimatePointCloud(points, targetCount) {
	if (points.length <= targetCount) return points;

	const step = Math.floor(points.length / targetCount);
	const decimatedPoints = [];

	for (let i = 0; i < points.length; i += step) {
		decimatedPoints.push(points[i]);
	}

	return decimatedPoints;
}
// Add this simple canvasToWorld function (without snapping)
function canvasToWorld(canvasX, canvasY) {
	const worldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;
	return [worldX, worldY];
}

function drawSurface() {


	if (!surfacesGroupVisible) return; // ? ADD: Check surfaces group visibility
	if (loadedSurfaces.size === 0) return;

	loadedSurfaces.forEach((surface, surfaceId) => {


		if (!surface.visible) return;

		// Step 0a) Check if we should render 3D geometry
		// CRITICAL: Use ONLY onlyShowThreeJS flag - DO NOT check camera orbit angles
		// Checking isIn3DMode causes dual rendering (2D and 3D at same time)
		const should3DRender = threeInitialized && onlyShowThreeJS;

		// Step 0) Handle textured meshes (OBJ files) - only for texture gradient with actual textures
		if (surface.isTexturedMesh && surface.threeJSMesh) {
			var gradient = surface.gradient || "texture";

			// Step 0a) Check if mesh actually has textures
			var hasTexture = false;
			if (surface.threeJSMesh) {
				surface.threeJSMesh.traverse(function (child) {
					if (child.isMesh && child.material) {
						if (Array.isArray(child.material)) {
							hasTexture = child.material.some(function (mat) {
								return mat.map !== null && mat.map !== undefined;
							});
						} else {
							hasTexture = child.material.map !== null && child.material.map !== undefined;
						}
					}
				});
			}

			if (developerModeEnabled) {
				console.log("üé® drawSurface textured mesh: " + surfaceId + ", gradient: " + gradient + ", hasTexture: " + hasTexture + ", should3DRender: " + should3DRender + ", onlyShowThreeJS: " + onlyShowThreeJS);
			}

			// If gradient is "texture" AND mesh has textures, use textured mesh rendering (original JPG texture)
			if (gradient === "texture" && hasTexture) {
				// Use meshBounds for Z range
				let surfaceMinZ = surface.meshBounds ? surface.meshBounds.minZ : 0;
				let surfaceMaxZ = surface.meshBounds ? surface.meshBounds.maxZ : 100;

				// Draw in Three.js ONLY if in 3D rendering mode
				if (should3DRender) {
					console.log("üé• Rendering textured mesh in 3D: " + surfaceId);
					drawSurfaceThreeJS(surfaceId, surface.triangles || [], surfaceMinZ, surfaceMaxZ, gradient, surface.transparency || 1.0, surface);
				} else {
					console.log("üßπ Skipping 3D render (2D-only mode): " + surfaceId);
				}
				return; // Textured mesh with texture gradient doesn't have 2D triangle rendering
			}

			// For "default" and other gradients (hillshade, viridis, terrain, etc.), OR if no texture exists,
			// fall through to standard triangle rendering with elevation-based colors
			console.log("üîª Using color gradient for textured mesh: " + gradient + " (hasTexture: " + hasTexture + ")");
		}

		// Step 1) Standard surface - requires triangles
		if (!surface.triangles || surface.triangles.length === 0) return;
		if (!surface.points || surface.points.length === 0) return;

		// Calculate THIS surface's elevation range only
		let surfaceMinZ = Infinity;
		let surfaceMaxZ = -Infinity;

		surface.points.forEach((point) => {
			if (point.z < surfaceMinZ) surfaceMinZ = point.z;
			if (point.z > surfaceMaxZ) surfaceMaxZ = point.z;
		});

		// Step 2) Draw surface in Three.js ONLY if in 3D rendering mode
		if (should3DRender) {
			drawSurfaceThreeJS(surfaceId, surface.triangles, surfaceMinZ, surfaceMaxZ, surface.gradient || "default", surface.transparency || 1.0, surface);
		}

		// Step 3) Draw surface in 2D canvas (only when not in Three.js-only mode)
		if (!onlyShowThreeJS) {
			// Step 3a) Check if we can use cached surface image
			if (isSurfaceCacheValid(surfaceId, surface)) {
				// Step 3b) Use cached image - much faster!
				var cache = surface2DCache.get(surfaceId);
				if (drawCachedSurface(cache)) {
					return; // Successfully drew from cache, skip triangle rendering
				}
			}

			// Step 3c) Cache miss or invalid - render to cache first, then draw
			var cache = renderSurfaceToCache(surfaceId, surface, surfaceMinZ, surfaceMaxZ);
			if (cache && drawCachedSurface(cache)) {
				return; // Successfully rendered and drew from cache
			}

			// Step 3d) Fallback: Direct triangle rendering (if caching fails)
			// CRITICAL: Pass surface-specific min/max, transparency, AND gradient
			surface.triangles.forEach((triangle, i) => {
				// Fix line 20344 - Surface drawing function (added hillshadeColor parameter)
				drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, ctx, surface.transparency || 1.0, surface.gradient || "default", gradientMethod, lightBearing, lightElevation, surface.hillshadeColor || null, surface.minLimit, surface.maxLimit);
			});
		}
	});
}
// Step #) Surface legend - now uses CSS panel stacked with other legends
function drawSurfaceLegend() {
	// Step 1) Check if any surfaces are visible and have legend enabled
	if (!showSurfaceLegend || loadedSurfaces.size === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 2) Get all visible surfaces
	var visibleSurfaces = Array.from(loadedSurfaces.values()).filter(function (surface) {
		return surface.visible && surface.points && surface.points.length > 0;
	});

	if (visibleSurfaces.length === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 3) Build array of surface legend data (individual surfaces, not combined)
	var surfaceLegendData = [];

	for (var i = 0; i < visibleSurfaces.length; i++) {
		var surface = visibleSurfaces[i];

		// Step 3a) Calculate THIS surface's elevation range
		var surfaceMinZ = Infinity;
		var surfaceMaxZ = -Infinity;

		for (var j = 0; j < surface.points.length; j++) {
			var point = surface.points[j];
			if (point.z < surfaceMinZ) surfaceMinZ = point.z;
			if (point.z > surfaceMaxZ) surfaceMaxZ = point.z;
		}

		// Step 3b) Skip flat surfaces (no elevation variation)
		if (surfaceMaxZ - surfaceMinZ < 0.001) {
			continue;
		}

		// Step 3c) Determine display range (custom limits if set, otherwise actual range)
		var displayMinZ = surface.minLimit !== null ? surface.minLimit : surfaceMinZ;
		var displayMaxZ = surface.maxLimit !== null ? surface.maxLimit : surfaceMaxZ;

		// Step 3d) Add surface to legend data array
		surfaceLegendData.push({
			name: surface.name || "Surface " + (i + 1),
			actualMinZ: surfaceMinZ,
			actualMaxZ: surfaceMaxZ,
			displayMinZ: displayMinZ,
			displayMaxZ: displayMaxZ,
			hasCustomLimits: surface.minLimit !== null || surface.maxLimit !== null,
			gradient: surface.gradient || "default",
			hillshadeColor: surface.hillshadeColor || null
		});
	}

	// Step 4) Show legend if we have any valid surfaces
	if (surfaceLegendData.length === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 5) Show CSS-based surface legend (stacked with individual surface entries)
	showSurfaceElevationLegend(surfaceLegendData);
}
// Color gradient functions
function getViridisColor(ratio) {
	const colors = [
		[68, 1, 84], // Dark purple
		[59, 82, 139], // Blue-purple
		[33, 144, 140], // Teal
		[92, 200, 99], // Green
		[253, 231, 37], // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getTurboColor(ratio) {
	const colors = [
		[48, 18, 59], // Dark purple
		[50, 136, 189], // Blue
		[94, 201, 98], // Green
		[253, 231, 37], // Yellow
		[240, 21, 22], // Red
	];
	return interpolateColors(colors, ratio);
}

function getParulaColor(ratio) {
	const colors = [
		[53, 42, 135], // Dark blue
		[15, 92, 221], // Blue
		[18, 125, 216], // Light blue
		[7, 156, 207], // Cyan
		[21, 177, 180], // Teal
		[89, 189, 140], // Green
		[170, 194, 97], // Yellow-green
		[249, 251, 14], // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getCividisColor(ratio) {
	const colors = [
		[0, 32, 76], // Dark blue
		[0, 52, 102], // Blue
		[39, 90, 129], // Light blue
		[92, 125, 147], // Gray-blue
		[150, 159, 157], // Gray
		[206, 187, 158], // Beige
		[254, 230, 206], // Light yellow
	];
	return interpolateColors(colors, ratio);
}

function getTerrainColor(ratio) {
	const colors = [
		[0, 68, 27], // Dark green (low elevation)
		[35, 132, 67], // Green
		[65, 174, 118], // Light green
		[120, 198, 121], // Pale green
		[186, 228, 179], // Very pale green
		[120, 85, 45], // Brown (mid elevation)
		[160, 118, 74], // Light brown
		[200, 200, 200], // Gray (high elevation)
		[255, 255, 255], // White (peaks)
	];
	return interpolateColors(colors, ratio);
}

function interpolateColors(colors, ratio) {
	const scaledRatio = ratio * (colors.length - 1);
	const index = Math.floor(scaledRatio);
	const localRatio = scaledRatio - index;

	if (index >= colors.length - 1) {
		const [r, g, b] = colors[colors.length - 1];
		return `rgb(${r}, ${g}, ${b})`;
	}

	const [r1, g1, b1] = colors[index];
	const [r2, g2, b2] = colors[index + 1];

	const r = Math.round(r1 + (r2 - r1) * localRatio);
	const g = Math.round(g1 + (g2 - g1) * localRatio);
	const b = Math.round(b1 + (b2 - b1) * localRatio);

	return `rgb(${r}, ${g}, ${b})`;
}

// Updated elevationToColor function to accept gradient parameter and custom limits
function elevationToColor(z, minZ, maxZ, gradient = "default", minLimit = null, maxLimit = null) {
	// Use custom limits if provided, otherwise use actual surface range
	const effectiveMinZ = minLimit !== null ? minLimit : minZ;
	const effectiveMaxZ = maxLimit !== null ? maxLimit : maxZ;
	const effectiveRange = effectiveMaxZ - effectiveMinZ;

	// Check if the effective range is too small (flat surface)
	if (effectiveRange < 0.001) {
		// Very small tolerance for floating point comparison
		return "rgb(255, 165, 0)"; // Orange for flat surfaces
	}

	// Clamp z value to the effective range for coloring
	const clampedZ = Math.max(effectiveMinZ, Math.min(effectiveMaxZ, z));
	const ratio = (clampedZ - effectiveMinZ) / effectiveRange;

	// Apply selected gradient (now surface-specific)
	switch (gradient) {
		case "hillshade":
			// For hillshade, we'll handle coloring in drawTriangleWithGradient
			// This is just a fallback
			return "rgb(127, 127, 127)";
		case "viridis":
			return getViridisColor(ratio);
		case "turbo":
			return getTurboColor(ratio);
		case "parula":
			return getParulaColor(ratio);
		case "cividis":
			return getCividisColor(ratio);
		case "terrain":
			return getTerrainColor(ratio);
		default:
			// Original blue->cyan->green->yellow->red spectrum
			if (ratio < 0.25) {
				return `rgb(0, ${Math.floor(ratio * 4 * 255)}, 255)`;
			} else if (ratio < 0.5) {
				return `rgb(0, 255, ${Math.floor(255 - (ratio - 0.25) * 4 * 255)})`;
			} else if (ratio < 0.75) {
				return `rgb(${Math.floor((ratio - 0.5) * 4 * 255)}, 255, 0)`;
			} else {
				return `rgb(255, ${Math.floor(255 - (ratio - 0.75) * 4 * 255)}, 0)`;
			}
	}
}

// // Add new hillshading functions
// function getTriangleAspect(triangle) {
// 	const [p1, p2, p3] = triangle.vertices;

// 	// Calculate two edge vectors
// 	const v1X = p2.x - p1.x;
// 	const v1Y = p2.y - p1.y;
// 	const v1Z = p2.z - p1.z;

// 	const v2X = p3.x - p1.x;
// 	const v2Y = p3.y - p1.y;
// 	const v2Z = p3.z - p1.z;

// 	// Cross product to get surface normal
// 	const normalX = v1Y * v2Z - v1Z * v2Y;
// 	const normalY = v1Z * v2X - v1X * v2Z;
// 	const normalZ = v1X * v2Y - v1Y * v2X;

// 	// Handle flat triangles
// 	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
// 	if (horizontalMagnitude < 1e-6) {
// 		return {
// 			aspect: 0,
// 			slope: 0,
// 			isFlat: true
// 		};
// 	}

// 	// Calculate aspect (direction the slope faces)
// 	// 0? = North, 90? = East, 180? = South, 270? = West
// 	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

// 	// Calculate slope angle (steepness)
// 	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
// 	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

// 	return {
// 		aspect,
// 		slope,
// 		isFlat: false
// 	};
// }

// function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 90) {
// 	// Convert to radians
// 	const aspectRad = (aspect * Math.PI) / 180;
// 	const slopeRad = (slope * Math.PI) / 180;
// 	const lightBearingRad = (lightBearing * Math.PI) / 180;
// 	const lightElevationRad = (lightElevation * Math.PI) / 180;

// 	// Calculate illumination using standard hillshade formula
// 	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

// 	// Normalize to 0-1 range
// 	return Math.max(0, Math.min(1, illumination));
// }

// function getHillshadeColor(aspect, slope, isFlat = false) {
// 	if (isFlat) {
// 		// Flat triangles = 50% grey
// 		return "rgb(127, 127, 127)";
// 	}

// 	// Calculate illumination with light source from North (bearing 0?)
// 	const illumination = calculateHillshade(aspect, slope, 0, 45);

// 	// Your proposed color scheme:
// 	// 30% grey (dark) to 70% grey (light)
// 	const minGrey = 30; // 30% grey = rgb(76, 76, 76)
// 	const maxGrey = 70; // 70% grey = rgb(178, 178, 178)

// 	// Map illumination (0-1) to your grey range
// 	const greyPercent = minGrey + (maxGrey - minGrey) * illumination;
// 	const greyValue = Math.round((greyPercent * 255) / 100);

// 	return "rgb(" + greyValue + ", " + greyValue + ", " + greyValue + ")";
// }

// Step 1) Enhanced drawTriangleWithGradient function with unified gradient methods and hillshade controls

let gradientMethod = "radial"; // Step #) Changed to radial for better 2D surface visualization
let lightBearing = 135;
let lightElevation = 15;

// Step #) Add event listener for gradient style dropdown
document.getElementById("gradientStyle").addEventListener("change", function () {
	changeGradientStyle();
});

// Step #) Function to handle gradient style changes
function changeGradientStyle() {
	gradientMethod = document.getElementById("gradientStyle").value;
	if (developerModeEnabled) {
		console.log("Gradient style changed to: " + gradientMethod);
	}
	drawData(allBlastHoles, selectedHole);
}

// Step #) Add event listener for light bearing slider
document.getElementById("lightBearingSlider").addEventListener("input", function () {
	lightBearing = parseInt(document.getElementById("lightBearingSlider").value);
	// change the slider labelto u
	document.getElementById("lightBearingLabel").textContent = "Light Bearing (deg): " + lightBearing + "¬∞";
	if (developerModeEnabled) {
		console.log("Light bearing changed to: " + lightBearing);
	}
	// Invalidate all surface caches (hillshade depends on light direction)
	invalidateSurfaceCache(null);
	drawData(allBlastHoles, selectedHole);
});

// Step #) Add event listener for light elevation slider
document.getElementById("lightElevationSlider").addEventListener("input", function () {
	lightElevation = parseInt(document.getElementById("lightElevationSlider").value);
	// change the slider labelto use the new value
	document.getElementById("lightElevationLabel").textContent = "Light Elevation (deg): " + lightElevation + "¬∞";
	if (developerModeEnabled) {
		console.log("Light elevation changed to: " + lightElevation);
	}
	// Invalidate all surface caches (hillshade depends on light direction)
	invalidateSurfaceCache(null);
	drawData(allBlastHoles, selectedHole);
});

function drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, targetCtx = ctx, alpha = 1.0, gradient = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45, hillshadeColor = null, minLimit = null, maxLimit = null) {
	const showWireFrame = false;
	const [p1, p2, p3] = triangle.vertices;

	// Step 2) Convert to canvas coordinates - handle both object and array formats
	const [x1, y1] = worldToCanvas(p1.x !== undefined ? p1.x : p1[0], p1.y !== undefined ? p1.y : p1[1]);
	const [x2, y2] = worldToCanvas(p2.x !== undefined ? p2.x : p2[0], p2.y !== undefined ? p2.y : p2[1]);
	const [x3, y3] = worldToCanvas(p3.x !== undefined ? p3.x : p3[0], p3.y !== undefined ? p3.y : p3[1]);

	// Step 3) Get Z values for elevation calculations
	const z1 = p1.z !== undefined ? p1.z : p1[2];
	const z2 = p2.z !== undefined ? p2.z : p2[2];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 4) Save context state
	targetCtx.save();

	// Step 5) Set transparency for THIS surface only
	targetCtx.globalAlpha = alpha;

	// Step 6) Check if we have texture data (future enhancement)
	if (surfaceTextureData && surfaceTextureData.hasTextures) {
		// For now, use a different color scheme for textured surfaces
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();

		// Use elevation coloring but with different palette for textured surfaces
		const avgZ = (z1 + z2 + z3) / 3;
		targetCtx.fillStyle = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.051;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 7) Handle hillshade gradient specially with configurable lighting
	if (gradient === "hillshade") {
		const { aspect, slope, isFlat } = getTriangleAspect(triangle);
		const computedHillshadeColor = getHillshadeColor(aspect, slope, isFlat, lightBearing, lightElevation, hillshadeColor);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = computedHillshadeColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.05;
			targetCtx.stroke();
		}

		targetCtx.restore();
		return;
	}

	// Step 8) Check if THIS surface is flat (using surface-specific min/max)
	if (surfaceMaxZ - surfaceMinZ < 0.001) {
		// Flat surface - use solid orange color
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = "rgba(255, 165, 0, 0.7)"; // Semi-transparent orange
		targetCtx.fill();

		// Add wireframe edges
		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 9) Apply gradient method based on gradientMethod parameter
	switch (gradientMethod) {
		case "radial":
			drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
		case "barycentric":
			drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
		case "default":
		default:
			drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
	}

	// Step 10) Restore context state
	targetCtx.restore();
}

// Step 11) Linear gradient method (improved default)
function drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 12) Find vertices with min and max Z values for better gradient orientation
	const vertices = [
		{ x: x1, y: y1, z: z1, index: 0 },
		{ x: x2, y: y2, z: z2, index: 1 },
		{ x: x3, y: y3, z: z3, index: 2 },
	];

	// Step 13) Sort vertices by elevation to find min and max Z points
	vertices.sort((a, b) => a.z - b.z);
	const minZVertex = vertices[0]; // Lowest elevation
	const maxZVertex = vertices[2]; // Highest elevation
	const midZVertex = vertices[1]; // Middle elevation

	// Step 14) Check if there's significant elevation difference
	const elevationDiff = maxZVertex.z - minZVertex.z;
	if (elevationDiff < 0.001) {
		// Essentially flat triangle - use average color
		const avgZ = (z1 + z2 + z3) / 3;
		const flatColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = flatColor;
		targetCtx.fill();
	} else {
		// Step 15) Create gradient from min elevation point to max elevation point
		const canvasGradient = targetCtx.createLinearGradient(minZVertex.x, minZVertex.y, maxZVertex.x, maxZVertex.y);

		// Step 16) Map Z values to colors using THIS surface's elevation range AND gradient
		const minColor = elevationToColor(minZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		const maxColor = elevationToColor(maxZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		// Step 17) Add color stops - more natural gradient flow
		canvasGradient.addColorStop(0, minColor);
		canvasGradient.addColorStop(1, maxColor);

		// Step 18) If middle vertex has significantly different elevation, add it as intermediate stop
		const midElevationRatio = (midZVertex.z - minZVertex.z) / elevationDiff;
		if (midElevationRatio > 0.1 && midElevationRatio < 0.9) {
			// Step 19) Calculate position of middle vertex along the gradient line
			const gradientLength = Math.sqrt(Math.pow(maxZVertex.x - minZVertex.x, 2) + Math.pow(maxZVertex.y - minZVertex.y, 2));

			if (gradientLength > 0) {
				// Project middle vertex onto gradient line
				const dx = maxZVertex.x - minZVertex.x;
				const dy = maxZVertex.y - minZVertex.y;
				const midDx = midZVertex.x - minZVertex.x;
				const midDy = midZVertex.y - minZVertex.y;

				// Calculate projection ratio
				const projectionRatio = (midDx * dx + midDy * dy) / (dx * dx + dy * dy);
				const clampedRatio = Math.max(0.1, Math.min(0.9, projectionRatio));

				const midColor = elevationToColor(midZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
				canvasGradient.addColorStop(clampedRatio, midColor);
			}
		}

		// Step 20) Draw triangle with improved gradient
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = canvasGradient;
		targetCtx.fill();
	}

	// Step 21) Add wireframe edges if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 22) Radial gradient method for natural elevation flow
function drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 23) Calculate triangle centroid
	const centerX = (x1 + x2 + x3) / 3;
	const centerY = (y1 + y2 + y3) / 3;
	const centerZ = (z1 + z2 + z3) / 3;

	// Step 24) Calculate triangle radius (distance to farthest vertex)
	const radius = Math.max(Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(y1 - centerY, 2)), Math.sqrt(Math.pow(x2 - centerX, 2) + Math.pow(y2 - centerY, 2)), Math.sqrt(Math.pow(x3 - centerX, 2) + Math.pow(y3 - centerY, 2)));

	// Step 25) Create radial gradient from center
	const radialGradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

	// Step 26) Determine inner and outer colors based on elevation variation
	const minZ = Math.min(z1, z2, z3);
	const maxZ = Math.max(z1, z2, z3);
	const elevationRange = maxZ - minZ;

	let innerColor, outerColor;

	if (elevationRange < 0.001) {
		// Flat triangle - use single color
		const flatColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		innerColor = flatColor;
		outerColor = flatColor;
	} else {
		// Step 27) Use center elevation for inner, highest elevation for outer (creates peak effect)
		const highestZ = Math.max(z1, z2, z3);
		innerColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		outerColor = elevationToColor(highestZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	}

	radialGradient.addColorStop(0, innerColor);
	radialGradient.addColorStop(1, outerColor);

	// Step 28) Draw triangle with radial gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = radialGradient;
	targetCtx.fill();

	// Step 29) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 30) Barycentric gradient method for smooth color interpolation
function drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 31) For small triangles or minimal elevation difference, use single color
	const elevationRange = Math.max(z1, z2, z3) - Math.min(z1, z2, z3);
	if (elevationRange < 0.001) {
		const avgZ = (z1 + z2 + z3) / 3;
		const solidColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = solidColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		return;
	}

	// Step 32) Create multiple gradient segments for smoother appearance
	// This approach creates overlapping gradients to simulate barycentric interpolation

	// Step 33) Calculate triangle bounds
	const minX = Math.min(x1, x2, x3);
	const maxX = Math.max(x1, x2, x3);
	const minY = Math.min(y1, y2, y3);
	const maxY = Math.max(y1, y2, y3);

	// Step 34) Create gradient across the triangle's bounding box oriented by elevation
	const vertices = [
		{ x: x1, y: y1, z: z1 },
		{ x: x2, y: y2, z: z2 },
		{ x: x3, y: y3, z: z3 },
	];

	// Step 35) Sort by elevation to determine gradient direction
	vertices.sort((a, b) => a.z - b.z);
	const lowVertex = vertices[0];
	const highVertex = vertices[2];

	const linearGradient = targetCtx.createLinearGradient(lowVertex.x, lowVertex.y, highVertex.x, highVertex.y);

	// Step 36) Sample colors at key points
	const color1 = elevationToColor(z1, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	const color2 = elevationToColor(z2, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	const color3 = elevationToColor(z3, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

	// Step 37) Create blended gradient based on vertex positions and elevations
	const sortedByElevation = [
		{ z: z1, color: color1 },
		{ z: z2, color: color2 },
		{ z: z3, color: color3 },
	].sort((a, b) => a.z - b.z);

	linearGradient.addColorStop(0, sortedByElevation[0].color);
	linearGradient.addColorStop(0.5, sortedByElevation[1].color);
	linearGradient.addColorStop(1, sortedByElevation[2].color);

	// Step 38) Draw triangle with enhanced gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = linearGradient;
	targetCtx.fill();

	// Step 39) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 40) Enhanced hillshade functions with configurable light source
function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 45) {
	// Step 41) Convert to radians
	const aspectRad = (aspect * Math.PI) / 180;
	const slopeRad = (slope * Math.PI) / 180;
	const lightBearingRad = (lightBearing * Math.PI) / 180;
	const lightElevationRad = (lightElevation * Math.PI) / 180;

	// Step 42) Calculate illumination using standard hillshade formula
	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

	// Step 43) Normalize to 0-1 range and apply contrast enhancement
	return Math.max(0, Math.min(1, illumination));
}

// Step 44) Enhanced hillshade color function with configurable lighting
function getHillshadeColor(aspect, slope, isFlat = false, lightBearing = 315, lightElevation = 45, baseColor = null) {
	// Step 44a) Parse base color if provided (for tinted hillshade)
	var baseR = 128, baseG = 128, baseB = 128;
	if (baseColor && baseColor.charAt(0) === "#") {
		baseR = parseInt(baseColor.substring(1, 3), 16) || 128;
		baseG = parseInt(baseColor.substring(3, 5), 16) || 128;
		baseB = parseInt(baseColor.substring(5, 7), 16) || 128;
	}

	if (isFlat) {
		// Step 45) Flat triangles = base color at 50% intensity
		if (baseColor) {
			return "rgb(" + baseR + ", " + baseG + ", " + baseB + ")";
		}
		return "rgb(127, 127, 127)";
	}

	// Step 46) Calculate illumination with configurable light source
	var illumination = calculateHillshade(aspect, slope, lightBearing, lightElevation);

	// Step 47) Enhanced color range - from dark shadow to bright highlight
	var minBrightness = 0.2; // 20% brightness for deep shadows
	var maxBrightness = 1.2; // 120% brightness for bright highlights (clamped)

	// Step 48) Apply contrast curve for more dramatic shading
	var contrastIllumination = Math.pow(illumination, 0.8); // Gamma correction for better contrast

	// Step 49) Map illumination to brightness range
	var brightness = minBrightness + (maxBrightness - minBrightness) * contrastIllumination;

	// Step 49a) Apply brightness to base color
	var r = Math.min(255, Math.round(baseR * brightness));
	var g = Math.min(255, Math.round(baseG * brightness));
	var b = Math.min(255, Math.round(baseB * brightness));

	return "rgb(" + r + ", " + g + ", " + b + ")";
}

// Step 50) Enhanced triangle aspect calculation with improved normal computation
function getTriangleAspect(triangle) {
	const [p1, p2, p3] = triangle.vertices;

	// Step 51) Handle both object and array formats
	const x1 = p1.x !== undefined ? p1.x : p1[0];
	const y1 = p1.y !== undefined ? p1.y : p1[1];
	const z1 = p1.z !== undefined ? p1.z : p1[2];

	const x2 = p2.x !== undefined ? p2.x : p2[0];
	const y2 = p2.y !== undefined ? p2.y : p2[1];
	const z2 = p2.z !== undefined ? p2.z : p2[2];

	const x3 = p3.x !== undefined ? p3.x : p3[0];
	const y3 = p3.y !== undefined ? p3.y : p3[1];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 52) Calculate two edge vectors
	const v1X = x2 - x1;
	const v1Y = y2 - y1;
	const v1Z = z2 - z1;

	const v2X = x3 - x1;
	const v2Y = y3 - y1;
	const v2Z = z3 - z1;

	// Step 53) Cross product to get surface normal
	const normalX = v1Y * v2Z - v1Z * v2Y;
	const normalY = v1Z * v2X - v1X * v2Z;
	const normalZ = v1X * v2Y - v1Y * v2X;

	// Step 54) Handle flat triangles
	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
	if (horizontalMagnitude < 1e-6) {
		return {
			aspect: 0,
			slope: 0,
			isFlat: true,
		};
	}

	// Step 55) Calculate aspect (direction the slope faces)
	// 0? = North, 90? = East, 180? = South, 270? = West
	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

	// Step 56) Calculate slope angle (steepness)
	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

	return {
		aspect,
		slope,
		isFlat: false,
	};
}

// Step 57) Utility function to create surfaces with enhanced gradient options
function createSurfaceWithGradientOptions(surfaceName, gradientType = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45) {
	// Example of how to create a surface with the new gradient options
	const surface = {
		name: surfaceName,
		gradient: gradientType,
		gradientMethod: gradientMethod,
		lightBearing: lightBearing,
		lightElevation: lightElevation,
		// ... other surface properties
	};

	console.log("Created surface with gradient options:");
	console.log("- Gradient Type: " + gradientType);
	console.log("- Gradient Method: " + gradientMethod);
	console.log("- Light Bearing: " + lightBearing + "¬∞");
	console.log("- Light Elevation: " + lightElevation + "¬∞");

	return surface;
}
// ADD: Global variable for texture data
let surfaceTextureData = null;
// Add this function near other surface-related functions
function getAllVisibleSurfaces() {
	const visibleSurfaces = [];
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				visibleSurfaces.push({
					id: surfaceId,
					name: surface.name || `Surface ${surfaceId}`,
				});
			}
		}
	}
	return visibleSurfaces;
}
// Helper function to assign holes to surface elevation (with proper geometry calculation)
// Step 26) Updated to support 5 modes: collar, grade, toe, grade_keep_toe, toe_keep_grade
function assignHoleToSurfaceElevation(hole, targetElevation, type) {
	if (!hole) return;

	var radAngle = hole.holeAngle * (Math.PI / 180);
	var cosAngle = Math.cos(radAngle);
	var sinAngle = Math.sin(radAngle);
	var radBearing = ((450 - hole.holeBearing) % 360) * (Math.PI / 180);

	if (type === "collar") {
		// Step 27) Keep TOE fixed, keep ANGLE and BEARING fixed
		// Move collar ALONG the existing hole vector to reach target Z elevation
		// This changes collar XYZ for angled holes, but preserves the hole direction

		// Step 27a) Save existing toe position and geometry
		var toeX = hole.endXLocation;
		var toeY = hole.endYLocation;
		var toeZ = hole.endZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 27b) Calculate angle components
		var radAngle = existingAngle * (Math.PI / 180);
		var cosAngle = Math.cos(radAngle);
		var sinAngle = Math.sin(radAngle);
		var radBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 27c) Check if hole is too horizontal (can't reach target Z)
		if (Math.abs(cosAngle) < 0.001) {
			console.warn("Cannot assign collar for near-horizontal hole (angle: " + existingAngle + "¬∞)");
			return;
		}

		// Step 27d) Calculate vertical distance from toe to new collar
		var verticalDistance = targetElevation - toeZ;

		// Step 27e) Calculate new hole length along the vector
		// Length = vertical distance / cos(angle)
		var newLength = verticalDistance / cosAngle;

		// Step 27f) Calculate horizontal distance along the vector
		var horizontalDistance = newLength * sinAngle;

		// Step 27g) Calculate new collar position (moving FROM toe TOWARD collar along vector)
		// The hole vector points from collar to toe, so we go opposite direction
		hole.startXLocation = toeX - horizontalDistance * Math.cos(radBearing);
		hole.startYLocation = toeY - horizontalDistance * Math.sin(radBearing);
		hole.startZLocation = targetElevation;

		// Step 27h) Update hole length (angle and bearing stay the same)
		hole.holeLengthCalculated = newLength;
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;

		// Step 27i) Toe stays fixed
		hole.endXLocation = toeX;
		hole.endYLocation = toeY;
		hole.endZLocation = toeZ;
		hole.subdrillAmount = existingSubdrill;

		// Step 27j) Recalculate grade position (subdrill distance from toe toward collar)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(angleRad);

		hole.gradeZLocation = toeZ + subdrillVertical;
		hole.gradeXLocation = toeX - subdrillHorizontal * Math.cos(radBearing);
		hole.gradeYLocation = toeY - subdrillHorizontal * Math.sin(radBearing);

		// Step 27k) Update bench height
		hole.benchHeight = hole.startZLocation - hole.gradeZLocation;

		console.log("Collar moved along vector to: (" + hole.startXLocation.toFixed(2) + ", " + hole.startYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Length: " + newLength.toFixed(2) + "m, Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles(); // Save changes to IndexedDB
	} else if (type === "grade") {
		// Step 28) Keep COLLAR fixed, keep ANGLE and BEARING fixed
		// Move GRADE along the hole vector to reach target Z, then calculate TOE from subdrill

		// Step 28a) Save existing geometry
		var collarX = hole.startXLocation;
		var collarY = hole.startYLocation;
		var collarZ = hole.startZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 28b) Calculate angle components
		var gradeRadAngle = existingAngle * (Math.PI / 180);
		var gradeCosAngle = Math.cos(gradeRadAngle);
		var gradeSinAngle = Math.sin(gradeRadAngle);
		var gradeRadBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 28c) Check if hole is too horizontal
		if (Math.abs(gradeCosAngle) < 0.001) {
			console.warn("Cannot assign grade for near-horizontal hole");
			return;
		}

		// Step 28d) Calculate vertical distance from collar to grade (bench height)
		var newBenchHeight = collarZ - targetElevation;
		hole.benchHeight = newBenchHeight;

		// Step 28e) Calculate distance from collar to grade along the hole vector
		var collarToGradeLength = newBenchHeight / gradeCosAngle;
		var collarToGradeHorizontal = collarToGradeLength * gradeSinAngle;

		// Step 28f) Calculate new grade position (sliding along vector from collar)
		hole.gradeXLocation = collarX + collarToGradeHorizontal * Math.cos(gradeRadBearing);
		hole.gradeYLocation = collarY + collarToGradeHorizontal * Math.sin(gradeRadBearing);
		hole.gradeZLocation = targetElevation;

		// Step 28g) Calculate toe position (subdrill distance beyond grade along vector)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(gradeRadAngle);

		hole.endXLocation = hole.gradeXLocation + subdrillHorizontal * Math.cos(gradeRadBearing);
		hole.endYLocation = hole.gradeYLocation + subdrillHorizontal * Math.sin(gradeRadBearing);
		hole.endZLocation = hole.gradeZLocation - subdrillVertical;

		// Step 28h) Calculate new hole length
		var newLength = collarToGradeLength + existingSubdrill;
		hole.holeLengthCalculated = newLength;

		// Step 28i) Angle and bearing stay the same
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;
		hole.subdrillAmount = existingSubdrill;

		console.log("Grade moved along vector to: (" + hole.gradeXLocation.toFixed(2) + ", " + hole.gradeYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles();

	} else if (type === "toe") {
		// Step 29) Keep COLLAR fixed, keep ANGLE and BEARING fixed
		// Move TOE along the hole vector to reach target Z, then calculate GRADE from subdrill

		// Step 29a) Save existing geometry
		var collarX = hole.startXLocation;
		var collarY = hole.startYLocation;
		var collarZ = hole.startZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 29b) Calculate angle components
		var toeRadAngle = existingAngle * (Math.PI / 180);
		var toeCosAngle = Math.cos(toeRadAngle);
		var toeSinAngle = Math.sin(toeRadAngle);
		var toeRadBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 29c) Check if hole is too horizontal
		if (Math.abs(toeCosAngle) < 0.001) {
			console.warn("Cannot assign toe for near-horizontal hole");
			return;
		}

		// Step 29d) Calculate vertical distance from collar to toe
		var collarToToeVertical = collarZ - targetElevation;

		// Step 29e) Calculate new hole length (from collar to toe along vector)
		var newLength = collarToToeVertical / toeCosAngle;
		var collarToToeHorizontal = newLength * toeSinAngle;

		// Step 29f) Calculate new toe position (sliding along vector from collar)
		hole.endXLocation = collarX + collarToToeHorizontal * Math.cos(toeRadBearing);
		hole.endYLocation = collarY + collarToToeHorizontal * Math.sin(toeRadBearing);
		hole.endZLocation = targetElevation;

		// Step 29g) Calculate grade position (subdrill distance back from toe toward collar)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(toeRadAngle);

		hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.cos(toeRadBearing);
		hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.sin(toeRadBearing);
		hole.gradeZLocation = hole.endZLocation + subdrillVertical;

		// Step 29h) Update bench height and hole length
		hole.benchHeight = collarZ - hole.gradeZLocation;
		hole.holeLengthCalculated = newLength;

		// Step 29i) Angle and bearing stay the same
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;
		hole.subdrillAmount = existingSubdrill;

		console.log("Toe moved along vector to: (" + hole.endXLocation.toFixed(2) + ", " + hole.endYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles();
	} else if (type === "grade_keep_toe") {
		// Step 30) Assign GRADE elevation - keep Toe fixed, calculate new Subdrill
		hole.gradeZLocation = targetElevation;

		// Calculate new bench height
		var newBenchHeight = hole.startZLocation - targetElevation;
		hole.benchHeight = newBenchHeight;

		// Calculate new subdrill from the vertical distance between grade and toe
		var verticalSubdrill = targetElevation - hole.endZLocation; // Grade is above Toe
		if (Math.abs(cosAngle) > 1e-9) {
			hole.subdrillAmount = Math.abs(verticalSubdrill) / cosAngle;
		} else {
			hole.subdrillAmount = Math.abs(verticalSubdrill);
		}

		// Ensure subdrill is non-negative
		if (hole.subdrillAmount < 0) hole.subdrillAmount = 0;

		// Recalculate GradeXY based on new grade position
		var benchDrillLength = newBenchHeight / (Math.abs(cosAngle) > 1e-9 ? cosAngle : 1);
		var horizontalToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = hole.startXLocation + horizontalToGrade * Math.cos(radBearing);
		hole.gradeYLocation = hole.startYLocation + horizontalToGrade * Math.sin(radBearing);

		console.log("Grade assigned: " + targetElevation + "mZ, Toe kept at: " + hole.endZLocation.toFixed(2) + "mZ, New subdrill: " + hole.subdrillAmount.toFixed(2) + "m");
		debouncedSaveHoles();

	} else if (type === "toe_keep_grade") {
		// Step 31) Assign TOE elevation - keep Grade fixed, calculate new Subdrill

		// Calculate new subdrill from the vertical distance between grade and new toe
		var verticalSubdrill = hole.gradeZLocation - targetElevation; // Grade is above Toe
		if (Math.abs(cosAngle) > 1e-9) {
			hole.subdrillAmount = Math.abs(verticalSubdrill) / cosAngle;
		} else {
			hole.subdrillAmount = Math.abs(verticalSubdrill);
		}

		// Ensure subdrill is non-negative
		if (hole.subdrillAmount < 0) hole.subdrillAmount = 0;

		// Calculate new hole length: (benchHeight + new subdrill) / cos(angle)
		if (Math.abs(cosAngle) > 1e-9) {
			var newLength = (hole.benchHeight + hole.subdrillAmount) / cosAngle;
			hole.holeLengthCalculated = newLength;

			// Recalculate ToeXYZ
			var horizontalDist = newLength * sinAngle;
			hole.endXLocation = hole.startXLocation + horizontalDist * Math.cos(radBearing);
			hole.endYLocation = hole.startYLocation + horizontalDist * Math.sin(radBearing);
			hole.endZLocation = targetElevation;
		}

		console.log("Toe assigned: " + targetElevation + "mZ, Grade kept at: " + hole.gradeZLocation.toFixed(2) + "mZ, New subdrill: " + hole.subdrillAmount.toFixed(2) + "m");
		debouncedSaveHoles();
	}
}

// Updated surface assignment functions - CONVERTED TO FloatingDialog
// Step 1) Assign Surface Tool - Uses FloatingDialog instead of Swal2
assignSurfaceTool.addEventListener("change", function () {
	var toolCheckbox = this;

	// Step 1) Cancel handler to reset toolbar
	var cancelHandler = function () {
		toolCheckbox.checked = false;
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
	};

	if (this.checked) {
		resetFloatingToolbarButtons("assignSurfaceTool");

		// Step 2) Check if surface is available
		var visibleSurfaces = getAllVisibleSurfaces();
		if (visibleSurfaces.length === 0) {
			// Step 3) No surface available - show FloatingDialog for manual entry
			window.showAssignCollarDialog(
				function (elevation) {
					// Step 4) Apply elevation to selected holes
					window.assignHolesToFixedElevation(elevation, "collar");
					// Step 5) Deselect tool
					toolCheckbox.checked = false;
					resetFloatingToolbarButtons("none");
				},
				cancelHandler // onCancel callback
			);
			return;
		}

		// Step 6) Multiple surfaces available - ask which one to use
		if (visibleSurfaces.length > 1) {
			window.showSurfaceSelectDialog(
				visibleSurfaces,
				"Collar",
				function (selectedSurfaceId) {
					// Step 7) Surface is available - proceed with surface assignment
					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						var assignedCount = 0;
						for (var i = 0; i < selectedMultipleHoles.length; i++) {
							var hole = selectedMultipleHoles[i];
							var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								window.assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
								assignedCount++;
							}
						}

						// Step 8) Show success message
						var surface = loadedSurfaces.get(selectedSurfaceId);
						var surfaceName = surface ? surface.name || ("Surface " + selectedSurfaceId) : "selected surface";
						window.showAssignmentCompleteDialog(assignedCount, surfaceName, "collar");

						updateStatusMessage("Select next tool\n to continue");
					} else {
						updateStatusMessage("Click on holes to assign surface elevation.");
						canvas.addEventListener("click", handleAssignSurfaceClick);
						return; // Don't uncheck the tool yet
					}
					// Step 9) Deselect tool
					toolCheckbox.checked = false;
					resetFloatingToolbarButtons("none");
				},
				cancelHandler // onCancel callback
			);
			return;
		}

		// Step 10) Single surface available - proceed directly with first surface
		var surfaceId = visibleSurfaces[0].id;
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			var assignedCount = 0;
			for (var i = 0; i < selectedMultipleHoles.length; i++) {
				var hole = selectedMultipleHoles[i];
				var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, surfaceId);
				if (surfaceZ !== null) {
					window.assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
					assignedCount++;
				}
			}

			// Step 11) Show success message
			window.showAssignmentCompleteDialog(assignedCount, "surface", "collar");

			// Step 12) Deselect tool
			this.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("Select next tool\n to continue");
		} else {
			updateStatusMessage("Click on holes to assign surface elevation.");
			canvas.addEventListener("click", handleAssignSurfaceClick);
		}
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignSurfaceClick);
	}
});

// Step 13) Assign Grade Tool - ALWAYS shows Grade/Toe mode selector dialog
assignGradeTool.addEventListener("change", function () {
	var toolCheckbox = this;

	if (this.checked) {
		resetFloatingToolbarButtons("assignGradeTool");

		// Step 14) Get visible surfaces BEFORE showing dialog
		var visibleSurfaces = getAllVisibleSurfaces();
		console.log("Grade/Toe assignment - visibleSurfaces:", visibleSurfaces.length, visibleSurfaces);

		// Step 15) Show enhanced FloatingDialog with Grade/Toe mode selector and surface dropdown
		window.showAssignGradeDialog(
			visibleSurfaces,
			// onConfirm callback: (elevation, mode, selectedSurfaceId)
			function (elevation, mode, selectedSurfaceId) {
				// Step 16) If we have a surface selected, use surface elevation
				if (selectedSurfaceId) {
					var surface = loadedSurfaces.get(selectedSurfaceId);
					var surfaceName = surface ? (surface.name || ("Surface " + selectedSurfaceId)) : "surface";

					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						var assignedCount = 0;
						for (var i = 0; i < selectedMultipleHoles.length; i++) {
							var hole = selectedMultipleHoles[i];
							var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								window.assignHoleToSurfaceElevation(hole, surfaceZ, mode);
								assignedCount++;
							}
						}
						// Step 17) Show success message
						window.showAssignmentCompleteDialog(assignedCount, surfaceName, mode);
						updateStatusMessage("Select next tool\n to continue");
					} else {
						// Step 18) No holes selected - enable click-to-assign mode
						updateStatusMessage("Click on holes to assign " + mode + " elevation to surface.");
						window._gradeAssignMode = mode;
						window._gradeAssignSurfaceId = selectedSurfaceId;
						canvas.addEventListener("click", handleAssignGradeClick);
						return; // Don't uncheck the tool yet
					}
				} else {
					// Step 19) No surface - use manual elevation
					console.log("No surface - using manual elevation:", elevation, "mode:", mode);
					window.assignHolesToFixedElevation(elevation, mode);
				}

				// Step 20) Deselect tool
				toolCheckbox.checked = false;
				resetFloatingToolbarButtons("none");
			},
			// onCancel callback
			function () {
				// Step 21) Cancel - reset toolbar and uncheck button
				toolCheckbox.checked = false;
				resetFloatingToolbarButtons("none");
				updateStatusMessage("Select next tool\n to continue");
			}
		);
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignGradeClick);
	}
});
// Step 22) Helper function to assign holes to a fixed elevation - CONVERTED TO FloatingDialog
// Note: This function now delegates to window.assignHolesToFixedElevation from SurfaceAssignmentDialogs.js
// Keeping local wrapper for backward compatibility with existing code
function assignHolesToFixedElevation(elevation, type) {
	// Step 23) Delegate to the new FloatingDialog-based function
	if (window.assignHolesToFixedElevation && window.assignHolesToFixedElevation !== assignHolesToFixedElevation) {
		return window.assignHolesToFixedElevation(elevation, type);
	}

	// Step 24) Fallback implementation if SurfaceAssignmentDialogs.js not loaded
	var assignedCount = 0;

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		for (var i = 0; i < selectedMultipleHoles.length; i++) {
			assignHoleToSurfaceElevation(selectedMultipleHoles[i], elevation, type);
			assignedCount++;
		}

		debouncedSaveHoles(); // Save all changes to IndexedDB

		// Step 25) Show success message using FloatingDialog
		if (window.showAssignmentCompleteDialog) {
			window.showAssignmentCompleteDialog(assignedCount, elevation.toFixed(2) + "mZ", type);
		} else if (window.showModalMessage) {
			window.showModalMessage("Elevation Assignment Complete",
				"Successfully adjusted " + assignedCount + " holes to " + elevation.toFixed(2) + "mZ " + type + " elevation.",
				"success");
		}
	} else {
		updateStatusMessage("No holes selected for elevation assignment.");
	}

	drawData(allBlastHoles, selectedHole);
}

// Update click handlers - simplified version
function handleAssignSurfaceClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// Find clicked hole using canvas coordinates
	const clickedHole = getClickedHole(clickX, clickY);
	if (clickedHole) {
		const surfaceZ = interpolateZFromSurface(clickedHole.startXLocation, clickedHole.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHole, surfaceZ, "collar");
			updateStatusMessage("Adjusted hole " + clickedHole.holeID + "\nCollar at " + surfaceZ.toFixed(2) + "m, length now " + clickedHole.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHole.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

function handleAssignGradeClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	var rect = canvas.getBoundingClientRect();
	var clickX = event.clientX - rect.left;
	var clickY = event.clientY - rect.top;

	// Step 21) Get the stored mode (grade or toe) from the dialog selection
	var mode = window._gradeAssignMode || "grade";

	// Find clicked hole using canvas coordinates
	var clickedHoleLocal = getClickedHole(clickX, clickY);
	if (clickedHoleLocal) {
		var surfaceZ = interpolateZFromSurface(clickedHoleLocal.startXLocation, clickedHoleLocal.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHoleLocal, surfaceZ, mode);
			var typeLabel = mode === "grade" ? "Grade" : "Toe";
			updateStatusMessage("Adjusted hole " + clickedHoleLocal.holeID + "\n" + typeLabel + " at " + surfaceZ.toFixed(2) + "m, length now " + clickedHoleLocal.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHoleLocal.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

// Fixed save function (around line 18158)
function saveViewControlsSliderValues() {
	// View control sliders
	localStorage.setItem("fontSize", fontSlider.value);
	localStorage.setItem("fontLock", fontLock.checked);
	localStorage.setItem("connSize", connSlider.value);
	localStorage.setItem("toeSize", toeSlider.value);
	localStorage.setItem("holeSize", holeSlider.value);
	localStorage.setItem("intervalSize", intervalSlider.value);
	localStorage.setItem("firstMovementSize", firstMovementSlider.value);

	// Connection controls
	localStorage.setItem("delay", connectorDelay.value);
	localStorage.setItem("connectorColor", connectorColor.jscolor.toHEXString());
	localStorage.setItem("connectSlider", connectSlider.value);
	localStorage.setItem("floatingDelay", floatingDelay.value);
	localStorage.setItem("floatingConnectorColor", floatingConnectorColor.jscolor.toHEXString());

	// Drawing controls
	localStorage.setItem("drawingColor", drawingColor.jscolor.toHEXString());
	localStorage.setItem("lineThickness", lineThickness.value);
	localStorage.setItem("drawingRadius", circleRadius.value);
	localStorage.setItem("drawingText", drawingText.value);
	localStorage.setItem("drawingPolygonRadius", polygonRadius.value);
	localStorage.setItem("radiiSteps", radiiSteps.value);
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);

	// Lightning and Gradient Controls
	localStorage.setItem("lightBearing", lightBearingSlider.value);
	localStorage.setItem("lightElevation", lightElevationSlider.value);
	localStorage.setItem("gradientStyle", gradientStyle.value);

	console.log("View controls saved to localStorage");
}

// Fixed load function with null checks
function loadViewControlsSliderValues() {
	// View control sliders with defaults
	if (localStorage.getItem("fontSize")) fontSlider.value = localStorage.getItem("fontSize");
	if (localStorage.getItem("fontLock")) fontLock.checked = localStorage.getItem("fontLock");
	if (localStorage.getItem("connSize")) connSlider.value = localStorage.getItem("connSize");
	if (localStorage.getItem("toeSize")) toeSlider.value = localStorage.getItem("toeSize");
	if (localStorage.getItem("holeSize")) holeSlider.value = localStorage.getItem("holeSize");
	if (localStorage.getItem("intervalSize")) intervalSlider.value = localStorage.getItem("intervalSize");
	if (localStorage.getItem("firstMovementSize")) firstMovementSlider.value = localStorage.getItem("firstMovementSize");
	if (localStorage.getItem("snapRadiusPixels")) snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
	// Connection controls
	if (localStorage.getItem("delay")) connectorDelay.value = localStorage.getItem("delay");
	if (localStorage.getItem("connectorColor")) connectorColor.jscolor.fromString(localStorage.getItem("connectorColor"));
	if (localStorage.getItem("connectSlider")) connectSlider.value = localStorage.getItem("connectSlider");
	if (localStorage.getItem("floatingDelay")) floatingDelay.value = localStorage.getItem("floatingDelay");
	if (localStorage.getItem("floatingConnectorColor")) floatingConnectorColor.jscolor.fromString(localStorage.getItem("floatingConnectorColor"));
	// Drawing controls
	if (localStorage.getItem("drawingColor")) {
		drawingColor.jscolor.fromString(localStorage.getItem("drawingColor"));
		// Step #) Also sync floatingKADColor to the saved drawingColor
		var floatingKADColorEl = document.getElementById("floatingKADColor");
		if (floatingKADColorEl && floatingKADColorEl.jscolor) {
			floatingKADColorEl.jscolor.fromString(localStorage.getItem("drawingColor"));
		}
	}
	if (localStorage.getItem("drawingRadius")) circleRadius.value = localStorage.getItem("drawingRadius");
	if (localStorage.getItem("drawingText")) drawingText.value = localStorage.getItem("drawingText");
	if (localStorage.getItem("drawingPolygonRadius")) polygonRadius.value = localStorage.getItem("drawingPolygonRadius");
	if (localStorage.getItem("radiiSteps")) radiiSteps.value = localStorage.getItem("radiiSteps");
	if (localStorage.getItem("lineThickness")) lineThickness.value = localStorage.getItem("lineThickness");
	// Lightning and Gradient Controls
	if (localStorage.getItem("lightBearing")) lightBearingSlider.value = localStorage.getItem("lightBearing");
	if (localStorage.getItem("lightElevation")) lightElevationSlider.value = localStorage.getItem("lightElevation");
	if (localStorage.getItem("gradientStyle")) gradientStyle.value = localStorage.getItem("gradientStyle");

	console.log("View controls loaded from localStorage");
}
// Auto-save when any control changes (add after the load function)
function setupAutoSavePreferences() {
	// View control sliders
	fontSlider.addEventListener("input", saveViewControlsSliderValues);
	connSlider.addEventListener("input", saveViewControlsSliderValues);
	toeSlider.addEventListener("input", saveViewControlsSliderValues);
	holeSlider.addEventListener("input", saveViewControlsSliderValues);
	intervalSlider.addEventListener("input", saveViewControlsSliderValues);
	firstMovementSlider.addEventListener("input", saveViewControlsSliderValues);
	snapToleranceSlider.addEventListener("input", saveViewControlsSliderValues);
	// Connection controls
	connectorDelay.addEventListener("input", saveViewControlsSliderValues);
	connectSlider.addEventListener("input", saveViewControlsSliderValues);
	floatingConnectorColor.addEventListener("input", saveViewControlsSliderValues);
	floatingDelay.addEventListener("input", saveViewControlsSliderValues);

	// Drawing controls
	circleRadius.addEventListener("input", saveViewControlsSliderValues);
	drawingText.addEventListener("input", saveViewControlsSliderValues);
	polygonRadius.addEventListener("input", saveViewControlsSliderValues);
	radiiSteps.addEventListener("input", saveViewControlsSliderValues);

	// Color pickers (these need special handling)
	connectorColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	drawingColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	// Step #) Also save when floatingKADColor changes
	var floatingKADColorEl = document.getElementById("floatingKADColor");
	if (floatingKADColorEl) {
		floatingKADColorEl.addEventListener("input", function () {
			setTimeout(saveViewControlsSliderValues, 100);
		});
	}
	lineThickness.addEventListener("input", saveViewControlsSliderValues);
}

//--------------------GLOBAL SNAPPING SNAP SELECT ------------------------//
// Global snapping configuration
let snapRadiusPixels = 10; // Default value in pixels
let snapEnabled = true; // Global snap toggle
let snapHighlight = null; // Store the current snap target for visual feedback

// Initialize snap radius from localStorage
if (localStorage.getItem("snapRadiusPixels")) {
	snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
} else if (localStorage.getItem("snapRadius") || localStorage.getItem("snapTolerance")) {
	// Migrate old meter-based snap to pixel-based (convert 1m to ~10 pixels as default)
	snapRadiusPixels = 10;
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
}

// Update slider to match loaded value
if (document.getElementById("snapToleranceSlider")) {
	document.getElementById("snapToleranceSlider").min = 2; // Minimum 2 pixels
	document.getElementById("snapToleranceSlider").max = 50; // Maximum 50 pixels
	document.getElementById("snapToleranceSlider").step = 1; // 1 pixel increments
	document.getElementById("snapToleranceSlider").value = snapRadiusPixels;
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";
}

// Single event listener for snap tolerance
document.getElementById("snapToleranceSlider")?.addEventListener("input", function () {
	snapRadiusPixels = parseFloat(this.value);
	// console.log("Snap Tolerance updated: " + snapRadiusPixels + "px");
	updateStatusMessage("Snap Tolerance: " + snapRadiusPixels + "px");
	setTimeout(() => updateStatusMessage(""), 1500);

	// Update all labels consistently
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

	// Save to localStorage
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
});

// Helper function to convert pixel tolerance to world coordinates for current zoom
function getSnapToleranceInWorldUnits() {
	return snapRadiusPixels / currentScale;
}

// All possible snap targets and their priorities
const SNAP_PRIORITIES = {
	HOLE_COLLAR: 1, // Highest priority
	HOLE_GRADE: 2,
	HOLE_TOE: 3,
	KAD_POINT: 4,
	KAD_LINE_VERTEX: 5,
	KAD_POLYGON_VERTEX: 6,
	KAD_CIRCLE_CENTER: 7,
	KAD_TEXT_POSITION: 8,
	KAD_LINE_SEGMENT: 9, // Segments get lower priority
	KAD_POLYGON_SEGMENT: 10, // Segments get lower priority
	SURFACE_POINT: 11,
	SURFACE_FACE: 12, // Lowest priority
};

// Step 1) Snap priorities for Move Tool (holes moving - excludes hole snap targets)
const MOVE_SNAP_PRIORITIES = {
	KAD_POINT: 1, // Highest priority
	KAD_LINE_VERTEX: 2,
	KAD_POLYGON_VERTEX: 3,
	KAD_CIRCLE_CENTER: 4,
	KAD_TEXT_POSITION: 5,
	KAD_LINE_SEGMENT: 6, // Segments lower priority
	KAD_POLYGON_SEGMENT: 7,
	SURFACE_POINT: 8,
	SURFACE_FACE: 9, // Lowest priority (with interpolation)
};

// Step 2) Snap function for Move Tool - excludes holes (holes cannot snap to other holes)
function snapToNearestPointExcludingHoles(rawWorldX, rawWorldY, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || (document.getElementById("drawingElevation") ? document.getElementById("drawingElevation").value : 0),
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets (excluding holes)
	const snapCandidates = [];

	// 1) Search KAD Objects (all vertices and segments)
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach(function (entity, entityName) {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// Check vertices
			entity.data.forEach(function (dataPoint) {
				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = MOVE_SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = MOVE_SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = MOVE_SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = MOVE_SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			});

			// Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = MOVE_SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: entity.entityType + " segment " + (i + 1),
							});
						}
					}
				}
			}
		});
	}

	// 2) Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach(function (surfacePoint, index) {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}

			// 3) Search Surface Faces (triangulated mesh) with Z interpolation
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				surface.triangles.forEach(function (triangle, triIndex) {
					if (!triangle.vertices || triangle.vertices.length !== 3) return;

					const v1 = triangle.vertices[0];
					const v2 = triangle.vertices[1];
					const v3 = triangle.vertices[2];

					// Project point onto triangle plane
					const projected = projectPointOntoTriangle(rawWorldX, rawWorldY, v1, v2, v3);

					if (projected && projected.isInside && projected.distance <= searchRadius) {
						snapCandidates.push({
							distance: projected.distance,
							point: {
								x: projected.x,
								y: projected.y,
								z: projected.z,
							},
							type: "SURFACE_FACE",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_FACE,
							description: surface.name + " face " + triIndex,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort(function (a, b) {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingZValue || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || (document.getElementById("drawingElevation") ? document.getElementById("drawingElevation").value : 0),
		snapped: false,
		snapTarget: null,
	};
}

// Helper function: Project point onto triangle and check if inside
function projectPointOntoTriangle(px, py, v1, v2, v3) {
	// Calculate barycentric coordinates
	const v0x = v3.x - v1.x;
	const v0y = v3.y - v1.y;
	const v1x = v2.x - v1.x;
	const v1y = v2.y - v1.y;
	const v2x = px - v1.x;
	const v2y = py - v1.y;

	const dot00 = v0x * v0x + v0y * v0y;
	const dot01 = v0x * v1x + v0y * v1y;
	const dot02 = v0x * v2x + v0y * v2y;
	const dot11 = v1x * v1x + v1y * v1y;
	const dot12 = v1x * v2x + v1y * v2y;

	const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

	// Check if point is inside triangle
	const isInside = u >= 0 && v >= 0 && u + v <= 1;

	if (!isInside) {
		return null;
	}

	// Interpolate Z using barycentric coordinates
	const w = 1 - u - v;
	const z = w * v1.z + u * v3.z + v * v2.z;

	// Calculate distance from original point to projected point (2D distance)
	const distance = Math.sqrt(Math.pow(px - px, 2) + Math.pow(py - py, 2)); // Always 0 since we're on the triangle

	return {
		x: px,
		y: py,
		z: z,
		isInside: true,
		distance: 0, // Point is projected onto triangle, so 2D distance is 0
	};
}

// Step 3) 3D variant: Snap function for Move Tool with ray-based snapping (cylindrical snap)
// Excludes holes - for moving holes in 3D mode
function snapToNearestPointExcludingHolesWithRay(rayOrigin, rayDirection, snapRadius) {
	if (!snapEnabled) {
		return {
			snapped: false,
			snapTarget: null,
		};
	}

	const snapCandidates = [];

	// Step 3a) Helper functions for coordinate conversion
	const worldToLocal = function (worldX, worldY, worldZ) {
		if (typeof window.worldToThreeLocal === "function") {
			const local = window.worldToThreeLocal(worldX, worldY);
			return { x: local.x, y: local.y, z: worldZ || 0 };
		}
		return { x: worldX, y: worldY, z: worldZ || 0 };
	};

	// Step 3b) Search KAD Objects (vertices and segments) - convert to local coords for ray comparison
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach(function (entity, entityName) {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// Check vertices
			entity.data.forEach(function (dataPoint) {
				// Convert world coords to local for ray comparison
				const pointLocal = worldToLocal(dataPoint.pointXLocation, dataPoint.pointYLocation, dataPoint.pointZLocation || 0);
				const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

				if (pointResult.distance <= snapRadius && pointResult.rayT > 0) {
					// Determine type and priority
					let snapType = "KAD_POINT";
					let priority = MOVE_SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = MOVE_SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = MOVE_SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = MOVE_SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					// Return actual object world coordinates
					snapCandidates.push({
						distance: pointResult.distance,
						rayT: pointResult.rayT,
						point: { x: dataPoint.pointXLocation, y: dataPoint.pointYLocation, z: dataPoint.pointZLocation || 0 },
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			});

			// Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length];

						// Sample points along the segment for 3D ray snapping
						const samples = 10;
						for (let s = 0; s <= samples; s++) {
							const t = s / samples;
							// Calculate sample point in world coordinates
							const samplePointWorld = {
								x: p1.pointXLocation + t * (p2.pointXLocation - p1.pointXLocation),
								y: p1.pointYLocation + t * (p2.pointYLocation - p1.pointYLocation),
								z: (p1.pointZLocation || 0) + t * ((p2.pointZLocation || 0) - (p1.pointZLocation || 0)),
							};

							// Convert sample point to local coords for ray comparison
							const samplePointLocal = worldToLocal(samplePointWorld.x, samplePointWorld.y, samplePointWorld.z);
							const segmentResult = distanceFromPointToRay(samplePointLocal, rayOrigin, rayDirection);

							if (segmentResult.distance <= snapRadius && segmentResult.rayT > 0) {
								const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
								const priority = MOVE_SNAP_PRIORITIES[segmentType];

								// Return actual segment sample point in world coordinates
								snapCandidates.push({
									distance: segmentResult.distance,
									rayT: segmentResult.rayT,
									point: samplePointWorld,
									type: segmentType,
									priority: priority,
									description: entity.entityType + " segment " + (i + 1),
								});
							}
						}
					}
				}
			}
		});
	}

	// Step 3c) Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach(function (surfacePoint, index) {
					// Convert world coords to local for ray comparison
					const pointLocal = worldToLocal(surfacePoint.x, surfacePoint.y, surfacePoint.z || 0);
					const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

					if (pointResult.distance <= snapRadius && pointResult.rayT > 0) {
						// Return actual object world coordinates
						snapCandidates.push({
							distance: pointResult.distance,
							rayT: pointResult.rayT,
							point: { x: surfacePoint.x, y: surfacePoint.y, z: surfacePoint.z || 0 },
							type: "SURFACE_POINT",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}

			// Step 3d) Search Surface Faces (triangulated mesh) with ray intersection and Z interpolation
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				surface.triangles.forEach(function (triangle, triIndex) {
					if (!triangle.vertices || triangle.vertices.length !== 3) return;

					const v1 = triangle.vertices[0];
					const v2 = triangle.vertices[1];
					const v3 = triangle.vertices[2];

					// Convert triangle vertices to local coords for ray comparison
					const v1Local = worldToLocal(v1.x, v1.y, v1.z || 0);
					const v2Local = worldToLocal(v2.x, v2.y, v2.z || 0);
					const v3Local = worldToLocal(v3.x, v3.y, v3.z || 0);

					// Perform ray-triangle intersection
					const intersection = rayTriangleIntersection(rayOrigin, rayDirection, v1Local, v2Local, v3Local);

					if (intersection && intersection.t > 0) {
						// Calculate perpendicular distance from ray to intersection point
						const dist = 0; // Ray intersects triangle, so distance is 0

						if (dist <= snapRadius) {
							// Convert intersection point back to world coordinates
							// Use barycentric coordinates to interpolate world position
							const u = intersection.u;
							const v = intersection.v;
							const w = 1 - u - v;

							const worldX = w * v1.x + u * v2.x + v * v3.x;
							const worldY = w * v1.y + u * v2.y + v * v3.y;
							const worldZ = w * v1.z + u * v2.z + v * v3.z;

							snapCandidates.push({
								distance: dist,
								rayT: intersection.t,
								point: { x: worldX, y: worldY, z: worldZ },
								type: "SURFACE_FACE",
								priority: MOVE_SNAP_PRIORITIES.SURFACE_FACE,
								description: surface.name + " face " + triIndex,
							});
						}
					}
				});
			}
		}
	}

	// Step 3e) Find the best snap candidate
	// Sort by: 1) Priority (lower number = higher priority), 2) Distance along ray (closer to camera)
	if (snapCandidates.length > 0) {
		snapCandidates.sort(function (a, b) {
			if (a.priority !== b.priority) {
				return a.priority - b.priority; // Lower priority number wins
			}
			return a.rayT - b.rayT; // Closer to camera wins
		});

		const bestCandidate = snapCandidates[0];

		console.log("üéØ [3D MOVE SNAP] Snapped to: " + bestCandidate.type + " (" + bestCandidate.description + ") | Priority: " + bestCandidate.priority);

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found
	return {
		snapped: false,
		snapTarget: null,
	};
}

// Helper function: Ray-triangle intersection using M?ller-Trumbore algorithm
function rayTriangleIntersection(rayOrigin, rayDir, v0, v1, v2) {
	const EPSILON = 0.0000001;

	// Edge vectors
	const edge1 = {
		x: v1.x - v0.x,
		y: v1.y - v0.y,
		z: v1.z - v0.z,
	};
	const edge2 = {
		x: v2.x - v0.x,
		y: v2.y - v0.y,
		z: v2.z - v0.z,
	};

	// Begin calculating determinant - also used to calculate u parameter
	const h = {
		x: rayDir.y * edge2.z - rayDir.z * edge2.y,
		y: rayDir.z * edge2.x - rayDir.x * edge2.z,
		z: rayDir.x * edge2.y - rayDir.y * edge2.x,
	};

	// If determinant is near zero, ray lies in plane of triangle
	const a = edge1.x * h.x + edge1.y * h.y + edge1.z * h.z;
	if (a > -EPSILON && a < EPSILON) {
		return null; // Ray is parallel to triangle
	}

	const f = 1.0 / a;
	const s = {
		x: rayOrigin.x - v0.x,
		y: rayOrigin.y - v0.y,
		z: rayOrigin.z - v0.z,
	};

	const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);
	if (u < 0.0 || u > 1.0) {
		return null;
	}

	const q = {
		x: s.y * edge1.z - s.z * edge1.y,
		y: s.z * edge1.x - s.x * edge1.z,
		z: s.x * edge1.y - s.y * edge1.x,
	};

	const v = f * (rayDir.x * q.x + rayDir.y * q.y + rayDir.z * q.z);
	if (v < 0.0 || u + v > 1.0) {
		return null;
	}

	// At this stage we can compute t to find out where the intersection point is on the line
	const t = f * (edge2.x * q.x + edge2.y * q.y + edge2.z * q.z);

	if (t > EPSILON) {
		// Ray intersection
		return { t: t, u: u, v: v };
	}

	return null; // Line intersection but not a ray intersection
}
// Add this new function before snapToNearestPoint
// Add this new function before snapToNearestPoint
function snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, excludeEntityName, excludeElementIndex, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation,
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation,
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation,
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// 2. Search KAD Objects but exclude the moving point and its segments
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip if this is the entity being moved
			const isMovingEntity = entityName === excludeEntityName;

			// Check vertices
			entity.data.forEach((dataPoint, index) => {
				// Skip the actual point being moved
				if (isMovingEntity && index === excludeElementIndex) {
					return;
				}

				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`,
					});
				}
			});

			// Check segments but exclude adjacent ones
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						// Skip segments adjacent to the moving point
						if (isMovingEntity) {
							const nextIndex = (i + 1) % points.length;
							if (i === excludeElementIndex || nextIndex === excludeElementIndex) {
								continue; // Skip this segment
							}
						}

						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t,
								},
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null,
	};
}

// Convert pixel radius to world radius for 3D snapping
// This ensures snap radius is always N pixels on screen regardless of zoom
function getSnapRadiusInWorldUnits3D(pixelRadius) {
	if (!threeRenderer || !threeRenderer.camera || !threeRenderer.renderer) {
		// Fallback to 2D calculation
		return pixelRadius / (currentScale || 1.0);
	}

	const camera = threeRenderer.camera;
	const canvas = threeRenderer.renderer.domElement;

	if (camera.isOrthographicCamera) {
		// Orthographic: World units per pixel is constant across the view
		// CRITICAL: With camera.zoom, effective frustum = base frustum / zoom
		// frustumWidth / screenWidth / zoom = world units per pixel
		const frustumWidth = camera.right - camera.left;
		const frustumHeight = camera.top - camera.bottom;
		const canvasWidth = canvas.width;
		const canvasHeight = canvas.height;
		const zoom = camera.zoom || 1.0;

		// Use the smaller dimension to ensure radius works in both X and Y
		const worldUnitsPerPixelX = frustumWidth / canvasWidth / zoom;
		const worldUnitsPerPixelY = frustumHeight / canvasHeight / zoom;
		const worldUnitsPerPixel = Math.min(worldUnitsPerPixelX, worldUnitsPerPixelY);

		return pixelRadius * worldUnitsPerPixel;
	} else if (camera.isPerspectiveCamera) {
		// Perspective: World units per pixel depends on distance from camera
		// This is more complex - for now, fall back to a reasonable estimate
		// based on the camera distance to the orbit center
		const distance = camera.position.length() || 1000;
		const fov = (camera.fov * Math.PI) / 180; // Convert to radians
		const canvasHeight = canvas.height;

		// At the focal distance, world size = 2 * distance * tan(fov/2)
		const worldHeight = 2 * distance * Math.tan(fov / 2);
		const worldUnitsPerPixel = worldHeight / canvasHeight;

		return pixelRadius * worldUnitsPerPixel;
	} else {
		// Unknown camera type, fallback
		return pixelRadius / (currentScale || 1.0);
	}
}

// Expose for canvas3DDrawing.js module
window.getSnapRadiusInWorldUnits3D = getSnapRadiusInWorldUnits3D;

// Helper function: Calculate perpendicular distance from a point to a ray (infinite line)
function distanceFromPointToRay(point, rayOrigin, rayDirection) {
	// Vector from ray origin to point
	const v = {
		x: point.x - rayOrigin.x,
		y: point.y - rayOrigin.y,
		z: point.z - rayOrigin.z,
	};

	// Project v onto ray direction to get distance along ray (t parameter)
	const t = v.x * rayDirection.x + v.y * rayDirection.y + v.z * rayDirection.z;

	// Point on ray closest to target point
	const closestPoint = {
		x: rayOrigin.x + t * rayDirection.x,
		y: rayOrigin.y + t * rayDirection.y,
		z: rayOrigin.z + t * rayDirection.z,
	};

	// Perpendicular distance from point to ray
	const distance = Math.sqrt(Math.pow(point.x - closestPoint.x, 2) + Math.pow(point.y - closestPoint.y, 2) + Math.pow(point.z - closestPoint.z, 2));

	return {
		distance: distance, // Perpendicular distance to ray (for snap radius check)
		rayT: t, // Distance along ray (for depth sorting)
		closestPoint: closestPoint, // Actual 3D snap point
	};
}

// 3D Cylindrical Snap: Snap to anything in the "shadow" along the view ray
// Uses same priorities as 2D snap but works in 3D space
// CRITICAL: Ray is in Three.js local coordinates, so all object positions must be converted to local before comparison
function snapToNearestPointWithRay(rayOrigin, rayDirection, snapRadius) {
	if (!snapEnabled) {
		return {
			snapped: false,
			snapTarget: null,
		};
	}

	const snapCandidates = [];

	// Step 1) Convert helper function: World coordinates to Three.js local coordinates
	const worldToLocal = function (worldX, worldY, worldZ) {
		if (typeof window.worldToThreeLocal === "function") {
			const local = window.worldToThreeLocal(worldX, worldY);
			return { x: local.x, y: local.y, z: worldZ || 0 };
		}
		// Fallback: No conversion if function not available
		return { x: worldX, y: worldY, z: worldZ || 0 };
	};

	// Step 2) Convert helper function: Three.js local coordinates back to world coordinates
	const localToWorld = function (localX, localY, localZ) {
		if (typeof window.threeLocalToWorld === "function") {
			const world = window.threeLocalToWorld(localX, localY);
			return { x: world.x, y: world.y, z: localZ || 0 };
		}
		// Fallback: No conversion if function not available
		return { x: localX, y: localY, z: localZ || 0 };
	};

	// Step 3) Search holes (collar, grade, toe) - convert to local coords for comparison
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// Hole collar (start) - convert world coords to local for ray comparison
			const collarLocal = worldToLocal(hole.startXLocation, hole.startYLocation, hole.startZLocation || 0);
			const collarResult = distanceFromPointToRay(collarLocal, rayOrigin, rayDirection);
			if (collarResult.distance <= snapRadius && collarResult.rayT > 0) {
				// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
				snapCandidates.push({
					distance: collarResult.distance,
					rayT: collarResult.rayT,
					point: { x: hole.startXLocation, y: hole.startYLocation, z: hole.startZLocation || 0 },
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade - convert world coords to local for ray comparison
			const gradeLocal = worldToLocal(hole.gradeXLocation, hole.gradeYLocation, hole.gradeZLocation || 0);
			const gradeResult = distanceFromPointToRay(gradeLocal, rayOrigin, rayDirection);
			if (gradeResult.distance <= snapRadius && gradeResult.rayT > 0) {
				// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
				snapCandidates.push({
					distance: gradeResult.distance,
					rayT: gradeResult.rayT,
					point: { x: hole.gradeXLocation, y: hole.gradeYLocation, z: hole.gradeZLocation || 0 },
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end) - convert world coords to local for ray comparison
			const toeLocal = worldToLocal(hole.endXLocation, hole.endYLocation, hole.endZLocation || 0);
			const toeResult = distanceFromPointToRay(toeLocal, rayOrigin, rayDirection);
			if (toeResult.distance <= snapRadius && toeResult.rayT > 0) {
				// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
				snapCandidates.push({
					distance: toeResult.distance,
					rayT: toeResult.rayT,
					point: { x: hole.endXLocation, y: hole.endYLocation, z: hole.endZLocation || 0 },
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// Step 4) Search ALL KAD Objects in unified map - convert to local coords for comparison
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// Check vertices (points, line endpoints, polygon vertices, etc.)
			entity.data.forEach((dataPoint) => {
				// Convert world coords to local for ray comparison
				const pointLocal = worldToLocal(dataPoint.pointXLocation, dataPoint.pointYLocation, dataPoint.pointZLocation || 0);
				const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

				if (pointResult.distance <= snapRadius && pointResult.rayT > 0) {
					// Determine type and priority based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
					snapCandidates.push({
						distance: pointResult.distance,
						rayT: pointResult.rayT,
						point: { x: dataPoint.pointXLocation, y: dataPoint.pointYLocation, z: dataPoint.pointZLocation || 0 },
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			});

			// Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length];

						// For segment snapping in 3D, sample points along the segment
						const samples = 10;
						for (let s = 0; s <= samples; s++) {
							const t = s / samples;
							// Calculate sample point in world coordinates
							const samplePointWorld = {
								x: p1.pointXLocation + t * (p2.pointXLocation - p1.pointXLocation),
								y: p1.pointYLocation + t * (p2.pointYLocation - p1.pointYLocation),
								z: (p1.pointZLocation || 0) + t * ((p2.pointZLocation || 0) - (p1.pointZLocation || 0)),
							};

							// Convert sample point to local coords for ray comparison
							const samplePointLocal = worldToLocal(samplePointWorld.x, samplePointWorld.y, samplePointWorld.z);
							const segmentResult = distanceFromPointToRay(samplePointLocal, rayOrigin, rayDirection);

							if (segmentResult.distance <= snapRadius && segmentResult.rayT > 0) {
								const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
								const priority = SNAP_PRIORITIES[segmentType];

								// IMPORTANT: Return the ACTUAL segment sample point in world coordinates, NOT the ray projection point
								snapCandidates.push({
									distance: segmentResult.distance,
									rayT: segmentResult.rayT,
									point: samplePointWorld, // Actual segment point in world coords
									type: segmentType,
									priority: priority,
									description: entity.entityType + " segment " + (i + 1),
									segmentInfo: {
										entityName: entity.entityName,
										segmentIndex: i,
										interpolationT: t,
									},
								});
							}
						}
					}
				}
			}
		});
	}

	// Step 5) Search Surface Points (if surfaces are loaded) - convert to local coords for comparison
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					// Convert world coords to local for ray comparison
					const pointLocal = worldToLocal(surfacePoint.x, surfacePoint.y, surfacePoint.z || 0);
					const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

					if (pointResult.distance <= snapRadius && pointResult.rayT > 0) {
						// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
						snapCandidates.push({
							distance: pointResult.distance,
							rayT: pointResult.rayT,
							point: { x: surfacePoint.x, y: surfacePoint.y, z: surfacePoint.z || 0 },
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Step 6) Find the best snap candidate
	// Sort by: 1) Priority (lower number = higher priority), 2) Distance along ray (closer to camera)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority; // Lower priority number wins
			}
			return a.rayT - b.rayT; // Closer to camera wins
		});

		const bestCandidate = snapCandidates[0];

		// Debug: Log snap success
		if (developerModeEnabled) { console.log("üß≤ [3D SNAP] Snapped to:", bestCandidate.type, "(" + bestCandidate.description + ") | Priority:", bestCandidate.priority, "| Distance:", bestCandidate.distance.toFixed(2)); }

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found
	return {
		snapped: false,
		snapTarget: null,
	};
}

// Enhanced global snapping function with segment support
function snapToNearestPoint(rawWorldX, rawWorldY, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation,
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation,
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation,
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// 2. Search ALL KAD Objects in unified map
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// First, check vertices (existing behavior)
			entity.data.forEach((dataPoint) => {
				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`,
					});
				}
			});

			// NEW: Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							// OLD CODE (problematic):
							// const priority = entity.entityType === "line" ? SNAP_PRIORITIES.KAD_LINE_VERTEX - 0.5 : SNAP_PRIORITIES.KAD_POLYGON_VERTEX - 0.5;

							// NEW CODE (fixed):
							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : entity.entityType === "poly" ? "KAD_POLYGON_SEGMENT" : "KAD_LINE_SEGMENT"; // fallback
							const priority = SNAP_PRIORITIES[segmentType]; // Use explicit segment priorities

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t,
								},
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null,
	};
}

// Convert canvas coordinates to world coordinates with snapping
function canvasToWorldWithSnap(canvasX, canvasY) {
	// Convert to raw world coordinates first
	const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

	// Apply snapping
	return snapToNearestPoint(rawWorldX, rawWorldY);
}

// Enhanced mouse move handler with snap preview
function handleMouseMoveWithSnap(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;
	const mouseZ = drawingZValue || document.getElementById("drawingElevation").value || 0;

	// Update global mouse tracking
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;
	currentMouseCanvasZ = mouseZ;

	// Get snapped coordinates for preview
	const snapResult = canvasToWorldWithSnap(mouseX, mouseY, mouseZ);
	currentMouseWorldX = snapResult.worldX;
	currentMouseWorldY = snapResult.worldY;
	currentMouseWorldZ = snapResult.worldZ;

	// Store snap target for visual feedback
	snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;
	// Update elevation field when snapping to a Z value
	if (snapResult.snapped && snapResult.worldZ !== undefined) {
		document.getElementById("drawingElevation").value = snapResult.worldZ;
		drawingZValue = snapResult.worldZ;
		currentMouseWorldZ = snapResult.worldZ;
	}
	// Existing mouse move logic...
	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	// ... rest of existing mouse move logic ...
	drawData(allBlastHoles, selectedHole);
}

// Visual feedback for snap highlights
//TODO Need to call this in the DrawData() function.
//TODO got fix this
function drawSnapHighlight() {
	if (!snapHighlight || !snapEnabled) return;

	// Convert world coordinates to canvas
	const [snapX, snapY] = worldToCanvas(snapHighlight.point.x, snapHighlight.point.y);

	// Draw snap indicator
	ctx.save();
	ctx.strokeStyle = "#00ff00"; // Bright green
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(0, 255, 0, 0.3)";

	// Draw crosshair
	const size = 8;
	ctx.beginPath();
	ctx.moveTo(snapX - size, snapY);
	ctx.lineTo(snapX + size, snapY);
	ctx.moveTo(snapX, snapY - size);
	ctx.lineTo(snapX, snapY + size);
	ctx.stroke();

	// Draw circle
	ctx.beginPath();
	ctx.arc(snapX, snapY, size * 0.7, 0, 2 * Math.PI);
	ctx.stroke();

	// Enhanced tooltip with Z value
	ctx.font = "10px Arial";
	ctx.fillStyle = "#00ff00";
	const zText = snapHighlight.point.z ? " (" + snapHighlight.point.z.toFixed(2) + "m RL)" : "";
	ctx.fillText(snapHighlight.description + zText, snapX + 12, snapY - 8);

	ctx.restore();
}

// Settings for snap configuration
function addSnapSettings() {
	// Add to the UI settings panel
	const snapSettings = `
        <div class="setting-group">
            <label class="labelWhite12">Snap Settings:</label>
            <div class="setting-row">
                <label class="labelWhite10">Enable Snapping:</label>
                <input type="checkbox" id="snapEnabled" ${snapEnabled ? "checked" : ""}>
            </div>
            <div class="setting-row">
                <label class="labelWhite10">Snap Radius:</label>
                <input type="number" id="snapRadius" value="${snapRadius}" min="1" max="50" step="0.5">
                <label class="labelWhite10">meters</label>
            </div>
        </div>
    `;

	// Add event listeners for snap settings
	document.getElementById("snapEnabled")?.addEventListener("change", (e) => {
		snapEnabled = e.target.checked;
		localStorage.setItem("snapEnabled", snapEnabled);
	});

	document.getElementById("snapRadius")?.addEventListener("change", (e) => {
		snapRadius = parseFloat(e.target.value);
		localStorage.setItem("snapRadius", snapRadius);
	});
}

///------------  GEOTIFF STUFF GOES HERE ------------///

// NEW: Interpolate elevation from GeoTIFF raster data
function interpolateZFromRaster(worldX, worldY, rasterSurface) {
	const bbox = rasterSurface.bbox;
	const width = rasterSurface.width;
	const height = rasterSurface.height;
	const elevationData = rasterSurface.rasterData;

	// Check if point is within raster bounds
	if (worldX < bbox[0] || worldX > bbox[2] || worldY < bbox[1] || worldY > bbox[3]) {
		return null;
	}

	// Convert world coordinates to pixel coordinates
	const pixelX = ((worldX - bbox[0]) / (bbox[2] - bbox[0])) * width;
	const pixelY = ((bbox[3] - worldY) / (bbox[3] - bbox[1])) * height; // Y is flipped

	// Get integer pixel coordinates for bilinear interpolation
	const x1 = Math.floor(pixelX);
	const y1 = Math.floor(pixelY);
	const x2 = Math.min(x1 + 1, width - 1);
	const y2 = Math.min(y1 + 1, height - 1);

	// Get the four surrounding elevation values
	const z11 = elevationData[y1 * width + x1];
	const z12 = elevationData[y2 * width + x1];
	const z21 = elevationData[y1 * width + x2];
	const z22 = elevationData[y2 * width + x2];

	// Check for nodata values
	if (z11 === -9999 || z12 === -9999 || z21 === -9999 || z22 === -9999) {
		return null;
	}

	// Bilinear interpolation
	const fx = pixelX - x1;
	const fy = pixelY - y1;

	const z1 = z11 * (1 - fx) + z21 * fx;
	const z2 = z12 * (1 - fx) + z22 * fx;
	const z = z1 * (1 - fy) + z2 * fy;

	return z;
}

// Enhanced loadGeoTIFF function
async function loadGeoTIFF(file) {
	try {
		updateStatusMessage("Reading GeoTIFF file...");

		const arrayBuffer = await file.arrayBuffer();
		const tiff = await fromArrayBuffer(arrayBuffer);
		const image = await tiff.getImage();
		const rasters = await image.readRasters();

		// Get geospatial info
		const bbox = image.getBoundingBox();
		const width = image.getWidth();
		const height = image.getHeight();
		const bandCount = image.getSamplesPerPixel();

		// console.log(`GeoTIFF Info: ${width}x${height}, ${bandCount} bands`);

		// Check if coordinates are in WGS84 (lat/lon)
		if (isLikelyWGS84(bbox)) {
			// Ask user for projection
			const result = await promptForProjection(bbox);
			if (result.transformed) {
				// Use transformed bbox
				await processGeoTIFF(rasters, result.bbox, width, height, bandCount, file.name);
			} else {
				updateStatusMessage("Coordinate transformation cancelled. GeoTIFF not loaded.");
			}
		} else {
			// Use original bbox
			await processGeoTIFF(rasters, bbox, width, height, bandCount, file.name);
		}
	} catch (error) {
		console.error("Error loading GeoTIFF:", error);
		updateStatusMessage("Error loading GeoTIFF: " + error.message);
	}
}

// Function to process GeoTIFF based on bbox type
async function processGeoTIFF(rasters, bbox, width, height, bandCount, surfaceName) {
	// Determine if this is imagery (RGB) or elevation data
	if (bandCount >= 3) {
		// RGB/RGBA imagery - create background image
		await createImageSurface(rasters, bbox, width, height, bandCount, surfaceName);
	} else {
		// Single band - likely elevation data
		await createElevationSurface(rasters[0], bbox, width, height, surfaceName);
	}
}
// NEW: Create elevation surface with raster data for interpolation
async function createElevationSurface(elevationData, bbox, width, height, surfaceName) {
	try {
		const imageId = imageName || "image_" + Date.now();
		loadedImages.set(imageId, {
			id: imageId,
			name: imageName || imageId,
			canvas: canvas,
			bbox: bbox,
			type: "elevation", // or whatever type
			visible: true,
			transparency: 0.7,
		});

		// Then save to DB:
		saveSurfaceToDB(imageId);

		// Also create point cloud for visualization (sampled)
		const points = [];
		const sampleRate = Math.max(1, Math.floor(Math.sqrt(width * height) / 1000));

		for (let y = 0; y < height; y += sampleRate) {
			for (let x = 0; x < width; x += sampleRate) {
				const elevation = elevationData[y * width + x];
				if (elevation !== null && !isNaN(elevation) && elevation !== -9999) {
					const worldX = bbox[0] + (x / width) * (bbox[2] - bbox[0]);
					const worldY = bbox[3] - (y / height) * (bbox[3] - bbox[1]);

					points.push({
						x: worldX,
						y: worldY,
						z: elevation,
					});
				}
			}
		}

		// Create triangulated surface for visualization using existing function
		createSurfaceFromPoints(points, surfaceName, true);

		updateStatusMessage("Elevation surface loaded: " + points.length + " points + full raster interpolation");
	} catch (error) {
		console.error("Error creating elevation surface:", error);
		updateStatusMessage("Error creating elevation surface: " + error.message);
	}
}

// NEW: Create image surface (background imagery)
// Fix the createImageSurface function
async function createImageSurface(rasters, bbox, width, height, bandCount, surfaceName) {
	try {
		// Create canvas for the image
		const imageCanvas = document.createElement("canvas");
		imageCanvas.width = width;
		imageCanvas.height = height;
		const imageCtx = imageCanvas.getContext("2d");

		// Create ImageData
		const imageData = imageCtx.createImageData(width, height);
		const data = imageData.data;

		// Convert raster data to RGBA
		for (let i = 0; i < width * height; i++) {
			const pixelIndex = i * 4;

			// RGB bands
			data[pixelIndex] = rasters[0][i]; // Red
			data[pixelIndex + 1] = rasters[1][i]; // Green
			data[pixelIndex + 2] = rasters[2][i]; // Blue
			data[pixelIndex + 3] = bandCount >= 4 ? rasters[3][i] : 255; // Alpha
		}

		// Put image data on canvas
		imageCtx.putImageData(imageData, 0, 0);

		// Generate unique ID for this image
		const imageId = "image_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);

		// Store in the new loadedImages Map instead of backgroundImage global
		loadedImages.set(imageId, {
			id: imageId,
			name: surfaceName || imageId,
			canvas: imageCanvas,
			bbox: bbox,
			type: "imagery",
			visible: true,
			transparency: 1.0,
		});

		// CRITICAL: Update centroids to include GeoTIFF extents
		updateCentroidsWithBBox(bbox);

		// Update display
		drawData(allBlastHoles, selectedHole);

		// SAVE TO DATABASE - Pass the imageId instead of name
		try {
			await saveImageToDB(imageId);
			console.log("üíæ Image saved to database:", surfaceName);
		} catch (saveError) {
			console.error("‚ùå Failed to save image to database:", saveError);
		}

		// Update tree view to show new image
		debouncedUpdateTreeView();

		setTimeout(() => {
			updateStatusMessage("Background image loaded: " + surfaceName + " (" + width + "x" + height + ")");
			setTimeout(() => {
				updateStatusMessage("");
			}, 3000);
		}, 0);
	} catch (error) {
		console.error("Error creating image surface:", error);
		updateStatusMessage("Error creating image surface: " + error.message);
	}
}

// Add this new helper function
function updateCentroidsWithBBox(bbox) {
	// Call regular updateCentroids first
	updateCentroids();

	// If there's no data yet, use the bbox directly
	if (centroidX === 0 && centroidY === 0) {
		centroidX = (bbox[0] + bbox[2]) / 2;
		centroidY = (bbox[1] + bbox[3]) / 2;
		// console.log("Centering view on GeoTIFF extent:", { centroidX, centroidY });
	}
}

// NEW: Background image support
// WITH this multi-image system:
let loadedImages = new Map(); // Map<imageId, {id, name, canvas, bbox, type, visible, transparency}>

function drawBackgroundImage() {
	if (!imagesGroupVisible) return; // ? ADD: Check images group visibility
	if (loadedImages.size === 0) return;

	loadedImages.forEach((image) => {
		if (!image.visible || !image.canvas) return;

		// Draw this image
		const bbox = image.bbox;
		if (bbox && bbox.length >= 4) {
			// Convert world coordinates to canvas coordinates
			const [x1, y1] = worldToCanvas(bbox[0], bbox[3]); // Top-left
			const [x2, y2] = worldToCanvas(bbox[2], bbox[1]); // Bottom-right

			ctx.save();
			// Fix line 21643 in drawBackgroundImage function
			ctx.globalAlpha = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;

			ctx.drawImage(image.canvas, x1, y1, x2 - x1, y2 - y1);
			ctx.restore();
			// Debug rectangle - FIX: Use canvas.width and canvas.height
			ctx.strokeStyle = "red";
			ctx.lineWidth = 1;
			ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));

			ctx.restore();
		}
	});
}

// Step 1) Image Context Menu using FloatingDialog for consistent styling
// MOVED TO ImagesContextMenu.js - This function is now loaded from external module
/*
function showImageContextMenu(x, y, imageId = null) {
	// Step 2) Get the specific image if ID provided, otherwise first visible image
	var image = imageId
		? loadedImages.get(imageId)
		: Array.from(loadedImages.values()).find(function (img) {
				return img.visible;
		  });
	if (!image) return;

	// Step 3) Store reference for dialog callbacks
	var currentImage = image;
	var currentImageId = imageId;
	var dialogInstance = null;

	// Step 4) Create content builder function
	var contentBuilder = function (dialog) {
		var container = document.createElement("div");
		container.style.display = "flex";
		container.style.flexDirection = "column";
		container.style.gap = "12px";
		container.style.padding = "12px";

		// Step 5) Create action buttons section with full-width buttons
		var buttonsSection = document.createElement("div");
		buttonsSection.style.display = "flex";
		buttonsSection.style.flexDirection = "column";
		buttonsSection.style.gap = "8px";
		buttonsSection.style.marginBottom = "16px";

		// Step 5a) Helper function to create styled full-width button
		var createActionButton = function (text, onClick) {
			var btn = document.createElement("button");
			btn.className = "floating-dialog-btn";
			btn.textContent = text;
			btn.style.width = "100%";
			btn.style.padding = "10px 16px";
			btn.style.fontSize = "13px";
			btn.style.cursor = "pointer";
			btn.style.borderRadius = "4px";
			btn.style.border = "1px solid #ccc";
			btn.style.backgroundColor = "#f5f5f5";
			btn.style.color = "#333";
			btn.style.transition = "background-color 0.2s";
			btn.onmouseover = function () {
				btn.style.backgroundColor = "#e0e0e0";
			};
			btn.onmouseout = function () {
				btn.style.backgroundColor = "#f5f5f5";
			};
			btn.onclick = onClick;
			return btn;
		};

		// Step 6) Toggle visibility button
		buttonsSection.appendChild(
			createActionButton(currentImage.visible ? "Hide Image" : "Show Image", function () {
				if (currentImageId && loadedImages.has(currentImageId)) {
					var targetImage = loadedImages.get(currentImageId);
					if (targetImage) {
						targetImage.visible = !targetImage.visible;
					}
				} else {
					currentImage.visible = !currentImage.visible;
				}
				drawData(allBlastHoles, selectedHole);
				if (dialogInstance) dialogInstance.close();
			})
		);

		// Step 7) Remove image button
		buttonsSection.appendChild(
			createActionButton("Remove Image", function () {
				if (currentImageId && loadedImages.has(currentImageId)) {
					deleteImageFromDB(currentImageId)
						.then(function () {
							loadedImages.delete(currentImageId);
							drawData(allBlastHoles, selectedHole);
							debouncedUpdateTreeView();
						})
						.catch(function (error) {
							console.error("Error removing image:", error);
							loadedImages.delete(currentImageId);
							drawData(allBlastHoles, selectedHole);
						});
				}
				if (dialogInstance) dialogInstance.close();
			})
		);

		// Step 8) Delete all images button
		buttonsSection.appendChild(
			createActionButton("Delete All Images", function () {
				deleteAllImagesFromDB()
					.then(function () {
						loadedImages.clear();
						debouncedUpdateTreeView();
						drawData(allBlastHoles, selectedHole);
					})
					.catch(function (error) {
						console.error("Error deleting all images:", error);
					});
				if (dialogInstance) dialogInstance.close();
			})
		);

		container.appendChild(buttonsSection);

		// Step 9) Create transparency slider section with proper styling
		var sliderSection = document.createElement("div");
		sliderSection.style.marginBottom = "12px";

		var sliderLabel = document.createElement("div");
		sliderLabel.textContent = "Transparency:";
		sliderLabel.style.fontSize = "13px";
		sliderLabel.style.marginBottom = "8px";
		sliderLabel.style.color = "#333";
		sliderSection.appendChild(sliderLabel);

		// Step 9a) Create styled range slider matching app theme
		var sliderContainer = document.createElement("div");
		sliderContainer.style.display = "flex";
		sliderContainer.style.alignItems = "center";
		sliderContainer.style.gap = "12px";

		var initialValue = Math.round((currentImage.transparency !== undefined ? currentImage.transparency : 1.0) * 100);
		var slider = document.createElement("input");
		slider.type = "range";
		slider.min = "0";
		slider.max = "100";
		slider.value = initialValue;
		slider.style.flex = "1";
		slider.style.height = "6px";
		slider.style.cursor = "pointer";
		slider.style.appearance = "none";
		slider.style.webkitAppearance = "none";
		slider.style.background = "linear-gradient(to right, #ff0000 0%, #ff0000 " + initialValue + "%, #ddd " + initialValue + "%, #ddd 100%)";
		slider.style.borderRadius = "3px";
		slider.style.outline = "none";

		var sliderValue = document.createElement("span");
		sliderValue.textContent = initialValue + "%";
		sliderValue.style.minWidth = "45px";
		sliderValue.style.fontSize = "12px";
		sliderValue.style.color = "#666";
		sliderValue.style.textAlign = "right";

		// Step 9b) Update slider appearance and value on input
		slider.oninput = function () {
			var val = parseInt(slider.value);
			sliderValue.textContent = val + "%";
			slider.style.background = "linear-gradient(to right, #ff0000 0%, #ff0000 " + val + "%, #ddd " + val + "%, #ddd 100%)";
			var newTransparency = val / 100;

			if (currentImageId && loadedImages.has(currentImageId)) {
				var targetImage = loadedImages.get(currentImageId);
				if (targetImage) {
					targetImage.transparency = newTransparency;
				}
			} else {
				currentImage.transparency = newTransparency;
			}
			drawData(allBlastHoles, selectedHole);
		};

		sliderContainer.appendChild(slider);
		sliderContainer.appendChild(sliderValue);
		sliderSection.appendChild(sliderContainer);
		container.appendChild(sliderSection);

		// Step 10) Create Z elevation section for 3D positioning
		var zSection = document.createElement("div");
		zSection.style.marginBottom = "12px";

		var zLabel = document.createElement("div");
		zLabel.textContent = "Z Elevation:";
		zLabel.style.fontSize = "13px";
		zLabel.style.marginBottom = "8px";
		zLabel.style.color = "#333";
		zSection.appendChild(zLabel);

		var zInput = document.createElement("input");
		zInput.type = "number";
		zInput.value = currentImage.zElevation !== undefined ? currentImage.zElevation : window.drawingZLevel || 0;
		zInput.style.width = "100%";
		zInput.style.padding = "8px 12px";
		zInput.style.fontSize = "13px";
		zInput.style.borderRadius = "4px";
		zInput.style.border = "1px solid #ccc";
		zInput.style.backgroundColor = "#fff";
		zInput.style.boxSizing = "border-box";

		zInput.onchange = function () {
			var newZ = parseFloat(zInput.value) || 0;
			if (currentImageId && loadedImages.has(currentImageId)) {
				var targetImage = loadedImages.get(currentImageId);
				if (targetImage) {
					targetImage.zElevation = newZ;
				}
			} else {
				currentImage.zElevation = newZ;
			}
			drawData(allBlastHoles, selectedHole);
		};

		zSection.appendChild(zInput);
		container.appendChild(zSection);

		return container;
	};

	// Step 11) Create and show the FloatingDialog
	dialogInstance = new FloatingDialog({
		title: currentImage.name || "Image Properties",
		content: contentBuilder,
		width: 320,
		height: 380,
		showConfirm: false,
		showCancel: false,
		draggable: true,
		resizable: false,
		closeOnOutsideClick: true,
		layoutType: "compact",
	});

	dialogInstance.show();

	// Step 12) Position dialog near click location (adjusted for viewport bounds)
	if (dialogInstance.element) {
		var dialogWidth = 320;
		var dialogHeight = 380;
		var posX = Math.min(x, window.innerWidth - dialogWidth - 20);
		var posY = Math.min(y, window.innerHeight - dialogHeight - 20);
		posX = Math.max(10, posX);
		posY = Math.max(10, posY);
		dialogInstance.element.style.left = posX + "px";
		dialogInstance.element.style.top = posY + "px";
	}
}
*/
// END OF MOVED FUNCTION - showImageContextMenu now loaded from ImagesContextMenu.js

// REPLACE this function to accept image parameter:
function isPointInBackgroundImage(canvasX, canvasY, image = null) {
	// If no specific image provided, check all visible images
	if (!image) {
		return Array.from(loadedImages.values()).some((img) => img.visible && isPointInBackgroundImage(canvasX, canvasY, img));
	}

	if (!image || !image.canvas || !image.visible) return false;

	const bbox = image.bbox;
	if (!bbox || bbox.length < 4) return false;

	// Convert canvas coordinates to world coordinates
	const [worldX, worldY] = canvasToWorld(canvasX, canvasY);

	// Check if point is within image bounds
	return worldX >= bbox[0] && worldX <= bbox[2] && worldY >= bbox[1] && worldY <= bbox[3];
}

///------------  GEOTIFF STUFF ENDS HERE ------------///

///------------ PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///
// For future conversions using PROJ4. That is if a user uploads a latlon geotiff ask them to convert.
// Convert should allow aeither a custom proj4 or one from the epsg.io site.
async function loadEPSGCode(epsgCode) {
	try {
		const url = `https://epsg.io/${epsgCode}.proj4`;
		const response = await fetch(url);
		if (!response.ok) throw new Error("Failed to fetch EPSG definition");

		const proj4def = await response.text();
		proj4.defs(`EPSG:${epsgCode}`, proj4def.trim());

		console.log(`Loaded EPSG:${epsgCode} ‚Üí`, proj4def.trim());
	} catch (err) {
		console.error("Error loading EPSG:", err);
	}
}
// Top 100 most commonly used EPSG codes worldwide
const top100EPSGCodes = [
	{
		code: "4326",
		name: "WGS 84",
	},
	{
		code: "3857",
		name: "WGS 84 / Pseudo-Mercator",
	},
	{
		code: "4269",
		name: "NAD83",
	},
	{
		code: "4267",
		name: "NAD27",
	},
	{
		code: "32633",
		name: "WGS 84 / UTM zone 33N",
	},
	{
		code: "32634",
		name: "WGS 84 / UTM zone 34N",
	},
	{
		code: "32635",
		name: "WGS 84 / UTM zone 35N",
	},
	{
		code: "32636",
		name: "WGS 84 / UTM zone 36N",
	},
	{
		code: "32637",
		name: "WGS 84 / UTM zone 37N",
	},
	{
		code: "32638",
		name: "WGS 84 / UTM zone 38N",
	},
	{
		code: "32639",
		name: "WGS 84 / UTM zone 39N",
	},
	{
		code: "32640",
		name: "WGS 84 / UTM zone 40N",
	},
	{
		code: "32641",
		name: "WGS 84 / UTM zone 41N",
	},
	{
		code: "32642",
		name: "WGS 84 / UTM zone 42N",
	},
	{
		code: "32643",
		name: "WGS 84 / UTM zone 43N",
	},
	{
		code: "32644",
		name: "WGS 84 / UTM zone 44N",
	},
	{
		code: "32645",
		name: "WGS 84 / UTM zone 45N",
	},
	{
		code: "32646",
		name: "WGS 84 / UTM zone 46N",
	},
	{
		code: "32647",
		name: "WGS 84 / UTM zone 47N",
	},
	{
		code: "32648",
		name: "WGS 84 / UTM zone 48N",
	},
	{
		code: "32649",
		name: "WGS 84 / UTM zone 49N",
	},
	{
		code: "32650",
		name: "WGS 84 / UTM zone 50N",
	},
	{
		code: "32651",
		name: "WGS 84 / UTM zone 51N",
	},
	{
		code: "32652",
		name: "WGS 84 / UTM zone 52N",
	},
	{
		code: "32653",
		name: "WGS 84 / UTM zone 53N",
	},
	{
		code: "32654",
		name: "WGS 84 / UTM zone 54N",
	},
	{
		code: "32655",
		name: "WGS 84 / UTM zone 55N",
	},
	{
		code: "32656",
		name: "WGS 84 / UTM zone 56N",
	},
	{
		code: "32657",
		name: "WGS 84 / UTM zone 57N",
	},
	{
		code: "32658",
		name: "WGS 84 / UTM zone 58N",
	},
	{
		code: "32659",
		name: "WGS 84 / UTM zone 59N",
	},
	{
		code: "32660",
		name: "WGS 84 / UTM zone 60N",
	},
	{
		code: "32701",
		name: "WGS 84 / UTM zone 1S",
	},
	{
		code: "32702",
		name: "WGS 84 / UTM zone 2S",
	},
	{
		code: "32703",
		name: "WGS 84 / UTM zone 3S",
	},
	{
		code: "32704",
		name: "WGS 84 / UTM zone 4S",
	},
	{
		code: "32705",
		name: "WGS 84 / UTM zone 5S",
	},
	{
		code: "32706",
		name: "WGS 84 / UTM zone 6S",
	},
	{
		code: "32707",
		name: "WGS 84 / UTM zone 7S",
	},
	{
		code: "32708",
		name: "WGS 84 / UTM zone 8S",
	},
	{
		code: "32709",
		name: "WGS 84 / UTM zone 9S",
	},
	{
		code: "32710",
		name: "WGS 84 / UTM zone 10S",
	},
	{
		code: "32711",
		name: "WGS 84 / UTM zone 11S",
	},
	{
		code: "32712",
		name: "WGS 84 / UTM zone 12S",
	},
	{
		code: "32713",
		name: "WGS 84 / UTM zone 13S",
	},
	{
		code: "32714",
		name: "WGS 84 / UTM zone 14S",
	},
	{
		code: "32715",
		name: "WGS 84 / UTM zone 15S",
	},
	{
		code: "32716",
		name: "WGS 84 / UTM zone 16S",
	},
	{
		code: "32717",
		name: "WGS 84 / UTM zone 17S",
	},
	{
		code: "32718",
		name: "WGS 84 / UTM zone 18S",
	},
	{
		code: "32719",
		name: "WGS 84 / UTM zone 19S",
	},
	{
		code: "32720",
		name: "WGS 84 / UTM zone 20S",
	},
	{
		code: "32721",
		name: "WGS 84 / UTM zone 21S",
	},
	{
		code: "32722",
		name: "WGS 84 / UTM zone 22S",
	},
	{
		code: "32723",
		name: "WGS 84 / UTM zone 23S",
	},
	{
		code: "32724",
		name: "WGS 84 / UTM zone 24S",
	},
	{
		code: "32725",
		name: "WGS 84 / UTM zone 25S",
	},
	{
		code: "32726",
		name: "WGS 84 / UTM zone 26S",
	},
	{
		code: "32727",
		name: "WGS 84 / UTM zone 27S",
	},
	{
		code: "32728",
		name: "WGS 84 / UTM zone 28S",
	},
	{
		code: "32729",
		name: "WGS 84 / UTM zone 29S",
	},
	{
		code: "32730",
		name: "WGS 84 / UTM zone 30S",
	},
	{
		code: "32731",
		name: "WGS 84 / UTM zone 31S",
	},
	{
		code: "32732",
		name: "WGS 84 / UTM zone 32S",
	},
	{
		code: "32733",
		name: "WGS 84 / UTM zone 33S",
	},
	{
		code: "32734",
		name: "WGS 84 / UTM zone 34S",
	},
	{
		code: "32735",
		name: "WGS 84 / UTM zone 35S",
	},
	{
		code: "32736",
		name: "WGS 84 / UTM zone 36S",
	},
	{
		code: "32737",
		name: "WGS 84 / UTM zone 37S",
	},
	{
		code: "32738",
		name: "WGS 84 / UTM zone 38S",
	},
	{
		code: "32739",
		name: "WGS 84 / UTM zone 39S",
	},
	{
		code: "32740",
		name: "WGS 84 / UTM zone 40S",
	},
	{
		code: "32741",
		name: "WGS 84 / UTM zone 41S",
	},
	{
		code: "32742",
		name: "WGS 84 / UTM zone 42S",
	},
	{
		code: "32743",
		name: "WGS 84 / UTM zone 43S",
	},
	{
		code: "32744",
		name: "WGS 84 / UTM zone 44S",
	},
	{
		code: "32745",
		name: "WGS 84 / UTM zone 45S",
	},
	{
		code: "32746",
		name: "WGS 84 / UTM zone 46S",
	},
	{
		code: "32747",
		name: "WGS 84 / UTM zone 47S",
	},
	{
		code: "32748",
		name: "WGS 84 / UTM zone 48S",
	},
	{
		code: "32749",
		name: "WGS 84 / UTM zone 49S",
	},
	{
		code: "32750",
		name: "WGS 84 / UTM zone 50S",
	},
	{
		code: "32751",
		name: "WGS 84 / UTM zone 51S",
	},
	{
		code: "32752",
		name: "WGS 84 / UTM zone 52S",
	},
	{
		code: "32753",
		name: "WGS 84 / UTM zone 53S",
	},
	{
		code: "32754",
		name: "WGS 84 / UTM zone 54S",
	},
	{
		code: "32755",
		name: "WGS 84 / UTM zone 55S",
	},
	{
		code: "32756",
		name: "WGS 84 / UTM zone 56S",
	},
	{
		code: "32757",
		name: "WGS 84 / UTM zone 57S",
	},
	{
		code: "32758",
		name: "WGS 84 / UTM zone 58S",
	},
	{
		code: "32759",
		name: "WGS 84 / UTM zone 59S",
	},
	{
		code: "32760",
		name: "WGS 84 / UTM zone 60S",
	},
	{
		code: "2154",
		name: "RGF93 / Lambert-93",
	},
	{
		code: "25832",
		name: "ETRS89 / UTM zone 32N",
	},
	{
		code: "25833",
		name: "ETRS89 / UTM zone 33N",
	},
	{
		code: "3035",
		name: "ETRS89 / LAEA Europe",
	},
	{
		code: "3395",
		name: "WGS 84 / World Mercator",
	},
	{
		code: "4277",
		name: "OSGB 1936",
	},
	{
		code: "27700",
		name: "OSGB 1936 / British National Grid",
	},
	{
		code: "2180",
		name: "ETRS89 / Poland CS92",
	},
	{
		code: "3003",
		name: "Monte Mario / Italy zone 1",
	},
	{
		code: "3004",
		name: "Monte Mario / Italy zone 2",
	},
	{
		code: "31370",
		name: "Belge 1972 / Belgian Lambert 72",
	},
	{
		code: "28992",
		name: "Amersfoort / RD New",
	},
	{
		code: "2056",
		name: "CH1903+ / LV95",
	},
	{
		code: "5514",
		name: "S-JTSK / Krovak East North",
	},
	{
		code: "102100",
		name: "WGS 1984 Web Mercator Auxiliary Sphere",
	},
];
//function to cache a list of common world EPSG codes.
// NOT IN USE - USE THE TOP100EPSGCodes ARRAY ABOVE
function getTop100EPSGCodesFromWeb(codesEPSG) {
	// Cache for storing EPSG codes to avoid repeated API calls
	const epsgCache = new Map();

	// Function to fetch EPSG definitions from web and cache them
	function fetchEPSGDefinitions() {
		return new Promise(function (resolve, reject) {
			updateStatusMessage("Loading coordinate system definitions...");

			let loadedCount = 0;
			const totalCount = codesEPSG.length;

			codesEPSG.forEach(function (epsg) {
				if (!epsgCache.has(epsg.code)) {
					const url = "https://epsg.io/" + epsg.code + ".proj4";
					fetch(url)
						.then(function (response) {
							if (response.ok) {
								return response.text();
							}
							throw new Error("Failed to fetch EPSG:" + epsg.code);
						})
						.then(function (proj4def) {
							epsgCache.set(epsg.code, proj4def.trim());
							proj4.defs("EPSG:" + epsg.code, proj4def.trim());
						})
						.catch(function (error) {
							console.warn("Failed to load EPSG:" + epsg.code, error);
						})
						.finally(function () {
							loadedCount++;
							if (loadedCount === totalCount) {
								updateStatusMessage("Coordinate system definitions loaded");
								resolve(codesEPSG);
							}
						});
				} else {
					loadedCount++;
					if (loadedCount === totalCount) {
						updateStatusMessage("Coordinate system definitions loaded");
						resolve(top100EPSGCodes);
					}
				}
			});
		});
	}

	// Return the cached list or fetch if needed
	if (epsgCache.size === 0) {
		return fetchEPSGDefinitions();
	} else {
		return Promise.resolve(top100EPSGCodes);
	}
}

// Add this function to detect if coordinates are likely WGS84
function isLikelyWGS84(bbox) {
	// WGS84 coordinates typically range from -180 to 180 for longitude
	// and -90 to 90 for latitude
	return bbox[0] >= -180 && bbox[0] <= 180 && bbox[2] >= -180 && bbox[2] <= 180 && bbox[1] >= -90 && bbox[1] <= 90 && bbox[3] >= -90 && bbox[3] <= 90;
}

// Prompt user for projection details
async function promptForProjection(bbox) {
	// Common Australian UTM zones
	const commonEPSGCodes = top100EPSGCodes;

	// Build dropdown options
	const dropdownOptions = commonEPSGCodes.map((item) => `<option value="${item.code}">${item.code} - ${item.name}</option>`).join("");

	return new Promise((resolve) => {
		Swal.fire({
			title: "Coordinate System Conversion Required",
			html: `
                <div style="text-align: left; margin-bottom: 15px;">
                    <p class="labelWhite15">The GeoTIFF appears to use WGS84 (latitude/longitude) coordinates:</p>
                    <pre style="background:#ccc; padding:5px; border-radius:3px; color:#444; font-size:12px;">${bbox[0].toFixed(6) + ", " + bbox[1].toFixed(6) + " to " + bbox[2].toFixed(6) + ", " + bbox[3].toFixed(6)}</pre>
                    <p class="labelWhite15">Kirra2D uses meters East(X)/North(Y). Please select a target coordinate system:</p>
                </div>
                <div class="button-container-2col">
                    <div class="labelWhite15">EPSG Code:</div>
                    <select id="epsgCode" class="swal2-select">
                        <option value="">Select EPSG Code</option>
                        ${dropdownOptions}
                    </select>
                    
                    <div class="labelWhite15">Or Custom Proj4:</div>
                    <textarea id="customProj4" class="swal2-input" placeholder="+proj=utm +zone=50 +south +datum=WGS84 +units=m +no_defs" style="height:60px; width:50%;"></textarea>
                </div>
            `,
			showCancelButton: true,
			focusConfirm: false,
			confirmButtonText: "Transform",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				popup: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container",
			},
			preConfirm: async () => {
				const epsgCode = document.getElementById("epsgCode").value;
				const customProj4 = document.getElementById("customProj4").value;

				try {
					let sourceDef = "+proj=longlat +datum=WGS84 +no_defs";
					let targetDef = "";

					if (epsgCode) {
						await loadEPSGCode(epsgCode);
						targetDef = `EPSG:${epsgCode}`;
					} else if (customProj4) {
						targetDef = customProj4;
					} else {
						Swal.showValidationMessage("Please select an EPSG code or provide a custom Proj4 definition");
						return false;
					}

					// Transform the bounding box
					const ll = proj4(sourceDef, targetDef, [bbox[0], bbox[1]]);
					const ur = proj4(sourceDef, targetDef, [bbox[2], bbox[3]]);

					console.log("Transformed coordinates:", {
						ll,
						ur,
					});

					return {
						transformed: true,
						bbox: [ll[0], ll[1], ur[0], ur[1]],
						epsgCode: epsgCode || null,
						customProj4: customProj4 || null,
					};
				} catch (error) {
					Swal.showValidationMessage(`Transformation error: ${error.message}`);
					return false;
				}
			},
		}).then((result) => {
			if (result.isConfirmed && result.value) {
				resolve(result.value);
			} else {
				resolve({
					transformed: false,
				});
			}
		});
	});
}

///------------ END OF PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///

//----REPLACEMENT OPTION FOR PRINTING----///
// Print functions have been moved to ./print/PrintSystem.js, ./print/PrintRendering.js, and ./print/PrintStats.js

//===========================
// End of the STATS SECTION
//===========================

//=============================================================
// TREE VIEW SYSTEM - NOW IMPORTED FROM MODULE
//=============================================================
// TreeView class has been moved to src/dialog/tree/TreeView.js
// This includes ~1,600 lines of code extracted for better modularity
// The TreeView is now imported at the top of this file and 
// initialized via initializeTreeView() function

// JS COLOR PICKER FOR INSTANT COLOUR CHANGES
function openColorPickerForElement(swatchElement, entityName, pointID) {
	console.log("üéØ openColorPickerForElement called with:", {
		swatchElement,
		entityName,
		pointID,
	});

	// Get the entity data
	const entity = allKADDrawingsMap.get(entityName);
	console.log("üìä Entity found:", entity);

	if (!entity) {
		console.log("‚ùå Entity not found:", entityName);
		return;
	}

	// Debug: Show all pointIDs in the entity
	console.log(
		"üîò All pointIDs in entity:",
		entity.data.map((el) => ({
			pointID: el.pointID,
			type: typeof el.pointID,
		}))
	);

	// ? FIX: Use 'let' instead of 'const' so we can reassign
	let element = entity.data.find((el) => el.pointID === pointID);
	console.log("üîé Element found:", element);

	if (!element) {
		console.log("‚ùå Element not found with pointID:", pointID);
		// Try converting to string
		element = entity.data.find((el) => el.pointID === pointID.toString());
		console.log("üîª Trying as string:", element);
		if (!element) {
			// Try converting pointID to string and compare
			element = entity.data.find((el) => el.pointID.toString() === pointID.toString());
			console.log("üîª Trying both as strings:", element);
		}
		if (!element) {
			console.log("‚ùå Element still not found after all attempts");
			return;
		}
	}

	// Check if JSColor is already installed and remove it
	if (swatchElement.jscolor) {
		try {
			swatchElement.jscolor.destroy();
		} catch (e) {
			// Ignore errors during cleanup
		}
	}

	// Create JSColor picker directly
	const picker = new JSColor(swatchElement, {
		value: element.color || getJSColorHexDrawing(),
		format: "hex",
		mode: "HSV",
		position: "right",
		onChange: function () {
			// ? FIX: Use toHEXString() instead of toString() to avoid double hash
			const newColor = this.toHEXString(); // This already includes the #
			element.color = newColor;

			// Update the original swatch element (might be orphaned after tree rebuild)
			swatchElement.style.backgroundColor = newColor;

			// Redraw the canvas
			drawData(allBlastHoles, selectedHole);

			// Update tree (rebuilds HTML with new color)
			debouncedUpdateTreeView();

			// CRITICAL: After tree updates, find and update the NEW swatch element in the DOM
			// The tree rebuild creates new elements, so we need to update the new swatch too
			setTimeout(function () {
				const newSwatchElement = document.querySelector(
					'.color-swatch[data-entity-name="' + entityName + '"][data-point-id="' + pointID + '"]'
				);
				if (newSwatchElement) {
					newSwatchElement.style.backgroundColor = newColor;
					console.log("üîª Updated NEW swatch element after tree rebuild");
				}
			}, 150); // Wait for debounced tree update (100ms) + render time

			console.log("‚úÖ Updated " + entityName + " point " + pointID + " color to:", newColor);
		},
	});

	// Show the picker
	picker.show();
}
// Initialize tree view
let treeView;
// Add this debounced version
let updateTreeViewTimeout;

// Step 1) Function to sync canvas selections to TreeView
function syncCanvasToTreeView() {
	if (!treeView) return;

	const nodeIds = [];

	// Step 2) Convert hole selections to node IDs
	if (selectedHole) {
		const nodeId = "hole‚£ø" + selectedHole.entityName + "‚£ø" + selectedHole.holeID;
		nodeIds.push(nodeId);
	} else if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach(function (hole) {
			const nodeId = "hole‚£ø" + hole.entityName + "‚£ø" + hole.holeID;
			nodeIds.push(nodeId);
		});
	}

	// Step 3) Convert KAD selections to node IDs
	if (selectedKADObject) {
		// Check if vertex-level selection
		if (selectedPoint) {
			// Individual vertex
			const nodeId = selectedKADObject.entityType + "‚£ø" + selectedKADObject.entityName + "‚£øelement‚£ø" + selectedPoint.pointID;
			nodeIds.push(nodeId);
		} else {
			// Entity-level selection
			const entityType = selectedKADObject.entityType === "point" ? "points" : selectedKADObject.entityType;
			const nodeId = entityType + "‚£ø" + selectedKADObject.entityName;
			nodeIds.push(nodeId);
		}
	} else if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		selectedMultipleKADObjects.forEach(function (kadObj) {
			if (kadObj.selectionType === "vertex") {
				// Vertex selection
				const entity = allKADDrawingsMap.get(kadObj.entityName);
				if (entity && entity.data[kadObj.elementIndex]) {
					const pointID = entity.data[kadObj.elementIndex].pointID;
					const nodeId = kadObj.entityType + "‚£ø" + kadObj.entityName + "‚£øelement‚£ø" + pointID;
					nodeIds.push(nodeId);
				}
			} else {
				// Entity selection
				const entityType = kadObj.entityType === "point" ? "points" : kadObj.entityType;
				const nodeId = entityType + "‚£ø" + kadObj.entityName;
				nodeIds.push(nodeId);
			}
		});
	}

	// Step 4) Highlight nodes in TreeView
	if (nodeIds.length > 0) {
		treeView.highlightNodes(nodeIds);
	} else {
		treeView.clearSelection();
	}
}


// Assign the actual implementation to the forward-declared variable
// PERFORMANCE FIX 2025-12-28: Smart tree updates - skip if hidden, use idle callback
debouncedUpdateTreeView = function (delay = 250) {  // Increased default delay
	if (updateTreeViewTimeout) {
		clearTimeout(updateTreeViewTimeout);
	}

	// Skip if tree panel is not visible
	var treePanel = document.getElementById("treePanel");
	if (!treePanel || treePanel.style.display === "none") {
		// Tree is hidden - mark as needing update when shown
		window._treeNeedsUpdate = true;
		return;
	}

	updateTreeViewTimeout = setTimeout(function () {
		// Use requestIdleCallback if available for non-blocking update
		if (typeof requestIdleCallback === "function") {
			requestIdleCallback(function () {
				updateTreeView();
			}, { timeout: 500 });  // Max wait 500ms
		} else {
			updateTreeView();
		}
	}, delay);
};
// ? Function to update TreeView visual states based on actual visibility
function updateTreeViewVisibilityStates() {
	if (!treeView) return;

	// Update group visibility states
	const groupNodes = [
		{
			nodeId: "blast",
			visible: blastGroupVisible,
		},
		{
			nodeId: "drawings",
			visible: drawingsGroupVisible,
		},
		{
			nodeId: "surfaces",
			visible: surfacesGroupVisible,
		},
		{
			nodeId: "images",
			visible: imagesGroupVisible,
		},
		{
			nodeId: "drawings?points",
			visible: pointsGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?lines",
			visible: linesGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?polygons",
			visible: polygonsGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?circles",
			visible: circlesGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?texts",
			visible: textsGroupVisible && drawingsGroupVisible,
		},
	];

	groupNodes.forEach(({ nodeId, visible }) => {
		const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
		if (element) {
			if (visible) {
				element.style.opacity = "1";
				element.classList.remove("hidden-node");
			} else {
				element.style.opacity = "0.5";
				element.classList.add("hidden-node");
			}
		}
	});

	// ? FIX: Update entity visibility states (inherit from parent group)
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap) {
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			const nodeId = entity.entityType + "?" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check both entity visibility AND parent group visibility
				let isVisible = entity.visible !== false && drawingsGroupVisible;

				// ? FIX: Also check specific subgroup visibility with correct entity types
				if (entity.entityType === "point") isVisible = isVisible && pointsGroupVisible;
				else if (entity.entityType === "line") isVisible = isVisible && linesGroupVisible;
				else if (entity.entityType === "poly") isVisible = isVisible && polygonsGroupVisible;
				else if (entity.entityType === "circle") isVisible = isVisible && circlesGroupVisible;
				else if (entity.entityType === "text") isVisible = isVisible && textsGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}

			// ? ADD: Update individual element visibility states
			entity.data.forEach((elementData, index) => {
				const elementNodeId = entity.entityType + "‚£ø" + entityName + "‚£øelement‚£ø" + (elementData.pointID || index + 1);
				const elementElement = treeView.container.querySelector('[data-node-id="' + elementNodeId + '"]');
				if (elementElement) {
					// Element inherits from entity and group visibility
					let isElementVisible = entity.visible !== false && drawingsGroupVisible;

					// Check specific subgroup visibility
					if (entity.entityType === "point") isElementVisible = isElementVisible && pointsGroupVisible;
					else if (entity.entityType === "line") isElementVisible = isElementVisible && linesGroupVisible;
					else if (entity.entityType === "poly") isElementVisible = isElementVisible && polygonsGroupVisible;
					else if (entity.entityType === "circle") isElementVisible = isElementVisible && circlesGroupVisible;
					else if (entity.entityType === "text") isElementVisible = isElementVisible && textsGroupVisible;

					// Check individual element visibility
					if (elementData.visible === false) isElementVisible = false;

					if (isElementVisible) {
						elementElement.style.opacity = "1";
						elementElement.classList.remove("hidden-node");
					} else {
						elementElement.style.opacity = "0.5";
						elementElement.classList.add("hidden-node");
					}
				}
			});
		}
	}

	// ? FIX: Update hole visibility states with correct node ID pattern
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const nodeId = "hole‚£ø" + hole.holeID; // ? FIX: Correct node ID pattern
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				const isVisible = hole.visible !== false && blastGroupVisible;
				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}

	// ? ADD: Update entity (blast) group visibility
	const entityGroups = {};
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const entityName = hole.entityName || "Unknown";
			if (!entityGroups[entityName]) {
				entityGroups[entityName] = [];
			}
			entityGroups[entityName].push(hole);
		});

		Object.keys(entityGroups).forEach((entityName) => {
			const nodeId = "entity‚£ø" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check if any holes in this entity are visible and blast group is visible
				const entityHoles = entityGroups[entityName];
				const hasVisibleHoles = entityHoles.some((hole) => hole.visible !== false);
				const isVisible = hasVisibleHoles && blastGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}
}

// Update tree when data changes
function updateTreeView() {
	if (treeView) {
		// ? Update tree visibility states first
		updateTreeViewVisibilityStates();

		treeView.updateTreeData();
	}
}

//=============================================================
// TREE VIEW DELEGATION FUNCTIONS
//=============================================================
// These functions are called by the TreeView module to handle operations
// that require access to global application state

// Step 1) Handle TreeView delete operations
window.handleTreeViewDelete = function (nodeIds, treeViewInstance) {
	console.log("üéÑ [TreeView] Delete requested for:", nodeIds.length, "items");

	// Determine what's being deleted
	const hasHoles = nodeIds.some(function (id) { return id.startsWith("hole‚£ø"); });
	const hasEntities = nodeIds.some(function (id) { return id.startsWith("entity‚£ø"); });
	const hasSurfaces = nodeIds.some(function (id) { return id.startsWith("surface‚£ø"); });
	const hasImages = nodeIds.some(function (id) { return id.startsWith("image‚£ø"); });
	const hasKADElements = nodeIds.some(function (id) { return id.includes("‚£øelement‚£ø"); });
	const hasKADEntities = nodeIds.some(function (id) {
		const parts = id.split("‚£ø");
		return (parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2;
	});

	// Delegate to existing deletion logic
	if (hasKADElements) {
		// Delete KAD elements (vertices/points)
		const entitiesToRenumber = new Set();

		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length >= 4 && parts[2] === "element") {
				const entityName = parts[1];
				const elementId = parts[3];

				const entity = allKADDrawingsMap.get(entityName);
				if (entity && entity.data) {
					const elementIndex = entity.data.findIndex(function (el) { return el.pointID == elementId; });
					if (elementIndex !== -1) {
						entity.data.splice(elementIndex, 1);
						entitiesToRenumber.add(entityName);

						if (entity.data.length === 0) {
							allKADDrawingsMap.delete(entityName);
							entitiesToRenumber.delete(entityName);
						}
					}
				}
			}
		});

		// Renumber affected entities
		entitiesToRenumber.forEach(function (entityName) {
			const entity = allKADDrawingsMap.get(entityName);
			if (entity && typeof renumberEntityPoints === "function") {
				renumberEntityPoints(entity);
			}
		});

		if (typeof debouncedSaveKAD === "function") {
			debouncedSaveKAD();
		}

		treeViewInstance.updateTreeData();
		drawData(allBlastHoles, selectedHole);
	} else if (hasKADEntities) {
		// Delete entire KAD entities
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2) {
				const entityName = parts[1];
				if (allKADDrawingsMap.has(entityName)) {
					allKADDrawingsMap.delete(entityName);
				}
			}
		});

		if (typeof debouncedSaveKAD === "function") {
			debouncedSaveKAD();
		}

		treeViewInstance.updateTreeData();
		drawData(allBlastHoles, selectedHole);
	} else if (hasSurfaces) {
		// Delete surfaces
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2 && parts[0] === "surface") {
				const surfaceId = parts[1];
				if (window.loadedSurfaces && window.loadedSurfaces.has(surfaceId)) {
					window.loadedSurfaces.delete(surfaceId);
					// Delete from IndexedDB
					if (typeof window.deleteSurfaceFromDB === "function") {
						window.deleteSurfaceFromDB(surfaceId);
					}
					console.log("‚úÖ Surface " + surfaceId + " deleted");
				}
			}
		});

		treeViewInstance.updateTreeData();
		drawData(allBlastHoles, selectedHole);
	} else if (hasImages) {
		// Delete images
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2 && parts[0] === "image") {
				const imageId = parts[1];
				if (window.loadedImages && window.loadedImages.has(imageId)) {
					window.loadedImages.delete(imageId);
					// Delete from IndexedDB
					if (typeof window.deleteImageFromDB === "function") {
						window.deleteImageFromDB(imageId);
					}
					console.log("‚úÖ Image " + imageId + " deleted");
				}
			}
		});

		treeViewInstance.updateTreeData();
		drawData(allBlastHoles, selectedHole);
	} else if (hasHoles || hasEntities) {
		// Step 2a) Delete holes and/or entire blast entities with renumber confirmation (USE FACTORY CODE)

		// Step 2a.1) Ask if user wants to renumber after deletion (USE FACTORY CODE)
		window.showConfirmationDialog(
			"Renumber Holes?",
			"Do you want to renumber holes after deletion?",
			"Yes",
			"No",
			function () {
				// Step 2a.2) Yes - Ask for starting number (USE FACTORY CODE)
				window.showConfirmationDialogWithInput(
					"Renumber Starting Value",
					"Enter the starting number for renumbering:",
					"Start From",
					"text",
					"1",
					"OK",
					"Cancel",
					function (startNumber) {
						// Step 2a.3) Delete and renumber with starting value
						const entitiesToRenumber = new Set();

						if (hasEntities) {
							// Delete entire blast entities (all holes in that entity)
							nodeIds.forEach(function (nodeId) {
								const parts = nodeId.split("‚£ø");
								if (parts[0] === "entity" && parts.length === 2) {
									const entityName = parts[1];

									// Remove all holes with this entityName
									const holesRemoved = allBlastHoles.filter(function (hole) { return hole.entityName === entityName; }).length;
									allBlastHoles = allBlastHoles.filter(function (hole) { return hole.entityName !== entityName; });

									console.log("‚ùå Deleted entity: " + entityName + " (" + holesRemoved + " holes)");
								}
							});
						}

						if (hasHoles) {
							// Delete individual holes
							nodeIds.forEach(function (nodeId) {
								const parts = nodeId.split("‚£ø");
								if (parts[0] === "hole" && parts.length === 3) {
									const entityName = parts[1];
									const holeID = parts[2];

									// Find and remove the specific hole
									const index = allBlastHoles.findIndex(function (h) { return h.entityName === entityName && h.holeID === holeID; });
									if (index !== -1) {
										allBlastHoles.splice(index, 1);
										entitiesToRenumber.add(entityName);
										console.log("‚ùå Deleted hole: " + entityName + ":" + holeID);
									}
								}
							});
						}

						// Renumber affected entities with starting number (USE FACTORY CODE)
						entitiesToRenumber.forEach(function (entityName) {
							if (typeof renumberHolesFunction === "function") {
								renumberHolesFunction(startNumber, entityName);
							}
						});

						// Save and update (USE FACTORY CODE)
						if (typeof debouncedSaveHoles === "function") {
							debouncedSaveHoles();
						}

						treeViewInstance.updateTreeData();
						drawData(allBlastHoles, selectedHole);
						updateStatusMessage("Deleted holes and renumbered from " + startNumber);
						setTimeout(function () { updateStatusMessage(""); }, 2000);
					},
					function () {
						// Step 2a.4) User cancelled starting number input
						updateStatusMessage("Delete cancelled");
						setTimeout(function () { updateStatusMessage(""); }, 2000);
					}
				);
			},
			function () {
				// Step 2a.5) No - Delete without renumbering
				if (hasEntities) {
					// Delete entire blast entities (all holes in that entity)
					nodeIds.forEach(function (nodeId) {
						const parts = nodeId.split("‚£ø");
						if (parts[0] === "entity" && parts.length === 2) {
							const entityName = parts[1];

							// Remove all holes with this entityName
							const holesRemoved = allBlastHoles.filter(function (hole) { return hole.entityName === entityName; }).length;
							allBlastHoles = allBlastHoles.filter(function (hole) { return hole.entityName !== entityName; });

							console.log("‚ùå Deleted entity: " + entityName + " (" + holesRemoved + " holes)");
						}
					});
				}

				if (hasHoles) {
					// Delete individual holes
					nodeIds.forEach(function (nodeId) {
						const parts = nodeId.split("‚£ø");
						if (parts[0] === "hole" && parts.length === 3) {
							const entityName = parts[1];
							const holeID = parts[2];

							// Find and remove the specific hole
							const index = allBlastHoles.findIndex(function (h) { return h.entityName === entityName && h.holeID === holeID; });
							if (index !== -1) {
								allBlastHoles.splice(index, 1);
								console.log("‚ùå Deleted hole: " + entityName + ":" + holeID);
							}
						}
					});
				}

				// Clear selections
				selectedHole = null;
				selectedMultipleHoles = [];				
				// Use refreshPoints() for complete update
				refreshPoints();				
				updateStatusMessage("Deleted holes without renumbering");
				setTimeout(function () { updateStatusMessage(""); }, 2000);
			}
		);
	}
};

// Step 2) Handle TreeView visibility toggle
window.handleTreeViewVisibility = function (nodeId, type, itemId, isVisible) {
	console.log("üéÑ [TreeView] Visibility toggle:", nodeId, "?", isVisible);

	// Main group visibility
	if (nodeId === "blast") {
		setBlastGroupVisibility(isVisible);
	} else if (nodeId === "drawings") {
		setDrawingsGroupVisibility(isVisible);
	} else if (nodeId === "surfaces") {
		setSurfacesGroupVisibility(isVisible);
	} else if (nodeId === "images") {
		setImagesGroupVisibility(isVisible);
	}
	// Drawing subgroup visibility
	else if (nodeId === "drawings?points") {
		setPointsGroupVisibility(isVisible);
	} else if (nodeId === "drawings?lines") {
		setLinesGroupVisibility(isVisible);
	} else if (nodeId === "drawings?polygons") {
		setPolygonsGroupVisibility(isVisible);
	} else if (nodeId === "drawings?circles") {
		setCirclesGroupVisibility(isVisible);
	} else if (nodeId === "drawings?texts") {
		setTextsGroupVisibility(isVisible);
	}
	// Individual item visibility
	else if (type === "surface") {
		setSurfaceVisibility(itemId, isVisible);
	} else if (type === "image") {
		setImageVisibility(itemId, isVisible);
	} else if (type === "hole") {
		setHoleVisibility(itemId, isVisible);
	} else if (type === "entity") {
		setEntityVisibility(itemId, isVisible);
	} else if (type === "points" || type === "line" || type === "poly" || type === "circle" || type === "text") {
		setKADEntityVisibility(itemId, isVisible);
	} else if (nodeId.includes("‚£øelement‚£ø")) {
		const parts = nodeId.split("‚£ø");
		if (parts.length >= 4 && parts[2] === "element") {
			const entityName = parts[1];
			const elementId = parts[3];
			setKADElementVisibility(entityName, elementId, isVisible);
		}
	}

	// Note: Individual visibility setters already call drawData() and updateTreeViewVisibilityStates()
};

// Step 3) Handle TreeView rename operations
window.handleTreeViewRename = function (nodeId, treeViewInstance) {
	console.log("üéÑ [TreeView] Rename requested for:", nodeId);

	const parts = nodeId.split("‚£ø");

	// Blast entity rename
	if (parts[0] === "entity" && parts.length === 2) {
		const entityName = parts[1];
		const firstHole = allBlastHoles.find(function (h) { return h.entityName === entityName; });
		if (firstHole && typeof window.editBlastNamePopup === "function") {
			// editBlastNamePopup now returns a promise
			window.editBlastNamePopup(firstHole).then(function (result) {
				if (result && result.isConfirmed) {
					// Update TreeView after successful rename
					if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
						treeViewInstance.updateTreeData();
					}
				}
			});
		}
		return;
	}

	// KAD entity rename
	if ((parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
		const oldEntityName = parts[1];
		const entity = allKADDrawingsMap.get(oldEntityName);
		if (!entity) {
			console.log("[BAD] [TreeView] Entity not found:", oldEntityName);
			return;
		}

		if (typeof window.renameEntityDialog === "function") {
			window.renameEntityDialog(parts[0], oldEntityName).then(function (result) {
				if (result.isConfirmed) {
					const newEntityName = result.value.trim();
					if (!newEntityName || newEntityName === oldEntityName) return;

					if (allKADDrawingsMap.has(newEntityName)) {
						showModalMessage("Name Error", "Name already exists!", "error");
						return;
					}

					// Rename entity
					allKADDrawingsMap.set(newEntityName, {
						...entity,
						entityName: newEntityName,
						data: entity.data.map(function (el) {
							return { ...el, entityName: newEntityName };
						})
					});
					allKADDrawingsMap.delete(oldEntityName);

					if (typeof debouncedSaveKAD === "function") {
						debouncedSaveKAD();
					}

					treeViewInstance.updateTreeData();
					drawData(allBlastHoles, selectedHole);
				}
			});
		} else {
			console.error("[BAD] [TreeView] window.renameEntityDialog is not a function! Type:", typeof window.renameEntityDialog);
		}
		return;
	}

	// Surface rename
	if (parts[0] === "surface" && parts.length === 2) {
		const surfaceId = parts[1];
		const surface = window.loadedSurfaces ? window.loadedSurfaces.get(surfaceId) : null;
		if (surface) {
			// Create a simple input dialog for renaming
			window.showConfirmationDialogWithInput(
				"Rename Surface",
				"Enter new name for surface:",
				"New Name",
				"text",
				surface.name || "Surface " + surfaceId,
				"OK",
				"Cancel",
				function (newName) {
					if (newName && newName.trim() && newName.trim() !== surface.name) {
						const trimmedName = newName.trim();
						surface.name = trimmedName;

						// Save to IndexedDB if function exists
						if (typeof window.saveSurfaceToDB === "function") {
							window.saveSurfaceToDB(surfaceId, surface);
						}

						// Update TreeView
						if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
							treeViewInstance.updateTreeData();
						}

						console.log("‚úÖ Surface renamed:", surfaceId, "->", trimmedName);
					}
				},
				function () {
					// Cancelled
				}
			);
		}
		return;
	}

	// Image rename
	if (parts[0] === "image" && parts.length === 2) {
		const imageId = parts[1];
		const image = window.loadedImages ? window.loadedImages.get(imageId) : null;
		if (image) {
			// Create a simple input dialog for renaming
			window.showConfirmationDialogWithInput(
				"Rename Image",
				"Enter new name for image:",
				"New Name",
				"text",
				image.name || "Image " + imageId,
				"OK",
				"Cancel",
				function (newName) {
					if (newName && newName.trim() && newName.trim() !== image.name) {
						const trimmedName = newName.trim();
						image.name = trimmedName;

						// Save to IndexedDB if function exists
						if (typeof window.saveImageToDB === "function") {
							window.saveImageToDB(imageId, image);
						}

						// Update TreeView
						if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
							treeViewInstance.updateTreeData();
						}

						console.log("‚úÖ Image renamed:", imageId, "->", trimmedName);
					}
				},
				function () {
					// Cancelled
				}
			);
		}
		return;
	}

	// Step 3b) Single hole HoleID rename
	// Node ID format: "hole‚£øentityName‚£øholeID"
	if (parts[0] === "hole" && parts.length === 3) {
		const entityName = parts[1];
		const oldHoleID = parts[2];
		const hole = allBlastHoles.find(function (h) {
			return h.entityName === entityName && h.holeID === oldHoleID;
		});

		if (!hole) {
			console.log("üö´ [TreeView] Hole not found:", entityName, oldHoleID);
			return;
		}

		// Step 3b.1) Generate unique code suffix for suggestion
		var generateUniqueCode = function () {
			var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
			var code = "";
			for (var i = 0; i < 4; i++) {
				code += chars.charAt(Math.floor(Math.random() * chars.length));
			}
			return code;
		};

		// Step 3b.2) Check if HoleID already exists in the same blast
		var holeIDExists = function (blastName, holeID) {
			return allBlastHoles.some(function (h) {
				return h.entityName === blastName && h.holeID === holeID;
			});
		};

		window.showConfirmationDialogWithInput(
			"Rename Hole ID",
			"Enter new Hole ID for " + oldHoleID + " in " + entityName + ":<br><small>Note: Must be unique within the blast pattern.</small>",
			"New Hole ID",
			"text",
			oldHoleID + "_" + generateUniqueCode(),
			"OK",
			"Cancel",
			function (newHoleID) {
				if (newHoleID && newHoleID.trim() && newHoleID.trim() !== oldHoleID) {
					var trimmedID = newHoleID.trim();

					// Step 3b.3) Check for duplicate HoleID in the same blast
					if (holeIDExists(entityName, trimmedID)) {
						showModalMessage("Duplicate ID", "A hole with ID '" + trimmedID + "' already exists in " + entityName + ". Please choose a different ID.", "error");
						return;
					}

					// Step 3b.4) Update the hole ID
					hole.holeID = trimmedID;

					// Step 3b.5) Save to IndexedDB
					if (typeof debouncedSaveBlastHoles === "function") {
						debouncedSaveBlastHoles();
					}

					// Step 3b.6) Update TreeView
					if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
						treeViewInstance.updateTreeData();
					}

					drawData(allBlastHoles, selectedHole);
					console.log("‚úÖ Hole ID renamed:", oldHoleID, "->", trimmedID, "in", entityName);
				}
			},
			function () {
				// Cancelled
			}
		);
		return;
	}
};

// Step 4) Handle multiple hole BlastName reassignment
window.handleTreeViewRenameMultipleHoles = function (nodeIds, treeViewInstance) {
	console.log("üéÑ [TreeView] BlastName reassignment requested for", nodeIds.length, "holes");

	// Step 4a) Extract all selected holes
	var selectedHolesList = [];
	nodeIds.forEach(function (nodeId) {
		var parts = nodeId.split("‚£ø");
		if (parts[0] === "hole" && parts.length === 3) {
			var entityName = parts[1];
			var holeID = parts[2];
			var hole = allBlastHoles.find(function (h) {
				return h.entityName === entityName && h.holeID === holeID;
			});
			if (hole) {
				selectedHolesList.push(hole);
			}
		}
	});

	if (selectedHolesList.length === 0) {
		console.log("üö´ [TreeView] No holes found for reassignment");
		return;
	}

	// Step 4b) Get list of existing blast names for selection
	var existingBlastNames = new Set();
	allBlastHoles.forEach(function (h) {
		if (h.entityName) {
			existingBlastNames.add(h.entityName);
		}
	});
	var blastNameOptions = Array.from(existingBlastNames).sort();

	// Step 4c) Build select options HTML
	var optionsHtml = blastNameOptions.map(function (name) {
		return "<option value=\"" + name + "\">" + name + "</option>";
	}).join("");

	// Step 4d) Create dialog content with select dropdown and new name input
	var dialogContent = document.createElement("div");
	dialogContent.innerHTML =
		"<p style=\"margin-bottom:10px;\">Reassign " + selectedHolesList.length + " hole(s) to a different blast pattern:</p>" +
		"<div style=\"margin-bottom:10px;\">" +
		"<label style=\"display:block;margin-bottom:5px;\">Select existing blast:</label>" +
		"<select id=\"blastNameSelect\" style=\"width:100%;padding:5px;\">" +
		"<option value=\"\">-- Select a blast --</option>" +
		optionsHtml +
		"<option value=\"__NEW__\">+ Create New Blast...</option>" +
		"</select>" +
		"</div>" +
		"<div id=\"newBlastNameDiv\" style=\"display:none;margin-bottom:10px;\">" +
		"<label style=\"display:block;margin-bottom:5px;\">New blast name:</label>" +
		"<input type=\"text\" id=\"newBlastNameInput\" style=\"width:100%;padding:5px;\" placeholder=\"Enter new blast name\">" +
		"</div>";

	// Step 4e) Create dialog
	var dialog = new FloatingDialog({
		title: "Reassign Holes to Blast",
		content: dialogContent,
		layoutType: "default",
		width: 400,
		height: 280,
		showConfirm: true,
		showCancel: true,
		confirmText: "Reassign",
		cancelText: "Cancel",
		onConfirm: function () {
			var selectEl = document.getElementById("blastNameSelect");
			var newNameInput = document.getElementById("newBlastNameInput");
			var targetBlastName = "";

			if (selectEl.value === "__NEW__") {
				targetBlastName = newNameInput.value.trim();
				if (!targetBlastName) {
					showModalMessage("Invalid Name", "Please enter a valid blast name.", "error");
					return;
				}
			} else if (selectEl.value) {
				targetBlastName = selectEl.value;
			} else {
				showModalMessage("No Selection", "Please select a blast pattern.", "error");
				return;
			}

			// Step 4f) Handle HoleID conflicts when moving to new blast
			// Generate unique suffix for conflicting IDs
			var generateUniqueCode = function () {
				var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
				var code = "";
				for (var i = 0; i < 4; i++) {
					code += chars.charAt(Math.floor(Math.random() * chars.length));
				}
				return code;
			};

			var existingHoleIDs = new Set();
			allBlastHoles.forEach(function (h) {
				if (h.entityName === targetBlastName) {
					existingHoleIDs.add(h.holeID);
				}
			});

			// Step 4g) Reassign holes with conflict resolution
			var renamedCount = 0;
			selectedHolesList.forEach(function (hole) {
				if (hole.entityName !== targetBlastName) {
					var newHoleID = hole.holeID;

					// Check for conflict and generate unique ID
					while (existingHoleIDs.has(newHoleID)) {
						newHoleID = hole.holeID + "_" + generateUniqueCode();
					}

					hole.entityName = targetBlastName;
					hole.holeID = newHoleID;
					existingHoleIDs.add(newHoleID);
					renamedCount++;
				}
			});

			// Step 4h) Save and update
			if (typeof debouncedSaveBlastHoles === "function") {
				debouncedSaveBlastHoles();
			}

			if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
				treeViewInstance.updateTreeData();
				treeViewInstance.clearSelection();
			}

			drawData(allBlastHoles, selectedHole);
			console.log("‚úÖ Reassigned", renamedCount, "holes to", targetBlastName);
			updateStatusMessage("Reassigned " + renamedCount + " holes to " + targetBlastName);
			setTimeout(function () { updateStatusMessage(""); }, 3000);
		},
		onCancel: function () {
			// Cancelled
		}
	});

	dialog.show();

	// Step 4i) Show/hide new blast name input based on selection
	setTimeout(function () {
		var selectEl = document.getElementById("blastNameSelect");
		var newBlastDiv = document.getElementById("newBlastNameDiv");
		if (selectEl && newBlastDiv) {
			selectEl.addEventListener("change", function () {
				newBlastDiv.style.display = selectEl.value === "__NEW__" ? "block" : "none";
			});
		}
	}, 100);
};

// Step 5) Handle TreeView show properties
window.handleTreeViewShowProperties = function (nodeId, type) {
	console.log("üéÑ [TreeView] Show properties for:", nodeId);

	const parts = nodeId.split("‚£ø");

	// KAD element properties
	if (parts.length >= 4 && parts[2] === "element") {
		const entityName = parts[1];
		const elementId = parts[3];

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data) {
			const element = entity.data.find(function (el) { return el.pointID == elementId; });
			if (element) {
				const kadObject = {
					...element,
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: entity.data.indexOf(element)
				};
				if (typeof window.showKADPropertyEditorPopup === "function") {
					window.showKADPropertyEditorPopup(kadObject);
				}
			}
		}
	}
	// KAD chunk properties (show first point in chunk range)
	else if (parts.length === 4 && parts[2] === "chunk") {
		const entityType = parts[0];
		const entityName = parts[1];
		const rangeStr = parts[3]; // e.g., "1-50"
		const rangeParts = rangeStr.split("-");
		const startIndex = parseInt(rangeParts[0]) - 1; // Convert to 0-based index

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data && entity.data[startIndex]) {
			const element = entity.data[startIndex];
			const kadObject = {
				...element,
				entityName: entityName,
				entityType: entity.entityType,
				elementIndex: startIndex
			};
			if (typeof window.showKADPropertyEditorPopup === "function") {
				window.showKADPropertyEditorPopup(kadObject);
			}
		}
	}
	// KAD entity properties (show first point in entity)
	else if ((parts[0] === "line" || parts[0] === "poly" || parts[0] === "points" ||
			  parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
		const entityType = parts[0];
		const entityName = parts[1];

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data && entity.data.length > 0) {
			const element = entity.data[0]; // Show first point
			const kadObject = {
				...element,
				entityName: entityName,
				entityType: entity.entityType,
				elementIndex: 0
			};
			if (typeof window.showKADPropertyEditorPopup === "function") {
				window.showKADPropertyEditorPopup(kadObject);
			}
		}
	}
	// Hole properties
	else if (parts[0] === "hole") {
		const entityName = parts[1];
		const holeID = parts[2];
		const hole = allBlastHoles.find(function (h) { return h.entityName === entityName && h.holeID === holeID; });
		if (hole && typeof showHolePropertyEditor === "function") {
			showHolePropertyEditor(hole);
		}
	}
	// Entity properties
	else if (parts[0] === "entity") {
		const entityName = parts.slice(1).join("‚£ø");
		const firstHole = allBlastHoles.find(function (h) { return h.entityName === entityName; });
		if (firstHole && typeof showHolePropertyEditor === "function") {
			showHolePropertyEditor(firstHole);
		}
	}
	// Surface properties
	else if (parts[0] === "surface") {
		const surfaceId = parts.slice(1).join("‚£ø");
		if (typeof window.showSurfaceContextMenu === "function") {
			// Use center of viewport as default position for TreeView-launched dialogs
			const centerX = window.innerWidth / 2;
			const centerY = window.innerHeight / 2;
			window.showSurfaceContextMenu(centerX, centerY, surfaceId);
		}
	}
	// Image properties  
	else if (parts[0] === "image") {
		const imageId = parts.slice(1).join("‚£ø");
		if (typeof window.showImageContextMenu === "function") {
			// Use center of viewport as default position for TreeView-launched dialogs
			const centerX = window.innerWidth / 2;
			const centerY = window.innerHeight / 2;
			window.showImageContextMenu(centerX, centerY, imageId);
		}
	}
};

// Step 5) Handle TreeView reset connections
window.handleTreeViewResetConnections = function (holeNodeIds) {
	console.log("üéÑ [TreeView] Reset connections for:", holeNodeIds.length, "holes");

	const holesToReset = [];
	holeNodeIds.forEach(function (nodeId) {
		const parts = nodeId.split("‚£ø");
		if (parts[0] === "hole" && parts.length === 3) {
			const entityName = parts[1];
			const holeID = parts[2];
			const hole = allBlastHoles.find(function (h) { return h.entityName === entityName && h.holeID === holeID; });
			if (hole) {
				holesToReset.push(hole);
			}
		}
	});

	if (holesToReset.length === 0) return;

	// Reset connections
	holesToReset.forEach(function (hole) {
		hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
	});

	// Recalculate timing
	if (typeof calculateTimes === "function") {
		holeTimes = calculateTimes(allBlastHoles);
	}
	if (typeof recalculateContours === "function") {
		const result = recalculateContours(allBlastHoles, 0, 0);
		if (result) {
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}

	drawData(allBlastHoles, selectedHole);
};

//=============================================================
// FLOATING DIALOG SYSTEM - NOW IMPORTED FROM MODULE
//=============================================================
// BUG FIX 6: Removed duplicate FloatingDialog code (736 lines)
// The FloatingDialog class is now imported from src/dialog/FloatingDialog.js
// This removes code duplication and ensures a single source of truth

// NOTE: FloatingDialog, createFormContent, createEnhancedFormContent,
// and showConfirmationDialog are all imported from the module
// Step 1) Create utility function for confirmation dialogs with 3 buttons
// Step 14) Load 3D settings from localStorage
function load3DSettings() {
	const defaultSettings = {
		dampingFactor: 0.05,
		cursorZoom: true,
		cursorOpacity: 0.2,
		lightBearing: 135,
		lightElevation: 15,
		ambientLightIntensity: 0.8,
		directionalLightIntensity: 2.5,
		shadowIntensity: 0.5,
		// Step 14a) Grid and Clipping Plane settings removed - not working properly
		// Keeping defaults for backward compatibility but not used in dialog
		clippingNear: -50000,
		clippingFar: 50000,
		showClippingPlane: false,
		previewClippingPlane: false,
		showGrid: false,
		gridSize: 10,
		gridOpacity: 0.3,
		gridPlane: "XY",
		gizmoDisplay: "only_when_orbit_or_rotate", // "always", "only_when_orbit_or_rotate", "never"
		axisLock: "none", // "none", "pitch", "roll", "yaw"
		textBillboarding: "off", // "off", "holes", "kad", "all" - which text types should billboard
	};

	const saved = localStorage.getItem("kirra3DSettings");
	if (saved) {
		try {
			const parsed = JSON.parse(saved);
			return { ...defaultSettings, ...parsed };
		} catch (e) {
			console.warn("Failed to parse 3D settings from localStorage:", e);
			return defaultSettings;
		}
	}

	return defaultSettings;
}

// Step 15) Save 3D settings to localStorage
function save3DSettings(settings) {
	try {
		localStorage.setItem("kirra3DSettings", JSON.stringify(settings));
		console.log("üíæ 3D settings saved to localStorage");
	} catch (e) {
		console.error("‚ùå Failed to save 3D settings to localStorage:", e);
	}
}

// Step 15a) Expose 3D settings functions on window for ThreeDSettingsDialog module
window.load3DSettings = load3DSettings;
window.save3DSettings = save3DSettings;

// Step 16) Show 3D Scene, Camera and Lighting Settings dialog
// Step 16a) Moved to separate module: src/dialog/popups/ThreeDSettingsDialog.js
// Step 16b) Function is now available via window.show3DSettingsDialog

// Step 17) Apply 3D settings
function apply3DSettings(settings) {
	// Step 17a) Update unified camera controls settings
	if (cameraControls) {
		const cameraSettings = {
			gizmoDisplay: settings.gizmoDisplay,
			axisLock: settings.axisLock,
			dampingFactor: settings.dampingFactor,
		};
		cameraControls.updateSettings(cameraSettings);

		// Step 17a.1) Update gizmo display immediately
		if (settings.gizmoDisplay !== undefined) {
			updateGizmoDisplay();
		}
	}

	// Step 17b) Update cursor opacity
	if (settings.cursorOpacity !== undefined) {
		window.cursorOpacity3D = settings.cursorOpacity;
	}

	// Step 17c) Update lighting
	if (threeRenderer) {
		if (settings.lightBearing !== undefined && settings.lightElevation !== undefined) {
			threeRenderer.updateLighting(settings.lightBearing, settings.lightElevation);
		}
		if (settings.ambientLightIntensity !== undefined) {
			threeRenderer.updateAmbientLightIntensity(settings.ambientLightIntensity);
		}
		if (settings.directionalLightIntensity !== undefined) {
			threeRenderer.updateDirectionalLightIntensity(settings.directionalLightIntensity);
		}
		if (settings.shadowIntensity !== undefined && typeof threeRenderer.updateShadowIntensity === "function") {
			threeRenderer.updateShadowIntensity(settings.shadowIntensity);
		}
	}

	// Step 17d) Update orbit center (needed for camera controls, removed grid-specific code)
	if (threeRenderer) {
		const centroid = calculateDataCentroid();
		if (typeof threeRenderer.setOrbitCenter === "function") {
			threeRenderer.setOrbitCenter(centroid.x, centroid.y, centroid.z);
		}
	}

	// Step 17e) Request re-render to apply changes
	if (threeRenderer) {
		threeRenderer.requestRender();
	}
}

// Step 17f) Expose apply3DSettings on window for ThreeDSettingsDialog module
window.apply3DSettings = apply3DSettings;

// Step 17g) Update gizmo display based on current mode and state
function updateGizmoDisplay() {
	if (!cameraControls || !threeRenderer) return;

	const gizmoMode = cameraControls.gizmoDisplayMode || "only_when_orbit_or_rotate";
	const isOrbiting = cameraControls.isOrbiting || false;
	const isRotating = cameraControls.isRotating || false;

	if (gizmoMode === "always") {
		// Step 17g1) Always show gizmo
		const currentState = cameraControls.getCameraState();
		threeRenderer.showAxisHelper(true, currentState.centroidX, currentState.centroidY, currentState.scale);
	} else if (gizmoMode === "only_when_orbit_or_rotate") {
		// Step 17g2) Show only when orbiting or rotating
		if (isOrbiting || isRotating) {
			const currentState = cameraControls.getCameraState();
			threeRenderer.showAxisHelper(true, currentState.centroidX, currentState.centroidY, currentState.scale);
		} else {
			threeRenderer.showAxisHelper(false);
		}
	} else if (gizmoMode === "never") {
		// Step 17g3) Never show gizmo
		threeRenderer.showAxisHelper(false);
	}
}

// NOTE: showConfirmationThreeDialog and showModalMessage are imported from FloatingDialog.js module

//CONTEXT DIALOG FOR HOLE MODIFICATION
// MOVED TO HolesContextMenu.js - These functions are now loaded from external module
// showHolePropertyEditor, processHolePropertyUpdates
/*
function showHolePropertyEditor(hole) {
	// ? CHECK VISIBILITY FIRST - Filter out hidden holes
	const visibleHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

	if (visibleHoles.length === 0) {
		console.log("‚ùå No visible holes to edit");
		return;
	}

	if (visibleHoles.length !== allBlastHoles.length) {
		console.log("‚ö†Ô∏è Some holes are hidden and will not be edited");
	}

	// Determine if we're dealing with single hole or multiple holes
	let candidateHoles;
	if (Array.isArray(hole)) {
		candidateHoles = hole;
	} else if (selectedMultipleHoles && selectedMultipleHoles.length > 1) {
		candidateHoles = selectedMultipleHoles;
	} else {
		candidateHoles = [hole];
	}
	// ? Filter candidate holes to only include visible ones
	const holes = candidateHoles.filter((h) => isHoleVisible(h));

	const isMultiple = holes.length > 1;
	const isArrayInput = Array.isArray(hole);

	if (holes.length === 0) return;

	// Calculate current values and averages with proper fallbacks
	let delaySum = 0,
		diameterSum = 0,
		bearingSum = 0,
		angleSum = 0,
		subdrillSum = 0;
	let collarZSum = 0,
		gradeZSum = 0;
	let uniqueDelays = new Set(),
		uniqueDelayColors = new Set(),
		uniqueHoleTypes = new Set();
	let uniqueRowIDs = new Set(),
		uniquePosIDs = new Set();
	let typeCounts = {};
	let connectorCurveSum = 0;
	let burdenSum = 0;
	let spacingSum = 0;

	holes.forEach((h) => {
		// Basic properties
		const currentDelay = h.holeDelay !== undefined ? h.holeDelay : h.timingDelayMilliseconds || 0;
		const currentColor = h.holeDelayColor || h.colorHexDecimal || "#FF0000";
		const currentType = h.holeType || "Production";

		// Geometry properties
		const diameter = h.holeDiameter || 0;
		const bearing = h.holeBearing || 0;
		const angle = h.holeAngle || 0;
		const subdrill = h.subdrillAmount || 0;
		const collarZ = h.startZLocation || 0;
		const gradeZ = h.gradeZLocation || h.endZLocation || 0;
		const rowID = h.rowID || "";
		const posID = h.posID || "";

		// Step 1) Add connectorCurve calculation
		const connectorCurve = h.connectorCurve || 0;
		const burden = h.burden || 0;
		const spacing = h.spacing || 0;

		// Sum for averages
		delaySum += parseFloat(currentDelay);
		diameterSum += parseFloat(diameter);
		bearingSum += parseFloat(bearing);
		angleSum += parseFloat(angle);
		subdrillSum += parseFloat(subdrill);
		collarZSum += parseFloat(collarZ);
		gradeZSum += parseFloat(gradeZ);

		// Step 2) Add new sums

		connectorCurveSum += parseFloat(connectorCurve);
		burdenSum += parseFloat(burden);
		spacingSum += parseFloat(spacing);

		// Track unique values
		uniqueDelays.add(currentDelay);
		uniqueDelayColors.add(currentColor);
		uniqueHoleTypes.add(currentType);
		uniqueRowIDs.add(rowID);
		uniquePosIDs.add(posID);

		// Count hole types for most common
		typeCounts[currentType] = (typeCounts[currentType] || 0) + 1;
	});

	// Calculate averages
	const count = holes.length;
	const avgDelay = delaySum / count;
	const avgDiameter = diameterSum / count;
	const avgBearing = bearingSum / count;
	const avgAngle = angleSum / count;
	const avgSubdrill = subdrillSum / count;
	const avgCollarZ = collarZSum / count;
	const avgGradeZ = gradeZSum / count;

	// Find most common values
	const firstDelayColor = Array.from(uniqueDelayColors)[0];
	const firstRowID = Array.from(uniqueRowIDs)[0];
	const firstPosID = Array.from(uniquePosIDs)[0];

	// Find most common hole type
	let mostCommonType = "Production";
	let maxCount = 0;
	for (const [type, typeCount] of Object.entries(typeCounts)) {
		if (typeCount > maxCount) {
			maxCount = typeCount;
			mostCommonType = type;
		}
	}

	// Create combined hole types list (standard + any custom types from selection)
	const standardHoleTypes = ["Angled", "Batter", "Buffer", "Infill", "Production", "Stab", "Toe", "Trim"];
	const customTypesFromSelection = Array.from(uniqueHoleTypes).filter((type) => !standardHoleTypes.includes(type));
	const allHoleTypes = [...standardHoleTypes, ...customTypesFromSelection].sort();
	// Calculate averages (add after existing averages around line 37240)
	const avgConnectorCurve = connectorCurveSum / count;
	const avgBurden = burdenSum / count;
	const avgSpacing = spacingSum / count;

	// Add to originalValues object around line 37275
	const originalValues = {
		delay: avgDelay.toFixed(1),
		diameter: avgDiameter.toFixed(0),
		bearing: avgBearing.toFixed(1),
		angle: avgAngle.toFixed(0),
		subdrill: avgSubdrill.toFixed(1),
		collarZ: avgCollarZ.toFixed(2),
		gradeZ: avgGradeZ.toFixed(2),
		holeType: mostCommonType,
		delayColor: firstDelayColor,
		rowID: firstRowID,
		posID: firstPosID,
		// Step 3) Add new original values
		connectorCurve: avgConnectorCurve.toFixed(0),
		burden: avgBurden.toFixed(2),
		spacing: avgSpacing.toFixed(2),
	};

	// Add display values around line 37285
	const displayConnectorCurve = isMultiple && new Set(holes.map((h) => h.connectorCurve || 0)).size > 1 ? "varies (avg: " + avgConnectorCurve.toFixed(0) + "?)" : avgConnectorCurve.toFixed(0) + "?";
	const displayBurden = isMultiple && new Set(holes.map((h) => h.burden || 0)).size > 1 ? "varies (avg: " + avgBurden.toFixed(2) + ")" : avgBurden.toFixed(2);
	const displaySpacing = isMultiple && new Set(holes.map((h) => h.spacing || 0)).size > 1 ? "varies (avg: " + avgSpacing.toFixed(2) + ")" : avgSpacing.toFixed(2);

	// Create display values with indicators for varying values
	const displayDelay = isMultiple && uniqueDelays.size > 1 ? "varies (avg: " + avgDelay.toFixed(1) + ")" : avgDelay.toFixed(1);
	const displayDiameter = isMultiple && new Set(holes.map((h) => h.holeDiameter)).size > 1 ? "varies (avg: " + avgDiameter.toFixed(0) + ")" : avgDiameter.toFixed(0);
	const displayBearing = isMultiple && new Set(holes.map((h) => h.holeBearing)).size > 1 ? "varies (avg: " + avgBearing.toFixed(1) + ")" : avgBearing.toFixed(1);
	const displayAngle = isMultiple && new Set(holes.map((h) => h.holeAngle)).size > 1 ? "varies (avg: " + avgAngle.toFixed(0) + ")" : avgAngle.toFixed(0);
	const displaySubdrill = isMultiple && new Set(holes.map((h) => h.subdrillAmount)).size > 1 ? "varies (avg: " + avgSubdrill.toFixed(1) + ")" : avgSubdrill.toFixed(1);
	const displayCollarZ = isMultiple && new Set(holes.map((h) => h.startZLocation)).size > 1 ? "varies (avg: " + avgCollarZ.toFixed(2) + ")" : avgCollarZ.toFixed(2);
	const displayGradeZ = isMultiple && new Set(holes.map((h) => h.gradeZLocation || h.endZLocation)).size > 1 ? "varies (avg: " + avgGradeZ.toFixed(2) + ")" : avgGradeZ.toFixed(2);

	// Create notes for multiple values
	const delayNote = isMultiple && uniqueDelays.size > 1 ? " (varying)" : "";
	const colorNote = isMultiple && uniqueDelayColors.size > 1 ? " (multiple)" : "";
	const typeNote = isMultiple && uniqueHoleTypes.size > 1 ? " (most common: " + mostCommonType + ")" : "";

	const title = isMultiple ? "Edit Multiple Holes (" + holes.length + " selected)" : "Edit Hole " + holes[0].holeID;

	// Define form fields
	const fields = [
		{
			label: "Delay" + delayNote,
			name: "delay",
			type: "text",
			value: originalValues.delay,
			placeholder: displayDelay,
		},
		{
			label: "Delay Color" + colorNote,
			name: "delayColor",
			type: "color",
			value: firstDelayColor,
		},
		{
			label: "Connector Curve (?)",
			name: "connectorCurve",
			type: "number",
			value: originalValues.connectorCurve,
			placeholder: displayConnectorCurve,
		},
		{
			label: "Hole Type",
			name: "holeType",
			type: "select",
			value: mostCommonType,
			options: [
				{
					value: "",
					text: "-- No Change --",
				},
				...allHoleTypes.map((type) => ({
					value: type,
					text: type,
				})),
				{
					value: "__CUSTOM__",
					text: "Other (custom)...",
				},
			],
		},
		{
			label: "Custom Type",
			name: "customType",
			type: "text",
			placeholder: "Enter custom hole type",
			disabled: true,
		},
		{
			label: "Diameter (mm)",
			name: "diameter",
			type: "text",
			value: originalValues.diameter,
			placeholder: displayDiameter,
		},
		{
			label: "Bearing (?)",
			name: "bearing",
			type: "text",
			value: originalValues.bearing,
			placeholder: displayBearing,
		},
		{
			label: "Dip/Angle (?)",
			name: "angle",
			type: "text",
			value: originalValues.angle,
			placeholder: displayAngle,
		},
		{
			label: "Subdrill (m)",
			name: "subdrill",
			type: "text",
			value: originalValues.subdrill,
			placeholder: displaySubdrill,
		},
		{
			label: "Collar Z RL (m)",
			name: "collarZ",
			type: "text",
			value: originalValues.collarZ,
			placeholder: displayCollarZ,
		},
		{
			label: "Grade Z RL (m)",
			name: "gradeZ",
			type: "text",
			value: originalValues.gradeZ,
			placeholder: displayGradeZ,
		},
		{
			label: "Burden (m)",
			name: "burden",
			type: "text",
			value: originalValues.burden,
			placeholder: displayBurden,
		},
		{
			label: "Spacing (m)",
			name: "spacing",
			type: "text",
			value: originalValues.spacing,
			placeholder: displaySpacing,
		},
	];

	// Add Row ID and Pos ID fields only for single hole edits
	if (!isMultiple) {
		fields.push(
			{
				label: "Row ID",
				name: "rowID",
				type: "text",
				value: firstRowID,
				placeholder: "Row identifier",
			},
			{
				label: "Pos ID",
				name: "posID",
				type: "text",
				value: firstPosID,
				placeholder: "Position identifier",
			}
		);
	}

	// Create enhanced form content with special handling
	const formContent = createEnhancedFormContent(fields, isMultiple);

	// Add note at the bottom
	const noteDiv = document.createElement("div");
	noteDiv.style.gridColumn = "1 / -1";
	noteDiv.style.marginTop = "10px";
	noteDiv.style.fontSize = "10px";
	noteDiv.style.color = "#888";
	noteDiv.textContent = isMultiple ? "Note: Use +/- for relative changes (e.g., +0.3, -0.2). Only changed values will be applied." : "Note: Use +/- for relative changes (e.g., +0.3, -0.2). Select hole type from dropdown or choose 'Other' for custom. Curved connectors are made by seting connector curve to (45? to 120?, -45? to -120?) Straight connctors are 0?";
	formContent.appendChild(noteDiv);

	const dialog = new FloatingDialog({
		title: title,
		content: formContent,
		layoutType: "compact",
		showConfirm: true,
		showCancel: true,
		showOption1: true, // Add hide button
		confirmText: "Apply",
		cancelText: "Cancel",
		option1Text: "Hide",
		width: 350,
		height: 600,
		onConfirm: () => {
			// Get form values
			const formData = getFormData(formContent);

			// Process the form data and update holes
			processHolePropertyUpdates(holes, formData, originalValues, isMultiple);

			// Clear any dragging states when dialog closes
			isDragging = false;
			clearTimeout(longPressTimeout);
		},
		onCancel: () => {
			// Clear any dragging states when dialog closes
			isDragging = false;
			clearTimeout(longPressTimeout);
		},
		onOption1: () => {
			// Hide holes - just set visible flag
			holes.forEach((hole) => {
				hole.visible = false;
			});
			drawData(allBlastHoles, selectedHole);
		},
	});

	dialog.show();
}

// Process hole property updates (extracted from original logic)
function processHolePropertyUpdates(holes, formData, originalValues, isMultiple) {
	// Helper function to handle relative/absolute value changes
	function processNumericValue(inputValue, originalValue, currentHoleValue) {
		if (inputValue === "" || inputValue === originalValue) {
			return null; // No change
		}

		if (inputValue.startsWith("+") || inputValue.startsWith("-")) {
			// Relative adjustment
			const delta = parseFloat(inputValue);
			if (!isNaN(delta)) {
				return currentHoleValue + delta;
			}
		} else {
			// Absolute value
			const absoluteValue = parseFloat(inputValue);
			if (!isNaN(absoluteValue)) {
				return absoluteValue;
			}
		}
		return null; // Invalid input
	}

	// ? NEW: Track which fields were actually modified by the user
	const modifiedFields = new Set();

	// Check each field to see if it was actually changed from the original average
	if (formData.delay !== originalValues.delay) modifiedFields.add("delay");
	if (formData.delayColor !== originalValues.delayColor) modifiedFields.add("delayColor");
	if (formData.holeType !== originalValues.holeType) modifiedFields.add("holeType");
	if (formData.diameter !== originalValues.diameter) modifiedFields.add("diameter");
	if (formData.bearing !== originalValues.bearing) modifiedFields.add("bearing");
	if (formData.angle !== originalValues.angle) modifiedFields.add("angle");
	if (formData.subdrill !== originalValues.subdrill) modifiedFields.add("subdrill");
	if (formData.collarZ !== originalValues.collarZ) modifiedFields.add("collarZ");
	if (formData.gradeZ !== originalValues.gradeZ) modifiedFields.add("gradeZ");
	if (formData.connectorCurve !== originalValues.connectorCurve) modifiedFields.add("connectorCurve");
	if (formData.burden !== originalValues.burden) modifiedFields.add("burden");
	if (formData.spacing !== originalValues.spacing) modifiedFields.add("spacing");

	// For single hole edits, also check Row ID and Pos ID
	if (!isMultiple) {
		if (formData.rowID !== originalValues.rowID) modifiedFields.add("rowID");
		if (formData.posID !== originalValues.posID) modifiedFields.add("posID");
	}

	// Handle hole type: check if custom or standard
	let newHoleType = formData.holeType;
	if (newHoleType === "__CUSTOM__") {
		newHoleType = formData.customType.trim();
		if (newHoleType !== originalValues.holeType) modifiedFields.add("holeType");
	}

	// Track if any timing-related properties were changed
	let timingChanged = false;
	let geometryChanged = false;

	holes.forEach((h) => {
		// ? ONLY process fields that were actually modified
		if (modifiedFields.has("delay")) {
			const processedDelay = processNumericValue(formData.delay, originalValues.delay, h.holeDelay !== undefined ? h.holeDelay : h.timingDelayMilliseconds || 0);
			if (processedDelay !== null) {
				h.holeDelay = processedDelay;
				if (h.timingDelayMilliseconds !== undefined) {
					h.timingDelayMilliseconds = processedDelay;
				}
				timingChanged = true;
			}
		}

		if (modifiedFields.has("delayColor")) {
			h.holeDelayColor = formData.delayColor;
			if (h.colorHexDecimal !== undefined) {
				h.colorHexDecimal = formData.delayColor;
			}
			timingChanged = true;
		}

		if (modifiedFields.has("holeType")) {
			h.holeType = newHoleType;
		}

		// Update geometry properties only if modified
		if (modifiedFields.has("diameter")) {
			const processedDiameter = processNumericValue(formData.diameter, originalValues.diameter, h.holeDiameter || 0);
			if (processedDiameter !== null) {
				calculateHoleGeometry(h, processedDiameter, 7);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("bearing")) {
			const processedBearing = processNumericValue(formData.bearing, originalValues.bearing, h.holeBearing || 0);
			if (processedBearing !== null) {
				calculateHoleGeometry(h, processedBearing, 3);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("angle")) {
			const processedAngle = processNumericValue(formData.angle, originalValues.angle, h.holeAngle || 0);
			if (processedAngle !== null) {
				calculateHoleGeometry(h, processedAngle, 2);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("subdrill")) {
			const processedSubdrill = processNumericValue(formData.subdrill, originalValues.subdrill, h.subdrillAmount || 0);
			if (processedSubdrill !== null) {
				calculateHoleGeometry(h, processedSubdrill, 8);
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("collarZ")) {
			const processedCollarZ = processNumericValue(formData.collarZ, originalValues.collarZ, h.startZLocation || 0);
			if (processedCollarZ !== null) {
				h.startZLocation = processedCollarZ;
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("gradeZ")) {
			const processedGradeZ = processNumericValue(formData.gradeZ, originalValues.gradeZ, h.gradeZLocation || h.endZLocation || 0);
			if (processedGradeZ !== null) {
				h.gradeZLocation = processedGradeZ;
				h.endZLocation = processedGradeZ;
				geometryChanged = true;
			}
		}

		if (modifiedFields.has("connectorCurve")) {
			// Step 1) Treat connectorCurve as absolute value only (no relative adjustments)
			const curveValue = parseFloat(formData.connectorCurve);
			if (!isNaN(curveValue)) {
				h.connectorCurve = curveValue;
				timingChanged = true; // Since this affects visual display
			}
		}

		if (modifiedFields.has("burden")) {
			const processedBurden = processNumericValue(formData.burden, originalValues.burden, h.burden || 0);
			if (processedBurden !== null) {
				h.burden = processedBurden;
			}
		}

		if (modifiedFields.has("spacing")) {
			const processedSpacing = processNumericValue(formData.spacing, originalValues.spacing, h.spacing || 0);
			if (processedSpacing !== null) {
				h.spacing = processedSpacing;
			}
		}

		// Only update Row ID and Pos ID for single hole edits and if modified
		if (!isMultiple) {
			if (modifiedFields.has("rowID")) {
				h.rowID = formData.rowID;
			}

			if (modifiedFields.has("posID")) {
				h.posID = formData.posID;
			}
		}
	});

	// ** RECALCULATE TIMING AND CONTOURS **
	if (timingChanged || geometryChanged) {
		// Always recalculate timing calculations after changes
		holeTimes = calculateTimes(allBlastHoles);

		// Update timing chart display
		timeChart();

		// Recalculate contours if they're being displayed
		const result = recalculateContours(allBlastHoles, 0, 0);
		if (result) {
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}

	// Update selection averages and sliders
	if (isMultiple) {
		updateSelectionAveragesAndSliders(holes);
	} else if (selectedHole === holes[0]) {
		updateSelectionAveragesAndSliders([holes[0]]);
	}

	drawData(allBlastHoles, selectedHole); // Redraw

	const statusMessage = isMultiple ? "Updated " + holes.length + " holes" + (timingChanged ? " - Timings recalculated" : "") : "Hole " + holes[0].holeID + " updated" + (timingChanged ? " - Timings recalculated" : "");
	updateStatusMessage(statusMessage);
	setTimeout(() => updateStatusMessage(""), 3000);
}
*/
// END OF MOVED FUNCTIONS - Holes functions now loaded from HolesContextMenu.js

//For Kad entities
// Step 1) Hole Property Dialogs - Removed 717 lines (41311-42027)
// Step 2) All 7 property dialog functions now in HolePropertyDialogs.js
// Step 3) Functions: renameEntityDialog, editBlastNamePopup, editHoleTypePopup, editHoleLengthPopup, measuredLengthPopup, measuredMassPopup, measuredCommentPopup
// Step 4) Loaded via <script> tag in kirra.html, exposed globally via window object

//===========================================
// FLOATING DIALOG END
//===========================================

//===========================================
// MINIMAL SAFE OVERLAY FOR THE APP
//===========================================
// Around line 39636, replace the problematic section with this clean version:

// Step 1) Initialize overlay system variables
// Note: contourOverlayCanvas and contourOverlayCtx are forward-declared earlier in the file
let useContourOverlay = false;

// Step 2) Create overlay canvas with proper positioning
function createContourOverlay() {
	if (contourOverlayCanvas) return;

	const mainCanvas = canvas;
	const container = mainCanvas.parentElement;

	contourOverlayCanvas = document.createElement("canvas");
	contourOverlayCtx = contourOverlayCanvas.getContext("2d");

	contourOverlayCanvas.width = mainCanvas.width;
	contourOverlayCanvas.height = mainCanvas.height;
	contourOverlayCanvas.style.position = "absolute";
	contourOverlayCanvas.style.left = "0";
	contourOverlayCanvas.style.top = "0";
	contourOverlayCanvas.style.zIndex = "10";
	contourOverlayCanvas.style.pointerEvents = "none";
	contourOverlayCanvas.style.width = mainCanvas.style.width;
	contourOverlayCanvas.style.height = mainCanvas.style.height;

	container.appendChild(contourOverlayCanvas);
	console.log("Contour overlay " + "created");
}

// Step 5) Synchronize overlay with main canvas dimensions
function syncOverlayWithMainCanvas() {
	if (!contourOverlayCanvas || !canvas) return;

	contourOverlayCanvas.width = canvas.width;
	contourOverlayCanvas.height = canvas.height;

	contourOverlayCanvas.style.width = canvas.style.width || canvas.width + "px";
	contourOverlayCanvas.style.height = canvas.style.height || canvas.height + "px";

	contourOverlayCanvas.style.left = canvas.offsetLeft + "px";
	contourOverlayCanvas.style.top = canvas.offsetTop + "px";
}

// Step 6) Draw contours on overlay with proper coordinate transformation
function drawContoursOnOverlayFixed() {
	if (!contourOverlayCanvas || !useContourOverlay) return;

	// Step 6.1) Don't draw 2D contour overlay when in 3D-only mode
	if (onlyShowThreeJS) {
		contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
		return;
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (!displayContours.checked || !contourLinesArray) {
		console.log("Contours disabled " + "or no data");
		return;
	}

	//console.log("Drawing overlay contours - " + "levels: " + contourLinesArray.length);
	drawBrightContoursFixed();
}

// Step 7) Draw bright contours with theme-aware colors
function drawBrightContoursFixed() {
	if (!contourLinesArray || contourLinesArray.length === 0) return;

	// Step 3a: Calculate interval
	const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
	let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
	if (typeof intervalAmount !== "undefined") {
		interval = parseInt(intervalAmount);
	}

	// Step 3b: Set up theme-aware contour colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	//console.log("Drawing with interval: " + interval + " (Dark mode: " + darkModeEnabled + ")");

	// Step 3c: Process each contour level
	for (let level = 0; level < contourLinesArray.length; level++) {
		const contourLevel = contourLinesArray[level];
		if (!contourLevel || contourLevel.length === 0) continue;

		const contourTime = level * interval;
		const color = colors[level % colors.length];

		//console.log("Level " + level + " (" + contourTime + "ms): " + contourLevel.length + " lines in " + color);

		// Step 3d: Remove line style settings (handled in drawAlternatingDashLine)
		let linesDrawn = 0;

		// Step 3e: Draw each line segment in this level
		for (let i = 0; i < contourLevel.length; i++) {
			const line = contourLevel[i];
			if (!line || !line[0] || !line[1]) continue;

			// Step 3f: Extract coordinates using your structure (line[0].x, line[0].y, line[1].x, line[1].y)
			const startWorldX = line[0].x;
			const startWorldY = line[0].y;
			const endWorldX = line[1].x;
			const endWorldY = line[1].y;

			// Step 3g: Transform to screen coordinates
			const startScreenX = (startWorldX - centroidX) * currentScale + canvas.width / 2;
			const startScreenY = (-startWorldY + centroidY) * currentScale + canvas.height / 2;
			const endScreenX = (endWorldX - centroidX) * currentScale + canvas.width / 2;
			const endScreenY = (-endWorldY + centroidY) * currentScale + canvas.height / 2;

			// Step 3h: Draw alternating colored dashes
			drawAlternatingDashLine(startScreenX, startScreenY, endScreenX, endScreenY);

			linesDrawn++;

			// Step 3i: Add time labels at 1/3 and 2/3 marks
			const totalLines = contourLevel.length;
			const oneThirdMark = Math.floor(totalLines / 3);
			const twoThirdsMark = Math.floor((totalLines * 2) / 3);

			if (i === oneThirdMark || i === twoThirdsMark) {
				const midX = (startScreenX + endScreenX) / 2;
				const midY = (startScreenY + endScreenY) / 2;
				drawTimeLabelFixed(midX, midY, contourTime + "ms", "#" + "FFFFFF");
			}
		}

		//console.log("Drew " + linesDrawn + " line segments for level " + level);
	}

	//console.log("Bright contours " + "drawn on overlay");
}

// Step 13) Draw alternating colored dash lines
function drawAlternatingDashLine(x1, y1, x2, y2) {
	// Step 4a: Calculate line properties
	const totalLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	const angle = Math.atan2(y2 - y1, x2 - x1);
	const dashLength = 10; // 10px dashes

	// Step 4b: Theme-aware dash colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	contourOverlayCtx.lineWidth = 3;
	contourOverlayCtx.lineCap = "butt";

	let currentDistance = 0;
	let colorIndex = 0;

	// Step 4b: Draw alternating colored segments
	while (currentDistance < totalLength) {
		const segmentStart = currentDistance;
		const segmentEnd = Math.min(currentDistance + dashLength, totalLength);

		// Step 4c: Calculate segment coordinates
		const startX = x1 + Math.cos(angle) * segmentStart;
		const startY = y1 + Math.sin(angle) * segmentStart;
		const endX = x1 + Math.cos(angle) * segmentEnd;
		const endY = y1 + Math.sin(angle) * segmentEnd;

		// Step 4d: Draw segment with alternating color
		contourOverlayCtx.strokeStyle = colors[colorIndex % colors.length];
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(startX, startY);
		contourOverlayCtx.lineTo(endX, endY);
		contourOverlayCtx.stroke();

		currentDistance += dashLength;
		colorIndex++;
	}
}

// Step 14) Draw time labels with theme-aware styling
function drawTimeLabelFixed(x, y, text, color) {
	// Step 5a: Use theme-aware background color
	const backgroundColor = darkModeEnabled ? "rgba(0, 0, 0,0.6)" : "rgba(255, 255, 255,0.6)";

	contourOverlayCtx.fillStyle = backgroundColor;
	contourOverlayCtx.font = "bold " + "16px Arial";
	const metrics = contourOverlayCtx.measureText(text);
	const padding = 6;
	// Step 5a1: Draw rounded rectangle background
	const rectX = x - metrics.width / 2 - padding;
	const rectY = y - 8 - padding;
	const rectWidth = metrics.width + padding * 2;
	const rectHeight = 16 + padding * 2;
	const radius = 4;

	contourOverlayCtx.beginPath();
	contourOverlayCtx.moveTo(rectX + radius, rectY);
	contourOverlayCtx.lineTo(rectX + rectWidth - radius, rectY);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
	contourOverlayCtx.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
	contourOverlayCtx.lineTo(rectX + radius, rectY + rectHeight);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
	contourOverlayCtx.lineTo(rectX, rectY + radius);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
	contourOverlayCtx.closePath();
	contourOverlayCtx.fill();

	// Step 5b: Use standard text color from your theme system
	contourOverlayCtx.fillStyle = textFillColor; // Uses your global theme variable
	contourOverlayCtx.textAlign = "center";
	contourOverlayCtx.textBaseline = "middle";
	contourOverlayCtx.fillText(text, x, y);
}
// Step 5X: Toggle overlay on/off
function toggleContourOverlayFixed() {
	useContourOverlay = !useContourOverlay;

	if (useContourOverlay) {
		// Step 5a: Create overlay canvas
		createContourOverlay();

		// Step 5b: Enable contours if needed
		if (!displayContours.checked) {
			displayContours.checked = true;
			drawData(allBlastHoles, selectedHole);
		}

		// Step 5c: Draw contours on overlay
		setTimeout(() => {
			drawContoursOnOverlayFixed();
		}, 100);
	} else {
		// Step 5d: Clear overlay when disabled
		if (contourOverlayCanvas) {
			contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
		}
	}
}

// Step 6: Update overlay colors when dark mode changes
function updateOverlayColorsForTheme() {
	if (useContourOverlay) {
		drawContoursOnOverlayFixed(); // Redraw with new colors?
	}
}

// Step 7: Hook into your existing dark mode system
function hookOverlayIntoThemeSystem() {
	// Step 7a: Hook into your updateColorsForDarkMode function
	const originalUpdateColors = window.updateColorsForDarkMode;
	if (typeof originalUpdateColors === "function") {
		window.updateColorsForDarkMode = function () {
			const result = originalUpdateColors.apply(this, arguments);
			updateOverlayColorsForTheme(); // Update overlay when theme changes
			return result;
		};
		console.log("üé® Overlay hooked into theme system");
	}

	// Step 7b: Hook into dark mode toggle
	const darkModeToggle = document.getElementById("darkModeToggle");
	if (darkModeToggle) {
		darkModeToggle.addEventListener("change", function () {
			setTimeout(() => {
				updateOverlayColorsForTheme(); // Update overlay after theme change
			}, 50);
		});
	}
}

function debugCorrectVariables() {
	console.log("=== USING YOUR EXACT VARIABLES ===");
	console.log("displayContours.checked: " + (typeof displayContours !== "undefined" ? displayContours.checked : "undefined"));
	console.log("contourLinesArray: " + (typeof contourLinesArray !== "undefined" ? contourLinesArray?.length + " levels" : "undefined"));
	console.log("centroidX: " + (typeof centroidX !== "undefined" ? centroidX : "undefined"));
	console.log("centroidY: " + (typeof centroidY !== "undefined" ? centroidY : "undefined"));
	console.log("currentScale: " + (typeof currentScale !== "undefined" ? currentScale : "undefined"));
	console.log("canvas size: " + (typeof canvas !== "undefined" ? canvas.width + "x" + canvas.height : "undefined"));
}

function testDrawOnOverlay() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	// Step 7a: Draw bright test rectangle
	contourOverlayCtx.fillStyle = "#FF0000";
	contourOverlayCtx.fillRect(100, 100, 200, 200);

	// Step 7b: Draw bright test text
	contourOverlayCtx.fillStyle = "#FFFF00";
	contourOverlayCtx.font = "bold " + "32px Arial";
	contourOverlayCtx.fillText("OVERLAY TEST", 150, 150);

	console.log("Drew test rectangle " + "and text on overlay");
}

function drawTestContourLine() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (allBlastHoles && allBlastHoles.length >= 2) {
		const hole1 = allBlastHoles[0];
		const hole2 = allBlastHoles[1];

		// Step 7c: Use same coordinate transformation as contours
		const x1 = (hole1.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y1 = (-hole1.startYLocation + centroidY) * currentScale + canvas.height / 2;
		const x2 = (hole2.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y2 = (-hole2.startYLocation + centroidY) * currentScale + canvas.height / 2;

		console.log("Drawing test line from " + x1 + "," + y1 + " to " + x2 + "," + y2);

		// Step 7d: Draw bright test line
		contourOverlayCtx.strokeStyle = "#00FF00";
		contourOverlayCtx.lineWidth = 5;
		contourOverlayCtx.setLineDash([]);
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(x1, y1);
		contourOverlayCtx.lineTo(x2, y2);
		contourOverlayCtx.stroke();

		// Step 7e: Add markers at endpoints
		contourOverlayCtx.fillStyle = "#" + "FF0000";
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x1, y1, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x2, y2, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();

		console.log("Drew test line between " + "first two blast holes");
	}
}

// Step 8: Auto-update hooks - Add these to integrate with your existing code
function hookOverlayIntoExistingFunctions() {
	// Step 8a: Hook into drawData function
	if (typeof window.drawData === "function") {
		const originalDrawData = window.drawData;
		window.drawData = function () {
			const result = originalDrawData.apply(this, arguments);
			updateOverlayColorsForTheme(); // Auto-update overlay
			return result;
		};
		console.log("Hooked into drawData");
	}

	// Step 8b: Hook into recalculateContours function
	if (typeof window.recalculateContours === "function") {
		const originalRecalculateContours = window.recalculateContours;
		window.recalculateContours = function () {
			const result = originalRecalculateContours.apply(this, arguments);
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 50); // Small delay for data to update
			}
			return result;
		};
		console.log("Hooked into recalculateContours");
	}

	// Step 8c: Hook into pan/zoom events if canvas has event listeners
	const originalAddEventListener = canvas.addEventListener;
	canvas.addEventListener = function (event, handler) {
		if (event === "wheel" || event === "mousemove") {
			const wrappedHandler = function () {
				const result = handler.apply(this, arguments);
				if (useContourOverlay) {
					updateOverlayColorsForTheme();
				}
				return result;
			};
			return originalAddEventListener.call(this, event, wrappedHandler);
		}
		return originalAddEventListener.call(this, event, handler);
	};

	// Step 8d: Hook into contour checkbox changes
	const contourCheckbox = displayContours;
	if (contourCheckbox && contourCheckbox.addEventListener) {
		contourCheckbox.addEventListener("change", function () {
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 100);
			}
		});
		console.log("Hooked into contour checkbox");
	}
}

// Step 19) Hook into resize events
function hookOverlayIntoResize() {
	window.addEventListener("resize", function () {
		if (contourOverlayCanvas && useContourOverlay) {
			// Resize overlay to match main canvas
			contourOverlayCanvas.width = canvas.width;
			contourOverlayCanvas.height = canvas.height;
			contourOverlayCanvas.style.width = canvas.style.width;
			contourOverlayCanvas.style.height = canvas.style.height;

			// Redraw with new size - contour overlay updates on next drawData call
		}
	});
	console.log("Hooked into window resize");
}

// Step 21) Enable auto-update system
function enableAutoUpdate() {
	hookOverlayIntoExistingFunctions();
	hookOverlayIntoThemeSystem();
	hookOverlayIntoResize(); // Add this line
	console.log("Auto-update enabled - overlay will update automatically");
}

// Step 10: Usage instructions with auto-update
console.log("Complete overlay system ready:");
console.log("1. debugContourStructure() - Check your contour data structure");
console.log("2. debugCorrectVariables() - Check variable availability");
console.log("3. testDrawOnOverlay() - Test overlay with simple shapes");
console.log("4. drawTestContourLine() - Test with blast hole coordinates");
console.log("5. toggleContourOverlayFixed() - Enable bright contour overlay");
console.log("6. enableAutoUpdate() - Enable automatic updates (RECOMMENDED)");
console.log("7. updateOverlayColorsForTheme() - Manual update if needed");
console.log("Theme-aware overlay system ready:");
console.log("- Colors automatically adapt to light/dark mode");
console.log("- Text uses standard theme colors (textFillColor)");
console.log("- Backgrounds use theme-appropriate opacity");
console.log("- Updates automatically when theme changes");

// Auto-enable the hooks when overlay system loads
console.log("Setting up auto-update hooks...");
if (typeof window.drawData === "function") {
	enableAutoUpdate();
}

//===========================================
// END OF MINIMAL SAFE OVERLAY FOR THE APP
//===========================================

//===========================================
// Step 1) Inline Contour Calculation (moved from webworker)
//===========================================

// Step 2) Interpolation function - essential for contour crossing points
function interpolateContourPoint(p1, p2, contourLevel) {
	const t = (contourLevel - p1.z) / (p2.z - p1.z);
	return {
		x: p1.x + t * (p2.x - p1.x),
		y: p1.y + t * (p2.y - p1.y),
	};
}

// Step 3) Main contour calculation function - now runs in main thread
function calculateContoursSync(contourData, contourLevels, maxEdgeLength, displayOptions) {
	const { displayContours, displayFirstMovements, displayRelief, firstMovementSize = 2 } = displayOptions;

	// Step 4) Early return if no display options enabled
	if (!displayContours && !displayFirstMovements && !displayRelief) {
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	if (!contourData || !Array.isArray(contourData) || contourData.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	const factor = 1.6;
	const minAngleThreshold = 5;
	const surfaceAreaThreshold = 0.1;

	// Step 5) Filter out holes where holeTime is null
	const filteredContourData = contourData.filter((hole) => hole.holeTime !== null);

	if (filteredContourData.length < 3) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	// Step 6) Helper function for distance calculation
	function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
		const distances = [];

		for (let i = 0; i < allPoints.length; i++) {
			if (allPoints[i] === targetPoint) continue;

			const dx = targetPoint.x - allPoints[i].x;
			const dy = targetPoint.y - allPoints[i].y;
			const distance = Math.sqrt(dx * dx + dy * dy);
			distances.push(distance);
		}

		distances.sort((a, b) => a - b);
		const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

		return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
	}

	// Step 7) Cache for performance
	const localAverageCache = new Map();
	function getCachedLocalAverage(point) {
		if (!localAverageCache.has(point)) {
			localAverageCache.set(point, getLocalAverageDistance(point, filteredContourData, 6));
		}
		return localAverageCache.get(point);
	}

	// Step 8) Compute Delaunay triangulation
	const delaunay = Delaunay.from(filteredContourData.map((hole) => [hole.x, hole.y]));
	const triangles = delaunay.triangles;

	if (!triangles || triangles.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	const contourLinesArray = [];
	const directionArrows = [];

	// Step 9) Process each contour level
	for (let levelIndex = 0; levelIndex < contourLevels.length; levelIndex++) {
		const contourLevel = contourLevels[levelIndex];
		const contourLines = [];

		// Step 10) Process triangles for this contour level
		for (let i = 0; i < triangles.length; i += 3) {
			const contourLine = [];

			const p1 = contourData[triangles[i]];
			const p2 = contourData[triangles[i + 1]];
			const p3 = contourData[triangles[i + 2]];

			// Step 11) Get cached local average distances for adaptive filtering
			const p1LocalAvg = getCachedLocalAverage(p1);
			const p2LocalAvg = getCachedLocalAverage(p2);
			const p3LocalAvg = getCachedLocalAverage(p3);

			const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;
			const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

			// Step 12) Calculate triangle properties for direction arrows
			const centroidX = (p1.x + p2.x + p3.x) / 3;
			const centroidY = (p1.y + p2.y + p3.y) / 3;

			// Step 13) Calculate edge lengths and check filtering
			const edge1Length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			const edge2Length = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			const edge3Length = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));

			let trianglePassesFilter = true;
			if (edge1Length > adaptiveMaxEdgeLength || edge2Length > adaptiveMaxEdgeLength || edge3Length > adaptiveMaxEdgeLength) {
				trianglePassesFilter = false;
			}

			// Step 14) Check triangle angles to reject acute triangles
			if (trianglePassesFilter) {
				const edge1Squared = edge1Length * edge1Length;
				const edge2Squared = edge2Length * edge2Length;
				const edge3Squared = edge3Length * edge3Length;

				const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2Length * edge3Length)))) * (180 / Math.PI);
				const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1Length * edge3Length)))) * (180 / Math.PI);
				const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1Length * edge2Length)))) * (180 / Math.PI);

				const minAngle = Math.min(angle1, angle2, angle3);
				if (minAngle < minAngleThreshold) {
					trianglePassesFilter = false;
				}
			}

			// Step 15) Only process triangles that pass filtering
			if (trianglePassesFilter) {
				// Step 16) Create direction arrows for first movement
				if (levelIndex === 0 && displayFirstMovements) {
					const surfaceArea = Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);

					if (surfaceArea > surfaceAreaThreshold) {
						const v1X = p2.x - p1.x;
						const v1Y = p2.y - p1.y;
						const v1Z = p2.z - p1.z;

						const v2X = p3.x - p1.x;
						const v2Y = p3.y - p1.y;
						const v2Z = p3.z - p1.z;

						const slopeX = v1Y * v2Z - v1Z * v2Y;
						const slopeY = v1Z * v2X - v1X * v2Z;
						const slopeLength = Math.sqrt(slopeX * slopeX + slopeY * slopeY);

						if (slopeLength > 0) {
							const normSlopeX = slopeX / slopeLength;
							const normSlopeY = slopeY / slopeLength;

							const arrowEndX = centroidX - normSlopeX * firstMovementSize;
							const arrowEndY = centroidY - normSlopeY * firstMovementSize;

							directionArrows.push([centroidX, centroidY, arrowEndX, arrowEndY, "goldenrod", firstMovementSize]);
						}
					}
				}

				// Step 17) Check each edge for contour level crossings
				for (let j = 0; j < 3; j++) {
					const edgeP1 = contourData[triangles[i + j]];
					const edgeP2 = contourData[triangles[i + ((j + 1) % 3)]];

					// Step 18) Calculate distance between edge points
					const distance = Math.sqrt(Math.pow(edgeP2.x - edgeP1.x, 2) + Math.pow(edgeP2.y - edgeP1.y, 2));

					// Step 19) CRITICAL: Only create contour point if level crosses the edge
					if (distance <= adaptiveMaxEdgeLength && ((edgeP1.z < contourLevel && edgeP2.z >= contourLevel) || (edgeP1.z >= contourLevel && edgeP2.z < contourLevel))) {
						// Step 20) Interpolate to find exact crossing point
						const point = interpolateContourPoint(edgeP1, edgeP2, contourLevel);
						contourLine.push(point);
					}
				}

				// Step 21) Only add contour line if it has exactly 2 points (proper line segment)
				if (contourLine.length === 2) {
					contourLines.push(contourLine);
				}
			}
		}

		// Step 22) Add this level's contour lines to the array
		contourLinesArray.push(contourLines);
	}

	// Step 23) Filter direction arrows
	const interval = 1;
	const filteredArrows = directionArrows.filter((arrow, index) => index % interval === 0);

	return {
		contourLinesArray,
		directionArrows: filteredArrows,
	};
}

// Step 24) Delaunay contours - now calls synchronous version
function delaunayContours(contourData, contourLevel, maxEdgeLength) {
	// Step 25) Calculate all contour levels
	const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
	let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
	if (typeof intervalAmount !== "undefined") {
		interval = parseInt(intervalAmount);
	}

	const numLevels = Math.ceil(maxHoleTime / interval) || 13;
	const contourLevels = [];
	for (let level = 0; level < numLevels; level++) {
		contourLevels.push(level * interval);
	}

	// Step 26) Prepare contour data
	const processedData = contourData.map((hole) => ({
		x: hole.x,
		y: hole.y,
		z: hole.z || hole.holeTime || 0,
		holeTime: hole.holeTime,
	}));

	// Step 27) Call synchronous calculation
	const displayOptions = {
		displayContours: displayContours ? displayContours.checked : false,
		displayFirstMovements: displayFirstMovements ? displayFirstMovements.checked : false,
		displayRelief: displayRelief ? displayRelief.checked : false,
		firstMovementSize: firstMovementSize || 2,
	};

	return calculateContoursSync(processedData, contourLevels, maxEdgeLength, displayOptions);
}

console.log("‚úÖ Contour calculations now run in main thread (synchronous)");

//===========================================
// END OF Inline Contour Calculation
//===========================================

document.addEventListener("DOMContentLoaded", function () {
	console.log("üöÄ Starting application initialization...");

	// Add click handlers for all file import icon buttons
	const fileImportButtons = document.querySelectorAll(".file-import-btn");

	fileImportButtons.forEach((button) => {
		button.addEventListener("click", function () {
			const targetId = this.getAttribute("data-target");
			const fileInput = document.getElementById(targetId);
			if (fileInput) {
				fileInput.click();
			}
		});
	});

	// Just hide the panel
	const treePanel = document.getElementById("treePanel");
	if (treePanel) {
		treePanel.style.display = "none";
	}

	// Initialize TreeView ONLY when the button is first clicked
	document.getElementById("showTreeBtn").addEventListener("click", function () {
		// Create TreeView on first use
		if (!treeView) {
			console.log("üå≥ Creating TreeView for first time...");
			treeView = new TreeView("treePanel");
			updateTreeView();
		}

		// Toggle panel visibility
		const treePanel = document.getElementById("treePanel");
		if (treePanel) {
			if (treePanel.style.display === "none" || !treePanel.style.display) {
				treePanel.style.display = "flex";
				// FIX: Populate tree immediately when opened (use cached data if available)
				if (treeView && treeView._cachedTreeData) {
					var tree = [
						{ id: "blast", type: "blast", label: "Blast", expanded: true, children: treeView._cachedTreeData.blastData },
						{ id: "drawings", type: "drawing", label: "Drawings", expanded: true, children: treeView._cachedTreeData.drawingData },
						{ id: "surfaces", type: "surface", label: "Surfaces", expanded: true, children: treeView._cachedTreeData.surfaceData || [] },
						{ id: "images", type: "image", label: "Images", expanded: true, children: treeView._cachedTreeData.imageData || [] }
					];
					var html = treeView.renderTree(tree);
					var treeViewElement = document.getElementById("treeView");
					if (treeViewElement) {
						treeViewElement.innerHTML = html;
					}
				} else {
					// No cached data, trigger update
					treeView.updateTreeData();
				}
			} else {
				treePanel.style.display = "none";
			}
		}
	});

	addPlaySpeedMarkers();
	updateConnectDistance(); // Set initial value based on current slider position
	addConnectDistanceMarkers(); // Add visual scale markers

	// ? CRITICAL: Add handleMouseMove and handleTouchMove listeners ONLY ONCE here
	// These are for general mouse tracking and crosshairs, and should always be active.
	// Ensure 'canvas' is defined globally or accessible here.
	if (typeof canvas !== "undefined" && canvas !== null) {
		// Add a check for 'canvas' existence
		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("touchmove", handleTouchMove);
	}
	// Also add to document if you need tracking outside the canvas area.
	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("touchmove", handleTouchMove);
	// Initialize overlay system automatically
	setTimeout(() => {
		if (typeof debugCorrectVariables === "function") {
			debugCorrectVariables(); // Check variables are ready
			enableAutoUpdate(); // Set up automatic hooks
			console.log("Overlay system initialized and ready");
		}
	}, 1000); // Small delay to ensure all your variables are loaded
	// The rest of your initialization code...
	setTimeout(function () {
		getDarkModeSettings();
		// updatePopup(); // remove and call from the initDB function
		initializeVoronoiControls();

		// Longer delay for jscolor
		setTimeout(function () {
			initializePreferences();
		}, 200);

		console.log("‚úÖ Application initialization complete");
		debugPreferences();
	}, 50);
});

