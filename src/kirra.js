//=================================================
// IMPORTS
//=================================================
import { Delaunay } from "d3-delaunay";
import Delaunator from "delaunator";
import Triangle from "triangle-wasm";
import earcut from "earcut";
import Constrainautor from "@kninnug/constrainautor";
import DxfParser from "dxf-data-parser";
import Swal from "sweetalert2";
window.Swal = Swal; // Expose to window for dialog modules
import Plotly from "plotly.js-dist";
// FileManager will be exposed after import below
import Papa from "papaparse";
import CryptoJS from "crypto-js";
import * as turf from "@turf/turf";
import { polygonCentroid } from "d3-polygon";
import ClipperLib from "clipper-lib";
import { fromUrl, fromArrayBuffer } from "geotiff";
import proj4 from "proj4";
import printJS from "print-js";
import { jsPDF } from "jspdf";
import html2canvas from "html2canvas";
import pdfMake from "pdfmake/build/pdfmake";
import pdfFonts from "pdfmake/build/vfs_fonts";
import { evaluate } from "mathjs";
//=================================================
// Three.js Renderer Selection (MUST BE EARLY!)
//=================================================
// CRITICAL: Load renderer preference from localStorage IMMEDIATELY
// This must happen BEFORE initializeThreeJS() is called
// Options: "v1" (legacy), "v2" (stable default), "perf" (performance)
const storedRendererPref = localStorage.getItem("rendererSelection") || "v2";
window.rendererSelection = storedRendererPref;
console.log("üéØ Renderer preference loaded:", storedRendererPref);
const rendererNames = { v1: "V1 (Legacy)", v2: "V2 (Stable)", perf: "Performance" };
console.log("üéØ Will use renderer:", rendererNames[storedRendererPref] || "V2 (Stable)");

//=================================================
// Three.js Rendering System
//=================================================
import * as THREE from "three";
// Three renderer options:
// - ThreeRenderer (V1): Original stable renderer
// - ThreeRendererV2: Cleaner architecture, memory optimizations
// - ThreeRendererPerf: V2 + dirty flags, batching support, culling (RECOMMENDED)
import { ThreeRenderer as ThreeRendererV1 } from "./three/ThreeRenderer.js";
import { ThreeRendererV2 } from "./three/ThreeRendererV2.js";
import { ThreeRendererPerf } from "./three/ThreeRendererPerf.js";

// Renderer selection:
// - V2 is the default stable renderer
// - ThreeRendererPerf adds dirty flags and performance tracking
// - V1 is legacy, kept for debugging
// Note: The renderer just renders the scene - the real performance issue was
// in the DRAWING code creating individual objects (now fixed with batching)

import { CameraControls } from "./three/CameraControls.js";
import { GeometryFactory, clearTextCache } from "./three/GeometryFactory.js";
import { InteractionManager } from "./three/InteractionManager.js";

// Performance-optimized rendering system
import { SceneManager, getSceneManager } from "./three/SceneManager.js";
import { getPerformanceMonitor } from "./three/PerformanceMonitor.js";
import { PolygonSelection3D } from "./three/PolygonSelection3D.js";
// Troika text optimization - configure builder and preload font for optimal performance
// import { configureTextBuilder, preloadFont } from "troika-three-text";
// import { Text } from "troika-three-text";
// OBJ/MTL Loaders for textured mesh import
import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
//=================================================
// Drawing Modules
//=================================================
import {
	clearThreeJS,
	renderThreeJS,
	drawHoleThreeJS,
	drawHoleThreeJS_Instanced,
	drawHoleToeThreeJS,
	drawHoleTextThreeJS,
	drawHoleTextsAndConnectorsThreeJS,
	drawKADPointThreeJS,
	drawKADLineSegmentThreeJS,
	drawKADPolygonSegmentThreeJS,
	drawKADBatchedPolylineThreeJS,
	drawKADSuperBatchedPointsThreeJS,
	drawKADSuperBatchedCirclesThreeJS,
	drawKADCircleThreeJS,
	drawKADTextThreeJS,
	drawSurfaceThreeJS,
	drawContoursThreeJS,
	drawDirectionArrowsThreeJS,
	drawBackgroundImageThreeJS,
	drawConnectorThreeJS,
	highlightSelectedHoleThreeJS,
	highlightSelectedKADPointThreeJS,
	drawToolPromptThreeJS,
	drawConnectStadiumZoneThreeJS,
	drawMousePositionIndicatorThreeJS,
	drawSlopeMapThreeJS,
	drawBurdenReliefMapThreeJS,
	drawVoronoiCellsThreeJS,
	clearVoronoiCellsThreeJS,
	clearKADLeadingLineThreeJS,
	drawKADLeadingLineThreeJSV2,
	clearKADLeadingLineThreeJSV2,
	drawRulerThreeJS,
	clearRulerThreeJS,
	drawProtractorThreeJS,
	clearProtractorThreeJS,
	disposeKADThreeJS,
} from "./draw/canvas3DDrawing.js";
import { clearCanvas, drawText, drawRightAlignedText, drawMultilineText, drawTrack, drawHoleToe, drawHole, drawDummy, drawNoDiameterHole, drawHiHole, drawExplosion, drawHexagon, drawKADPoints, drawKADLines, drawKADPolys, drawKADCircles, drawKADTexts, drawDirectionArrow, drawArrow, drawArrowDelayText } from "./draw/canvas2DDrawing.js";
import { drawKADHighlightSelectionVisuals } from "./draw/canvas2DDrawSelection.js";
import { highlightSelectedKADThreeJS } from "./draw/canvas3DDrawSelection.js";
//=================================================
// BUG FIX 6: Uncommented FloatingDialog module import (duplicate code removed)
import { FloatingDialog, createFormContent, createEnhancedFormContent, getFormData, showConfirmationDialog, showConfirmationThreeDialog, showModalMessage } from "./dialog/FloatingDialog.js";
// Projection Dialog Module
import { promptForProjection, isLikelyWGS84 } from "./dialog/popups/generic/ProjectionDialog.js";
// TreeView Module
import { TreeView, initializeTreeView } from "./dialog/tree/TreeView.js";
// DXF Export Dialog Module
import "./dialog/popups/export/DXFExportDialog.js";
// Helper Modules
import { exportImagesAsGeoTIFF, exportSurfacesAsElevationGeoTIFF } from "./helpers/GeoTIFFExporter.js";
import { CoordinateDebugger } from "./helpers/CoordinateDebugger.js";
//=================================================
// Dialog Modules - Converted to ES Modules for Vite bundling 2025-12-26
// These are imported as side-effect imports - the modules set window globals
// This avoids duplicate identifier errors with functions already in kirra.js
//=================================================
import "./dialog/contextMenu/HolesContextMenu.js";
import "./dialog/contextMenu/KADContextMenu.js";
import "./dialog/contextMenu/SurfacesContextMenu.js";
import "./dialog/contextMenu/ImagesContextMenu.js";
import "./dialog/contextMenu/ContextMenuManager.js";
import "./dialog/settings/ThreeDSettingsDialog.js";
import "./dialog/popups/confirm/ConfirmDialogs.js";
import "./dialog/popups/error/ErrorDialogs.js";
import "./dialog/popups/info/InfoDialogs.js";
import "./dialog/popups/generic/PatternGenerationDialogs.js";
import "./dialog/popups/generic/AddHoleDialog.js";
import "./dialog/popups/generic/HolePropertyDialogs.js";
import "./dialog/popups/generic/ExportDialogs.js";
import "./dialog/popups/generic/KADDialogs.js";
import "./dialog/popups/generic/SurfaceAssignmentDialogs.js";
//=================================================
// FileManager IO System - Modular file import/export
//=================================================
import { fileManager, initializeFileManager } from "./fileIO/init.js";
//=================================================
// Overlay System - Unified UI overlay for status, selection, coordinates
//=================================================
import {
	initHUD,
	updateSidebarState as updateHUDSidebarState,
	OverlayEventBus,
	OverlayEvents,
	// Status panel
	showStatusMessage,
	showSelectionMessage,
	clearStatus,
	// Stats panel
	emitStats,
	emitCoords,
	emitCentroid,
	emitRuler,
	emitProtractor,
	// Legend panels
	showSlopeLegend,
	showReliefLegend,
	showVoronoiLegend,
	showSurfaceLegend as showSurfaceElevationLegend,
	hideSlopeLegend,
	hideReliefLegend,
	hideSurfaceLegend as hideSurfaceElevationLegend,
	hideVoronoiLegend,
	hideLegend,
	// Ruler panel
	showRulerPanel,
	hideRulerPanel,
	// Protractor panel
	showProtractorPanel,
	hideProtractorPanel,
	// Drawing distance panel
	showDrawingDistance,
	hideDrawingDistance,
	// Pattern tool panel
	showPatternToolLabels,
	hidePatternToolLabels,
	// Tooltip panel
	showHoleTooltip,
	showPointTooltip,
	hideTooltipPanel
} from "./overlay/index.js";
//=================================================
import ToolbarPanel, { showToolbar } from "./toolbar/ToolbarPanel.js";
//=================================================
// Print and Statistics Modules
//=================================================
import { getBlastStatisticsPerEntity } from "./helpers/BlastStatistics.js";
import { printMode, printOrientation, printPaperSize, isPrinting, paperRatios, printCanvas, printCtx, togglePrintMode, getPrintBoundary, drawPrintBoundary, printCanvasHiRes, printToPDF, setupPrintEventHandlers, remove3DPrintBoundaryOverlay } from "./print/PrintSystem.js";
import {
	drawDataForPrinting,
	drawCompleteBlastDataForPrint,
	printData,
	printVoronoiMetric,
	printBlastBoundary,
	printKADPoints,
	printKADLines,
	printKADPolys,
	printKADCircles,
	printKADTexts,
	printTrack,
	printHoleToe,
	printHole,
	printDummy,
	printNoDiameterHole,
	printHiHole,
	printText,
	printRightAlignedText,
	printMultilineText,
	printDirectionArrow,
	printArrow,
	printArrowDelayText,
	printDelauanySlopeMap,
	printDelauanyBurdenRelief,
	printReliefLegend,
	printTriangleAngleText,
	printTriangleBurdenReliefText,
	printLegend,
	printVoronoiLegendAndCells,
	printHoleTextsAndConnectors,
	printHoleMainShape,
	printSurface,
	printSurfaceLegend,
	printTriangleWithGradient,
	printBackgroundImage,
} from "./print/PrintRendering.js";
import { printHeader, printFooter, printBlastStats, printBlastStatsSimple } from "./print/PrintStats.js";

//=================================================
// END IMPORTS
//=================================================

// Description: This file contains the main functions for the Kirra App
// Author: Brent Buffham
// Last Modified: "20250816.0140AWST"
// Get system date/time and format as YYYYMMDD.HHMM (in user's local time)
const now = new Date();
const pad = (n, len = 2) => n.toString().padStart(len, '0');
const buildVersion =
	`${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}.` +
	`${pad(now.getHours())}${pad(now.getMinutes())}`;
window.buildVersion = buildVersion; // Expose to window for dialog modules

//=================================================
// FileManager IO System - Expose globally for file operations
//=================================================
window.fileManager = fileManager;
console.log("FileManager initialized with formats:", fileManager.getSupportedFormats());

//=================================================
// SETUP JSCOLOR
// Set up jscolor configuration
//Position 1 for STR files String #1,33,65...
//Position 2 for STR files String #2,34,66
//Position 3 for STR files String #3,35
//Position 4 for STR files String #4,36
//Position 5 for STR files String #5,37
//Position 6 for STR files String #6,38
//Position 7 for STR files String #7,39
//Position 8 for STR files String #8,40
//Position 9 for STR files String #9,41
//Position 10 for STR files String #10,42
//...	
//Position 32 for STR files String #32,64
jscolor.presets = jscolor.presets || {};
jscolor.presets.default = {
	format: "rgb",
	palette: [
		"#770000",
		"#FF0000",
		"#FF9900",
		"#FFFF00",
		"#00ff00",
		"#009900",
		"#00ffFF",
		"#0099ff",
		"#0000FF",
		"#FF00FF",
		"#550000",
		"#AA0000",
		"#883300",
		"#bbbb00",
		"#33AA00",
		"#006600",
		"#007F7F",
		"#002288",
		"#000099",
		"#7F007F",
		"#010101",
		"#222222",
		"#333333",
		"#444444",
		"#555555",
		"#777777",
		"#888888",
		"#AAAAAA",
		"#cccccc",
		"#FEFEFE",
	],
};

// Initialize jscolor after DOM is loaded
document.addEventListener("DOMContentLoaded", function () {
	jscolor.install();
});

// END SETUP JSCOLOR
//==============================================


// Separate function for Voronoi initialization
function initializeVoronoiControls() {
	const voronoiBoundarySwitch = document.getElementById("voronoiBoundarySwitch");
	if (voronoiBoundarySwitch) {
		voronoiBoundarySwitch.addEventListener("change", function () {
			useToeLocation = voronoiBoundarySwitch.checked;
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiMetricDropdown = document.getElementById("voronoiSelect");
	if (voronoiMetricDropdown) {
		voronoiMetricDropdown.addEventListener("change", function () {
			drawData(allBlastHoles, selectedHole);
		});
	}

	const voronoiLegendDropdown = document.getElementById("voronoiLegendSelect");
	if (voronoiLegendDropdown) {
		voronoiLegendDropdown.addEventListener("change", function () {
			isVoronoiLegendFixed = voronoiLegendDropdown.value === "fixed";
			drawData(allBlastHoles, selectedHole);
		});
	}
}

// Separate function for preferences initialization
function initializePreferences() {
	try {
		loadViewControlsSliderValues();
		fontSlider.value = 14; // force the font size.
		setupAutoSavePreferences();
		console.log("‚úÖ Preferences loaded successfully");
		debugPreferences();
	} catch (error) {
		console.error("? Error loading preferences:", error);
	}
}
// Add this temporarily to debug
function debugPreferences() {
	console.log("Checking preference controls:");
	console.log("fontSlider:", document.getElementById("fontSlider"));
	console.log("snapToleranceSlider:", document.getElementById("snapToleranceSlider"));
	console.log("elevation:", document.getElementById("elevation"));

	// Test localStorage
	console.log("LocalStorage test:", localStorage.getItem("fontSize"));
}

// Call this in your consolidated DOMContentLoaded
//------------------------------------------
const canvas = document.getElementById("canvas");
const padding = 10; // add 10 pixels of padding

const uiVersionElement = document.getElementById("htmlUIVersion");
const htmlUIVersion = uiVersionElement ? uiVersionElement.value : "1"; // Default to "1" if not found

//get the menu bar --var from the css
const menubarSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--menubar-size"));
const canvasBorderWidth2X = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-border")) * 2;
const canvasContainerMargin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--canvas-container-margin"));

// Existing canvas setup logic that you want to make conditional
if (htmlUIVersion === "1") {
	// Get the screen size and calculate the dimensions based on the desired ratio
	const screenWidth = window.innerWidth;
	const screenHeight = window.innerHeight;
	const canvasWidth = Math.round(screenWidth);
	const canvasHeight = Math.round(screenHeight);

	const canvasAdjustWidth = 40; //was 40 for kirra.html and styles.css;
	const canvasAdjustHeight = 0.12; //was 0.12 for kirra.html and styles.css;
	// Set the dimensions of the canvas and its container
	canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
	canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
} else {
	//Do nothing
}

const timeChartObject = document.getElementById("timeChart");
let statusMessage = "";
const resizeRight = document.getElementById("resizeHandleRight");
let isResizingRight = false;
const resizeLeft = document.getElementById("resizeHandleLeft");
let isResizingLeft = false;

//=================================================
// Step 1) Initialize Three.js Rendering System
//=================================================
let threeRenderer = null;
let cameraControls = null;
let interactionManager = null; // 3D raycasting and interaction manager
let coordinateDebugger = null; // Coordinate transform debugging tool
let sceneManager = null; // Performance-optimized scene coordinator
let threeInitialized = false;
let threeInitializationFailed = false; // Step 0a) Prevent retry storm if initialization fails
let onlyShowThreeJS = false; // Toggle to show only Three.js rendering
// let troikaFontBaked = false; // Step 0b) Track if Troika font SDF texture has been baked

// Step 1) Local coordinate offset for precision with large UTM coordinates
// Three.js uses these local coordinates (offset from origin) to avoid floating-point errors
let threeLocalOriginX = 0;
let threeLocalOriginY = 0;

// Step 1b) Track current rotation state (in radians)
let currentRotation = 0;

// Step 1c) Track Z centroid of all data for orbit center
let dataCentroidZ = 0;

// Step 1d) Flag to indicate centroid needs recalculation (only on data change, NOT every frame)
// CRITICAL: Calculating centroid every frame caused 1-5 FPS with large LAS files
let centroidNeedsRecalculation = true;

// Step 2) Helper to convert world coordinates to local Three.js coordinates
function worldToThreeLocal(worldX, worldY) {
	return {
		x: worldX - threeLocalOriginX,
		y: worldY - threeLocalOriginY,
	};
}

// Step 2a) Helper to project 3D world position to 2D screen pixels (for selection and raycasting)
function worldToScreen(worldX, worldY, worldZ) {
	// Step 2a.1) Early return if Three.js not initialized
	if (!threeRenderer || !threeRenderer.camera || !threeRenderer.getCanvas()) {
		return null;
	}

	// Step 2a.2) Get canvas dimensions
	const canvas = threeRenderer.getCanvas();
	const rect = canvas.getBoundingClientRect();
	const canvasWidth = rect.width;
	const canvasHeight = rect.height;

	// Step 2a.3) Convert world to Three.js local coordinates
	const local = worldToThreeLocal(worldX, worldY);

	// Step 2a.4) Create vector and project to normalized device coordinates
	const vector = new THREE.Vector3(local.x, local.y, worldZ);
	vector.project(threeRenderer.camera);

	// Step 2a.5) Convert NDC (-1 to +1) to screen pixels (0 to width/height)
	const screenX = ((vector.x + 1) * canvasWidth) / 2;
	const screenY = ((-vector.y + 1) * canvasHeight) / 2; // Invert Y for screen coordinates

	return { x: screenX, y: screenY };
}

// Expose globals for canvas3DDrawing.js module
window.worldToThreeLocal = worldToThreeLocal;
window.worldToScreen = worldToScreen;
// Note: getSnapRadiusInWorldUnits3D exposed near its definition (line ~36617)

// Function to sync globals to window for module access
// Called before rendering to ensure all values are current
function exposeGlobalsToWindow() {
	// Step 1) Three.js globals
	window.threeInitialized = threeInitialized;
	window.threeRenderer = threeRenderer;
	window.dataCentroidZ = dataCentroidZ;
	window.centroidNeedsRecalculation = centroidNeedsRecalculation;
	window.threeLocalOriginX = threeLocalOriginX;
	window.threeLocalOriginY = threeLocalOriginY;

	// Step 2) 2D Canvas globals (ctx and canvas exposed at initialization)
	window.strokeColor = strokeColor;
	window.fillColor = fillColor;
	window.firstMovementSize = firstMovementSize;
	window.connScale = connScale;

	// Step 3) Shared globals
	window.holeScale = holeScale;
	window.currentScale = currentScale;
	window.darkModeEnabled = darkModeEnabled;
	window.currentFontSize = currentFontSize;
	window.textFillColor = textFillColor;
	window.depthColor = depthColor;
	window.angleDipColor = angleDipColor;
	window.snapRadiusPixels = snapRadiusPixels;

	// Step 4) Connector state (for stadium zone tracking)
	window.fromHoleStore = fromHoleStore;
	window.isAddingMultiConnector = isAddingMultiConnector;
	window.connectAmount = connectAmount;

	// Step 5) Helper functions
	window.elevationToColor = elevationToColor;
	window.rgbStringToThreeColor = rgbStringToThreeColor;
	window.worldToCanvas = worldToCanvas;

	// Step 6) Selection state for KAD and holes (for selection highlighting modules)
	// FIX: Preserve window.selectedKADObject if local variable is null but window already has a value
	// This prevents pattern tool selections from being cleared when exposeGlobalsToWindow() runs
	if (selectedKADObject !== null && selectedKADObject !== undefined) {
		window.selectedKADObject = selectedKADObject;
	} else if (window.selectedKADObject && (window.isPatternInPolygonActive || window.isHolesAlongPolyLineActive)) {
		// Preserve window.selectedKADObject for pattern tools even if local variable is null
		// This handles the case where drawData() calls exposeGlobalsToWindow() before the local variable is set
		// The local variable will be set by the click handler, but exposeGlobalsToWindow() runs first
	} else {
		window.selectedKADObject = selectedKADObject;
	}
	window.selectedKADPolygon = selectedKADPolygon;
	window.selectedMultipleKADObjects = selectedMultipleKADObjects;
	window.selectedHole = selectedHole;
	window.selectedMultipleHoles = selectedMultipleHoles;
	window.selectedPoint = selectedPoint; // CRITICAL: Expose selectedPoint for vertex highlighting
	window.selectedMultiplePoints = selectedMultiplePoints; // CRITICAL: Expose for multi-vertex highlighting
	window.isSelectionPointerActive = isSelectionPointerActive;
	window.allKADDrawingsMap = allKADDrawingsMap;
	// Step 3) Expose layer Maps for TreeView access
	window.allDrawingLayers = allDrawingLayers;
	window.allSurfaceLayers = allSurfaceLayers;
	window.DEFAULT_DRAWING_LAYER_ID = DEFAULT_DRAWING_LAYER_ID;
	window.DEFAULT_SURFACE_LAYER_ID = DEFAULT_SURFACE_LAYER_ID;
	// Step 18a) Expose active layer tracking
	window.activeDrawingLayerId = activeDrawingLayerId;
	window.activeSurfaceLayerId = activeSurfaceLayerId;
	window.isPatternInPolygonActive = isPatternInPolygonActive;
	window.isHolesAlongPolyLineActive = isHolesAlongPolyLineActive;
	window.getEntityFromKADObject = getEntityFromKADObject;
	window.developerModeEnabled = developerModeEnabled;
	// Step 6a) Expose radio buttons and helper functions for 3D polygon selection
	window.selectHolesRadio = selectHolesRadio;
	window.selectKADRadio = selectKADRadio;
	window.isHoleVisible = isHoleVisible;
	window.isEntityVisible = isEntityVisible;
	window.allBlastHoles = allBlastHoles;

	// Step 6b) Expose drawing functions for 3D polygon selection
	window.drawData = drawData;
	window.renderThreeJS = renderThreeJS;

	// Step 6b.1) Helper function for dialogs to trigger 3D rebuild when properties change
	// Use this instead of just drawData() when changing: transparency, gradient, color, visibility, etc.
	window.redraw3D = function () {
		window.threeDataNeedsRebuild = true;
		drawData(window.allBlastHoles, window.selectedHole);
	};
	window.updateStatusMessage = updateStatusMessage;
	window.updateSelectionAveragesAndSliders = updateSelectionAveragesAndSliders;

	// Step 6c) Expose context menu functions for tree view and 3D interactions
	window.showSurfaceContextMenu = showSurfaceContextMenu;
	window.showImageContextMenu = showImageContextMenu;

	// Step 6d) Expose additional functions needed by ContextMenuManager
	window.getClickedHole = getClickedHole;
	window.getClickedHole3DWithTolerance = getClickedHole3DWithTolerance;
	window.getClickedKADObject = getClickedKADObject;
	window.getClickedKADObject3D = getClickedKADObject3D;
	window.getSnapToleranceInWorldUnits = getSnapToleranceInWorldUnits;
	window.canvasToWorld = canvasToWorld;
	window.isKADObjectSelected = isKADObjectSelected;
	window.isPointInSurface = isPointInSurface;
	window.isPointInBackgroundImage = isPointInBackgroundImage;
	window.loadedImages = loadedImages;
	window.loadedSurfaces = loadedSurfaces;
	window.debouncedUpdateTreeView = debouncedUpdateTreeView;
	window.clearCurrentDrawingEntity = clearCurrentDrawingEntity;
	window.addPointDraw = addPointDraw;
	window.addLineDraw = addLineDraw;
	window.addCircleDraw = addCircleDraw;
	window.addPolyDraw = addPolyDraw;
	window.addTextDraw = addTextDraw;
	window.onlyShowThreeJS = onlyShowThreeJS;
	window.cameraControls = cameraControls;
	window.interactionManager = interactionManager;
	window.isPolygonSelectionActive = isPolygonSelectionActive;

	// Step 6e) Expose state variables needed by context menus
	window.isDragging = isDragging;
	window.longPressTimeout = longPressTimeout;
	window.createNewEntity = createNewEntity;
	window.lastKADDrawPoint = lastKADDrawPoint;

	// Step 6f) ONLY expose functions that actually exist in kirra.js
	window.calculateHoleGeometry = calculateHoleGeometry;
	window.debouncedSaveHoles = debouncedSaveHoles;
	window.debouncedSaveKAD = debouncedSaveKAD;
	window.debouncedSaveLayers = debouncedSaveLayers;
	window.clearAllSelectionState = clearAllSelectionState;
	window.setSelectionFromTreeView = setSelectionFromTreeView; // CRITICAL: For TreeView to update selection
	window.openColorPickerForElement = openColorPickerForElement; // CRITICAL: For TreeView color swatch clicks
	window.setKADEntityVisibility = setKADEntityVisibility;
	window.endKadTools = endKadTools; // CRITICAL: Expose for ContextMenuManager right-click handling
	window.setSurfaceVisibility = setSurfaceVisibility;
	window.showSurfaceLegend = showSurfaceLegend;
	window.deleteSurfaceFromDB = deleteSurfaceFromDB;
	window.deleteAllSurfacesFromDB = deleteAllSurfacesFromDB;
	window.saveSurfaceToDB = saveSurfaceToDB;
	window.deleteImageFromDB = deleteImageFromDB;
	window.deleteAllImagesFromDB = deleteAllImagesFromDB;
}

// Step 3) Set local origin from first hole, surface, or current centroid
function updateThreeLocalOrigin() {
	// Priority 1: Use first hole if available
	if (allBlastHoles && allBlastHoles.length > 0) {
		threeLocalOriginX = allBlastHoles[0].startXLocation;
		threeLocalOriginY = allBlastHoles[0].startYLocation;
		console.log("üìç Three.js local origin set from first hole:", threeLocalOriginX, threeLocalOriginY);
		return;
	}

	// Priority 2: Use first surface point if available (including textured meshes)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			// Check for standard surface points (LAS, DXF 3DFACE, point cloud triangulations, etc.)
			if (surface.points && surface.points.length > 0) {
				threeLocalOriginX = surface.points[0].x;
				threeLocalOriginY = surface.points[0].y;
				console.log("üìç Three.js local origin set from surface points:", surfaceId, "->", threeLocalOriginX, threeLocalOriginY);
				return;
			}
			// Check for meshBounds (LAS surfaces, OBJ files, any surface with bounds)
			// This handles both textured meshes AND triangulated surfaces with meshBounds
			if (surface.meshBounds) {
				threeLocalOriginX = (surface.meshBounds.minX + surface.meshBounds.maxX) / 2;
				threeLocalOriginY = (surface.meshBounds.minY + surface.meshBounds.maxY) / 2;
				console.log("üìç Three.js local origin set from mesh bounds center:", surfaceId, "->", threeLocalOriginX, threeLocalOriginY);
				return;
			}
		}
	}

	// Priority 3: Fallback to current centroid
	if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined") {
		threeLocalOriginX = centroidX;
		threeLocalOriginY = centroidY;
		console.log("üìç Three.js local origin set to centroid:", threeLocalOriginX, threeLocalOriginY);
	}
}

// Step 4) Calculate XYZ centroid of all data for orbit center and grid positioning
// Note: X/Y and Z are calculated with separate counts to avoid Z values (small elevation numbers)
// diluting the X/Y centroid calculation
function calculateDataCentroid() {
	let sumX = 0,
		sumY = 0,
		sumZ = 0;
	let countXY = 0;
	let countZ = 0;

	// Step 4a) Add hole values - X/Y from collar only, Z from collar/grade/toe
	// Note: parseFloat ensures string values are converted to numbers
	if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
		for (const hole of allBlastHoles) {
			if (hole && typeof hole === "object") {
				// X/Y: Only use collar position (startX/Y) to avoid zeros from grade/toe
				sumX += parseFloat(hole.startXLocation) || 0;
				sumY += parseFloat(hole.startYLocation) || 0;
				countXY++;

				// Z: Use all three elevations (collar, grade, toe) for better Z average
				sumZ += parseFloat(hole.startZLocation) || 0;
				countZ++;
				if (hole.gradeZLocation) {
					sumZ += parseFloat(hole.gradeZLocation) || 0;
					countZ++;
				}
				if (hole.endZLocation) {
					sumZ += parseFloat(hole.endZLocation) || 0;
					countZ++;
				}
			}
		}
	}

	// Step 4b) Add surface XYZ values if available
	if (typeof loadedSurfaces !== "undefined" && loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface && surface.points && Array.isArray(surface.points) && surface.points.length > 0) {
				// Step 4b.1) Surface with points array - use points for XYZ
				for (const point of surface.points) {
					if (point && typeof point === "object") {
						sumX += parseFloat(point.x) || 0;
						sumY += parseFloat(point.y) || 0;
						countXY++;
						if (point.z !== undefined) {
							sumZ += parseFloat(point.z) || 0;
							countZ++;
						}
					}
				}
			} else if (surface && surface.meshBounds) {
				// Step 4b.2) Surface with meshBounds - use bounds for XYZ
				sumX += (parseFloat(surface.meshBounds.minX) || 0) + (parseFloat(surface.meshBounds.maxX) || 0);
				sumY += (parseFloat(surface.meshBounds.minY) || 0) + (parseFloat(surface.meshBounds.maxY) || 0);
				countXY += 2;
				sumZ += parseFloat(surface.meshBounds.minZ) || 0;
				sumZ += parseFloat(surface.meshBounds.maxZ) || 0;
				countZ += 2;
			}
		}
	}
	// Step 4c) Add KAD drawing XYZ values if available
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			if (entity && entity.data && Array.isArray(entity.data) && entity.data.length > 0) {
				for (const point of entity.data) {
					if (point && typeof point === "object") {
						sumX += parseFloat(point.pointXLocation) || 0;
						sumY += parseFloat(point.pointYLocation) || 0;
						countXY++;
						if (point.pointZLocation) {
							sumZ += parseFloat(point.pointZLocation) || 0;
							countZ++;
						}
					}
				}
			}
		}
	}
	return {
		x: countXY > 0 ? sumX / countXY : 0,
		y: countXY > 0 ? sumY / countXY : 0,
		z: countZ > 0 ? sumZ / countZ : 0,
	};
}

// Step 5) Calculate Z centroid only (for backward compatibility)
function calculateDataZCentroid() {
	const centroid = calculateDataCentroid();
	return centroid.z;
}

// Step 5a) Request centroid recalculation on next render frame
// Call this after data imports, deletes, or any change that affects centroid
function requestCentroidRecalculation() {
	centroidNeedsRecalculation = true;
	window.centroidNeedsRecalculation = true;
}
// Expose to window for external modules
window.requestCentroidRecalculation = requestCentroidRecalculation;

// Step 5b) Validate and clamp world Z coordinate to prevent extreme values
// CRITICAL FIX: Without validation, cursor can disappear when Z becomes extreme (e.g., -683885)
// This typically happens when no valid surface intersection occurs and plane intersection fails
function validateWorldZ(zValue, fallbackZ) {
	// Step 5b.1) If zValue is not a valid finite number, use fallback
	if (zValue === undefined || zValue === null || !isFinite(zValue)) {
		return fallbackZ || dataCentroidZ || 0;
	}

	// Step 5b.2) Detect extreme Z values (more than 100km from centroid)
	// This catches failed plane intersection results that return garbage values
	var centroid = dataCentroidZ || 0;
	var maxDeviation = 100000; // 100km max deviation from centroid

	if (Math.abs(zValue - centroid) > maxDeviation) {
		if (window.developerModeEnabled) {
			console.warn("‚ö†Ô∏è Extreme Z value detected: " + zValue.toFixed(2) + ", using fallback: " + (fallbackZ || centroid).toFixed(2));
		}
		return fallbackZ || centroid;
	}

	return zValue;
}
// Expose to window for external modules
window.validateWorldZ = validateWorldZ;

function initializeThreeJS() {
	if (threeInitialized) return;

	// Step 0a) Prevent retry storm - if initialization failed once, don't retry on every mouse move
	if (threeInitializationFailed) {
		return;
	}

	// Step 1) Check if canvas exists
	if (!canvas) {
		console.warn("‚ö†Ô∏è Canvas not ready yet, deferring Three.js initialization");
		return;
	}

	try {
		console.log("üé¨ Initializing Three.js rendering system...");

		// Step 1a) Load 3D settings (guard against function not being defined yet)
		const settings = typeof load3DSettings === "function" ? load3DSettings() : {};

		// Step 2) Create Three.js renderer
		const canvasContainer = canvas.parentElement;

		if (!canvasContainer) {
			console.error("‚ùå Canvas container not found");
			return;
		}

		// Choose renderer based on user preference (dropdown selection)
		// Options: "v1" (legacy), "v2" (stable default), "perf" (performance)
		let RendererClass;
		let rendererVersion;
		switch (window.rendererSelection) {
			case "v1":
				RendererClass = ThreeRendererV1;
				rendererVersion = "ThreeRendererV1 (Legacy)";
				break;
			case "perf":
				RendererClass = ThreeRendererPerf;
				rendererVersion = "ThreeRendererPerf (Performance)";
				break;
			case "v2":
			default:
				RendererClass = ThreeRendererV2;
				rendererVersion = "ThreeRendererV2 (Stable)";
				break;
		}
		console.log("üé® Renderer selected:", rendererVersion);
		console.log("üé® RendererClass =", RendererClass.name);

		threeRenderer = new RendererClass(canvasContainer, canvas.clientWidth, canvas.clientHeight);

		// Store renderer info for display
		window.currentRendererVersion = rendererVersion;

		console.log("‚úÖ Renderer created successfully:", threeRenderer.constructor.name);

		// Step 2a) Optimize Troika font rendering for optimal performance (one-time, shared by all text)
		// This configures optimal SDF settings and preloads all glyphs into Troika's shared atlas.
		// This must happen before creating any Text instances
		//await optimizeTroikaFont();//Didn't work well enough

		// Step 2b) Apply lighting settings
		if (settings.lightBearing !== undefined && settings.lightElevation !== undefined) {
			threeRenderer.updateLighting(settings.lightBearing, settings.lightElevation);
		}
		if (settings.ambientLightIntensity !== undefined) {
			threeRenderer.updateAmbientLightIntensity(settings.ambientLightIntensity);
		}
		if (settings.directionalLightIntensity !== undefined) {
			threeRenderer.updateDirectionalLightIntensity(settings.directionalLightIntensity);
		}
		if (settings.shadowIntensity !== undefined) {
			threeRenderer.updateShadowIntensity(settings.shadowIntensity);
		}

		// Step 2b) Apply clipping plane settings
		if (settings.clippingNear !== undefined && settings.clippingFar !== undefined) {
			threeRenderer.updateClippingPlanes(settings.clippingNear, settings.clippingFar);
		}
		if (settings.showClippingPlane !== undefined) {
			threeRenderer.setClippingPlaneVisualization(settings.showClippingPlane);
		}

		// Step 2c) Apply grid settings
		if (settings.showGrid !== undefined) {
			threeRenderer.setGridVisible(settings.showGrid);
		}
		if (settings.gridSize !== undefined) {
			threeRenderer.updateGridSize(settings.gridSize);
		}
		if (settings.gridOpacity !== undefined) {
			threeRenderer.updateGridOpacity(settings.gridOpacity);
		}

		// Step 2d) Apply cursor opacity
		if (settings.cursorOpacity !== undefined) {
			window.cursorOpacity3D = settings.cursorOpacity;
		}

		// Step 2a) Create base canvas for background color (bottom layer)
		const baseCanvas = document.createElement("canvas");
		baseCanvas.id = "baseCanvas";
		baseCanvas.width = canvas.clientWidth;
		baseCanvas.height = canvas.clientHeight;
		baseCanvas.style.position = "absolute";
		baseCanvas.style.top = "0";
		baseCanvas.style.left = "0";
		baseCanvas.style.width = "100%";
		baseCanvas.style.height = "100%";
		baseCanvas.style.pointerEvents = "none"; // No interaction, just background
		baseCanvas.style.zIndex = "0"; // Bottom layer

		// Step 2b) Set base canvas color based on dark mode
		const baseCtx = baseCanvas.getContext("2d");
		baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
		baseCtx.fillRect(0, 0, baseCanvas.width, baseCanvas.height);

		// Step 2c) Insert base canvas first
		canvasContainer.insertBefore(baseCanvas, canvas);

		// Step 2d) Store reference for later updates
		window.baseCanvas = baseCanvas;
		window.baseCtx = baseCtx;

		// Step 3) Insert Three.js canvas after base canvas
		const threeCanvas = threeRenderer.getCanvas();
		threeCanvas.id = "threeCanvas";
		threeCanvas.style.position = "absolute";
		threeCanvas.style.top = "0";
		threeCanvas.style.left = "0";
		threeCanvas.style.width = "100%";
		threeCanvas.style.height = "100%";
		threeCanvas.style.pointerEvents = "auto";
		threeCanvas.style.zIndex = "1";

		// Step 4) Insert before 2D canvas (but after base canvas)
		canvasContainer.insertBefore(threeCanvas, canvas);

		// Step 5) Update 2D canvas to be transparent overlay
		canvas.style.zIndex = "2";
		// IMPORTANT: Keep pointer-events AUTO so 2D canvas still works!
		// Three.js will render behind, 2D canvas renders on top
		canvas.style.pointerEvents = "auto";
		canvas.style.setProperty("background-color", "transparent", "important"); // Override CSS
		canvas.style.border = "none"; // Remove border for cleaner look

		// Step 5b) Ensure toggle buttons are above both canvases
		const toggleButtonsContainer = document.querySelector(".toggle-buttons-container");
		if (toggleButtonsContainer) {
			toggleButtonsContainer.style.zIndex = "10"; // Above both canvases
			console.log("üìç Set toggle buttons z-index to 10");
		}

		// Step 6) Create unified camera controls
		cameraControls = new CameraControls(threeRenderer, canvas);

		// Step 6a) Apply unified camera settings
		const cameraSettings = {
			gizmoDisplay: settings.gizmoDisplay || "only_when_orbit_or_rotate",
			axisLock: settings.axisLock || "none",
			dampingFactor: settings.dampingFactor || 0.05,
		};
		cameraControls.updateSettings(cameraSettings);

		// Step 6a.1) START ANIMATION LOOP IMMEDIATELY for smooth 3D rendering
		// This ensures the scene renders continuously even without user interaction
		// Fixes QUIRK 1: Jerkiness on startup until user drags 2D then returns to 3D
		if (cameraControls.animationFrameId === null) {
			cameraControls.animationFrameId = requestAnimationFrame(cameraControls.animate);
			console.log("üì∑ Started CameraControls animation loop for smooth 3D rendering");
		}

		// Step 6b) Set gizmo display mode
		if (settings.gizmoDisplay !== undefined) {
			cameraControls.setGizmoDisplayMode(settings.gizmoDisplay);
		}

		// Step 6c) Set axis lock mode
		if (settings.axisLock !== undefined) {
			cameraControls.setAxisLock(settings.axisLock);
		}

		cameraControls.attachEvents();

		// Step 6d) Set callback for camera changes to update pattern tool labels
		cameraControls.onCameraChange = function () {
			if (isPatternInPolygonActive) {
				drawPatternInPolygon3DVisual(); // Updates HUD label positions via worldToScreen()
			}
			if (isHolesAlongLineActive) {
				drawHolesAlongLine3DVisual();
			}
			if (isHolesAlongPolyLineActive) {
				drawHolesAlongPolyline3DVisual();
			}
		};

		// Step 6a) Create interaction manager for 3D raycasting
		interactionManager = new InteractionManager(threeRenderer, threeRenderer.camera);
		window.interactionManager = interactionManager; // Expose globally

		// Step 6a.1) Create SceneManager for performance-optimized rendering
		sceneManager = getSceneManager(threeRenderer);
		window.sceneManager = sceneManager; // Expose globally for console access
		console.log("üé¨ SceneManager created - use window.sceneManager for performance utilities");

		// Step 6a.2) Create coordinate debugger for troubleshooting transform issues
		coordinateDebugger = new CoordinateDebugger(threeRenderer, interactionManager);
		window.coordinateDebugger = coordinateDebugger; // Expose globally for console access
		console.log("üîç CoordinateDebugger created - use window.coordinateDebugger.enable() to activate");

		// Step 6b) Expose globals to window immediately after initialization
		// This ensures mouse tracking works from the start
		exposeGlobalsToWindow();

		// Step 7) Override camera controls to sync with 2D overlay
		const originalHandleWheel = cameraControls.handleWheel.bind(cameraControls);
		cameraControls.handleWheel = function (event) {
			const result = originalHandleWheel(event);
			if (result) {
				syncCameraFromThreeJS(result);
			}
			return result;
		};

		const originalHandleMouseMove = cameraControls.handleMouseMove.bind(cameraControls);
		cameraControls.handleMouseMove = function (event) {
			const result = originalHandleMouseMove(event);
			if (result) {
				syncCameraFromThreeJS(cameraControls.getCameraState());
			}
			return result;
		};

		// Step 8) Test square removed - Three.js is working!

		// Step 8b) Initialize camera with current state (use local coordinates)
		if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && typeof currentScale !== "undefined") {
			const localCentroid = worldToThreeLocal(centroidX, centroidY);
			// Initialize with default top-down view (rotation=0, orbitX=0, orbitY=0)
			cameraControls.setCameraState(localCentroid.x, localCentroid.y, currentScale, 0, 0, 0);
			console.log("üì∑ Camera initialized - World:", centroidX.toFixed(2), centroidY.toFixed(2), "Local:", localCentroid.x.toFixed(2), localCentroid.y.toFixed(2), "Scale:", currentScale);
		}

		// Step 9) Start render loop
		threeRenderer.startRenderLoop();

		// Step 10) Set initial background color based on current dark mode
		threeRenderer.setBackgroundColor(darkModeEnabled);
		console.log("üé® Three.js background set to", darkModeEnabled ? "black" : "white");

		// Step 10a) Also update base canvas background on initialization
		if (window.baseCanvas && window.baseCtx) {
			window.baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
			window.baseCtx.fillRect(0, 0, window.baseCanvas.width, window.baseCanvas.height);
			console.log("üé® Base canvas background set to", darkModeEnabled ? "black" : "white");
		}

		// Step 10b) Set threeInitialized to true BEFORE setting up event handlers
		threeInitialized = true;

		// Step 10b) Setup 3D mouse event handlers for independent 3D selection
		setup3DMouseEvents();

		console.log("‚úÖ Three.js rendering system initialized");

		// Step 10c) Update LineMaterial resolution for any fat lines on initial render
		if (typeof updateAllLineMaterialResolution === "function") {
			updateAllLineMaterialResolution();
		}

		// Step 10d) If data was already loaded, redraw it now that 3D is ready
		if (allBlastHoles && allBlastHoles.length > 0) {
			console.log("üé® Redrawing existing data in 3D...");
			drawData(allBlastHoles, selectedHole);
		}
	} catch (error) {
		console.error("‚ùå Failed to initialize Three.js:", error);
		threeInitialized = false;
		threeInitializationFailed = true; // Step 0b) Mark failure to prevent retry storm

		// Step 0c) Use centralized cleanup function to ensure all resources are cleaned up
		cleanupAllResources();

		// Step 0c.1) CRITICAL: Restore failure flag after cleanup (cleanup resets it, but we need to prevent retry storm)
		threeInitializationFailed = true;

		// Step 0d) Show user-friendly error message
		console.error("‚ùå WebGL initialization failed. This may be caused by:");
		console.error("  - Browser WebGL context limit exhausted (refresh page)");
		console.error("  - GPU/graphics driver issues");
		console.error("  - Too many browser tabs with WebGL content");
		console.error("  - Outdated graphics drivers");
	}
}

// Step 9) Sync camera state FROM Three.js TO 2D variables
// This updates 2D variables when user interacts with Three.js camera
function syncCameraFromThreeJS(cameraState) {
	if (cameraState) {
		// Convert local coordinates back to world
		centroidX = cameraState.centroidX + threeLocalOriginX;
		centroidY = cameraState.centroidY + threeLocalOriginY;
		currentScale = cameraState.scale;

		// Preserve rotation state
		if (cameraState.rotation !== undefined) {
			currentRotation = cameraState.rotation;
		}

		// Note: orbitX and orbitY are not synced to 2D (2D doesn't support orbit)
		// They remain in CameraControls state only
	}
}

// Step 9b) Sync camera state FROM 2D TO Three.js
// This is used only for initialization and fit-to-view operations (not ongoing updates)
function syncCameraToThreeJS() {
	if (threeInitialized && cameraControls) {
		const localCentroid = worldToThreeLocal(centroidX, centroidY);
		cameraControls.setCameraState(localCentroid.x, localCentroid.y, currentScale, currentRotation || 0, cameraControls.orbitX || 0, cameraControls.orbitY || 0);
		console.log("üì∑ Synced camera TO Three.js - World:", centroidX.toFixed(2), centroidY.toFixed(2), "Local:", localCentroid.x.toFixed(2), localCentroid.y.toFixed(2), "Scale:", currentScale);

		// After camera sync, redraw mouse indicator at current position (or camera center)
		// This ensures the grey torus stays visible after camera changes
		if (onlyShowThreeJS && threeRenderer && interactionManager) {
			setTimeout(() => {
				const threeCanvas = threeRenderer.getCanvas();
				if (threeCanvas) {
					// Get current mouse position or canvas center
					const rect = threeCanvas.getBoundingClientRect();
					const centerX = rect.left + rect.width / 2;
					const centerY = rect.top + rect.height / 2;

					// Trigger mousemove event to recalculate and redraw mouse indicator
					const syntheticEvent = new MouseEvent("mousemove", {
						bubbles: true,
						cancelable: true,
						clientX: centerX,
						clientY: centerY,
						button: 0,
						buttons: 0,
					});

					// Synthetic Events is killing the GPU and destroying performance.  
					// document.dispatchEvent(syntheticEvent);
				}
			}, 50); // Small delay to ensure camera state is fully updated
		}
	}
}

//=================================================
// End Three.js Initialization
// Note: initializeThreeJS() is called from drawData() when canvas is ready
//=================================================

// Step 11) Setup 3D mouse event handlers for independent 3D selection
function setup3DMouseEvents() {
	if (!threeRenderer) {
		if (developerModeEnabled) {
			console.warn("üö® [3D EVENTS] threeRenderer not ready");
		}
		return;
	}

	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) {
		if (developerModeEnabled) {
			console.warn("üö® [3D EVENTS] No 3D canvas found");
		}
		return;
	}

	// Step 11a) Get container (same as camera controls) to ensure events are received
	const container = threeCanvas.parentElement;
	if (!container) {
		console.warn("üö® [3D EVENTS] Could not find container for 3D mouse events");
		return;
	}

	if (developerModeEnabled) {
		console.log("üëÇ [3D EVENTS] Setting up event listeners on container:", container);
	}

	// Step 11b) Attach event handlers
	// IMPORTANT: Use capture phase for click to run before camera controls
	// IMPORTANT: Use DOCUMENT for mousemove to track mouse even when it leaves canvas (for stadium zone)
	container.addEventListener("click", handle3DClick, true); // Capture phase for selection priority
	container.addEventListener("contextmenu", window.handle3DContextMenu, true); // Capture phase for context menu
	document.addEventListener("mousemove", handle3DMouseMove, false); // Document-wide to track all mouse movement
	container.addEventListener("touchstart", handle3DTouchStart, { passive: false, capture: true });
	container.addEventListener("touchend", handle3DTouchEnd, { passive: false, capture: true });
	container.addEventListener("touchmove", handle3DTouchMove, { passive: false, capture: true });

	if (developerModeEnabled) {
		console.log("üëã [3D EVENTS] 3D mouse event handlers attached", {
			container: container.tagName,
			containerId: container.id,
			containerClass: container.className,
			mouseMoveTarget: "document (for full tracking)",
		});
	}
}

// Step 12) Handle 3D click - independent 3D selection using raycasting
// Using click instead of mousedown ensures it only fires after a full click (not during drag)
// Simplified pattern matching Three.js examples - works at any camera orientation
function handle3DClick(event) {
	if (developerModeEnabled) {
		console.log("üî´ [3D CLICK] Event fired", {
			onlyShowThreeJS,
			threeInitialized: !!threeInitialized,
			threeRenderer: !!threeRenderer,
			allBlastHoles: !!allBlastHoles,
			allBlastHolesLength: allBlastHoles ? allBlastHoles.length : 0,
			clientX: event.clientX,
			clientY: event.clientY,
			button: event.button,
			altKey: event.altKey,
			ctrlKey: event.ctrlKey,
			metaKey: event.metaKey,
		});
	}

	// Step 12a) Only handle if in 3D mode (onlyShowThreeJS flag determines mode)
	if (!onlyShowThreeJS) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] Not in 3D mode - onlyShowThreeJS =", onlyShowThreeJS);
		}
		// 2D mode is active, don't handle 3D selection
		return;
	}

	// Step 12a.0) Skip if we just finished dragging (prevents re-selection after mouseup)
	if (justFinishedDragging) {
		console.log("üèÅ [3D CLICK] Just finished dragging - skipping selection to prevent re-highlight");
		return;
	}

	// Step 12a.1) Skip if polygon selection tool is active
	const polygonToolCheckbox = document.getElementById("selectByPolygon");
	if (polygonToolCheckbox && polygonToolCheckbox.checked) {
		console.log("üî∂ [3D CLICK] Polygon selection tool active - skipping raycast selection");
		return;
	}

	// Step 12b) Skip if modifier keys are held (let camera controls handle orbit/rotate)
	// Alt = orbit, Ctrl/Cmd = rotate, Right-click = rotate
	if (event.altKey || event.metaKey || event.ctrlKey || event.button === 2) {
		console.log("ü§å [3D CLICK] Modifier keys held - skipping selection (3D arrow icon)");
		// Let camera controls handle these
		return;
	}

	// Step 12c) Early return if dependencies not ready
	// Note: allBlastHoles is NOT required - KAD objects can be selected without holes
	if (!threeInitialized || !threeRenderer) {
		console.log("üö® [3D CLICK] Dependencies not ready", {
			threeInitialized: !!threeInitialized,
			threeRenderer: !!threeRenderer,
		});
		return;
	}

	// Step 12c.1) Handle KAD drawing tools AND hole creation tools in 3D mode
	// Check if any drawing tool or hole creation tool is active and forward to appropriate handler
	// BUG FIX 2025-12-28: Added all hole/pattern creation tools to enable in 3D
	const isAnyDrawingToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole || isAddingPattern || isPatternInPolygonActive || isHolesAlongLineActive || isHolesAlongPolyLineActive;
	if (isAnyDrawingToolActive) {
		console.log("‚¨áÔ∏è [3D CLICK] Drawing/creation tool active, forwarding to handler");

		// Step 12c.1a) Get world coordinates using 3D cylindrical snap
		let snapResult;

		// Calculate snap radius in world units based on camera view
		const snapRadiusPixels = window.snapRadiusPixels || 15; // 15 pixels on screen
		const snapRadiusWorld = getSnapRadiusInWorldUnits3D(snapRadiusPixels);

		// Step 12c.1a.0) Get drawing elevation Z value
		var clickWorldZ = parseFloat(drawingZValue) || parseFloat(document.getElementById("drawingElevation").value) || 0;

		// Step 12c.1a.1) Calculate world coordinates using plane intersection at drawing elevation
		// This works correctly regardless of camera angle
		var clickWorldX = currentMouseWorldX;
		var clickWorldY = currentMouseWorldY;

		if (interactionManager && threeRenderer) {
			// Update raycaster to click position
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Step 12c.1a.2) Intersect ray with horizontal plane at drawing elevation
			// Use getMouseWorldPositionOnPlane which handles all camera angles correctly
			var planeWorldPos = interactionManager.getMouseWorldPositionOnPlane(clickWorldZ);
			if (planeWorldPos && isFinite(planeWorldPos.x) && isFinite(planeWorldPos.y)) {
				clickWorldX = planeWorldPos.x;
				clickWorldY = planeWorldPos.y;
				console.log("‚¨áÔ∏è [3D CLICK] Plane intersection at Z=" + clickWorldZ + ": X=" + clickWorldX.toFixed(2) + ", Y=" + clickWorldY.toFixed(2));
			} else {
				console.warn("‚¨áÔ∏è [3D CLICK] Plane intersection failed, using currentMouseWorld");
			}
		}

		// Step 12c.1a.3) Try cylindrical snap to nearby points
		if (interactionManager && interactionManager.raycaster) {
			// Get ray from raycaster (already set above)
			const ray = interactionManager.raycaster.ray;

			// Calculate mouse screen coordinates for snap
			const rect = threeRenderer.getCanvas().getBoundingClientRect();
			const mouseScreenX = event.clientX - rect.left;
			const mouseScreenY = event.clientY - rect.top;

			snapResult = snapToNearestPointWithRay(ray.origin, ray.direction, snapRadiusPixels, mouseScreenX, mouseScreenY);
		} else {
			// Fallback to 2D snap (shouldn't happen in 3D mode, but safe fallback)
			snapResult = snapToNearestPoint(clickWorldX, clickWorldY, snapRadiusWorld);
		}

		// Use snap result if available, otherwise use plane intersection coordinates
		worldX = snapResult.snapped && snapResult.worldX !== undefined ? snapResult.worldX : clickWorldX;
		worldY = snapResult.snapped && snapResult.worldY !== undefined ? snapResult.worldY : clickWorldY;
		worldZ = snapResult.snapped && snapResult.worldZ !== undefined ? snapResult.worldZ : clickWorldZ;

		// Step 12c.1b) Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(function () {
				updateStatusMessage("");
			}, 1500);
		}

		// Step 12c.1c) Call appropriate KAD drawing function based on active tool
		if (isDrawingPoint) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Point at:", worldX, worldY, worldZ);
			}
			addKADPoint();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingLine) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Line point at:", worldX, worldY, worldZ);
			}
			addKADLine();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingPoly) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Polygon point at:", worldX, worldY, worldZ);
			}
			addKADPoly();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingCircle) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Circle at:", worldX, worldY, worldZ);
			}
			addKADCircle();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isDrawingText) {
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Adding KAD Text at:", worldX, worldY, worldZ);
			}
			addKADText();
			updateLastKADDrawPoint(worldX, worldY, worldZ);
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		} else if (isAddingHole) {
			// Step 12c.1c.1) Handle Add Hole tool in 3D mode (BUG FIX 2025-12-28, 2025-12-29)
			console.log("‚¨áÔ∏è [3D CLICK] Adding Hole at:", worldX, worldY, worldZ);
			// Set world coordinates for AddHoleDialog to access
			window.worldX = worldX;
			window.worldY = worldY;
			window.worldZ = worldZ;
			// Step 12c.1c.1a) Check if we're in multiple mode (have stored form data)
			// This matches the 2D behavior at line ~17954
			if (window.isAddingSingleHole && window.multipleAddHoleFormData) {
				// Multiple mode: Reuse stored form data, don't show dialog
				console.log("üìçüìç [3D] Multiple mode: Reusing stored form data");
				if (typeof window.addHoleMultipleMode === "function") {
					window.addHoleMultipleMode(worldX, worldY);
				} else {
					console.error("addHoleMultipleMode function not found");
					// Fallback to showing dialog
					if (typeof window.showAddHoleDialog === "function") {
						window.showAddHoleDialog();
					}
				}
			} else {
				// Single mode or first click: Show dialog
				if (typeof window.showAddHoleDialog === "function") {
					window.showAddHoleDialog();
				} else {
					console.error("showAddHoleDialog not found - ensure AddHoleDialog.js is loaded");
				}
			}
		} else if (isAddingPattern) {
			// Step 12c.1c.2) Handle Add Pattern tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Adding Pattern at:", worldX, worldY, worldZ);
			// Set world coordinates for pattern creation
			window.worldX = worldX;
			window.worldY = worldY;
			window.worldZ = worldZ;
			// Show the pattern dialog using showPatternDialog from PatternGenerationDialogs.js
			if (typeof window.showPatternDialog === "function") {
				window.showPatternDialog("add_pattern", worldX, worldY);
			} else {
				console.error("showPatternDialog not found - ensure PatternGenerationDialogs.js is loaded");
			}
		} else if (isPatternInPolygonActive) {
			// Step 12c.1c.3) Handle Pattern in Polygon tool in 3D mode
			console.log("‚¨áÔ∏è [3D CLICK] Pattern in Polygon click at:", worldX, worldY, worldZ);

			// Step 12c.1c.3a) For polygon selection (step 0), use 3D raycast to find KAD polygon
			if (patternPolygonStep === 0) {
				// Perform raycast to find KAD objects
				const threeCanvas = threeRenderer.getCanvas();
				if (!threeCanvas || !interactionManager) {
					console.warn("‚¨áÔ∏è [3D CLICK] Pattern tool: Missing threeCanvas or interactionManager");
					return;
				}
				interactionManager.updateMousePosition(event, threeCanvas);
				const intersects = interactionManager.raycast();

				let clickedKADObject = null;
				// Search intersects for KAD polygon objects
				for (const intersect of intersects) {
					let object = intersect.object;

					// Skip selection highlights
					let isHighlight = false;
					let checkObj = object;
					let depth = 0;
					while (checkObj && depth < 10) {
						if (checkObj.userData && checkObj.userData.type === "kadSelectionHighlight") {
							isHighlight = true;
							break;
						}
						checkObj = checkObj.parent;
						depth++;
					}
					if (isHighlight) continue;

					// Traverse up to find KAD polygon
					depth = 0;
					while (object && depth < 10) {
						if (object.userData && object.userData.kadId && object.userData.type === "kadPolygon") {
							const entity = allKADDrawingsMap.get(object.userData.kadId);
							if (entity && entity.entityType === "poly") {
								// Found polygon - create KAD object descriptor
								clickedKADObject = {
									entityName: object.userData.kadId,
									entity: entity,
									entityType: "poly"
								};
								break;
							}
						}
						object = object.parent;
						depth++;
					}
					if (clickedKADObject) break;
				}

				// If polygon found, set selection state
				if (clickedKADObject) {
					selectedPolygon = clickedKADObject.entity;
					// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
					selectedKADObject = clickedKADObject;
					window.selectedKADObject = clickedKADObject;
					patternPolygonStep = 1;
					updateStatusMessage("Step 2: Click to select pattern start point");

					// FIX: Ensure highlight is drawn by calling drawData and then explicitly calling highlight function
					drawData(allBlastHoles, selectedHole);
					// Explicitly trigger highlight after drawData to ensure it runs
					if (window.selectedKADObject && window.selectedKADObject.entityType === "poly") {
						highlightSelectedKADThreeJS();
					}
					event.preventDefault();
					event.stopPropagation();
					return;
				} else {
					updateStatusMessage("No polygon found.\nStep 1: Click on a polygon to select it");
					drawData(allBlastHoles, selectedHole);
					event.preventDefault();
					event.stopPropagation();
					return;
				}
			} else {
				// For steps 1-3 (point selection), use snapping same as 2D
				var rect = canvas.getBoundingClientRect();
				// Step 1) Apply snapping directly to world coords (no canvas conversion in 3D mode)
				var patternSnapResult = snapToNearestPoint(worldX, worldY);
				var snappedWorldX = patternSnapResult.worldX;
				var snappedWorldY = patternSnapResult.worldY;

				// Step 2) Show snap feedback if snapped (same as 2D)
				if (patternSnapResult.snapped) {
					updateStatusMessage("Snapped to " + patternSnapResult.snapTarget.description);
					setTimeout(() => updateStatusMessage(""), 1500);
				}

				// Step 3) Set snapped coordinates for handler
				window.worldX = snappedWorldX;
				window.worldY = snappedWorldY;
				window.worldZ = worldZ;

				// Step 4) Create synthetic event with canvas coordinates (handler will re-apply snap, but coordinates already snapped)
				var syntheticEvent = {
					clientX: rect.left + clickX,
					clientY: rect.top + clickY,
					preventDefault: function () { },
					stopPropagation: function () { }
				};
				if (typeof handlePatternInPolygonClick === "function") {
					handlePatternInPolygonClick(syntheticEvent);
				}
			}
		} else if (isHolesAlongLineActive) {
			// Step 12c.1c.4) Handle Holes Along Line tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Holes Along Line click at:", worldX, worldY, worldZ);
			// Use snapping directly to world coords
			var rect = canvas.getBoundingClientRect();

			// Step 1) Apply snapping directly to world coords (no canvas conversion in 3D mode)
			const snapResult = snapToNearestPoint(worldX, worldY);
			var snappedWorldX = snapResult.worldX;
			var snappedWorldY = snapResult.worldY;

			// Convert snapped world coords to canvas for synthetic event
			var canvasCoords = worldToCanvas(snappedWorldX, snappedWorldY);
			var clickX = canvasCoords[0];
			var clickY = canvasCoords[1];

			// Step 2) Show snap feedback if snapped (same as 2D)
			if (snapResult.snapped) {
				updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
				setTimeout(() => updateStatusMessage(""), 1500);
			}

			// Step 3) Set snapped coordinates for handler
			window.worldX = snappedWorldX;
			window.worldY = snappedWorldY;
			window.worldZ = worldZ;

			// Step 4) Create synthetic event with canvas coordinates for the 2D handler
			var syntheticEvent = {
				clientX: rect.left + clickX,
				clientY: rect.top + clickY,
				preventDefault: function () { },
				stopPropagation: function () { }
			};
			// Call the existing handler
			if (typeof handleHolesAlongLineClick === "function") {
				handleHolesAlongLineClick(syntheticEvent);
			}
		} else if (isHolesAlongPolyLineActive) {
			// Step 12c.1c.5) Handle Holes Along Polyline tool in 3D mode (BUG FIX 2025-12-28)
			console.log("‚¨áÔ∏è [3D CLICK] Holes Along Polyline click at:", worldX, worldY, worldZ);
			// Use snapping directly to world coords
			var rect = canvas.getBoundingClientRect();

			// Step 1) Apply snapping directly to world coords (no canvas conversion in 3D mode)
			const snapResult = snapToNearestPoint(worldX, worldY);
			var snappedWorldX = snapResult.worldX;
			var snappedWorldY = snapResult.worldY;

			// Convert snapped world coords to canvas for synthetic event
			var canvasCoords = worldToCanvas(snappedWorldX, snappedWorldY);
			var clickX = canvasCoords[0];
			var clickY = canvasCoords[1];

			// Step 2) Show snap feedback if snapped (same as 2D)
			if (snapResult.snapped) {
				updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
				setTimeout(() => updateStatusMessage(""), 1500);
			}

			// Step 3) Set snapped coordinates for handler
			window.worldX = snappedWorldX;
			window.worldY = snappedWorldY;
			window.worldZ = worldZ;

			// Step 4) Create synthetic event with canvas coordinates for the 2D handler
			var syntheticEvent = {
				clientX: rect.left + clickX,
				clientY: rect.top + clickY,
				preventDefault: function () { },
				stopPropagation: function () { }
			};
			// Call the existing handler
			if (typeof handleHolesAlongPolyLineClick === "function") {
				handleHolesAlongPolyLineClick(syntheticEvent);
			}
		}

		// Step 12c.1d) Prevent default and stop propagation
		event.preventDefault();
		event.stopPropagation();

		// Step 12c.1e) Redraw to show new KAD object
		drawData(allBlastHoles, selectedHole);
		return; // Don't process as selection click
	}

	// Step 12c.2) Handle Ruler tool in 3D mode
	if (isRulerActive) {
		console.log("üìè [3D CLICK] Ruler tool active, handling 3D ruler click");

		// Step 12c.2a) Get world coordinates from click using plane intersection
		var rulerClickX = currentMouseWorldX;
		var rulerClickY = currentMouseWorldY;
		var rulerClickZ = currentMouseWorldZ || window.dataCentroidZ || 0;

		// Step 12c.2b) Calculate coordinates using plane intersection (works at any camera angle)
		if (interactionManager && threeRenderer) {
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Intersect with horizontal plane at data centroid Z
			var rulerPlanePos = interactionManager.getMouseWorldPositionOnPlane(rulerClickZ);
			if (rulerPlanePos && isFinite(rulerPlanePos.x) && isFinite(rulerPlanePos.y)) {
				rulerClickX = rulerPlanePos.x;
				rulerClickY = rulerPlanePos.y;
			}
		}

		// Step 12c.2c) Apply 3D snap if available
		if (interactionManager && interactionManager.raycaster) {
			const rulerSnapRadiusPixels = window.snapRadiusPixels || 15;

			// Calculate mouse screen coordinates for snap
			const rect = threeRenderer.getCanvas().getBoundingClientRect();
			const mouseScreenX = event.clientX - rect.left;
			const mouseScreenY = event.clientY - rect.top;

			var rulerSnapResult = snapToNearestPointWithRay(interactionManager.raycaster.ray.origin, interactionManager.raycaster.ray.direction, rulerSnapRadiusPixels, mouseScreenX, mouseScreenY);
			if (rulerSnapResult.snapped) {
				rulerClickX = rulerSnapResult.worldX;
				rulerClickY = rulerSnapResult.worldY;
				rulerClickZ = rulerSnapResult.worldZ || rulerClickZ;
				updateStatusMessage("Snapped to " + rulerSnapResult.snapTarget.description);
				setTimeout(function () { updateStatusMessage(""); }, 1500);
			}
		}

		// Step 12c.2d) Handle ruler click logic (same as 2D)
		if (!rulerStartPoint) {
			rulerStartPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
			rulerEndPoint = null;
		} else if (!rulerEndPoint) {
			rulerEndPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
		} else {
			rulerStartPoint = { x: rulerClickX, y: rulerClickY, z: rulerClickZ };
			rulerEndPoint = null;
		}

		event.preventDefault();
		event.stopPropagation();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Step 12c.3) Handle Protractor tool in 3D mode
	if (isRulerProtractorActive) {
		console.log("üìê [3D CLICK] Protractor tool active, handling 3D protractor click");

		// Step 12c.3a) Get world coordinates from click using plane intersection
		var protClickX = currentMouseWorldX;
		var protClickY = currentMouseWorldY;
		var protClickZ = currentMouseWorldZ || window.dataCentroidZ || 0;

		// Step 12c.3b) Calculate coordinates using plane intersection (works at any camera angle)
		if (interactionManager && threeRenderer) {
			interactionManager.updateMousePosition(event, threeRenderer.getCanvas());
			interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);

			// Intersect with horizontal plane at data centroid Z
			var protPlanePos = interactionManager.getMouseWorldPositionOnPlane(protClickZ);
			if (protPlanePos && isFinite(protPlanePos.x) && isFinite(protPlanePos.y)) {
				protClickX = protPlanePos.x;
				protClickY = protPlanePos.y;
			}
		}

		// Step 12c.3c) Apply 3D snap if available
		if (interactionManager && interactionManager.raycaster) {
			const protSnapRadiusPixels = window.snapRadiusPixels || 15;

			// Calculate mouse screen coordinates for snap
			const rect = threeRenderer.getCanvas().getBoundingClientRect();
			const mouseScreenX = event.clientX - rect.left;
			const mouseScreenY = event.clientY - rect.top;

			var protSnapResult = snapToNearestPointWithRay(interactionManager.raycaster.ray.origin, interactionManager.raycaster.ray.direction, protSnapRadiusPixels, mouseScreenX, mouseScreenY);
			if (protSnapResult.snapped) {
				protClickX = protSnapResult.worldX;
				protClickY = protSnapResult.worldY;
				protClickZ = protSnapResult.worldZ || protClickZ;
				updateStatusMessage("Snapped to " + protSnapResult.snapTarget.description);
				setTimeout(function () { updateStatusMessage(""); }, 1500);
			}
		}

		// Step 12c.3d) Handle protractor click logic (same as 2D)
		rulerProtractorPoints.push({ x: protClickX, y: protClickY, z: protClickZ });
		if (rulerProtractorPoints.length > 3) {
			rulerProtractorPoints = [{ x: protClickX, y: protClickY, z: protClickZ }];
		}

		event.preventDefault();
		event.stopPropagation();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Step 12d) Get 3D canvas for coordinate conversion
	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] No 3D canvas found");
		}
		return;
	}

	// Step 12e) Update mouse position in interaction manager and perform raycast
	// Use interactionManager which has the proper logic for finding holes
	if (!interactionManager) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] interactionManager not available");
		}
		return;
	}

	interactionManager.updateMousePosition(event, threeCanvas);

	// Step 12f) Perform raycast
	const intersects = interactionManager.raycast();

	if (developerModeEnabled) {
		console.log("üîç [3D CLICK] Raycast results:", {
			intersectsCount: intersects.length,
			firstIntersect:
				intersects.length > 0
					? {
						object: intersects[0].object.type,
						userData: intersects[0].object.userData,
						distance: intersects[0].distance.toFixed(2),
					}
					: null,
		});
	}

	// Step 12g) Find clicked hole from intersects using interactionManager's method
	// This has proper logic for traversing parent chains and finding the correct hole
	// But let's also log what we're checking to debug why it always finds hole 1
	if (developerModeEnabled) {
		console.log("üîç [3D CLICK] Checking", intersects.length, "intersections for holes...");
	}
	for (let i = 0; i < Math.min(intersects.length, 5); i++) {
		const intersect = intersects[i];
		let object = intersect.object;
		let userData = object.userData;
		let depth = 0;

		// Traverse up to find userData
		while (object && (!userData || !userData.holeId)) {
			object = object.parent;
			if (object) {
				userData = object.userData;
				depth++;
				if (depth > 5) break;
			} else {
				break;
			}
		}
	}

	// Step 12h.5) Check radio button selection mode (Holes vs KAD) - matching 2D behavior
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	// Step 12h.5a) Only allow selection if SelectPointer tool, Move tool, or connector tool is active
	// Fixes QUIRK 2: Prevent selection when no tool is active
	const isConnectorToolActive = isAddingConnector || isAddingMultiConnector;
	if (!isSelectionPointerActive && !isConnectorToolActive && !isMultiHoleSelectionEnabled && !isMoveToolActive) {
		if (developerModeEnabled) {
			console.log("üö´ [3D CLICK] Select Pointer tool not active - skipping selection");
		}
		return;
	}

	const clickedHole = selectingHoles ? interactionManager.findClickedHole(intersects, allBlastHoles || []) : null;

	if (clickedHole) {
		if (developerModeEnabled) {
			console.log("üîç [3D CLICK] Found hole:", clickedHole.holeID, "in", clickedHole.entityName);
		}
	} else if (selectingHoles) {
		if (developerModeEnabled) {
			console.log("üö® [3D CLICK] No hole found in intersections");
		}
	}

	// Step 12i) Handle selection based on current tool mode
	if (clickedHole && selectingHoles) {
		if (developerModeEnabled) {
			console.log("‚¨áÔ∏è [3D CLICK] Processing selection for hole:", clickedHole.holeID);
		}
		console.log("üîç [3D CLICK] Current tool state:", {
			isAddingConnector,
			isAddingMultiConnector,
			isMultiHoleSelectionEnabled,
			selectedHoleBefore: selectedHole ? selectedHole.holeID : null,
			selectedMultipleHolesBefore: selectedMultipleHoles.length,
		});

		// Prevent camera controls from handling this event
		event.stopPropagation();
		event.preventDefault();

		if (isAddingConnector) {
			// Step 12i.1) Single connector tool logic in 3D (matching 2D handleConnectorClick)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Single connector tool mode");
			}
			if (!fromHoleStore) {
				// Step 12i.1a) First hole selection
				fromHoleStore = clickedHole;
				firstSelectedHole = clickedHole;
				selectedHole = clickedHole;
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set first connector hole:", clickedHole.holeID);
				}
				// Step 12i.1a.1) Immediately render to show green highlight
				drawData(allBlastHoles, selectedHole);
				//renderThreeJS();
			} else {
				// Step 12i.1b) Second hole selection - create connector
				selectedHole = clickedHole; // Set selected hole to second hole for yellow highlight
				secondSelectedHole = clickedHole; // IMPORTANT: Set this for highlighting
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set second connector hole:", clickedHole.holeID);
				}

				// Step 12i.1c) Get delay and color values
				const delay = getDelayValue();
				const color = getJSColorHex();

				// Step 12i.1d) Find clicked hole in allBlastHoles array
				const clickedHoleIndex = allBlastHoles.findIndex((h) => h === clickedHole);

				if (clickedHoleIndex !== -1) {
					// Step 12i.1e) Set connector data (matching 2D format)
					allBlastHoles[clickedHoleIndex].fromHoleID = fromHoleStore.entityName + ":::" + fromHoleStore.holeID;
					allBlastHoles[clickedHoleIndex].timingDelayMilliseconds = delay;
					allBlastHoles[clickedHoleIndex].colorHexDecimal = color;
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Created connector:", fromHoleStore.holeID, "?", clickedHole.holeID, "delay:", delay, "color:", color);
					}
				}

				// Step 12i.1f) Reset connector state - green disappears, only yellow persists from selectedHole
				fromHoleStore = null;
				firstSelectedHole = null;
				// NOTE: secondSelectedHole and selectedHole remain set to show yellow highlight

				// Step 12i.1g) Recalculate timing and contours
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step 12i.1g.1) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Step 12i.1g.2) Save connector changes to IndexedDB
				debouncedSaveHoles();

				// Step 12i.1h) Update time chart
				timeChart();

				// Step 12i.1i) Trigger 3D rebuild to show new connector
				window.threeDataNeedsRebuild = true;
				// Step 12i.1j) Draw - only yellow highlight visible now
				drawData(allBlastHoles, selectedHole);
			}
		} else if (isAddingMultiConnector) {
			// Step 12i.2) Multi-connector tool logic in 3D (matching 2D handleConnectorClick)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Multi-connector tool mode");
			}
			if (!fromHoleStore) {
				// Step 12i.2a) First hole selection - clear previous yellow highlight
				secondSelectedHole = null; // Clear old yellow
				fromHoleStore = clickedHole;
				firstSelectedHole = clickedHole;
				selectedHole = clickedHole;
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set first multi-connector hole:", clickedHole.holeID);
				}

				// Step 12i.2a.1) Ensure globals are exposed and trigger redraw
				exposeGlobalsToWindow();
				drawData(allBlastHoles, selectedHole);
			} else {
				// Step 12i.2b) Second hole selection - create connectors
				selectedHole = clickedHole; // Set selected hole to second hole for yellow highlight
				secondSelectedHole = clickedHole; // IMPORTANT: Set this for highlighting
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Set second multi-connector hole:", clickedHole.holeID);
				}

				// Step 12i.2c) Get all holes in stadium zone (line with tolerance)
				const pointsInLine = getPointsInLine(fromHoleStore, clickedHole);

				if (pointsInLine.length > 0) {
					// Step 12i.2d) Connect all holes in sequence
					connectHolesInLine(pointsInLine);
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Connected " + pointsInLine.length + " holes in line");
					}
				}

				// Step 12i.2e) Reset connector state - green disappears, only yellow persists from selectedHole
				// Step 12i.2e) Reset connector state - green disappears, only yellow persists from selectedHole
				fromHoleStore = null;
				firstSelectedHole = null;
				// NOTE: secondSelectedHole and selectedHole remain set to show yellow highlight

				// Step 12i.2f) Recalculate timing and contours
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step 12i.2f.1) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Step 12i.2f.2) Save multi-connector changes to IndexedDB
				debouncedSaveHoles();

				// Step 12i.2g) Update time chart
				timeChart();

				// Step 12i.2h) Trigger 3D rebuild to show new connectors
				window.threeDataNeedsRebuild = true;
				// Step 12i.2i) Draw - only yellow highlight visible now
				drawData(allBlastHoles, selectedHole);
			}
		} else if (isMultiHoleSelectionEnabled) {
			// Multi-selection mode
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Multi-selection mode");
			}
			const index = selectedMultipleHoles.findIndex((h) => h.entityName === clickedHole.entityName && h.holeID === clickedHole.holeID);
			if (index >= 0) {
				selectedMultipleHoles.splice(index, 1);
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Removed from multi-selection. New count:", selectedMultipleHoles.length);
				}
			} else {
				selectedMultipleHoles.push(clickedHole);
				if (developerModeEnabled) {
					console.log(
						"‚¨áÔ∏è [3D CLICK] Added to multi-selection. New count:",
						selectedMultipleHoles.length,
						"Holes:",
						selectedMultipleHoles.map((h) => h.holeID)
					);
				}
			}
			selectedHole = null; // Clear single selection
		} else {
			// Single selection mode (SelectionPointer tool)
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Single selection mode (SelectionPointer)");
			}
			const previousSelectedHole = selectedHole ? selectedHole.holeID : null;
			selectedHole = clickedHole;
			selectedMultipleHoles = [];
			// Step 12i.3a) Clear KAD selections when hole is selected (matching 2D behavior)
			selectedKADObject = null;
			selectedKADPolygon = null;
			selectedMultipleKADObjects = [];
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] SELECTED HOLE:", {
					previous: previousSelectedHole,
					current: selectedHole.holeID,
					entityName: selectedHole.entityName,
					selectedHoleObject: selectedHole,
				});
			}
		}

		// Redraw to show selection (ONLY for non-connector modes)
		// Connector modes handle their own drawData calls with proper timing
		if (!isAddingConnector && !isAddingMultiConnector) {
			console.log("‚¨áÔ∏è [3D CLICK] Calling drawData with selectedHole:", selectedHole ? selectedHole.holeID : null);
			drawData(allBlastHoles, selectedHole);
			syncCanvasToTreeView(); // Sync selection to TreeView
		}
	} else {
		if (developerModeEnabled) {
			// Step 12j) No hole clicked - check for KAD objects in 3D
			console.log("‚¨áÔ∏è [3D CLICK] No hole found, checking for KAD objects...");
			console.log("‚¨áÔ∏è [3D CLICK] Total intersects:", intersects.length);
			console.log("‚¨áÔ∏è [3D CLICK] Selection pointer active?", isSelectionPointerActive);
			console.log("‚¨áÔ∏è [3D CLICK] KAD entities in map:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
		}
		if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
			const entityTypes = [];
			allKADDrawingsMap.forEach((entity, name) => {
				entityTypes.push(name + " (" + entity.entityType + ")");
			});
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Entity list:", entityTypes.join(", "));
			}
		}

		// Step 12j.0) Debug: Log all intersect types
		intersects.forEach((intersect, index) => {
			let obj = intersect.object;
			let types = [];
			let depth = 0;
			while (obj && depth < 5) {
				if (obj.userData && obj.userData.type) {
					types.push(obj.userData.type);
				}
				obj = obj.parent;
				depth++;
			}
			if (developerModeEnabled) {
				console.log("  Intersect " + index + ":", intersect.object.type, "types in chain:", types.join(" -> "));
			}
		});

		// Step 12j.1) Check if selection pointer is active and KAD radio is selected
		if (isSelectionPointerActive && selectingKAD) {
			let clickedKADObject = null;

			// Step 12j.2) Search intersects for KAD objects (they have userData.kadId)
			// Skip selection highlights and look for actual KAD geometry
			for (const intersect of intersects) {
				let object = intersect.object;

				// Step 12j.3) Skip if this intersect is a selection highlight
				// Check immediate object and parents
				let isHighlight = false;
				let checkObj = object;
				let depth = 0;
				while (checkObj && depth < 10) {
					if (checkObj.userData && checkObj.userData.type === "kadSelectionHighlight") {
						isHighlight = true;
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Skipping selection highlight at depth", depth);
						}
						break;
					}
					checkObj = checkObj.parent;
					depth++;
				}

				// Step 12j.4) If this was a highlight, skip to next intersect
				if (isHighlight) {
					continue;
				}

				// Step 12j.5) Now traverse up to find actual KAD object
				depth = 0;
				while (object && depth < 10) {
					// Step 12j.5a) Check for actual KAD objects (kadPoint, kadLine, kadPolygon, kadCircle, kadText)
					if (object.userData && object.userData.kadId && object.userData.type && (object.userData.type === "kadPoint" || object.userData.type === "kadLine" || object.userData.type === "kadPolygon" || object.userData.type === "kadCircle" || object.userData.type === "kadText")) {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Found KAD object:", object.userData.kadId, "type:", object.userData.type);
						}

						// Step 12j.4) Get the KAD entity from the map
						const entity = allKADDrawingsMap.get(object.userData.kadId);
						if (entity) {
							// Step 12j.5) Find which specific element was clicked
							// Use intersection point to determine closest element
							let closestElementIndex = 0;
							let minDistance = Infinity;

							if (entity.data && entity.data.length > 1 && intersect.point) {
								// Convert intersection point from local to world coordinates
								const intersectWorldX = intersect.point.x + (window.threeLocalOriginX || 0);
								const intersectWorldY = intersect.point.y + (window.threeLocalOriginY || 0);

								// Find closest element by distance
								entity.data.forEach((element, index) => {
									const elemX = element.pointXLocation || element.centerX;
									const elemY = element.pointYLocation || element.centerY;
									const dx = elemX - intersectWorldX;
									const dy = elemY - intersectWorldY;
									const distance = Math.sqrt(dx * dx + dy * dy);

									if (distance < minDistance) {
										minDistance = distance;
										closestElementIndex = index;
									}
								});

								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Found closest element:", closestElementIndex, "at distance:", minDistance.toFixed(2) + "m");
								}
							}

							// Step 12j.6) Create KAD object descriptor (similar to 2D getClickedKADObject)
							// Step 12j.6a) Determine selectionType based on entity type and distance to vertex
							// Points are always "vertex", lines/polys are "vertex" if close enough, else "segment"
							var selectionType = "entity";
							var vertexSnapDistance = 5; // meters - threshold for vertex vs segment selection

							if (entity.entityType === "point") {
								selectionType = "vertex"; // Points are always vertex selection
							} else if ((entity.entityType === "line" || entity.entityType === "poly") && minDistance < vertexSnapDistance) {
								selectionType = "vertex"; // Close to a vertex
							} else if (entity.entityType === "line" || entity.entityType === "poly") {
								selectionType = "segment"; // On a segment between vertices
							}

							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] selectionType:", selectionType, "(minDistance:", minDistance.toFixed(2) + "m, threshold:", vertexSnapDistance + "m)");
							}

							clickedKADObject = {
								entityName: object.userData.kadId,
								entityType: entity.entityType,
								elementIndex: closestElementIndex, // Use calculated closest element
								selectionType: selectionType, // vertex, segment, or entity based on distance
							};

							// Step 12j.7) Add type-specific properties from the clicked element
							if (entity.data && entity.data[closestElementIndex]) {
								const clickedElement = entity.data[closestElementIndex];
								if (entity.entityType === "circle") {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation || clickedElement.centerX;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation || clickedElement.centerY;
									clickedKADObject.radius = clickedElement.radius;
								} else if (entity.entityType === "text") {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation;
									clickedKADObject.text = clickedElement.text;
								} else {
									clickedKADObject.pointXLocation = clickedElement.pointXLocation;
									clickedKADObject.pointYLocation = clickedElement.pointYLocation;
								}
							}
							break;
						}
					}
					object = object.parent;
					depth++;
				}

				if (clickedKADObject) break;
			}

			// Step 12j.6.5) If no raycast hit, try screen-space distance-based selection (fallback)
			if (!clickedKADObject && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] No raycast hit, trying screen-space distance selection...");
				}

				// Step 12j.6.5a) Get camera and canvas for screen-space projection
				const camera = threeRenderer.camera;
				const canvas = threeRenderer.getCanvas();
				if (!camera || !canvas) {
					if (developerModeEnabled) {
						console.log("üì∑ [3D CLICK] Missing camera or canvas for screen-space selection");
					}
				} else {
					// Step 12j.6.5b) Get mouse position in screen pixels
					const rect = canvas.getBoundingClientRect();
					const mouseScreenX = event.clientX - rect.left;
					const mouseScreenY = event.clientY - rect.top;
					const canvasWidth = rect.width;
					const canvasHeight = rect.height;

					// Step 12j.6.5c) Snap tolerance in pixels (use snapRadiusPixels directly)
					const snapTolerancePixels = snapRadiusPixels || 20;
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Mouse at (" + mouseScreenX.toFixed(0) + "px, " + mouseScreenY.toFixed(0) + "px), tolerance: " + snapTolerancePixels + "px");
					}
					// Step 12j.6.5d) Helper function to project 3D world position to 2D screen pixels
					const worldToScreen = function (worldX, worldY, worldZ) {
						// Step 12j.6.5d.1) Convert world to Three.js local coordinates
						const local = worldToThreeLocal(worldX, worldY);

						// Step 12j.6.5d.2) Create vector and project to normalized device coordinates
						const vector = new THREE.Vector3(local.x, local.y, worldZ);
						vector.project(camera);

						// Step 12j.6.5d.3) Convert NDC (-1 to +1) to screen pixels (0 to width/height)
						const screenX = ((vector.x + 1) * canvasWidth) / 2;
						const screenY = ((-vector.y + 1) * canvasHeight) / 2; // Invert Y for screen coordinates

						return { x: screenX, y: screenY };
					};

					// Step 12j.6.5e) Helper function to calculate distance from point to line segment in 2D screen space
					const screenPointToSegmentDistance = function (px, py, x1, y1, x2, y2) {
						const A = px - x1;
						const B = py - y1;
						const C = x2 - x1;
						const D = y2 - y1;
						const dot = A * C + B * D;
						const lenSq = C * C + D * D;

						if (lenSq === 0) {
							return Math.sqrt(A * A + B * B);
						}

						let t = dot / lenSq;
						t = Math.max(0, Math.min(1, t));

						const projX = x1 + t * C;
						const projY = y1 + t * D;
						const dx = px - projX;
						const dy = py - projY;

						return Math.sqrt(dx * dx + dy * dy);
					};

					// Step 12j.6.5f) Search all KAD entities for closest one within tolerance
					let closestEntity = null;
					let closestEntityName = null;
					let closestDistance = Infinity;
					let closestElementIndex = 0;

					allKADDrawingsMap.forEach((entity, entityName) => {
						if (!entity.data || entity.data.length === 0) return;

						// Step 12j.6.5g) Calculate screen-space distance based on entity type
						if (entity.entityType === "point") {
							// Step 12j.6.5g.1) Points: screen distance to each point
							entity.data.forEach((point, index) => {
								const screenPos = worldToScreen(point.pointXLocation, point.pointYLocation, point.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
								}
							});
						} else if (entity.entityType === "line" || entity.entityType === "poly") {
							// Step 12j.6.5g.2) Lines/Polys: screen distance to closest segment
							const points = entity.data;
							if (points.length >= 2) {
								const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D LINE SELECT] Checking " + entity.entityType + " '" + entity.entityName + "' with " + numSegments + " segments");
								}

								// Step 12j.6.5g.2a) Store segment info for proper highlighting
								let closestSegmentIndex = 0;
								let closestSegmentDistance = Infinity;

								for (let i = 0; i < numSegments; i++) {
									const p1 = points[i];
									const p2 = points[(i + 1) % points.length];

									// Project both endpoints to screen space
									const screen1 = worldToScreen(p1.pointXLocation, p1.pointYLocation, p1.pointZLocation || dataCentroidZ || 0);
									const screen2 = worldToScreen(p2.pointXLocation, p2.pointYLocation, p2.pointZLocation || dataCentroidZ || 0);

									// Calculate screen-space distance to segment
									const segmentDist = screenPointToSegmentDistance(mouseScreenX, mouseScreenY, screen1.x, screen1.y, screen2.x, screen2.y);

									if (developerModeEnabled) {
										console.log("  Segment " + i + ": p1=(" + screen1.x.toFixed(0) + "," + screen1.y.toFixed(0) + ") p2=(" + screen2.x.toFixed(0) + "," + screen2.y.toFixed(0) + ") dist=" + segmentDist.toFixed(1) + "px");
									}

									if (segmentDist < closestSegmentDistance) {
										closestSegmentDistance = segmentDist;
										closestSegmentIndex = i;
									}
								}

								// Step 12j.6.5g.2b) If closest segment is within tolerance, update closestEntity
								if (closestSegmentDistance < closestDistance) {
									closestDistance = closestSegmentDistance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = closestSegmentIndex; // Which segment was clicked
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D LINE SELECT] Closest segment:", closestSegmentIndex, "at distance:", closestSegmentDistance.toFixed(2) + "px");
									}
								}
							}
						} else if (entity.entityType === "circle") {
							// Step 12j.6.5g.3) Circles: screen distance to circle outline (approximate - use center for now)
							entity.data.forEach((circle, index) => {
								const centerX = circle.pointXLocation || circle.centerX;
								const centerY = circle.pointYLocation || circle.centerY;
								const centerZ = circle.pointZLocation || dataCentroidZ || 0;

								const screenCenter = worldToScreen(centerX, centerY, centerZ);
								const dx = screenCenter.x - mouseScreenX;
								const dy = screenCenter.y - mouseScreenY;
								const distToCenter = Math.sqrt(dx * dx + dy * dy);

								// Approximate: just use distance to center (could improve by projecting radius)
								const distance = distToCenter;

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D CIRCLE SELECT] Closest circle:", closestElementIndex, "at distance:", closestDistance.toFixed(2) + "px");
									}
								}
							});
						} else if (entity.entityType === "text") {
							// Step 12j.6.5g.4) Text: screen distance to text anchor point
							entity.data.forEach((text, index) => {
								const screenPos = worldToScreen(text.pointXLocation, text.pointYLocation, text.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestDistance) {
									closestDistance = distance;
									closestEntity = entity;
									closestEntityName = entityName;
									closestElementIndex = index;
									if (developerModeEnabled) {
										console.log("‚¨áÔ∏è [3D TEXT SELECT] Closest text:", closestElementIndex, "at distance:", closestDistance.toFixed(2) + "px");
									}
								}
							});
						}
					});

					// Step 12j.6.5h) Check if closest entity is within tolerance
					if (closestEntity && closestDistance <= snapTolerancePixels) {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Found entity by screen distance:", closestEntityName, "type:", closestEntity.entityType, "distance:", closestDistance.toFixed(1) + "px");
						}

						// Step 12j.6.5h.1) For lines/polys, check if we're closer to a vertex than the segment
						let closestVertexDistance = Infinity;
						let closestVertexIndex = -1;
						if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
							// Check each vertex to see if mouse is closer to it than to the segment
							closestEntity.data.forEach(function (point, index) {
								const screenPos = worldToScreen(point.pointXLocation, point.pointYLocation, point.pointZLocation || dataCentroidZ || 0);
								const dx = screenPos.x - mouseScreenX;
								const dy = screenPos.y - mouseScreenY;
								const distance = Math.sqrt(dx * dx + dy * dy);

								if (distance < closestVertexDistance) {
									closestVertexDistance = distance;
									closestVertexIndex = index;
								}
							});
						}

						// Step 12j.6.5i) Determine selection type (match 2D behavior)
						let selectionType = "entity";
						if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
							// Step 12j.6.5i.1) If vertex is significantly closer than segment, use vertex selection
							if (closestVertexDistance < closestDistance && closestVertexDistance <= snapTolerancePixels) {
								selectionType = "vertex";
								closestElementIndex = closestVertexIndex; // Update to use vertex index
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Vertex selection - closest vertex at distance:", closestVertexDistance.toFixed(1) + "px");
								}
							} else {
								selectionType = "segment"; // Lines/polys use segment selection
								if (developerModeEnabled) {
									console.log("‚¨áÔ∏è [3D CLICK] Segment selection - distance:", closestDistance.toFixed(1) + "px");
								}
							}
						} else if (closestEntity.entityType === "point") {
							selectionType = "point";
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Point selection - distance:", closestDistance.toFixed(1) + "px");
							}
						}

						// Step 12j.6.5j) Create KAD object descriptor (match 2D structure)
						clickedKADObject = {
							entityName: closestEntityName,
							entityType: closestEntity.entityType,
							elementIndex: closestElementIndex,
							segmentIndex: closestElementIndex, // For lines/polys, this is the clicked segment
							selectionType: selectionType,
						};

						// Step 12j.6.5k) Add type-specific properties
						if (closestEntity.data && closestEntity.data[closestElementIndex]) {
							const clickedElement = closestEntity.data[closestElementIndex];
							if (closestEntity.entityType === "circle") {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation || clickedElement.centerX;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation || clickedElement.centerY;
								clickedKADObject.radius = clickedElement.radius;
							} else if (closestEntity.entityType === "text") {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
								clickedKADObject.text = clickedElement.text;
							} else if (closestEntity.entityType === "line" || closestEntity.entityType === "poly") {
								// For lines/polys, use first point of segment as base
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
							} else {
								clickedKADObject.pointXLocation = clickedElement.pointXLocation;
								clickedKADObject.pointYLocation = clickedElement.pointYLocation;
							}
						}
					} else {
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Closest entity at " + closestDistance.toFixed(1) + "px (outside tolerance " + snapTolerancePixels + "px)");
						}
					}
				}
			}

			// Step 12j.7) Handle KAD object selection (matching 2D handleSelection logic)
			if (clickedKADObject) {
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Processing KAD selection:", clickedKADObject.entityName);
				}

				// Step 12j.8) Check for Shift key (multiple selection)
				const isShiftPressed = event.shiftKey;

				if (isShiftPressed) {
					// Step 12j.9) Multiple selection mode
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Multiple KAD selection mode (Shift pressed)");
					}
					const existingIndex = selectedMultipleKADObjects.findIndex((obj) => {
						return obj.entityName === clickedKADObject.entityName && obj.entityType === clickedKADObject.entityType;
					});

					if (existingIndex === -1) {
						// Add to multiple selection
						selectedMultipleKADObjects.push(clickedKADObject);
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Added to selection, total:", selectedMultipleKADObjects.length);
						}
					} else {
						// Remove from multiple selection
						selectedMultipleKADObjects.splice(existingIndex, 1);
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Removed from selection, total:", selectedMultipleKADObjects.length);
						}
					}

					// Clear single selection
					selectedKADObject = null;
					selectedKADPolygon = null;
					selectedPoint = null; // Clear selectedPoint in multi-selection mode
				} else {
					// Step 12j.10) Single selection mode
					if (developerModeEnabled) {
						console.log("‚¨áÔ∏è [3D CLICK] Single KAD selection mode");
					}
					selectedKADObject = clickedKADObject;
					selectedKADPolygon = clickedKADObject; // Backward compatibility
					selectedMultipleKADObjects = [];

					// Step 12j.10a) Set selectedPoint - for segments, highlight the endpoint that will be deleted
					if (clickedKADObject.selectionType === "vertex") {
						const entity = allKADDrawingsMap.get(clickedKADObject.entityName);
						if (entity && entity.data && entity.data[clickedKADObject.elementIndex]) {
							selectedPoint = entity.data[clickedKADObject.elementIndex];
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Set selectedPoint:", selectedPoint.pointID);
							}
						}
					} else if (clickedKADObject.selectionType === "segment" && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
						const entity = allKADDrawingsMap.get(clickedKADObject.entityName);
						if (entity && entity.data) {
							const isPoly = clickedKADObject.entityType === "poly";
							const numPoints = entity.data.length;
							const endpointIndex = isPoly ? (clickedKADObject.elementIndex + 1) % numPoints : clickedKADObject.elementIndex + 1;
							selectedPoint = entity.data[endpointIndex];
							if (developerModeEnabled) {
								console.log("‚¨áÔ∏è [3D CLICK] Set selectedPoint for segment endpoint:", selectedPoint.pointID);
							}
						}
					} else {
						selectedPoint = null;
						if (developerModeEnabled) {
							console.log("‚¨áÔ∏è [3D CLICK] Cleared selectedPoint (entity selection)");
						}
					}
				}

				// Step 12j.11) Clear hole selections
				selectedHole = null;
				selectedMultipleHoles = [];

				// Step 12j.12) Expose globals and redraw
				exposeGlobalsToWindow();
				drawData(allBlastHoles || [], selectedHole);
				syncCanvasToTreeView(); // Sync KAD selection to TreeView

				// Prevent camera controls from handling this event
				event.stopPropagation();
				event.preventDefault();
			} else {
				// Step 12j.13) No KAD object clicked - clear KAD selections only if KAD radio is selected
				if (developerModeEnabled) {
					console.log("‚¨áÔ∏è [3D CLICK] Clicked on empty space - clearing selections");
				}
				if (!isAddingConnector && !isAddingMultiConnector) {
					const previousSelectedHole = selectedHole ? selectedHole.holeID : null;
					const previousMultiCount = selectedMultipleHoles.length;
					const previousKADCount = selectedMultipleKADObjects.length;

					// Step 12j.13a) Clear selections based on radio button state (matching 2D behavior)
					if (selectingKAD) {
						selectedKADObject = null;
						selectedKADPolygon = null;
						selectedMultipleKADObjects = [];
					}
					if (selectingHoles && !isMultiHoleSelectionEnabled) {
						selectedHole = null;
						selectedMultipleHoles = [];
					}
					if (developerModeEnabled) {
						console.log("üßπ [3D CLICK] Cleared selections:", {
							selectingHoles,
							selectingKAD,
							previousSelectedHole,
							previousMultiCount,
							previousKADCount,
						});
					}

					exposeGlobalsToWindow();
					drawData(allBlastHoles || [], selectedHole);
					syncCanvasToTreeView(); // Sync cleared selection to TreeView
				}
			}
		} else if (isSelectionPointerActive && selectingHoles && !clickedHole) {
			// Step 12j.14) Selection pointer active with Holes radio, but no hole clicked - clear hole selections
			if (developerModeEnabled) {
				console.log("‚¨áÔ∏è [3D CLICK] Selection pointer active (Holes mode), no hole clicked");
			}
			if (!isAddingConnector && !isAddingMultiConnector) {
				if (!isMultiHoleSelectionEnabled) {
					selectedHole = null;
					selectedMultipleHoles = [];
					exposeGlobalsToWindow();
					drawData(allBlastHoles || [], selectedHole);
				}
			}
		}
	}
}

// handle3DContextMenu now loaded from ContextMenuManager.js

// Step 13) Handle 3D mouse move - hover effects and stadium zone tracking
function handle3DMouseMove(event) {
	// Step 13a) Only handle if in 3D mode
	if (!onlyShowThreeJS) return;

	// Step 13b) Early return if dependencies not ready
	if (!threeInitialized || !threeRenderer || !interactionManager) {
		// Try to get interactionManager from window if not set locally
		if (!interactionManager && window.interactionManager) {
			interactionManager = window.interactionManager;
		}
		// Ensure globals are exposed (in case they weren't set up yet)
		if (threeInitialized && threeRenderer) {
			exposeGlobalsToWindow();
		}
		if (!threeInitialized || !threeRenderer || !interactionManager) return;
	}

	// Step 13c) Get 3D canvas
	const threeCanvas = threeRenderer.getCanvas();
	if (!threeCanvas) return;

	// Step 13d) ALWAYS update mouse position for raycasting (needed for cursor and snapping)
	interactionManager.updateMousePosition(event, threeCanvas);

	// Step 13d.0) COORDINATE DEBUGGING: Trace transforms when debugger is enabled
	if (coordinateDebugger && coordinateDebugger.enabled) {
		coordinateDebugger.traceMousePosition(event);
	}

	// Step 13e) Update hover state and get raytrace intersection for 3D tracking
	// Always raycast to get 3D position (even if no blast holes, we might hit surfaces/other objects)
	const intersects = interactionManager.raycast();

	// Only update hover state if we have blast holes
	if (allBlastHoles && allBlastHoles.length > 0) {
		interactionManager.updateHover(intersects, allBlastHoles);
	}

	// Step 13f) Calculate world coordinates for stadium zone tracking
	// Try to get 3D world position from raytrace intersection first
	let mouseWorldPos = null;
	if (intersects && intersects.length > 0) {
		// Step 13f.1) Use raytrace intersection to get full 3D world position
		mouseWorldPos = interactionManager.getWorldPosition(intersects);
		// Validate the result - if it has NaN values, treat as null
		if (mouseWorldPos && (!isFinite(mouseWorldPos.x) || !isFinite(mouseWorldPos.y) || !isFinite(mouseWorldPos.z))) {
			mouseWorldPos = null;
		}
	}

	// Step 13f.2) If no object intersection, use ground plane intersection for interaction
	if (!mouseWorldPos && interactionManager && typeof interactionManager.getMouseWorldPositionOnPlane === "function") {
		// Use plane intersection at fromHoleStore Z level, or dataCentroidZ, or 0
		const zLevel = fromHoleStore ? fromHoleStore.startZLocation || window.dataCentroidZ || 0 : window.dataCentroidZ || 0;
		mouseWorldPos = interactionManager.getMouseWorldPositionOnPlane(zLevel);
	}

	//=============================================================================
	// AGENT NOTE - DO NOT REVERT THIS TO getMouseWorldPositionOnPlane()
	//=============================================================================
	// The torus/cursor indicator MUST use getMouseWorldPositionOnViewPlane() which
	// calculates position on a plane PERPENDICULAR to the camera direction.
	// This allows the cursor to follow the view angle in 3D, not be stuck on XY.
	//
	// WRONG: getMouseWorldPositionOnPlane() - horizontal XY plane, cursor stuck
	// CORRECT: getMouseWorldPositionOnViewPlane() - perpendicular to camera view
	//
	// This has been incorrectly reverted multiple times. DO NOT CHANGE.
	//=============================================================================
	// Step 13f.2a) Calculate mouse position on view plane for torus indicator
	// This ensures torus is always visible at cursor location in 3D view
	let torusWorldPos = null;
	if (interactionManager && typeof interactionManager.getMouseWorldPositionOnViewPlane === "function") {
		torusWorldPos = interactionManager.getMouseWorldPositionOnViewPlane();
		// DEBUG: Log view plane position
		if (torusWorldPos && developerModeEnabled) {
			console.log("üìê torusWorldPos (view plane):", torusWorldPos.x.toFixed(2), torusWorldPos.y.toFixed(2), torusWorldPos.z.toFixed(2));
		}
	}

	// DEBUG: Compare mouseWorldPos vs torusWorldPos
	if (developerModeEnabled && mouseWorldPos && torusWorldPos) {
		console.log("üéØ Coordinate comparison:");
		console.log("  mouseWorldPos (raycast/plane):", mouseWorldPos.x.toFixed(2), mouseWorldPos.y.toFixed(2), mouseWorldPos.z.toFixed(2));
		console.log("  torusWorldPos (view plane):", torusWorldPos.x.toFixed(2), torusWorldPos.y.toFixed(2), torusWorldPos.z.toFixed(2));
		console.log("  Difference XY:", Math.abs(mouseWorldPos.x - torusWorldPos.x).toFixed(2), Math.abs(mouseWorldPos.y - torusWorldPos.y).toFixed(2));
	}

	// Step 13f.3) Final fallback to camera projection if plane intersection fails
	if (!mouseWorldPos) {
		// Get mouse position in canvas coordinates
		const rect = threeCanvas.getBoundingClientRect();
		const mouseX = event.clientX - rect.left;
		const mouseY = event.clientY - rect.top;

		// Validate canvas dimensions
		if (!rect.width || !rect.height || rect.width <= 0 || rect.height <= 0) {
			console.warn("handle3DMouseMove: Invalid canvas dimensions", rect);
			return; // Can't calculate position without valid canvas
		}

		// Convert canvas coordinates to world coordinates using current camera state
		const camera = threeRenderer.camera;
		if (camera && camera.isOrthographicCamera) {
			// Step 13f.3.1) Get normalized device coordinates (-1 to +1)
			const ndcX = (mouseX / rect.width) * 2 - 1;
			const ndcY = -(mouseY / rect.height) * 2 + 1;

			// Step 13f.3.2) Calculate world position at Z=0 plane
			// Try to get camera state from CameraControls first, fallback to global centroidX/Y
			let worldCentroidX = null;
			let worldCentroidY = null;

			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				// CameraControls.centroidX/Y are in LOCAL coordinates (relative to threeLocalOrigin)
				// Need to convert to world coordinates
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				worldCentroidX = cameraState.centroidX + originX;
				worldCentroidY = cameraState.centroidY + originY;
			} else {
				// Fallback to global centroidX/Y variables (already in world coordinates)
				if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
					// Use global variables directly (they're already in world coordinates)
					worldCentroidX = centroidX;
					worldCentroidY = centroidY;
				} else {
					console.warn("handle3DMouseMove: No valid camera state or centroid available", {
						cameraState: cameraState,
						globalCentroidX: typeof centroidX !== "undefined" ? centroidX : "undefined",
						globalCentroidY: typeof centroidY !== "undefined" ? centroidY : "undefined",
					});
					return; // Can't calculate position without centroid
				}
			}

			// Step 13f.3.3) Calculate viewport dimensions and offsets
			const viewportWidth = camera.right - camera.left;
			const viewportHeight = camera.top - camera.bottom;

			// Validate viewport dimensions
			if (isFinite(viewportWidth) && isFinite(viewportHeight) && viewportWidth > 0 && viewportHeight > 0) {
				const offsetX = ndcX * (viewportWidth / 2);
				const offsetY = ndcY * (viewportHeight / 2);

				// Step 13f.3.4) Calculate world mouse position
				// worldCentroidX/Y are in WORLD coordinates, just add viewport offsets
				const worldX = worldCentroidX + offsetX;
				const worldY = worldCentroidY + offsetY;

				// Validate calculated coordinates
				if (isFinite(worldX) && isFinite(worldY)) {
					// Use fromHoleStore Z as fallback when no intersection
					const worldZ = fromHoleStore ? fromHoleStore.startZLocation || window.dataCentroidZ || 0 : window.dataCentroidZ || 0;

					mouseWorldPos = { x: worldX, y: worldY, z: worldZ };
				} else {
					console.warn("handle3DMouseMove: Calculated world coordinates are NaN", {
						worldCentroidX: worldCentroidX,
						worldCentroidY: worldCentroidY,
						offsetX: offsetX,
						offsetY: offsetY,
						worldX: worldX,
						worldY: worldY,
					});
				}
			} else {
				console.warn("handle3DMouseMove: Invalid viewport dimensions", {
					viewportWidth: viewportWidth,
					viewportHeight: viewportHeight,
				});
			}
		} else {
			console.warn("handle3DMouseMove: Camera not available or not orthographic", camera);
		}
	}

	// Step 13f.4) Apply 3D cylindrical snap if snapping enabled
	// This ensures cursor sphere and leading lines show snapped position during mouse move
	let snapResult = {
		snapped: false,
		snapTarget: null,
		worldX: mouseWorldPos ? mouseWorldPos.x : currentMouseWorldX,
		worldY: mouseWorldPos ? mouseWorldPos.y : currentMouseWorldY,
		worldZ: mouseWorldPos ? mouseWorldPos.z : currentMouseWorldZ,
	};

	// Step 13f.4) Screen Space Snapping - RE-ENABLED for connector tool
	var screenSpaceSnappingCheckbox = document.getElementById("screenSpaceSnapping");
	var screenSpaceSnappingEnabled = screenSpaceSnappingCheckbox ? screenSpaceSnappingCheckbox.checked : false;

	if (snapEnabled && screenSpaceSnappingEnabled && interactionManager && interactionManager.raycaster) {
		// Step 13f.4a) Calculate snap radius in pixels (NOT world units - use screen space!)
		const snapRadiusPixels = window.snapRadiusPixels || 15; // 15 pixels on screen

		// Step 13f.4b) Get ray from raycaster and mouse screen coordinates
		interactionManager.raycaster.setFromCamera(interactionManager.mouse, threeRenderer.camera);
		const ray = interactionManager.raycaster.ray;

		const rect = threeCanvas.getBoundingClientRect();
		const mouseScreenX = event.clientX - rect.left;
		const mouseScreenY = event.clientY - rect.top;

		// Step 13f.4c) Perform snap using screen-space for segments, ray for points
		snapResult = snapToNearestPointWithRay(ray.origin, ray.direction, snapRadiusPixels, mouseScreenX, mouseScreenY);

		// Step 13f.4d) If snapped, use snap position; otherwise use mouseWorldPos
		if (snapResult.snapped && snapResult.snapTarget) {
			// Use snapped position
			if (mouseWorldPos) {
				mouseWorldPos.x = snapResult.worldX;
				mouseWorldPos.y = snapResult.worldY;
				mouseWorldPos.z = snapResult.worldZ;
			} else {
				mouseWorldPos = {
					x: snapResult.worldX,
					y: snapResult.worldY,
					z: snapResult.worldZ,
				};
			}

			// Also update torusWorldPos so cursor sphere shows at snap point
			if (torusWorldPos) {
				torusWorldPos.x = snapResult.worldX;
				torusWorldPos.y = snapResult.worldY;
				torusWorldPos.z = snapResult.worldZ;
			} else {
				torusWorldPos = {
					x: snapResult.worldX,
					y: snapResult.worldY,
					z: snapResult.worldZ,
				};
			}
		}
	}

	// Step 13f.5) Update current mouse world coordinates and HUD
	if (mouseWorldPos) {
		currentMouseWorldX = mouseWorldPos.x;
		currentMouseWorldY = mouseWorldPos.y;
		// Step 13f.5.0) CRITICAL FIX: Validate Z to prevent extreme values that cause cursor to disappear
		var rawZ = mouseWorldPos.z || document.getElementById("drawingElevation").value;
		currentMouseWorldZ = validateWorldZ(parseFloat(rawZ), dataCentroidZ);

		// Step 13f.5a) Update snapHighlight for HUD magnet icon
		snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;

		// Step 13f.5b) Get canvas mouse coordinates for HUD
		const rect = threeCanvas.getBoundingClientRect();
		const canvasMouseX = event.clientX - rect.left;
		const canvasMouseY = event.clientY - rect.top;
		currentMouseCanvasX = canvasMouseX;
		currentMouseCanvasY = canvasMouseY;

		// Step 13f.5c) Emit coordinates to HUD (same as 2D path)
		var isCurrentlySnapped = snapHighlight !== null && snapEnabled;
		emitCoords(
			{ x: canvasMouseX, y: canvasMouseY },
			{ x: currentMouseWorldX, y: currentMouseWorldY, z: parseFloat(currentMouseWorldZ) || 0 },
			currentScale,
			isCurrentlySnapped
		);
	}

	// Step 13f.7) Always draw mouse position indicator at mouse position
	// Special case: During orbit mode, lock torus to orbit focal point to prevent jumping
	// CRITICAL: Must use torusWorldPos (view plane) for screen-space tracking, NOT mouseWorldPos
	// Priority: 1) Snapped position (if snapping), 2) Orbit center (if orbiting), 3) torusWorldPos (view plane), 4) mouseWorldPos, 5) Camera centroid
	let indicatorPos = null;

	// Step 13f.7a) Check if we have a snap target - highest priority for cursor display
	if (snapResult && snapResult.snapped && snapResult.snapTarget) {
		// Show cursor at snap target position
		indicatorPos = {
			x: snapResult.worldX,
			y: snapResult.worldY,
			z: snapResult.worldZ,
		};
		if (developerModeEnabled) {
			console.log("  ‚ûú Indicator Branch 1: SNAP TARGET", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
		}
	} else {
		// Step 13f.7b) Check if orbit mode is active via CameraControls
		const isOrbitingNow = window.cameraControls && window.cameraControls.isOrbiting;

		if (isOrbitingNow) {
			// Step 13f.7c) During orbit: Lock torus to orbit focal point (centroid + orbitCenterZ)
			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				const orbitZ = window.threeRenderer ? window.threeRenderer.orbitCenterZ || 0 : window.dataCentroidZ || 0;
				indicatorPos = {
					x: cameraState.centroidX + originX,
					y: cameraState.centroidY + originY,
					z: orbitZ,
				};
				if (developerModeEnabled) {
					console.log("  ‚ûú Indicator Branch 2: ORBITING", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
				}
			}
		} else if (torusWorldPos && isFinite(torusWorldPos.x) && isFinite(torusWorldPos.y) && isFinite(torusWorldPos.z)) {
			// Step 13f.7d) Use torusWorldPos (view plane) - ensures screen-space cursor tracking
			// This is CRITICAL for cursor to follow mouse in 3D regardless of camera angle
			indicatorPos = torusWorldPos;
			if (developerModeEnabled) {
				console.log("  ‚ûú Indicator Branch 3: VIEW PLANE (torusWorldPos)", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
			}
		} else if (mouseWorldPos && isFinite(mouseWorldPos.x) && isFinite(mouseWorldPos.y)) {
			// Step 13f.7e) Fallback to mouseWorldPos if view plane not available
			indicatorPos = mouseWorldPos;
			if (developerModeEnabled) {
				console.log("  ‚ûú Indicator Branch 4: MOUSE WORLD POS (fallback)", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
			}
		} else {
			// Step 13f.7f) Final fallback: camera centroid
			const fallbackZ = window.dataCentroidZ || 0;
			const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
			if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
				const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
				const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
				indicatorPos = {
					x: cameraState.centroidX + originX,
					y: cameraState.centroidY + originY,
					z: fallbackZ,
				};
				if (developerModeEnabled) {
					console.log("  ‚ûú Indicator Branch 5: CAMERA CENTROID", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
				}
			} else if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
				indicatorPos = {
					x: centroidX,
					y: centroidY,
					z: fallbackZ,
				};
				if (developerModeEnabled) {
					console.log("  ‚ûú Indicator Branch 6: GLOBAL CENTROID", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));
				}
			}
		}
	}

	if (indicatorPos && isFinite(indicatorPos.x) && isFinite(indicatorPos.y)) {
		// DEBUG: Store for console inspection (only if developer mode enabled)
		if (developerModeEnabled) {
			window._debugIndicatorPos = indicatorPos;
		}
		// DEBUG: Disabled excessive logging on mouse move
		// console.log("üî¥ SLOW PATH cursor:", indicatorPos.x.toFixed(2), indicatorPos.y.toFixed(2), indicatorPos.z.toFixed(2));

		// Step 13f.7e) Determine cursor color based on active tool or snap state
		var torusColor = "rgba(128, 128, 128, 0.4)"; // Default grey

		// Step 13f.7f) If snapped, change color to indicate snap (bright green)
		// MUST use rgba() format - parseRGBA only handles rgba/rgb, not hex colors!
		if (snapResult && snapResult.snapped && snapResult.snapTarget) {
			// Different alpha for vertices vs segments
			const snapType = snapResult.snapTarget.type;
			const isSegmentSnap = snapType && (snapType.includes("SEGMENT") || snapType.includes("LINE_SEGMENT") || snapType.includes("POLYGON_SEGMENT"));
			const snapAlpha = isSegmentSnap ? 0.3 : 0.8; // Dimmer for segments, brighter for vertices/points
			torusColor = `rgba(0, 255, 0, ${snapAlpha})`;
		} else {
			// Otherwise use tool-specific colors
			var isAnyDrawingToolActiveForTorus = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole;
			if (isAnyDrawingToolActiveForTorus) {
				if (isDrawingPoint || isAddingHole) {
					torusColor = "rgba(209, 0, 0, 0.5)"; // Red for points and holes
				} else if (isDrawingLine) {
					torusColor = "rgba(0, 255, 255, 0.5)"; // Cyan for lines
				} else if (isDrawingPoly) {
					torusColor = "rgba(255, 0, 255, 0.5)"; // Magenta for polygons
				} else if (isDrawingCircle) {
					torusColor = "rgba(255, 165, 0, 0.5)"; // Orange for circles
				} else if (isDrawingText) {
					torusColor = "rgba(0, 150, 50, 0.5)"; // Green for text
				}
			}
		}
		drawMousePositionIndicatorThreeJS(indicatorPos.x, indicatorPos.y, indicatorPos.z, torusColor);

		// Step 13f.7f.1) Store indicator position for use in drawData (stadium zone)
		currentMouseIndicatorX = indicatorPos.x;
		currentMouseIndicatorY = indicatorPos.y;
		currentMouseIndicatorZ = indicatorPos.z;

		// Step 13f.7g) Draw stadium zone at SAME position as mouse indicator
		// This ensures stadium endpoint is attached to the mouse cursor
		if (isAddingMultiConnector && fromHoleStore && fromHoleStore.entityName && fromHoleStore.holeID && threeRenderer && threeRenderer.connectorsGroup) {
			// Step 13f.7g.1) Clear old stadium zone first
			const toRemove = [];
			threeRenderer.connectorsGroup.children.forEach(function (child) {
				if (child.userData && child.userData.type === "stadiumZone") {
					toRemove.push(child);
				}
			});
			toRemove.forEach(function (obj) {
				threeRenderer.connectorsGroup.remove(obj);
				if (obj.geometry) obj.geometry.dispose();
				if (obj.material) {
					if (Array.isArray(obj.material)) {
						obj.material.forEach(function (mat) { mat.dispose(); });
					} else {
						obj.material.dispose();
					}
				}
			});

			// Step 13f.7g.2) Draw new stadium zone at mouse indicator position
			drawConnectStadiumZoneThreeJS(fromHoleStore, { x: indicatorPos.x, y: indicatorPos.y, z: indicatorPos.z }, connectAmount);
		}
	}

	// Step 13f.8) Draw KAD leading line preview if drawing tool is active
	const isAnyDrawingToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole;

	// DEBUG: Log leading line conditions
	if (developerModeEnabled && isAnyDrawingToolActive) {
		console.log("üî∏ Leading Line Check: isAnyDrawingToolActive=" + isAnyDrawingToolActive + ", lastKADDrawPoint=" + (lastKADDrawPoint ? "exists" : "null") + ", createNewEntity=" + createNewEntity);
		if (lastKADDrawPoint) {
			console.log("üî∏ lastKADDrawPoint: x=" + lastKADDrawPoint.x + ", y=" + lastKADDrawPoint.y + ", z=" + lastKADDrawPoint.z);
		}
	}

	if (isAnyDrawingToolActive && lastKADDrawPoint && createNewEntity === false) {
		// Get drawing Z value - IMPORTANT: Use same Z for both ends (like 2D drawing)
		const drawZ = parseFloat(drawingZValue || document.getElementById("drawingElevation").value || 0);
		// Use the LAST POINT's Z, NOT the raycasted mouse Z (which could be on a surface at different elevation)
		const leadingLineZ = lastKADDrawPoint.z || drawZ;

		if (developerModeEnabled) {
			console.log("üî∏ DRAWING LEADING LINE from (" + lastKADDrawPoint.x.toFixed(2) + "," + lastKADDrawPoint.y.toFixed(2) + "," + leadingLineZ.toFixed(2) + ") to (" + currentMouseWorldX.toFixed(2) + "," + currentMouseWorldY.toFixed(2) + "," + leadingLineZ.toFixed(2) + ")");
		}

		// Determine color based on active tool
		var leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan default
		if (isDrawingPoint || isAddingHole) {
			leadingLineColor = "rgba(209, 0, 0, 0.8)"; // Red for points and holes
		} else if (isDrawingLine) {
			leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan for lines
		} else if (isDrawingPoly) {
			leadingLineColor = "rgba(255, 0, 255, 0.8)"; // Magenta for polygons
		} else if (isDrawingCircle) {
			leadingLineColor = "rgba(255, 165, 0, 0.8)"; // Orange for circles
		} else if (isDrawingText) {
			leadingLineColor = "rgba(0, 255, 0, 0.8)"; // Green for text
		}


		// Step 13f.8a) REMOVED - Leading line is now drawn ONLY in drawData() at line ~28758
		// This duplicate code was being overwritten by drawData() anyway
		// The drawData() version uses currentMouseIndicatorX/Y/Z which correctly tracks the cursor

		// Step 13f.8b) Show distance overlay for drawing tools with tool-specific color
		var drawDx = currentMouseWorldX - lastKADDrawPoint.x;
		var drawDy = currentMouseWorldY - lastKADDrawPoint.y;
		var drawDistance = Math.sqrt(drawDx * drawDx + drawDy * drawDy);
		var drawBearing = (90 - (Math.atan2(drawDy, drawDx) * 180) / Math.PI + 360) % 360;

		// Determine tool type for color
		var drawToolType = "line";
		if (isDrawingPoint || isAddingHole) {
			drawToolType = "point";
		} else if (isDrawingLine) {
			drawToolType = "line";
		} else if (isDrawingPoly) {
			drawToolType = "poly";
		} else if (isDrawingCircle) {
			drawToolType = "circle";
		} else if (isDrawingText) {
			drawToolType = "text";
		}

		showDrawingDistance(drawDistance, drawBearing, drawToolType, event.clientX, event.clientY);
	} else {
		// Clear leading line if no drawing tool active or no last point
		clearKADLeadingLineThreeJS();
		hideDrawingDistance();
	}

	// Step 13f.9) Draw ruler in 3D mode if active
	if (isRulerActive && rulerStartPoint) {
		var rulerEndX = currentMouseWorldX;
		var rulerEndY = currentMouseWorldY;
		var rulerEndZ = currentMouseWorldZ || rulerStartPoint.z || 0;

		if (rulerEndPoint) {
			rulerEndX = rulerEndPoint.x;
			rulerEndY = rulerEndPoint.y;
			rulerEndZ = rulerEndPoint.z || 0;
		}

		drawRulerThreeJS(
			rulerStartPoint.x,
			rulerStartPoint.y,
			rulerStartPoint.z || 0,
			rulerEndX,
			rulerEndY,
			rulerEndZ
		);

		// Step 13f.9a) Update CSS ruler panel with measurements (same as 2D drawRuler)
		var ruler3DStartZ = rulerStartPoint.z || 0;
		var ruler3DEndZ = rulerEndZ || 0;
		var ruler3DDeltaX = rulerEndX - rulerStartPoint.x;
		var ruler3DDeltaY = rulerEndY - rulerStartPoint.y;
		var ruler3DDeltaZ = ruler3DEndZ - ruler3DStartZ;
		var ruler3DPlanDistance = Math.sqrt(ruler3DDeltaX * ruler3DDeltaX + ruler3DDeltaY * ruler3DDeltaY);
		var ruler3DTotalDistance = Math.sqrt(ruler3DDeltaX * ruler3DDeltaX + ruler3DDeltaY * ruler3DDeltaY + ruler3DDeltaZ * ruler3DDeltaZ);
		var ruler3DElevationAngle = ruler3DPlanDistance > 0 ? (Math.atan(Math.abs(ruler3DDeltaZ) / ruler3DPlanDistance) * 180) / Math.PI : 0;
		var ruler3DSlopePercent = ruler3DPlanDistance > 0 ? (Math.abs(ruler3DDeltaZ) / ruler3DPlanDistance) * 100 : 0;

		showRulerPanel({
			z1: ruler3DStartZ,
			z2: ruler3DEndZ,
			planDistance: ruler3DPlanDistance,
			totalDistance: ruler3DTotalDistance,
			deltaZ: ruler3DDeltaZ,
			elevationAngle: ruler3DElevationAngle,
			slopePercent: ruler3DSlopePercent,
			mouseX: currentMouseCanvasX,
			mouseY: currentMouseCanvasY
		});
	} else {
		clearRulerThreeJS();
		hideRulerPanel();
	}

	// Step 13f.9.5) Draw Pattern In Polygon leading line if active
	if (isPatternInPolygonActive && patternStartPoint && !patternEndPoint) {
		// Step 13f.9.5a) Get snapped mouse coordinates
		// In 3D mode, use current mouseWorldPos (calculated fresh this frame)
		var patternSnapResult = mouseWorldPos
			? snapToNearestPoint(mouseWorldPos.x, mouseWorldPos.y)
			: snapToNearestPoint(currentMouseWorldX, currentMouseWorldY);
		var snappedMouseX = patternSnapResult.worldX;
		var snappedMouseY = patternSnapResult.worldY;

		// Step 13f.9.5b) Reuse existing drawKADLeadingLineThreeJSV2 for cheap dashed line
		var startZ = patternStartPoint.z || dataCentroidZ || 0;
		var mouseZ = currentMouseWorldZ || startZ;
		// Step 13f.9.5a) Draw leading line from start point to mouse cursor
		drawKADLeadingLineThreeJSV2(
			patternStartPoint.x,
			patternStartPoint.y,
			startZ,
			currentMouseIndicatorX,
			currentMouseIndicatorY,
			currentMouseIndicatorZ,
			"rgba(0, 255, 0, 0.5)" // Green to match 2D
		);
		// Also redraw markers (green start, red end) and triangle via the visual function
		drawPatternInPolygon3DVisual();

		// Step 13f.9.5c) Show distance overlay at line midpoint
		var midWorldX = (patternStartPoint.x + currentMouseIndicatorX) / 2;
		var midWorldY = (patternStartPoint.y + currentMouseIndicatorY) / 2;
		var midWorldZ = (startZ + currentMouseIndicatorZ) / 2;
		var screenMid = worldToScreen(midWorldX, midWorldY, midWorldZ);
		if (screenMid && threeRenderer && threeRenderer.getCanvas()) {
			var canvasRect = threeRenderer.getCanvas().getBoundingClientRect();
			var dx = currentMouseIndicatorX - patternStartPoint.x;
			var dy = currentMouseIndicatorY - patternStartPoint.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			var bearing = ((90 - Math.atan2(dy, dx) * 180 / Math.PI) + 360) % 360;
			showDrawingDistance(distance, bearing, "poly", screenMid.x + canvasRect.left, screenMid.y + canvasRect.top);
		}
	} else if (isPatternInPolygonActive) {
		// Still active but no leading line needed - just update visuals (markers, direction line, arrow)
		drawPatternInPolygon3DVisual();
	}

	// Step 13f.9.6) Draw Holes Along Line leading line if active
	if (isHolesAlongLineActive && lineStartPoint && !lineEndPoint) {
		// In 3D mode, use current mouseWorldPos (calculated fresh this frame)
		var holesLineSnapResult = mouseWorldPos
			? snapToNearestPoint(mouseWorldPos.x, mouseWorldPos.y)
			: snapToNearestPoint(currentMouseWorldX, currentMouseWorldY);
		var snappedMouseX = holesLineSnapResult.worldX;
		var snappedMouseY = holesLineSnapResult.worldY;

		// Step 13f.9.6a) Use snapped Z values - check for undefined, not falsy (Z=0 is valid)
		var startZ = lineStartPoint.z !== undefined ? lineStartPoint.z : (currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : 0);
		var mouseZ = currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : startZ;

		// Step 13f.9.6b) Draw leading line from start point to mouse cursor
		drawKADLeadingLineThreeJSV2(
			lineStartPoint.x,
			lineStartPoint.y,
			startZ,
			currentMouseIndicatorX,
			currentMouseIndicatorY,
			mouseZ,
			"rgba(0, 255, 0, 0.5)"
		);
		drawHolesAlongLine3DVisual();

		// Step 13f.9.6c) Show distance marker at line midpoint
		var midWorldX = (lineStartPoint.x + currentMouseIndicatorX) / 2;
		var midWorldY = (lineStartPoint.y + currentMouseIndicatorY) / 2;
		var midWorldZ = (startZ + mouseZ) / 2;
		var screenMid = worldToScreen(midWorldX, midWorldY, midWorldZ);
		if (screenMid && threeRenderer && threeRenderer.getCanvas()) {
			// FIX: Add canvas offset to convert canvas-relative to viewport-relative coordinates
			var canvasRect = threeRenderer.getCanvas().getBoundingClientRect();
			var dx = currentMouseIndicatorX - lineStartPoint.x;
			var dy = currentMouseIndicatorY - lineStartPoint.y;
			var distance = Math.sqrt(dx * dx + dy * dy);
			var bearing = ((90 - Math.atan2(dy, dx) * 180 / Math.PI) + 360) % 360;
			showDrawingDistance(distance, bearing, "line", screenMid.x + canvasRect.left, screenMid.y + canvasRect.top);
		}
	}

	// Step 13f.9.7) Draw Holes Along Polyline leading line if active - REMOVED per user request
	// Leading line removed for holesAlongPolyline tool

	// Step 13f.10) Draw protractor in 3D mode if active
	if (isRulerProtractorActive && rulerProtractorPoints.length > 0) {
		var p1 = rulerProtractorPoints[0];
		var p2 = rulerProtractorPoints.length > 1 ? rulerProtractorPoints[1] : { x: currentMouseWorldX, y: currentMouseWorldY, z: currentMouseWorldZ || p1.z || 0 };
		var p3 = { x: currentMouseWorldX, y: currentMouseWorldY, z: currentMouseWorldZ || p1.z || 0 };

		if (rulerProtractorPoints.length === 2) {
			p2 = rulerProtractorPoints[1];
		}
		if (rulerProtractorPoints.length === 3) {
			p3 = rulerProtractorPoints[2];
		}

		drawProtractorThreeJS(
			p1.x, p1.y, p1.z || 0,
			p2.x, p2.y, p2.z || 0,
			p3.x, p3.y, p3.z || 0
		);

		// Step 13f.10a) Update CSS protractor panel with measurements (same as 2D drawProtractor)
		var prot3DDeltaX1 = p2.x - p1.x;
		var prot3DDeltaY1 = p2.y - p1.y;
		var prot3DD1 = Math.sqrt(prot3DDeltaX1 * prot3DDeltaX1 + prot3DDeltaY1 * prot3DDeltaY1);
		var prot3DBearing1 = ((90 - Math.atan2(prot3DDeltaY1, prot3DDeltaX1) * 180 / Math.PI) + 360) % 360;

		var prot3DDeltaX2 = p3.x - p1.x;
		var prot3DDeltaY2 = p3.y - p1.y;
		var prot3DD2 = Math.sqrt(prot3DDeltaX2 * prot3DDeltaX2 + prot3DDeltaY2 * prot3DDeltaY2);
		var prot3DBearing2 = ((90 - Math.atan2(prot3DDeltaY2, prot3DDeltaX2) * 180 / Math.PI) + 360) % 360;

		// Calculate inner angle between the two legs
		var prot3DAngle1Rad = Math.atan2(prot3DDeltaY1, prot3DDeltaX1);
		var prot3DAngle2Rad = Math.atan2(prot3DDeltaY2, prot3DDeltaX2);
		var prot3DInnerAngle = Math.abs(prot3DAngle2Rad - prot3DAngle1Rad) * 180 / Math.PI;
		if (prot3DInnerAngle > 180) prot3DInnerAngle = 360 - prot3DInnerAngle;
		var prot3DOuterAngle = 360 - prot3DInnerAngle;

		showProtractorPanel({
			d1: prot3DD1,
			d2: prot3DD2,
			bearing1: prot3DBearing1,
			bearing2: prot3DBearing2,
			innerAngle: prot3DInnerAngle,
			outerAngle: prot3DOuterAngle,
			mouseX: currentMouseCanvasX,
			mouseY: currentMouseCanvasY
		});
	} else {
		clearProtractorThreeJS();
		hideProtractorPanel();
	}

	// Step 13f.11) REMOVED - Duplicate Pattern In Polygon code
	// Pattern In Polygon leading line is now handled ONLY at Step 13f.9.5 above (line ~3100)
	// This duplicate was causing the leading line to be drawn twice

	// NOTE: Removed direct render() call here - was causing WebGL context crash
	// The CameraControls animation loop already handles continuous rendering
	// Calling render() on every mouse move (hundreds/sec) caused shader errors to accumulate
}

// Step 15) Handle 3D touch events
function handle3DTouchStart(event) {
	if (event.touches.length === 1) {
		const touch = event.touches[0];
		const mouseEvent = new MouseEvent("mousedown", {
			clientX: touch.clientX,
			clientY: touch.clientY,
			button: 0,
		});
		handle3DMouseDown(mouseEvent);
	}
	event.preventDefault();
}

function handle3DTouchEnd(event) {
	if (event.changedTouches.length === 1) {
		const touch = event.changedTouches[0];
		const mouseEvent = new MouseEvent("mouseup", {
			clientX: touch.clientX,
			clientY: touch.clientY,
			button: 0,
		});
		handle3DMouseUp(mouseEvent);
	}
	event.preventDefault();
}

function handle3DTouchMove(event) {
	if (event.touches.length === 1) {
		const touch = event.touches[0];
		const mouseEvent = new MouseEvent("mousemove", {
			clientX: touch.clientX,
			clientY: touch.clientY,
		});
		handle3DMouseMove(mouseEvent);
	}
	event.preventDefault();
}

// Step 10) Setup onlyShowThreeJS checkbox listener
document.addEventListener("DOMContentLoaded", function () {
	const onlyThreeJSCheckbox = document.getElementById("onlyShowThreeJS");
	if (onlyThreeJSCheckbox) {
		onlyThreeJSCheckbox.addEventListener("change", function () {
			onlyShowThreeJS = this.checked;
			console.log(onlyShowThreeJS ? "üé® Showing only Three.js rendering" : "üé® Showing both 2D canvas and Three.js");

			const threeCanvas = document.getElementById("threeCanvas");

			if (onlyShowThreeJS) {
				// Step 1a) Show only 3D canvas - hide 2D canvas completely
				canvas.style.zIndex = "0"; // 2D canvas behind
				canvas.style.opacity = "0"; // Hide 2D canvas
				canvas.style.pointerEvents = "none"; // Don't block events

				if (threeCanvas) {
					threeCanvas.style.zIndex = "2"; // Three.js on top
					threeCanvas.style.opacity = "1"; // Show 3D canvas
					threeCanvas.style.pointerEvents = "auto"; // Receive events
				}
				console.log("üîç Layers: Three.js (z:2, visible), 2D canvas (z:0, hidden)");
			} else {
				// Step 1b) Show only 2D canvas - hide 3D canvas completely
				canvas.style.zIndex = "2"; // 2D canvas on top
				canvas.style.opacity = "1"; // Show 2D canvas
				canvas.style.pointerEvents = "auto"; // Receive events

				if (threeCanvas) {
					threeCanvas.style.zIndex = "0"; // Three.js behind
					threeCanvas.style.opacity = "0"; // Hide 3D canvas
					threeCanvas.style.pointerEvents = "none"; // Don't block events
				}

				// Reset pan state to prevent stuck dragging
				if (window.cameraControls) {
					window.cameraControls.resetPanState();
					console.log("üîÑ Reset camera controls pan state on switch to 2D");
				}

				console.log("üîç Layers: 2D canvas (z:2, visible), Three.js (z:0, hidden)");
			}

			// Redraw to apply changes
			drawData(allBlastHoles);

			// If switching to 3D mode, trigger mouse indicator initialization
			if (show3D && threeInitialized && interactionManager && threeRenderer) {
				// Use setTimeout to ensure canvas is visible and ready
				setTimeout(() => {
					const threeCanvas = threeRenderer.getCanvas();
					if (threeCanvas) {
						const rect = threeCanvas.getBoundingClientRect();
						const centerX = rect.left + rect.width / 2;
						const centerY = rect.top + rect.height / 2;

						const syntheticEvent = new MouseEvent("mousemove", {
							bubbles: true,
							cancelable: true,
							clientX: centerX,
							clientY: centerY,
							button: 0,
							buttons: 0,
						});

						// Synthetic Events is killing the GPU and destroying performance.  
						// document.dispatchEvent(syntheticEvent);
					}
				}, 100);
			}
		});
	}

	// Step 11) Setup 2D-3D dimension toggle button
	const dimension2D3DBtn = document.getElementById("dimension2D-3DBtn");
	if (dimension2D3DBtn) {
		dimension2D3DBtn.addEventListener("change", function () {
			const show3D = this.checked;
			const threeCanvas = document.getElementById("threeCanvas");
			const iconImg = this.nextElementSibling.querySelector("img");

			if (show3D) {
				// Step 1c) 3D-only mode - show only 3D canvas, hide 2D canvas
				onlyShowThreeJS = true;
				// Reset mouse indicator flag so it initializes when switching to 3D mode
				mouseIndicatorInitialized = false;
				// Step 1ca) Reset initialization failure flag to allow retry
				threeInitializationFailed = false;
				// Step 1cb) Reset camera pan state to prevent stuck drag
				if (cameraControls && cameraControls.resetPanState) {
					cameraControls.resetPanState();
				}
				console.log("üßä 3D-ONLY Mode: ON (cube icon active, 2D canvas hidden)");

				// Step 1cc.0b) Clear text cache to ensure text renders at correct scale
				clearTextCache();

				// Step 1cc.1) Force geometry rebuild when entering 3D mode
				window.threeDataNeedsRebuild = true;

				// Step 1cc.2) Update Move Tool if active - switch to 3D canvas
				if (isMoveToolActive) {
					const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
					if (threeCanvas) {
						// Remove listeners from 2D canvas
						canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
						canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
						canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
						canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
						canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
						canvas.removeEventListener("touchend", handleMoveToolMouseUp);

						// Add listeners to 3D canvas
						threeCanvas.addEventListener("mousedown", handleMoveToolMouseDown);
						threeCanvas.addEventListener("touchstart", handleMoveToolMouseDown);

						// Update mode flag
						moveToolIn3DMode = true;
						console.log("üëã Move Tool switched to 3D canvas");
					}
				}

				// Step 1cc.3) Handle KAD drawing tools when switching to 3D
				const anyKADToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText;
				if (anyKADToolActive) {
					// Remove event listeners from 2D canvas (drawing doesn't work in 3D)
					canvas.removeEventListener("click", handleKADPointClick);
					canvas.removeEventListener("touchstart", handleKADPointClick);
					canvas.removeEventListener("click", handleKADLineClick);
					canvas.removeEventListener("touchstart", handleKADLineClick);
					canvas.removeEventListener("click", handleKADPolyClick);
					canvas.removeEventListener("touchstart", handleKADPolyClick);
					canvas.removeEventListener("click", handleKADCircleClick);
					canvas.removeEventListener("touchstart", handleKADCircleClick);
					canvas.removeEventListener("click", handleKADTextClick);
					canvas.removeEventListener("touchstart", handleKADTextClick);

					// Clear drawing state to prevent stale preview lines
					lastKADDrawPoint = null;

					// Keep the tool active but inform user about 3D limitations
					updateStatusMessage("KAD drawing: Right-click to end entities in 3D mode");
					setTimeout(() => updateStatusMessage(""), 3000);

					console.log("üîÑ KAD drawing tools switched to 3D mode (right-click only)");
				}

				if (threeCanvas) {
					threeCanvas.style.zIndex = "2"; // Three.js on top
					threeCanvas.style.opacity = "1"; // Show 3D canvas
					threeCanvas.style.pointerEvents = "auto"; // Receive events
				}
				// Hide 2D canvas completely
				if (canvas) {
					canvas.style.zIndex = "0"; // 2D canvas behind
					canvas.style.opacity = "0"; // Hide 2D canvas
					canvas.style.pointerEvents = "none"; // Don't block events
				}
				// Step 1cc) Hide contour overlay canvas in 3D mode (labels render as 3D text)
				if (typeof contourOverlayCanvas !== "undefined" && contourOverlayCanvas) {
					contourOverlayCanvas.style.display = "none";
				}
				// Swap icon to 3D badge
				if (iconImg) {
					iconImg.src = "icons/badge-3d-v2.png";
					iconImg.alt = "3D View Active (3D Only)";
				}
				// Step 1cd) CRITICAL: Trigger contour recalculation and drawData to populate 3D scene
				// Without this, the 3D scene remains empty until user interaction
				if (allBlastHoles && allBlastHoles.length > 0) {
					// Step 1cd.1) Recalculate contours if contour OR direction arrows display is enabled
					// This ensures both contourLinesArray and directionArrows are populated for 3D rendering
					var needsContourRecalc = (displayContours && displayContours.checked) ||
						(displayFirstMovements && displayFirstMovements.checked);
					if (needsContourRecalc) {
						var result = recalculateContours(allBlastHoles, 0, 0);
						if (result) {
							contourLinesArray = result.contourLinesArray;
							directionArrows = result.directionArrows;
						}
					}
					// Step 1cd.2) Now draw the data with populated contours/arrows
					// Step 1cd.2a) Store Three.js initialization state BEFORE drawData()
					drawData(allBlastHoles, selectedHole);

					// Step 1cd.3) CRITICAL FIX: Complete 3D setup AFTER drawData() initializes Three.js
					// This ensures threeRenderer and cameraControls exist
					if (threeInitialized) {
						// Three.js was just initialized during drawData()
						console.log("üì∑ Three.js just initialized - completing 3D mode setup");

						// Step 1cd.3a) Now set the orbit center (threeRenderer now exists)
						if (threeRenderer && typeof threeRenderer.setOrbitCenter === "function") {
							var fullCentroid = calculateDataCentroid();
							threeRenderer.setOrbitCenter(fullCentroid.x, fullCentroid.y, fullCentroid.z);
							console.log("üéØ Orbit center set after init: X=" + fullCentroid.x.toFixed(2) + " Y=" + fullCentroid.y.toFixed(2) + " Z=" + fullCentroid.z.toFixed(2));
						}

						// Step 1cd.3b) Sync camera with proper state
						syncCameraToThreeJS();
						console.log("üì∑ Camera synced after Three.js initialization on 3D mode switch");
						// Step 1cd.3c) Force a mouse move event to initialize the torus indicator
						requestAnimationFrame(function () {
							if (threeRenderer) {
								var threeCanvas = threeRenderer.getCanvas();
								if (threeCanvas) {
									var rect = threeCanvas.getBoundingClientRect();
									var centerX = rect.left + rect.width / 2;
									var centerY = rect.top + rect.height / 2;
									var syntheticEvent = new MouseEvent("mousemove", {
										bubbles: true,
										cancelable: true,
										clientX: centerX,
										clientY: centerY,
										button: 0,
										buttons: 0
									});
									// Synthetic Events is killing the GPU and destroying performance.  
									// document.dispatchEvent(syntheticEvent);
									// console.log("üñ±Ô∏è Synthetic mouse move dispatched to initialize cursor");
								}
							}
						});
					}
				}
				console.log("üîÑ 3D mode setup complete");
				console.log("üîÑ threeInitialized:", threeInitialized);
				console.log("üîÑ cameraControls:", cameraControls);
				console.log("üîÑ threeRenderer:", threeRenderer);
				console.log("üîÑ interactionManager:", interactionManager);
				console.log("üîÑ threeCanvas:", threeCanvas);
				console.log("üîÑ canvas:", canvas);
				console.log("üîÑ ctx:", ctx);
				console.log("üîÑ allBlastHoles:", allBlastHoles);
				console.log("üîÑ selectedHole:", selectedHole);
			} else {
				// Step 1d) 2D-only mode - show only 2D canvas, hide 3D canvas
				onlyShowThreeJS = false;
				// Step 1da) SYNC CAMERA: Get 3D camera state and apply to 2D view
				if (cameraControls) {
					var cameraState = cameraControls.getCameraState();
					if (cameraState) {
						syncCameraFromThreeJS(cameraState);
						console.log("üì∑ Synced camera FROM Three.js - centroidX:", centroidX.toFixed(2), "centroidY:", centroidY.toFixed(2), "scale:", currentScale);
					}
					// Reset camera pan state to prevent stuck drag
					if (cameraControls.resetPanState) {
						cameraControls.resetPanState();
					}
				}
				console.log("üé® 2D-ONLY Mode: ON (3D canvas hidden)");

				// Step 1db) Update Move Tool if active - switch to 2D canvas
				if (isMoveToolActive) {
					const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
					if (threeCanvas) {
						// Remove listeners from 3D canvas
						threeCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
						threeCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
						threeCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
						threeCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
						threeCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
						threeCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
					}

					// Add listeners to 2D canvas
					canvas.addEventListener("mousedown", handleMoveToolMouseDown);
					canvas.addEventListener("touchstart", handleMoveToolMouseDown);

					// Update mode flag
					moveToolIn3DMode = false;
					dragPlaneZ = 0;
					console.log("üîÑ Move Tool switched to 2D canvas");
				}

				// Step 1db.1) Update KAD drawing tools if active - ensure event listeners are on 2D canvas
				const anyKADToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText;
				if (anyKADToolActive) {
					// Remove any existing listeners (just in case)
					canvas.removeEventListener("click", handleKADPointClick);
					canvas.removeEventListener("touchstart", handleKADPointClick);
					canvas.removeEventListener("click", handleKADLineClick);
					canvas.removeEventListener("touchstart", handleKADLineClick);
					canvas.removeEventListener("click", handleKADPolyClick);
					canvas.removeEventListener("touchstart", handleKADPolyClick);
					canvas.removeEventListener("click", handleKADCircleClick);
					canvas.removeEventListener("touchstart", handleKADCircleClick);
					canvas.removeEventListener("click", handleKADTextClick);
					canvas.removeEventListener("touchstart", handleKADTextClick);

					// Add listeners to 2D canvas based on active tool
					if (isDrawingPoint) {
						canvas.addEventListener("click", handleKADPointClick);
						canvas.addEventListener("touchstart", handleKADPointClick);
					} else if (isDrawingLine) {
						canvas.addEventListener("click", handleKADLineClick);
						canvas.addEventListener("touchstart", handleKADLineClick);
					} else if (isDrawingPoly) {
						canvas.addEventListener("click", handleKADPolyClick);
						canvas.addEventListener("touchstart", handleKADPolyClick);
					} else if (isDrawingCircle) {
						canvas.addEventListener("click", handleKADCircleClick);
						canvas.addEventListener("touchstart", handleKADCircleClick);
					} else if (isDrawingText) {
						canvas.addEventListener("click", handleKADTextClick);
						canvas.addEventListener("touchstart", handleKADTextClick);
					}

					// Inform user that full drawing functionality is restored
					updateStatusMessage("KAD drawing: Full functionality restored in 2D mode");
					setTimeout(() => updateStatusMessage(""), 2000);

					console.log("üîÑ KAD drawing tool event listeners switched to 2D canvas");
				}

				// Step 1dc) Clear all Three.js geometry when switching to 2D mode
				if (typeof clearThreeJS === "function") {
					clearThreeJS();
					console.log("üé® Cleared Three.js geometry on switch to 2D mode");
				}

				// Step 1dc.1) Remove 3D print preview overlay if present
				remove3DPrintBoundaryOverlay();
				console.log("üñ®Ô∏è Removed 3D print boundary overlay on switch to 2D mode");

				if (threeCanvas) {
					threeCanvas.style.zIndex = "0"; // Three.js behind
					threeCanvas.style.opacity = "0"; // Hide 3D canvas
					threeCanvas.style.pointerEvents = "none"; // Don't block events
				}
				if (canvas) {
					canvas.style.zIndex = "2"; // 2D canvas on top
					canvas.style.opacity = "1"; // Show 2D canvas
					canvas.style.pointerEvents = "auto"; // Receive events
				}

				// Step 1dc) Reset 2D canvas transform state to prevent 3D rotation artifacts
				// This fixes the quirk where surfaces render above KAD and Holes after 3D rotation
				if (ctx) {
					ctx.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
					console.log("üîÑ Reset 2D canvas transform state on switch to 2D mode");
				}

				// Step 1dd) Show contour overlay canvas in 2D mode
				if (typeof contourOverlayCanvas !== "undefined" && contourOverlayCanvas) {
					contourOverlayCanvas.style.display = "block";
				}
				// Swap icon to 2D badge
				if (iconImg) {
					iconImg.src = "icons/badge-2d-v2.png";
					iconImg.alt = "2D View Active (2D Only)";
				}
				// Step 1de) CRITICAL: Recalculate contours and redraw for 2D mode
				// This ensures contours display correctly after switching from 3D
				if (allBlastHoles && allBlastHoles.length > 0) {
					if (displayContours && displayContours.checked) {
						var result = recalculateContours(allBlastHoles, 0, 0);
						if (result) {
							contourLinesArray = result.contourLinesArray;
							directionArrows = result.directionArrows;
						}
					}
					drawData(allBlastHoles, selectedHole);
				}
				console.log("üîÑ 2D mode setup complete");
				console.log("üîÑ onlyShowThreeJS:", onlyShowThreeJS);
				console.log("üîÑ threeCanvas:", threeCanvas);
				console.log("üîÑ canvas:", canvas);
				console.log("üîÑ ctx:", ctx);
				console.log("üîÑ allBlastHoles:", allBlastHoles);
				console.log("üîÑ selectedHole:", selectedHole);
			}

			// Redraw to apply changes
			drawData(allBlastHoles);
		});

		// Step 12) Set initial state (2D visible by default for faster startup and smoother UX)
		// Starting in 2D mode avoids choppy 3D navigation on initial load
		dimension2D3DBtn.checked = false;
		dimension2D3DBtn.dispatchEvent(new Event("change"));
	}

	// Step 13) Setup 3D Settings button
	const dimension2D3DSettingsBtn = document.getElementById("dimension2D-3D-SettingsBtn");
	if (dimension2D3DSettingsBtn) {
		dimension2D3DSettingsBtn.addEventListener("change", function () {
			if (this.checked) {
				// Step 13a) Show settings dialog
				if (window.show3DSettingsDialog) {
					window.show3DSettingsDialog();
				} else {
					console.warn("üö® 3D Settings Dialog not loaded");
				}
				// Step 13b) Uncheck button after dialog is shown (dialog handles its own state)
				setTimeout(() => {
					this.checked = false;
				}, 100);
			}
		});
	}
});

const ctx = canvas.getContext("2d");
// Expose ctx and canvas globally for canvas2DDrawing.js module
window.ctx = ctx;
window.canvas = canvas;

let scale = 5; // adjust the scale to fit the allBlastHoles in the canvas
let fontSize = document.getElementById("fontSlider").value;
//TODO Eventually use this class for all holes.
class BlastHole {
	/**
	 * The BlastHole class is used to store the data for a blast hole.
	 * 
	 * @param {*} data 
	 * @param {string} entityName - The entity name
	 * @param {string} entityType - The entity type (default: "hole")
	 * @param {*} holeID - The hole identifier
	 * @param {number} startXLocation - The start X location
	 * @param {number} startYLocation - The start Y location
	 * @param {number} startZLocation - The start Z location
	 * @param {number} endXLocation - The end X location
	 * @param {number} endYLocation - The end Y location
	 * @param {number} endZLocation - The end Z location
	 * @param {number} gradeXLocation - The grade X location
	 * @param {number} gradeYLocation - The grade Y location
	 * @param {number} gradeZLocation - The grade Z location
	 * @param {number} subdrillAmount - The subdrill amount (deltaZ of gradeZ to toeZ -> downhole =+ve uphole =-ve)
	 * @param {number} subdrillLength - The subdrill length (distance of subdrill from gradeXYZ to toeXYZ -> downhole =+ve uphole =-ve)
	 * @param {number} benchHeight - The bench height (deltaZ of collarZ to gradeZ -> always Absolute)
	 * @param {number} holeDiameter - The hole diameter
	 * @param {string} holeType - The hole type
	 * @param {string} fromHoleID - The from hole identifier
	 * @param {number} timingDelayMilliseconds - The timing delay in milliseconds
	 * @param {string} colorHexDecimal - The color in hex decimal format
	 * @param {number} holeLengthCalculated - The calculated hole length (Distance from the collarXYZ to the ToeXYZ)
	 * @param {number} holeAngle - The hole angle from Collar to Toe (0¬∞ = Vertical) --> 0¬∞ = Vertical, 90¬∞ = Horizontal, 180¬∞ = Inverted, 270¬∞ = Upside Down
	 * @param {number} holeBearing - The hole bearing
	 * @param {number} holeTime - The initiation time (holeTime and initiationTime are the same)
	 * @param {number} measuredLength - The measured length
	 * @param {string} measuredLengthTimeStamp - The measured length timestamp
	 * @param {number} measuredMass - The measured mass
	 * @param {string} measuredMassTimeStamp - The measured mass timestamp
	 * @param {string} measuredComment - The measured comment
	 * @param {string} measuredCommentTimeStamp - The measured comment timestamp
	 * @param {*} rowID - The row identifier
	 * @param {*} posID - The position identifier
	 * @param {number} burden - The burden
	 * @param {number} spacing - The spacing
	 * @param {number} connectorCurve - The connector curve
	 * @param {boolean} visible - The visibility flag
	 * future properties:
	 * @params {colorHexDecimal} holeColor - The color of the hole
	 * @params {string} holeMarkerShape - The shape of the hole marker shape at collar - currently X for Dummy(no depth hole), square for no diameter hole and circle for a diameter hole
	 * @params {float} holeMarkerSize - The size of the hole marker shape at collar - currently controlled by holescale and diameter.
	 */


	constructor(data = {}) {
		this.entityName = data.entityName || "";
		this.entityType = data.entityType || "hole";
		this.holeID = data.holeID || null;
		this.startXLocation = data.startXLocation || 0;
		this.startYLocation = data.startYLocation || 0;
		this.startZLocation = data.startZLocation || 0;
		this.endXLocation = data.endXLocation || 0;
		this.endYLocation = data.endYLocation || 0;
		this.endZLocation = data.endZLocation || 0;
		this.gradeXLocation = data.gradeXLocation || 0;
		this.gradeYLocation = data.gradeYLocation || 0;
		this.gradeZLocation = data.gradeZLocation || 0;
		this.subdrillAmount = data.subdrillAmount || 0; //deltaZ of gradeZ to toeZ -> downhole =+ve uphole =-ve
		this.subdrillLength = data.subdrillLength || 0; //distance of subdrill from gradeXYZ to toeXYZ -> downhole =+ve uphole =-ve
		this.benchHeight = data.benchHeight || 0; //deltaZ of collarZ to gradeZ -> always Absolute
		this.holeDiameter = data.holeDiameter || 115;
		this.holeType = data.holeType || "Undefined";
		this.fromHoleID = data.fromHoleID || "";
		this.timingDelayMilliseconds = data.timingDelayMilliseconds || 0;
		this.colorHexDecimal = data.colorHexDecimal || "red";
		this.holeTime = data.holeTime || 0; //initiation time and holrTime are the same
		this.holeLengthCalculated = data.holeLengthCalculated || 0; //Distance from the collarXYZ to the ToeXYZ
		this.holeAngle = data.holeAngle || 0; //Angle of the blast hole from Collar to Toe --> 0¬∞ = Vertical
		this.holeBearing = data.holeBearing || 0;
		this.measuredLength = data.measuredLength || 0;
		this.measuredLengthTimeStamp = data.measuredLengthTimeStamp || "09/05/1975 00:00:00";
		this.measuredMass = data.measuredMass || 0;
		this.measuredMassTimeStamp = data.measuredMassTimeStamp || "09/05/1975 00:00:00";
		this.measuredComment = data.measuredComment || "None";
		this.measuredCommentTimeStamp = data.measuredCommentTimeStamp || "09/05/1975 00:00:00";
		this.rowID = data.rowID || null;
		this.posID = data.posID || null;
		this.visible = data.visible !== false;
		this.burden = data.burden || 1;
		this.spacing = data.spacing || 1;
		this.connectorCurve = data.connectorCurve || 0;
	}
}

let allBlastHoles = [];
let dxfEntities = [];
let countAllBlastHoles = allBlastHoles.length;
let sumMeters = 0;
let currentScale = scale; // declare a variable to store the current scale
let currentFontSize = fontSize; // declare a variable to store the current font size
let toeScale = document.getElementById("toeSlider").value;
let holeScale = document.getElementById("holeSlider").value;
let deltaX = 0;
let deltaY = 0;
let centroidX = 0;
let centroidY = 0;
let centroidZ = 0;
let firstPointInLine = null;
let blastNameValue = "";
let currentEntityName = "";

// Group visibility flags
let blastGroupVisible = true;
let drawingsGroupVisible = true;
let surfacesGroupVisible = true;
let imagesGroupVisible = true;
// Drawing sub-group visibility flags
let pointsGroupVisible = true;
let linesGroupVisible = true;
let polygonsGroupVisible = true;
let circlesGroupVisible = true;
let textsGroupVisible = true;

// Forward declarations for functions/variables defined later in the file
// These prevent "not defined" errors when used early
let contourOverlayCanvas = null;
let contourOverlayCtx = null;
// debouncedUpdateTreeView is defined later at line ~41322 with proper debouncing
let debouncedUpdateTreeView;

// Function to update TreeView when holes are added
window.updateTreeFromBlastHoles = function () {
	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}
};

// Variable to store the "fromHole" ID during connector mode
let fromHoleStore = null;
let mouseIndicatorInitialized = false; // Track if mouse indicator has been initialized on startup
let isAddingConnector = false;
let isAddingMultiConnector = false;

let isAddingPoint = false;
let isAddingLine = false;
let isAddingPoly = false;
let isAddingCircle = false;
let isAddingText = false;
let isAssignSurfaceActive = false;
let isAssignGradeActive = false;
let isOffsetKADActive = false;
let isRadiiHolesOrKADActive = false;
let isRulerToolActive = false;
let isRulerProtractorToolActive = false;
let startPanX, startPanY;

let isAddingHole = false;
let isAddingPattern = false;
let isDeletingHole = false;
let isDeletingPattern = false;
let isMovingCanvas = false;
let isDragging = false;
let isModifyingKAD = false;
let entityName; // Define entityName outside the function to persist between calls
let createNewEntity = true; // Flag to create a new entity
// Variables to store the initial mouse position during canvas movement
let lastMouseX = 0;
let lastMouseY = 0;
let initialMouseX = 0;
let initialMouseY = 0;
let touchStartX,
	touchStartY = 0;
// Add current mouse tracking for interactive previews
let currentMouseCanvasX = 0;
let currentMouseCanvasY = 0;
let currentMouseCanvasZ = document.getElementById("drawingElevation").value;
let currentMouseWorldX = 0;
let currentMouseWorldY = 0;
let currentMouseWorldZ = document.getElementById("drawingElevation").value;
// Step #) Store view-plane mouse position for stadium zone (follows cursor in 3D)
let currentMouseIndicatorX = 0;
let currentMouseIndicatorY = 0;
let currentMouseIndicatorZ = 0;
// Surfaces
let allAvailableSurfaces = [];
let intervalAmount = document.getElementById("intervalSlider").value;
let firstMovementSize = document.getElementById("firstMovementSlider").value;
let connectAmount = document.getElementById("connectSlider").value;
let contourLevel = 0;
let contourUpdatePending = false;
let clipperUnionWarned = false; // Flag to prevent console spam for Clipper union warnings
let minX;
let minY;
let worldX = null;
let worldY = null;
let worldZ = null;
let contourLines = [];
let contourLinesArray = [];
let directionArrows = [];
let epsilon = 1;

// Contour caching - only recalculate when hole positions/times change
let cachedContourHash = null;
let cachedContourLinesArray = [];
let cachedDirectionArrows = [];
let holeTimes = {};
let deleteRenumberStart = document.getElementById("deleteRenumberStart").value;
let firstSelectedHole = null;
let secondSelectedHole = null;
let selectedHole = null;
let isBlastNameEditing = false;
let isHoleEditing = false;
let isSelectionPointerActive = false;
let polyPointsX = [];
let polyPointsY = [];
let isPolygonSelectionActive = false;
let useToeLocation = false;
let selectedVoronoiMetric = "powderFactor"; // default
// Add these variables near the top (around line 190)
let lastKADDrawPoint = null; // Store the last drawn point from any KAD tool
let isVoronoiLegendFixed = false;
let isBearingToolActive = false;

// Add this declaration around line 99 (after bearingToolSelectedHole declaration)
let bearingToolSelectedHole = null;
let moveToolSelectedHole = null; // Add this declaration
let bearingToolStartAngle = 0;
let bearingToolStartMouseAngle = 0;
let isDraggingBearing = false;
let rulerStartPoint = null;
let rulerEndPoint = null;
let rulerProtractorPoints = []; // For 3-point bearing measurement
let isRulerActive = false;
let isRulerProtractorActive = false;
let isLengthPopupEditing = false;
let isDisplayingContours = false;
let isDisplayingSlopeTriangles = false;
let isDisplayingReliefTriangles = false;
let isDisplayingDirectionArrows = false;
let isTypeEditing = false;
let fixToeLocation = false;
// Add these missing global variable declarations
let imageVisible = false;
let surfaceVisible = false;
//drawing tool booleans
let isDrawingPoint = false;
let isDrawingLine = false;
let isDrawingCircle = false;
let isDrawingPoly = false;
let isDrawingText = false;

let selectedKADObject = null;
let selectedKADPolygon = null;
let selectedKADPoint = null;
let selectedKADLine = null;
let selectedKADCircle = null;
let selectedKADText = null;

let isAddKADLineToolActive = false;
let isAddKADPolygonToolActive = false;
let isAddKADPointsToolActive = false;
let isAddKADCircleToolActive = false;
let isAddKADTextToolActive = false;
let isTriangulateToolActive = false;

//delete tool booleans
let isDeletingKAD = false;
//modify tool booleans
let isModifyingPoint = false;
//offset tool booleans
let isOffsetLinePoly = false;
//offset kad tool booleans
let isOffsetKAD = false;

// Step #) OFFSET PREVIEW STATE - Live preview for offset dialog
// These variables store the preview data for real-time visualization
let offsetPreviewEnabled = false;
let offsetPreviewOriginalEntity = null;
let offsetPreviewEntities = []; // Array of preview offset results (not saved to map)
let offsetPreviewParams = {}; // Current preview parameters

//radii holes or kads tool booleans
let isRadiiHolesOrKADs = false;
//Record Measurements booleans
let isMeasureRecording = false;
// PolyLine select for use in tools
let selectedVertices = [];
let isSelectingPolyline = false;
//has selected multiple holes
let hasSelectedMultipleHoles = false;
let isMultiHoleSelectionEnabled = false; // Selection mode is false if single ONLY hole selection on each click and true when each click adds a hole to the selection.  It does not indicate that selection is active or inactive.
let isMoveToolActive = false;
let isMovingHole = false;
let holeToMove = null;
// Step 1) Move Tool 3D mode tracking variables
let moveToolIn3DMode = false; // Track if move tool is in 3D mode
let dragPlaneZ = 0; // Z elevation of plane for 3D raycasting
let justFinishedDragging = false; // Flag to prevent click event after drag
let dragInitialKADPositions = null; // Initial positions for multiple KAD points

let maxEdgeLength = 15;
let clickedHole; // Declare clickedHole outside the event listener
let timingWindowHolesSelected = [];
let selectedMultipleHoles = [];
let selectedPoint = null; // Global selectedPoint declaration
let selectedMultiplePoints = [];
let selectedMultipleKADObjects = []; // Array to store multiple selected KAD objects
let isMultiKADSelectionEnabled = false; // Flag for multi-KAD selection mode
// Add this global flag at the top of your file (near other globals like snapEnabled)
let isSelfSnapEnabled = false; // Tracks if 'S' is held down
// Step 4) Move tool state for KAD vertices
let moveToolSelectedKAD = null;
let moveToolKADOriginalZ = 0;
let toeSizeInMeters = 1;
let connScale = 1;
let isPlaying = false; // To track whether the animation is playing
let animationInterval; // To store the interval ID for the animation
let animationFrameId = null; // To store the requestAnimationFrame ID for smooth animation
let playSpeed = 1; // Default play speed
//COLOURS
let noneColor = "rgba(0, 0, 0, 0)";
// Step 1) Initialize darkModeEnabled from localStorage BEFORE setting colors
let darkModeEnabled = localStorage.getItem("darkMode") === "true" || document.body.classList.contains("dark-mode");
console.log("üåô Dark mode detected on init:", darkModeEnabled, "from localStorage:", localStorage.getItem("darkMode"));
// Step 2) Set colors correctly based on dark mode
let transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
let fillColor = darkModeEnabled ? "darkgrey" : "lightgrey"; // FIXED: was backwards
let strokeColor = darkModeEnabled ? "white" : "black";
let textFillColor = darkModeEnabled ? "white" : "black";
let depthColor = darkModeEnabled ? "cyan" : "blue"; // FIXED: was backwards
let angleDipColor = darkModeEnabled ? "orange" : "darkorange"; // FIXED: was backwards

///////////////////////////
//DEVELOPER MODE BUTTON
const developerModeCheckbox = document.getElementById("developerMode");
let developerModeEnabled = false;
developerModeCheckbox.addEventListener("change", function () {
	developerModeEnabled = developerModeCheckbox.checked;
	console.log("Developer mode enabled:", developerModeEnabled);
});
///////////////////////////

///////////////////////////
// PERFORMANCE MONITOR TOGGLE
// Step PM1) Get checkbox element
const perfMonitorCheckbox = document.getElementById("perfMonitorEnabled");
let perfMonitorEnabled = false;

// Step PM2) Performance monitor instance (lazy loaded)
let perfMonitor = null;

// Step PM3) Add event listener
if (perfMonitorCheckbox) {
	perfMonitorCheckbox.addEventListener("change", function () {
		perfMonitorEnabled = perfMonitorCheckbox.checked;
		window.perfMonitorEnabled = perfMonitorEnabled;
		console.log("Performance Monitor " + (perfMonitorEnabled ? "enabled" : "disabled"));

		// Step PM4) Toggle performance monitor overlay
		if (perfMonitorEnabled) {
			// Lazy load and show
			if (!perfMonitor && window.threeRenderer) {
				// Use the already imported getPerformanceMonitor
				perfMonitor = getPerformanceMonitor(window.threeRenderer);
				perfMonitor.show();
				// Expose for debugging
				window.perfMonitor = perfMonitor;
			} else if (perfMonitor) {
				// Update renderer reference if changed
				if (window.threeRenderer) {
					perfMonitor.setRenderer(window.threeRenderer);
				}
				perfMonitor.show();
			}
		} else {
			// Hide
			if (perfMonitor) {
				perfMonitor.hide();
			}
		}
	});
}

// Step PM5) Expose flag for other modules
window.perfMonitorEnabled = perfMonitorEnabled;
///////////////////////////

///////////////////////////
// 3D OPTIMIZATION FLAGS
// Step 1) Get checkbox elements for 3D optimization options
var use3DSimplificationCheckbox = document.getElementById("use3DSimplification");
var useInstancedHolesCheckbox = document.getElementById("useInstancedHoles");

// Step 2) Initialize global flags (default values match HTML checked states)
var use3DSimplification = use3DSimplificationCheckbox ? use3DSimplificationCheckbox.checked : true;
var useInstancedHoles = useInstancedHolesCheckbox ? useInstancedHolesCheckbox.checked : false;

// Step 3) Expose to window for access from other modules
window.use3DSimplification = use3DSimplification;
window.useInstancedHoles = useInstancedHoles;

// Step 4) Add event listeners to sync checkbox changes
if (use3DSimplificationCheckbox) {
	use3DSimplificationCheckbox.addEventListener("change", function () {
		use3DSimplification = this.checked;
		window.use3DSimplification = use3DSimplification;
		console.log("3D Simplification " + (use3DSimplification ? "enabled" : "disabled"));
		// Trigger redraw to apply change
		if (typeof redraw === "function") {
			redraw();
		}
	});
}

if (useInstancedHolesCheckbox) {
	useInstancedHolesCheckbox.addEventListener("change", function () {
		useInstancedHoles = this.checked;
		window.useInstancedHoles = useInstancedHoles;
		console.log("Instanced Holes " + (useInstancedHoles ? "enabled" : "disabled"));
		// Trigger redraw to apply change
		if (typeof redraw === "function") {
			redraw();
		}
	});
}

// Step 5) 3D Renderer Selection (dropdown)
// NOTE: window.rendererSelection is already set from localStorage at top of file
// This code syncs the dropdown with the saved preference
const rendererSelect = document.getElementById("rendererSelect");
if (rendererSelect) {
	// Sync dropdown with saved preference
	rendererSelect.value = window.rendererSelection || "v2";

	// Add event listener for selection change
	rendererSelect.addEventListener("change", function () {
		const newValue = this.value;
		window.rendererSelection = newValue;
		localStorage.setItem("rendererSelection", newValue);

		const names = { v1: "V1 (Legacy)", v2: "V2 (Stable)", perf: "Performance" };
		console.log("üîÑ Renderer changed to:", names[newValue]);
		console.log("‚ö†Ô∏è Reload page to apply change");

		// Show user prompt to reload
		if (confirm("Switch to " + names[newValue] + " renderer?\n\nThis requires reloading the page.\nClick OK to reload now, Cancel to reload later.")) {
			location.reload();
		}
	});
}

///////////////////////////

//Switches
const addConnectorButton = document.getElementById("addConnectorButton");
const addMultiConnectorButton = document.getElementById("addMultiConnectorButton");
const addPatternSwitch = document.getElementById("addPatternSwitch");
const addHoleSwitch = document.getElementById("addHoleSwitch");

const editLengthPopupSwitch = document.getElementById("editLengthPopupButton");
const editHoleTypePopupSwitch = document.getElementById("editHoleTypePopupButton");

const editBlastNameSwitch = document.getElementById("editBlastNameButton");
// const editDiameterSwitch = document.getElementById("editDiameterButton");
const deleteHoleSwitch = document.getElementById("deleteHoleSwitch");
const modifyKADSwitch = document.getElementById("modifyKADDraw");
const offsetKADButton = document.getElementById("offsetKADTool");
const radiiHolesOrKADsButton = document.getElementById("radiiHolesOrKADsTool");
const selectionModeButton = document.getElementById("selectionModeButton");
const editHolesToggle = document.getElementById("editHolesToggle"); //required to be true if holes are to be fine tuned

// Drawing Switch Event Listeners
const addPointDraw = document.getElementById("addPointDraw");
const addLineDraw = document.getElementById("addLineDraw");
const addCircleDraw = document.getElementById("addCircleDraw");
const addPolyDraw = document.getElementById("addPolyDraw");
const addTextDraw = document.getElementById("addTextDraw");
// Delete Drawing Switch Event Listeners
const deleteKADDraw = document.getElementById("deleteKADDraw");
//Record Measurements Switch Event Listeners
const measuredLengthSwitch = document.getElementById("measuredLengthSwitch");
const measuredMassSwitch = document.getElementById("measuredMassSwitch");
const measuredCommentSwitch = document.getElementById("measuredCommentSwitch");

//switch Options - Do not include in switches array
const renumberStartListener = document.getElementById("deleteRenumberStart");
const renumberHoles = document.getElementById("renumberHoles");
let isRenumberingHoles = false;

const switches = [addConnectorButton, addMultiConnectorButton, addPatternSwitch, addHoleSwitch, editLengthPopupSwitch, editBlastNameSwitch, deleteHoleSwitch, modifyKADSwitch, editHoleTypePopupSwitch, addPointDraw, addLineDraw, addCircleDraw, addPolyDraw, addTextDraw, deleteKADDraw, measuredLengthSwitch, measuredMassSwitch, measuredCommentSwitch, selectionModeButton, editHolesToggle];

const booleans = [
	isAddingConnector,
	isAddingMultiConnector,
	isAddingHole,
	isAddingPattern,
	isDeletingHole,
	isMovingCanvas,
	isDragging,
	isBlastNameEditing,
	isHoleEditing,
	isLengthPopupEditing,
	isDisplayingContours,
	isDisplayingSlopeTriangles,
	isDisplayingReliefTriangles,
	isDisplayingDirectionArrows,
	isTypeEditing,
	isDrawingPoint,
	isDrawingLine,
	isDrawingCircle,
	isDrawingPoly,
	isDrawingText,
	isDeletingKAD,
	isPlaying,
	isModifyingPoint,
	isOffsetLinePoly,
	isMeasureRecording,
	isMultiHoleSelectionEnabled, //check this
];

// Boolean set to False
function setAllBoolsToFalse() {
	isAddingConnector = false;
	isAddingMultiConnector = false;
	isAddingHole = false;
	isAddingPattern = false;
	isDeletingHole = false;
	isMovingCanvas = false;
	isDragging = false;
	isBlastNameEditing = false;
	isHoleEditing = false;
	isLengthPopupEditing = false;
	isDisplayingContours = false;
	isDisplayingSlopeTriangles = false;
	isDisplayingReliefTriangles = false;
	isDisplayingDirectionArrows = false;
	isTypeEditing = false;
	isDrawingPoint = false;
	isDrawingLine = false;
	isDrawingCircle = false;
	isDrawingPoly = false;
	isDrawingText = false;
	isDeletingKAD = false;
	isPlaying = false;
	isModifyingPoint = false;
	isOffsetLinePoly = false;
	isMeasureRecording = false;
	isMultiHoleSelectionEnabled = false;
	isMoveToolActive = false;
	window.isMoveToolActive = false;
	isMovingHole = false;

	// CRITICAL FIX: Remove move tool event listeners when deactivating
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Also clear move tool state variables
	moveToolSelectedHole = null;

	// Hide drawing distance panel when tools are deactivated
	hideDrawingDistance();
	isDraggingHole = false;

	// Remove bearing tool listeners too
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);

	// Clear bearing tool state
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
}

// Function 2: Reset all switches and toggles
function resetSwitchesTogglesOptionalDisplay(resetDisplayOptions) {
	// Reset all switches
	const allSwitches = [
		"addConnectorSwitch",
		"addMultiConnectorSwitch",
		"addHoleSwitch",
		"addPatternSwitch",
		"deleteHoleSwitch",
		"renumberHoles",
		"editBlastNameSwitch",
		"editHoleSwitch",
		"editLengthPopupSwitch",
		"editTypePopupSwitch",
		"selectionModeSwitch",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"addPointDraw",
		"addLineDraw",
		"addCircleDraw",
		"addPolyDraw",
		"addTextDraw",
		"deleteKADDraw",
		"measuredLengthSwitch",
		"measuredMassSwitch",
		"measuredCommentSwitch",
		"selectionModeButton",
		"editHolesToggle",
	];

	allSwitches.forEach((switchId) => {
		const switchElement = document.getElementById(switchId);
		if (switchElement) {
			switchElement.checked = false;
		}
	});

	if (resetDisplayOptions) {
		// Reset display options toggles
		allToggles.forEach((toggle) => {
			if (toggle) {
				toggle.checked = false;
			}
		});
	}
}

// Function 3: Reset all selected stores and state variables
function resetAllSelectedStores() {
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	firstSelectedHole = null;
	secondSelectedHole = null;
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	clickedHole = null;
	timingWindowHolesSelected = [];

	// Reset pattern tool variables
	selectedPolygon = null;
	selectedPolyline = null;
	patternStartPoint = null;
	patternEndPoint = null;
	patternReferencePoint = null;

	// Reset line tool variables
	lineStartPoint = null;
	lineEndPoint = null;

	// Reset poly line tool variables
	polylineStartPoint = null;
	polylineEndPoint = null;

	// Reset any other state variables
	blastNameValue = "";
	currentEntityName = "";

	console.log("üßπ All selected stores and pattern states reset");
}

/**
 * Removes event listeners for various tools, with option to exclude specific tools
 *
 * @param {string|string[]} [excluding=[]] - Tool(s) to exclude from listener removal
 * Possible exclusion values include:
 * - "moveToTool", "bearingTool", "tieConnectTool", "tieConnectMultiTool", "lineDrawing", "polygonDrawing", "pointDrawing", "textDrawing", "circleDrawing", "rulerTool", "rulerProtractorTool", "selectPointerTool", "selectByPolygonTool", "addingHoleSwitch", "addingPatternSwitch", "patternInPolygonTool", "holesAlongLineTool", "holesAlongPolyLineTool", "measuredLengthClick", "measuredMassClick", "measuredCommentClick", "editBlastNameClick", "editLengthWithPopupClick", "editHoleTypeClick", "defaultListeners"
 */
function removeEventListenersExcluding(excluding = []) {
	console.log("Removing event listeners excluding: ", excluding);
	// Convert single string to array for consistency
	if (typeof excluding === "string") {
		excluding = [excluding];
	}

	// Remove move tool listeners
	if (!excluding.includes("moveToTool")) {
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		document.removeEventListener("mousemove", handleMoveToolMouseMove);
		document.removeEventListener("touchmove", handleMoveToolMouseMove);
		moveToolSelectedHole = null;
		isDraggingHole = false;
	}

	// Remove bearing tool listeners
	if (!excluding.includes("bearingTool")) {
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		document.removeEventListener("mousemove", handleBearingToolMouseMove);
		document.removeEventListener("touchmove", handleBearingToolMouseMove);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}

	// Remove connector tool listeners
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Remove drawing tool listeners
	if (!excluding.includes("lineDrawing")) {
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		isDrawingLine = false;
		createNewEntity = true;
		lastKADDrawPoint = null; // Step #) Clear last draw point to prevent stale leading lines
	}

	// Remove polygon drawing listeners
	if (!excluding.includes("polygonDrawing")) {
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		isDrawingPoly = false;
		createNewEntity = true;
		lastKADDrawPoint = null; // Step #) Clear last draw point to prevent stale leading lines
	}

	// Remove point drawing listeners
	if (!excluding.includes("pointDrawing")) {
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		isDrawingPoint = false;
		createNewEntity = true;
		lastKADDrawPoint = null; // Step #) Clear last draw point to prevent stale leading lines
	}

	// Remove text drawing listeners
	if (!excluding.includes("textDrawing")) {
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		isDrawingText = false;
		createNewEntity = true;
		lastKADDrawPoint = null; // Step #) Clear last draw point to prevent stale leading lines
	}

	// Remove circle drawing listeners
	if (!excluding.includes("circleDrawing")) {
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		isDrawingCircle = false;
		createNewEntity = true;
		lastKADDrawPoint = null; // Step #) Clear last draw point to prevent stale leading lines
	}

	// Remove ruler tool listeners
	if (!excluding.includes("rulerTool")) {
		canvas.removeEventListener("click", handleRulerClick);
		canvas.removeEventListener("touchstart", handleRulerClick);
		rulerStartPoint = null;
		rulerEndPoint = null;
		hideRulerPanel(); // Step #) Hide CSS ruler panel when tool is removed
	}

	// Remove ruler protractor listeners
	if (!excluding.includes("rulerProtractorTool")) {
		canvas.removeEventListener("click", handleRulerProtractorClick);
		canvas.removeEventListener("touchstart", handleRulerProtractorClick);
		rulerProtractorPoints = [];
		hideProtractorPanel(); // Step #) Hide CSS protractor panel when tool is removed
	}

	// Remove selection tool listeners
	if (!excluding.includes("selectPointerTool")) {
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		isSelectionPointerActive = false;
	}

	// Remove polygon selection listeners
	if (!excluding.includes("selectByPolygonTool")) {
		// Remove polygon listeners
		canvas.removeEventListener("click", selectInsidePolygon);
		canvas.removeEventListener("dblclick", completePolygonSelection);
		canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
		canvas.removeEventListener("mousemove", handlePolygonMouseMove);
		document.removeEventListener("mousemove", handlePolygonMouseMove);
		isPolygonSelectionActive = false;
	}

	// Remove the adding Pattern Listener
	if (!excluding.includes("addingPatternSwitch")) {
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		isAddingPattern = false;
	}

	// Remove the adding hole listener
	if (!excluding.includes("addingHoleSwitch")) {
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		isAddingHole = false;
	}

	// Remove pattern in polygon listeners
	if (!excluding.includes("patternInPolygonTool")) {
		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);
		isPatternInPolygonActive = false;
	}

	// Remove holes along line listeners
	if (!excluding.includes("holesAlongLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);
		isHolesAlongLineActive = false;
	}

	// Remove holes along poly line listeners
	if (!excluding.includes("holesAlongPolyLineTool")) {
		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);
		isHolesAlongPolyLineActive = false;
	}

	// Hide pattern tool HUD labels when any pattern tool is deactivated
	if (!excluding.includes("patternInPolygonTool") || !excluding.includes("holesAlongLineTool") || !excluding.includes("holesAlongPolyLineTool")) {
		hidePatternToolLabels();
	}

	// Remove measured length click listeners
	if (!excluding.includes("measuredLengthClick")) {
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
	}

	// Remove measured mass click listeners
	if (!excluding.includes("measuredMassClick")) {
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
	}

	// Remove measured comment click listeners
	if (!excluding.includes("measuredCommentClick")) {
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
	}

	// Remove edit blast name click listeners
	if (!excluding.includes("editBlastNameClick")) {
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
	}

	// Remove edit length with popup click listeners
	if (!excluding.includes("editLengthWithPopupClick")) {
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
	}

	// Remove edit hole type click listeners
	if (!excluding.includes("editHoleTypeClick")) {
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
	}

	// ? IMPORTANT: NEVER remove handleMouseMove or handleTouchMove here
	// These are intended to be persistent for basic mouse/touch tracking.
	if (!excluding.includes("defaultListeners")) {
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Do NOT remove handleMouseMove or handleTouchMove here!
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// document.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		// document.removeEventListener("touchmove", handleTouchMove);
	}

	// Reset tool-specific state variables that aren't excluded
	if (!excluding.includes("tieConnectTool") && !excluding.includes("tieConnectMultiTool")) {
		isAddingConnector = false;
		isAddingMultiConnector = false;
		firstSelectedHole = null;
		secondSelectedHole = null;
	}

	// Reset drawing states if not excluded
	if (!excluding.includes("lineDrawing") && !excluding.includes("polygonDrawing") && !excluding.includes("pointDrawing") && !excluding.includes("textDrawing") && !excluding.includes("circleDrawing")) {
		createNewEntity = true;
	}
}

// Add a centralized function to clear all selection state
function clearAllSelectionState() {
	// Clear individual selections
	selectedPoint = null;
	selectedHole = null;
	selectedKADObject = null;
	selectedKADPolygon = null;
	selectedMultipleKADObjects = []; // Add this line
	// Clear multiple selections (with null safety)
	if (selectedMultipleHoles) {
		selectedMultipleHoles.length = 0; // Clear array but keep reference?
	} else {
		selectedMultipleHoles = [];
	}

	// Clear selected multiple KAD objects
	if (selectedMultipleKADObjects) {
		selectedMultipleKADObjects.length = 0;
	} else {
		selectedMultipleKADObjects = [];
	}

	// Clear timing window holes selected
	if (timingWindowHolesSelected) {
		timingWindowHolesSelected.length = 0;
	} else {
		timingWindowHolesSelected = [];
	}

	console.log("üßπ All selection state cleared");
}

// Step 7a) Function for TreeView to set selection state (bypasses window.* overwrite issue)
function setSelectionFromTreeView(selectionState) {
	// TreeView calls this instead of setting window.* directly
	// This ensures the local module variables are updated before exposeGlobalsToWindow() runs
	if (selectionState.selectedHole !== undefined) {
		selectedHole = selectionState.selectedHole;
	}
	if (selectionState.selectedMultipleHoles !== undefined) {
		selectedMultipleHoles = selectionState.selectedMultipleHoles;
	}
	if (selectionState.selectedKADObject !== undefined) {
		selectedKADObject = selectionState.selectedKADObject;
	}
	if (selectionState.selectedMultipleKADObjects !== undefined) {
		selectedMultipleKADObjects = selectionState.selectedMultipleKADObjects;
	}
	if (selectionState.selectedPoint !== undefined) {
		selectedPoint = selectionState.selectedPoint;
	}
	if (selectionState.selectedMultiplePoints !== undefined) {
		selectedMultiplePoints = selectionState.selectedMultiplePoints;
	}

	console.log("üìä [TreeView] Selection state updated:", {
		selectedKADObject: selectedKADObject ? selectedKADObject.entityName : null,
		selectedPoint: selectedPoint ? selectedPoint.pointID : null
	});
}

// Update resetFloatingToolbarButtons to only clear floating toolbar related booleans
function resetFloatingToolbarButtons(excluding) {
	// Clear only floating toolbar tool states
	isSelectionPointerActive = false;
	isPolygonSelectionActive = false;
	isHolesAlongPolyLineActive = false;
	isHolesAlongLineActive = false;
	isMoveToolActive = false;
	window.isMoveToolActive = false;
	isBearingToolActive = false;
	isRulerActive = false;
	isRulerProtractorActive = false;

	// ALSO clear connector tool states when switching floating toolbar tools
	isAddingConnector = false;
	isAddingMultiConnector = false;

	// CRITICAL: Remove move and bearing tool listeners when switching away
	if (excluding !== "moveToTool") {
		// Remove the 2D move tool listeners
		canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
		canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
		canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
		canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
		canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
		canvas.removeEventListener("touchend", handleMoveToolMouseUp);

		//ALSO Remove from 3Dcanvas if it exists
		const threeCanvas = threeRenderer ? threeRenderer.getCanvas() : null;
		if (threeCanvas) {
			threeCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
			threeCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
			threeCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			threeCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			threeCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			threeCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		//clear move tool state
		moveToolSelectedHole = null;
		moveToolSelectedKAD = null;
		isDraggingHole = false;
		window.isdraggingHole = false;
		moveToolIn3DMode = false;
		dragPlaneZ = 0;
	}

	if (excluding !== "bearingTool") {
		// Remove the 2D bearing tool listeners
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
	}
	// Set all tool checkboxes to false except the excluded one
	selectPointerTool.checked = excluding === "selectPointerTool";
	selectByPolygonTool.checked = excluding === "selectByPolygonTool";
	moveToTool.checked = excluding === "moveToTool";
	tieConnectTool.checked = excluding === "tieConnectTool";
	tieConnectMultiTool.checked = excluding === "tieConnectMultiTool";
	addKADPointsTool.checked = excluding === "addKADPointsTool";
	addKADLineTool.checked = excluding === "addKADLineTool";
	addKADPolygonTool.checked = excluding === "addKADPolygonTool";
	addKADCircleTool.checked = excluding === "addKADCircleTool";
	addKADTextTool.checked = excluding === "addKADTextTool";
	triangulateTool.checked = excluding === "triangulateTool";
	bearingTool.checked = excluding === "bearingTool";
	rulerTool.checked = excluding === "rulerTool";
	rulerProtractorTool.checked = excluding === "rulerProtractorTool";
	patternInPolygonTool.checked = excluding === "patternInPolygonTool";
	holesAlongLineTool.checked = excluding === "holesAlongLineTool";
	holesAlongPolyLineTool.checked = excluding === "holesAlongPolyLineTool";
	// Step #) Sync holesAddingTool with null check (declared later in code)
	var holesAddingToolRef = document.getElementById("holesAddingTool");
	if (holesAddingToolRef) holesAddingToolRef.checked = excluding === "holesAddingTool";

	// ALSO uncheck connector buttons when switching floating toolbar tools
	if (excluding !== "tieConnectTool") {
		addConnectorButton.checked = false;
	}
	if (excluding !== "tieConnectMultiTool") {
		addMultiConnectorButton.checked = false;
	}
	// Step #) ALSO uncheck addHoleSwitch when switching away from holesAddingTool
	if (excluding !== "holesAddingTool") {
		addHoleSwitch.checked = false;
		isAddingHole = false;
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
	}

	// Set only the excluded tool's active state to true
	isSelectionPointerActive = excluding === "selectPointerTool";
	isPolygonSelectionActive = excluding === "selectByPolygonTool";
	isPatternInPolygonActive = excluding === "patternInPolygonTool";
	isHolesAlongLineActive = excluding === "holesAlongLineTool";
	isHolesAlongPolyLineActive = excluding === "holesAlongPolyLineTool";
	isMoveToolActive = excluding === "moveToTool";
	isBearingToolActive = excluding === "bearingTool";
	isRulerActive = excluding === "rulerTool";
	isRulerProtractorActive = excluding === "rulerProtractorTool";
	isAddKADPointsToolActive = excluding === "addKADPointsTool";
	isAddKADLineToolActive = excluding === "addKADLineTool";
	isAddKADPolygonToolActive = excluding === "addKADPolygonTool";
	isAddKADCircleToolActive = excluding === "addKADCircleTool";
	isAddKADTextToolActive = excluding === "addKADTextTool";
	isTriangulateToolActive = excluding === "triangulateTool";

	// Reset floating toolbar tool-specific state variables
	rulerStartPoint = null;
	rulerEndPoint = null;
	rulerProtractorPoints = [];
	hideRulerPanel(); // Step #) Hide CSS ruler panel when switching tools
	hideProtractorPanel(); // Step #) Hide CSS protractor panel when switching tools
	bearingToolSelectedHole = null;
	isDraggingBearing = false;
	isDraggingHole = false;

	// Reset selection-related variables for floating toolbar tools
	firstSelectedHole = null;
	secondSelectedHole = null;

	// Remove connector event listeners when switching away from connector tools
	if (excluding !== "tieConnectTool" && excluding !== "tieConnectMultiTool") {
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
	}

	// Force redraw to update button states
	drawData(allBlastHoles, selectedHole);
}

// Step 1) Function to clear all pending timers to prevent memory leaks
function clearAllPendingTimers() {
	// Step 1a) Clear debounced update tree view timer
	if (updateTreeViewTimeout) {
		clearTimeout(updateTreeViewTimeout);
		updateTreeViewTimeout = null;
	}
	// Step 1b) Clear debounced save KAD timer
	if (saveTimeout) {
		clearTimeout(saveTimeout);
		saveTimeout = null;
	}
	// Step 1c) Clear debounced save holes timer
	if (holesSaveTimeout) {
		clearTimeout(holesSaveTimeout);
		holesSaveTimeout = null;
	}
	// Step 1d) Clear animation interval if exists
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}
	// Step 1e) Clear animation frame if exists
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
		animationFrameId = null;
	}
}

// Step 2) Function to clear all data structures to prevent memory leaks
function clearAllDataStructures() {
	// Step 2a) Clear KAD drawings map
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap) {
		allKADDrawingsMap.clear();
	}
	// Step 2b) Clear loaded surfaces map
	if (typeof loadedSurfaces !== "undefined" && loadedSurfaces) {
		loadedSurfaces.clear();
	}
	// Step 2c) Clear loaded images map
	if (typeof loadedImages !== "undefined" && loadedImages) {
		loadedImages.clear();
	}
	// Step 2d) Clear blast holes array
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.length = 0;
	}
}

// Step 3) Centralized cleanup function to prevent memory leaks
// Call this on page unload, data clear, and error recovery
function cleanupAllResources() {
	console.log("üßπ Starting comprehensive resource cleanup...");

	// Step 3a) Clear all pending timers
	clearAllPendingTimers();

	// Step 3b) Clear all data structures
	clearAllDataStructures();

	// Step 3c) Dispose CameraControls if it exists
	if (cameraControls) {
		try {
			cameraControls.dispose();
		} catch (disposeError) {
			console.warn("üö® Failed to dispose cameraControls:", disposeError);
		}
		cameraControls = null;
	}

	// Step 3d) Dispose Three.js renderer if it exists
	if (threeRenderer) {
		try {
			threeRenderer.dispose();
		} catch (disposeError) {
			console.warn("üö® Failed to dispose threeRenderer:", disposeError);
		}
		threeRenderer = null;
	}

	// Step 3e) Dispose interaction manager if it exists
	if (interactionManager) {
		try {
			if (typeof interactionManager.dispose === "function") {
				interactionManager.dispose();
			}
		} catch (disposeError) {
			console.warn("‚ùå Failed to dispose interactionManager:", disposeError);
		}
		interactionManager = null;
	}

	// Step 3f) Reset initialization flags
	threeInitialized = false;
	threeInitializationFailed = false;

	console.log("üßπ Resource cleanup completed");
}
// Step 3h) Force Three.js re-initialization (call after cleanupAllResources)
function forceThreeJSReset() {
	console.log("üîÑ Forcing Three.js reset and re-initialization...");

	// Step 1) Clean up all resources first
	cleanupAllResources();

	// Step 2) Wait for cleanup to complete (browser needs time to release contexts)
	setTimeout(function () {
		console.log("üßπ Cleanup complete, attempting re-initialization...");

		// Step 3) Try to initialize again
		initializeThreeJS()
			.then(function () {
				console.log("üîÑ Three.js re-initialized successfully!");
				// Step 4) Redraw existing data
				if (allBlastHoles && allBlastHoles.length > 0) {
					drawData();
				}
			})
			.catch(function (error) {
				console.error("‚ùå Re-initialization failed:", error);
				alert("WebGL initialization failed. Try:\n\n1. Refresh the page (F5)\n2. Close other browser tabs\n3. Close and reopen browser\n4. Update graphics drivers");
			});
	}, 500); // Wait 500ms for browser to release contexts
}

// Step 3i) Expose to window for console access
window.forceThreeJSReset = forceThreeJSReset;
// Master function to reset everything
function resetAppToDefaults() {
	// Step 3) Clear all pending timers before reset
	clearAllPendingTimers();
	// Step 4) Clear all data structures before reset
	clearAllDataStructures();
	setAllBoolsToFalse();
	resetSwitchesTogglesOptionalDisplay(true);
	resetAllSelectedStores();
	resetFloatingToolbarButtons("none");
	console.log("App reset to defaults: booleans, switches, toggles, stores, and data structures cleared");
}

// Buttons
document.getElementById("deletePointButton").addEventListener("click", deleteSelectedPoint);
document.getElementById("deleteObjectButton").addEventListener("click", deleteSelectedObject);
document.getElementById("deleteAllButton").addEventListener("click", deleteSelectedAll);
document.getElementById("fileInput").addEventListener("change", handleFileUpload);
document.getElementById("fileInputDXF").addEventListener("change", handleDXFUpload);
document.getElementById("fileInputMeasured").addEventListener("change", handleMeasuredUpload);
document.getElementById("fileInputSurface").addEventListener("change", handleSurfaceUpload);
document.getElementById("fileInputGeotiff").addEventListener("change", handleGeotiffUpload);
document.getElementById("helpButton").addEventListener("click", openHelp);
document.getElementById("zoomInButton").addEventListener("click", zoomIn);
document.getElementById("zoomOutButton").addEventListener("click", zoomOut);
// document.getElementById("resetZoomButton").addEventListener("click", resetZoom);
document.getElementById("deleteHoleButton").addEventListener("click", deleteSelectedHoles);

// Print event listeners
document.addEventListener("DOMContentLoaded", function () {
	// Setup print event handlers - pass a function that returns fresh context
	// This ensures we always get current data values when printing
	setupPrintEventHandlers(() => ({
		updateStatusMessage: updateStatusMessage,
		drawData: () => drawData(allBlastHoles, selectedHole),
		allBlastHoles: allBlastHoles,
		allKADDrawingsMap: allKADDrawingsMap,
		allAvailableSurfaces: allAvailableSurfaces,
		selectedHole: selectedHole,
		canvas: canvas,
		currentScale: currentScale,
		centroidX: centroidX,
		centroidY: centroidY,
		imageVisible: imageVisible,
		surfaceVisible: surfaceVisible,
		getDisplayOptions: getDisplayOptions,
		buildHoleMap: buildHoleMap,
		developerModeEnabled: developerModeEnabled,
		simplifyByPxDist: simplifyByPxDist,
		worldToCanvas: worldToCanvas,
		delaunayTriangles: delaunayTriangles,
		maxEdgeLength: maxEdgeLength,
		createBlastBoundaryPolygon: createBlastBoundaryPolygon,
		offsetPolygonClipper: offsetPolygonClipper,
		getAverageDistance: getAverageDistance,
		selectedVoronoiMetric: selectedVoronoiMetric,
		isVoronoiLegendFixed: isVoronoiLegendFixed,
		getVoronoiMetrics: getVoronoiMetrics,
		useToeLocation: useToeLocation,
		clipVoronoiCells: clipVoronoiCells,
		getPFColor: getPFColor,
		getMassColor: getMassColor,
		getVolumeColor: getVolumeColor,
		getAreaColor: getAreaColor,
		getLengthColor: getLengthColor,
		getHoleFiringTimeColor: getHoleFiringTimeColor,
		strokeColor: strokeColor,
		directionArrows: directionArrows,
		contourLinesArray: contourLinesArray,
		firstMovementSize: firstMovementSize,
		currentFontSize: currentFontSize,
		holeScale: holeScale,
		transparentFillColor: transparentFillColor,
		textFillColor: textFillColor,
		fillColor: fillColor,
		depthColor: depthColor,
		angleDipColor: angleDipColor,
		isAddingConnector: isAddingConnector,
		isAddingMultiConnector: isAddingMultiConnector,
		fromHoleStore: fromHoleStore,
		firstSelectedHole: firstSelectedHole,
		secondSelectedHole: secondSelectedHole,
		selectedMultipleHoles: selectedMultipleHoles,
		loadedSurfaces: loadedSurfaces,
		showSurfaceLegend: showSurfaceLegend,
		elevationToColor: elevationToColor,
		currentGradient: currentGradient,
		surfaceTextureData: surfaceTextureData,
		loadedImages: loadedImages,
		buildVersion: buildVersion,
		showModalMessage: showModalMessage,
		FloatingDialog: FloatingDialog,
		getDipAngle: getDipAngle,
		currentRotation: currentRotation,
		// Step) 3D printing support - ThreeJS renderer and camera controls
		threeRenderer: threeRenderer,
		cameraControls: cameraControls,
		darkModeEnabled: darkModeEnabled,
	}));
});
document.getElementById("deletePatternButton").addEventListener("click", deleteSelectedPattern);
document.getElementById("deleteAllPatternsButton").addEventListener("click", deleteSelectedAllPatterns);

// Step 5a) GPU Memory Management button
var freeGPUMemoryButton = document.getElementById("freeGPUMemoryButton");
if (freeGPUMemoryButton) {
	freeGPUMemoryButton.addEventListener("click", function () {
		console.log("üóëÔ∏è User requested GPU memory cleanup");
		if (window.threeInitialized) {
			disposeKADThreeJS();
			showModalMessage("GPU Memory Freed", "CAD drawing GPU memory has been freed.\n\nNote: Drawings will be redrawn on next render.", "success");
		} else {
			showModalMessage("3D Not Initialized", "3D rendering is not active. GPU cleanup not needed.", "info");
		}
	});
}

const displayHoleId = document.getElementById("display1"); //holeID
const displayHoleLength = document.getElementById("display2"); //holeLength
const displayHoleDiameter = document.getElementById("display2A"); //holeDiameter
const displayHoleAngle = document.getElementById("display3"); //holeAngle
const displayHoleDip = document.getElementById("display4"); //holeDip
const displayHoleBearing = document.getElementById("display5"); //holeBearing
const displayHoleSubdrill = document.getElementById("display5B"); //subdrill
const displayConnectors = document.getElementById("display5A"); //connectors
const displayDelays = document.getElementById("display6"); //delays
const displayTimes = document.getElementById("display6A"); //times only
const displayContours = document.getElementById("display8"); //contours
const displaySlope = document.getElementById("display8A"); //slope
const displayRelief = document.getElementById("display8B"); //relief
const displayFirstMovements = document.getElementById("display8C"); //direction
const displayXLocation = document.getElementById("display9"); //xlocation
const displayYLocation = document.getElementById("display10"); //ylocation
const displayElevation = document.getElementById("display11"); //zlocation
const displayHoleType = document.getElementById("display12"); //holeType
const displayMLength = document.getElementById("display13"); //holeLength
const displayMMass = document.getElementById("display14"); //holeMass
const displayMComment = document.getElementById("display15"); //holeComment
const displayVoronoiCells = document.getElementById("display16"); //voronoi
const displayRowAndPosId = document.getElementById("rowAndPosDisplay"); //Developer mode Row and Position Display

// after const option16 = ?
const allToggles = [displayHoleId, displayHoleLength, displayHoleDiameter, displayHoleAngle, displayHoleDip, displayHoleBearing, displayHoleSubdrill, displayConnectors, displayDelays, displayTimes, displayContours, displaySlope, displayRelief, displayFirstMovements, displayXLocation, displayYLocation, displayElevation, displayHoleType, displayMLength, displayMMass, displayMComment, displayVoronoiCells, displayRowAndPosId];

allToggles.forEach((opt) => {
	if (opt)
		opt.addEventListener("change", function () {
			// Step #) When toggling OFF, clear relevant 3D geometry groups to ensure they're removed
			if (!this.checked && window.threeRenderer) {
				// Step #) Map display toggles to their 3D groups
				if (this === displayConnectors) {
					window.threeRenderer.clearGroup("connectors");
				} else if (this === displayContours || this === displayRelief || this === displayFirstMovements) {
					window.threeRenderer.clearGroup("contours");
				} else if (this === displayVoronoiCells) {
					// Step #) Clear Voronoi cells specifically (they're in surfaces group)
					if (typeof clearVoronoiCellsThreeJS === "function") {
						clearVoronoiCellsThreeJS();
					}
				}
			}
			// Step #) Force 3D rebuild on any display toggle change
			window.threeDataNeedsRebuild = true;
			// assuming drawData is your main render function
			drawData(allBlastHoles, selectedHole);
		});
});

const holeCountRadio = document.getElementById("holeCountRadio");
const measuredMassRadio = document.getElementById("measuredMassRadio");

//create holeCountRadio and measureMassRadio Listener
document.getElementById("measuredMassRadio")?.addEventListener("change", timeChart);
document.getElementById("holeCountRadio")?.addEventListener("change", timeChart);

// Add event listeners for mouse down, move, and up events
canvas.addEventListener("mousedown", handleMouseDown);
// canvas.addEventListener("mousemove", handleMouseMove);
canvas.addEventListener("mouseup", handleMouseUp);
// Add event listeners for touch start, move, and end events
canvas.addEventListener("touchstart", handleTouchStart, {
	passive: false,
});
// canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
canvas.addEventListener("touchend", handleTouchEnd, {
	passive: false,
});

// Event listener for the language dropdown
document.getElementById("languageSelect").addEventListener("change", function () {
	const selectedLanguage = this.value;
	updateTranslations(selectedLanguage);
});

// Function to update translations
function updateTranslations(language) {
	// Use the inline translations object
	const langTranslations = translations[language]?.translation;

	if (langTranslations) {
		// Update the text content of elements in the DOM with null checks
		const titleElement = document.querySelector("title");
		if (titleElement) titleElement.textContent = langTranslations.title;

		const helpButton = document.querySelector("#helpButton");
		if (helpButton) helpButton.title = langTranslations.help_button;

		const zoomInButton = document.querySelector("#zoomInButton");
		if (zoomInButton) zoomInButton.title = langTranslations.zoom_in_button;

		const zoomOutButton = document.querySelector("#zoomOutButton");
		if (zoomOutButton) zoomOutButton.title = langTranslations.zoom_out_button;

		const buttonGoBack = document.querySelector("#buttonGoBack");
		if (buttonGoBack) buttonGoBack.title = langTranslations.go_back_button;

		const languageSelect = document.querySelector("#languageSelect");
		if (languageSelect) languageSelect.title = langTranslations.select_language;

		const darkModeToggle = document.querySelector("#dark-mode-toggle");
		if (darkModeToggle) darkModeToggle.placeholder = langTranslations.dark_mode;

		// Display option tooltips
		const display1Label = document.querySelector("label[for='display1']");
		if (display1Label) display1Label.title = langTranslations.display_hole_id_title;

		const display2Label = document.querySelector("label[for='display2']");
		if (display2Label) display2Label.title = langTranslations.display_hole_length_title;

		const display2ALabel = document.querySelector("label[for='display2A']");
		if (display2ALabel) display2ALabel.title = langTranslations.display_hole_diameter_title;

		const display3Label = document.querySelector("label[for='display3']");
		if (display3Label) display3Label.title = langTranslations.display_angle_title;

		const display4Label = document.querySelector("label[for='display4']");
		if (display4Label) display4Label.title = langTranslations.display_dip_title;

		const display5Label = document.querySelector("label[for='display5']");
		if (display5Label) display5Label.title = langTranslations.display_bearing_title;

		const display5BLabel = document.querySelector("label[for='display5B']");
		if (display5BLabel) display5BLabel.title = langTranslations.display_subdrill_title;

		const display5ALabel = document.querySelector("label[for='display5A']");
		if (display5ALabel) display5ALabel.title = langTranslations.display_ties_title;

		const display6Label = document.querySelector("label[for='display6']");
		if (display6Label) display6Label.title = langTranslations.display_connectors_title;

		const display6ALabel = document.querySelector("label[for='display6A']");
		if (display6ALabel) display6ALabel.title = langTranslations.display_times_only_title;

		const display8Label = document.querySelector("label[for='display8']");
		if (display8Label) display8Label.title = langTranslations.display_contours_title;

		const display8ALabel = document.querySelector("label[for='display8A']");
		if (display8ALabel) display8ALabel.title = langTranslations.display_slope_title;

		const display8BLabel = document.querySelector("label[for='display8B']");
		if (display8BLabel) display8BLabel.title = langTranslations.display_relief_title;

		const display8CLabel = document.querySelector("label[for='display8C']");
		if (display8CLabel) display8CLabel.title = langTranslations.display_direction_title;

		const display9Label = document.querySelector("label[for='display9']");
		if (display9Label) display9Label.title = langTranslations.display_xlocation_title;

		const display10Label = document.querySelector("label[for='display10']");
		if (display10Label) display10Label.title = langTranslations.display_ylocation_title;

		const display11Label = document.querySelector("label[for='display11']");
		if (display11Label) display11Label.title = langTranslations.display_zlocation_title;

		const display12Label = document.querySelector("label[for='display12']");
		if (display12Label) display12Label.title = langTranslations.display_hole_type_title;

		const display13Label = document.querySelector("label[for='display13']");
		if (display13Label) display13Label.title = langTranslations.display_measure_title;

		const display14Label = document.querySelector("label[for='display14']");
		if (display14Label) display14Label.title = langTranslations.display_mass_title;

		const display15Label = document.querySelector("label[for='display15']");
		if (display15Label) display15Label.title = langTranslations.display_comment_title;

		const display16Label = document.querySelector("label[for='display16']");
		if (display16Label) display16Label.title = langTranslations.display_voronoi_title;

		// Left panel sections
		const openOrImportAcc = document.querySelector("#openOrImportAcc span");
		if (openOrImportAcc) openOrImportAcc.textContent = langTranslations.open_import;

		// File input icon button titles
		const fileInputBtns = document.querySelectorAll(".file-import-btn");
		fileInputBtns.forEach((btn) => {
			const target = btn.getAttribute("data-target");
			if (target === "fileInput") btn.title = langTranslations.file_holes_kad_title;
			if (target === "fileInputCustomCSV") btn.title = langTranslations.custom_csv_title;
			if (target === "fileInputDXF") btn.title = langTranslations.file_dxf_title;
			if (target === "fileInputMeasured") btn.title = langTranslations.measured_values_title;
			if (target === "fileInputSurface") btn.title = langTranslations.file_surface_title;
			if (target === "fileInputGeotiff") btn.title = langTranslations.file_geotiff_title;
		});

		// File input alt text
		const fileInputImgs = document.querySelectorAll(".file-import-btn img");
		fileInputImgs.forEach((img) => {
			const alt = img.getAttribute("alt");
			if (alt === "Load Holes & KAD") img.alt = langTranslations.load_holes_kad_alt;
			if (alt === "Load CSV") img.alt = langTranslations.load_csv_alt;
			if (alt === "Load DXF") img.alt = langTranslations.load_dxf_alt;
			if (alt === "Load Measured Values") img.alt = langTranslations.load_measured_alt;
			if (alt === "Load Surface") img.alt = langTranslations.load_surface_alt;
			if (alt === "Load Geotiff") img.alt = langTranslations.load_geotiff_alt;
		});

		const plusorminusHolesAcc = document.querySelector("#plusorminusHolesAcc span");
		if (plusorminusHolesAcc) plusorminusHolesAcc.textContent = langTranslations.plus_minus_holes;

		const addPatternLabel = document.querySelector("#addPatternLabel");
		if (addPatternLabel) addPatternLabel.textContent = langTranslations.add_pattern_label;

		const addHoleLabel = document.querySelector("#addHoleLabel");
		if (addHoleLabel) addHoleLabel.textContent = langTranslations.add_hole_label;

		const deleteHoleLabel = document.querySelector("#deleteHoleLabel");
		if (deleteHoleLabel) deleteHoleLabel.textContent = langTranslations.delete_label;

		const deleteHoleButton = document.querySelector("#deleteHoleButton");
		if (deleteHoleButton) deleteHoleButton.textContent = langTranslations.delete_hole_button;

		const deletePatternButton = document.querySelector("#deletePatternButton");
		if (deletePatternButton) deletePatternButton.textContent = langTranslations.delete_pattern_button;

		const deleteAllPatternsButton = document.querySelector("#deleteAllPatternsButton");
		if (deleteAllPatternsButton) deleteAllPatternsButton.textContent = langTranslations.delete_all_patterns_button;

		const renumberHolesLabel = document.querySelector("label[for='renumberHoles']");
		if (renumberHolesLabel) renumberHolesLabel.textContent = langTranslations.renumber_holes_label;

		const deleteRenumberStartLabel = document.querySelector("label[for='deleteRenumberStart']");
		if (deleteRenumberStartLabel) deleteRenumberStartLabel.textContent = langTranslations.delete_renumber_start_label;

		const editHolesAcc = document.querySelector("#editHolesAcc span");
		if (editHolesAcc) editHolesAcc.textContent = langTranslations.edit_holes;

		const editBlastNameLabel = document.querySelector("#editBlastNameLabel");
		if (editBlastNameLabel) editBlastNameLabel.textContent = langTranslations.edit_blast_name_label;

		const editLengthPopupLabel = document.querySelector("#editLengthPopupLabel");
		if (editLengthPopupLabel) editLengthPopupLabel.textContent = langTranslations.edit_length_popup_label;

		const editHoleTypePopupLabel = document.querySelector("#editHoleTypePopupLabel");
		if (editHoleTypePopupLabel) editHoleTypePopupLabel.textContent = langTranslations.edit_hole_type_popup_label;

		const selectionModeLabels = document.querySelectorAll("#selectionModeLabel");
		selectionModeLabels.forEach((label, index) => {
			if (index === 0) label.textContent = langTranslations.allow_holes_edited;
			if (index === 1) label.textContent = langTranslations.selection_mode_label;
		});

		const holeEastingLabel = document.querySelector("#holeEastingLabel");
		if (holeEastingLabel) holeEastingLabel.textContent = langTranslations.hole_easting_label;

		const holeNorthingLabel = document.querySelector("#holeNorthingLabel");
		if (holeNorthingLabel) holeNorthingLabel.textContent = langTranslations.hole_northing_label;

		const holeElevationLabel = document.querySelector("#holeElevationLabel");
		if (holeElevationLabel) holeElevationLabel.textContent = langTranslations.hole_elevation_label;

		const holeDiameterLabel = document.querySelector("#holeDiameterLabel");
		if (holeDiameterLabel) holeDiameterLabel.textContent = langTranslations.hole_diameter_label;

		const holeLengthLabel = document.querySelector("#holeLengthLabel");
		if (holeLengthLabel) holeLengthLabel.textContent = langTranslations.hole_length_label;

		const holeAngleLabel = document.querySelector("#holeAngleLabel");
		if (holeAngleLabel) holeAngleLabel.textContent = langTranslations.hole_angle_label;

		const holeBearingLabel = document.querySelector("#holeBearingLabel");
		if (holeBearingLabel) holeBearingLabel.textContent = langTranslations.hole_bearing_label;

		const holeSubdrillLabel = document.querySelector("#holeSubdrillLabel");
		if (holeSubdrillLabel) holeSubdrillLabel.textContent = langTranslations.hole_subdrill_label;

		const recordActualsAcc = document.querySelector("#recordActualsAcc span");
		if (recordActualsAcc) recordActualsAcc.textContent = langTranslations.record_actuals;

		const recordLengthPopupLabel = document.querySelector("#recordLengthPopupLabel");
		if (recordLengthPopupLabel) recordLengthPopupLabel.textContent = langTranslations.record_length_popup_label;

		const editMassPopupLabel = document.querySelector("#editMassPopupLabel");
		if (editMassPopupLabel) editMassPopupLabel.textContent = langTranslations.record_mass_popup_label;

		const recordCommentPopupLabel = document.querySelector("#recordCommentPopupLabel");
		if (recordCommentPopupLabel) recordCommentPopupLabel.textContent = langTranslations.record_comment_popup_label;

		const viewControlsAcc = document.querySelector("#viewControlsAcc span");
		if (viewControlsAcc) viewControlsAcc.textContent = langTranslations.view_controls;

		const fontLabel = document.querySelector("#fontLabel");
		if (fontLabel) fontLabel.textContent = langTranslations.font_size_label;

		const connLabel = document.querySelector("#connLabel");
		if (connLabel) connLabel.textContent = langTranslations.tie_size_label;

		const toeLabel = document.querySelector("#toeLabel");
		if (toeLabel) toeLabel.textContent = langTranslations.toe_size_label;

		const holeLabel = document.querySelector("#holeLabel");
		if (holeLabel) holeLabel.textContent = langTranslations.hole_adjust_label;

		const intervalLabel = document.querySelector("#intervalLabel");
		if (intervalLabel) intervalLabel.textContent = langTranslations.interval_label;

		const firstMovementLabel = document.querySelector("#firstMovementLabel");
		if (firstMovementLabel) firstMovementLabel.textContent = langTranslations.first_movement_label;

		const snapToleranceLabel = document.querySelector("#snapToleranceLabel");
		if (snapToleranceLabel) snapToleranceLabel.textContent = langTranslations.snap_tolerance_label;

		const outputfilesAcc = document.querySelector("#outputfilesAcc span");
		if (outputfilesAcc) outputfilesAcc.textContent = langTranslations.output_files;

		const label_saveHoles = document.querySelector("#label_saveHoles");
		if (label_saveHoles) label_saveHoles.textContent = langTranslations.save_holes_label;

		const saveHoles = document.querySelector("#saveHoles");
		if (saveHoles) saveHoles.textContent = langTranslations.save_holes_button;

		const label_saveKAD = document.querySelector("#label_saveKAD");
		if (label_saveKAD) label_saveKAD.textContent = langTranslations.save_kad_label;

		const saveKAD = document.querySelector("#saveKAD");
		if (saveKAD) saveKAD.textContent = langTranslations.save_kad_button;

		const label_saveAll = document.querySelector("#label_saveAll");
		if (label_saveAll) label_saveAll.textContent = langTranslations.save_all_label;

		const saveAll = document.querySelector("#saveAll");
		if (saveAll) saveAll.textContent = langTranslations.save_all_button;

		const label_saveMeasures = document.querySelector("#label_saveMeasures");
		if (label_saveMeasures) label_saveMeasures.textContent = langTranslations.save_measures_label;

		const saveMeasures = document.querySelector("#saveMeasures");
		if (saveMeasures) saveMeasures.textContent = langTranslations.save_measures_button;

		const label_exportHolesDXF = document.querySelector("#label_exportHolesDXF");
		if (label_exportHolesDXF) label_exportHolesDXF.textContent = langTranslations.export_holes_dxf_label;

		const exportHolesDXF = document.querySelector("#exportHolesDXF");
		if (exportHolesDXF) exportHolesDXF.textContent = langTranslations.export_holes_dxf_button;

		const label_exportDrawingDXF = document.querySelector("#label_exportDrawingDXF");
		if (label_exportDrawingDXF) label_exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_label;

		const exportDrawingDXF = document.querySelector("#exportDrawingDXF");
		if (exportDrawingDXF) exportDrawingDXF.textContent = langTranslations.export_drawing_dxf_button;

		const label_saveIREDES = document.querySelector("#label_saveIREDES");
		if (label_saveIREDES) label_saveIREDES.textContent = langTranslations.export_epiroc_label;

		const saveIREDES = document.querySelector("#saveIREDES");
		if (saveIREDES) saveIREDES.textContent = langTranslations.export_epiroc_button;

		const label_saveAQM = document.querySelector("#label_saveAQM");
		if (label_saveAQM) label_saveAQM.textContent = langTranslations.export_minestar_label;

		const saveAQM = document.querySelector("#saveAQM");
		if (saveAQM) saveAQM.textContent = langTranslations.export_minestar_button;

		const aboutAcc = document.querySelector("#aboutAcc span");
		if (aboutAcc) aboutAcc.textContent = langTranslations.about_title;

		const developerModeLabel = document.querySelector("label[for='developerMode']");
		if (developerModeLabel) developerModeLabel.textContent = langTranslations.developer_mode;

		const connectorsAcc = document.querySelector("#connectorsAcc span");
		if (connectorsAcc) connectorsAcc.textContent = langTranslations.connectors;

		const singleTie = document.querySelector("#singleTie");
		if (singleTie) singleTie.textContent = langTranslations.single_tie_label;

		const multiTie = document.querySelector("#multiTie");
		if (multiTie) multiTie.textContent = langTranslations.multi_tie_label;

		const delayLabel = document.querySelector("#delayLabel");
		if (delayLabel) delayLabel.textContent = langTranslations.delay_label;

		jscolor.install();
		const connectorColor = document.querySelector("#connectorColor");
		if (connectorColor) connectorColor.textContent = langTranslations.color_label;
		if (connectorColor.jscolor) {
			// Step #) Set the color programmatically
			connectorColor.jscolor.fromString("#00FF00");

			// Step #) Get the current color as hex
			var currentColor = connectorColor.jscolor.toHEXString();

			// Step #) Set jscolor options (optional)
			connectorColor.jscolor.option("width", 80);
			connectorColor.jscolor.option("height", 30);

			// Step #) You can also add event handlers if needed
			connectorColor.jscolor.option("onInput", function () {
				// Do something when the color changes
				// Example: update a preview or save to localStorage
			});
		}

		const connectLabel = document.querySelector("#connectLabel");
		if (connectLabel) connectLabel.textContent = langTranslations.connect_distance_label;

		const animateAcc = document.querySelector("#animateAcc span");
		if (animateAcc) animateAcc.textContent = langTranslations.animate_firing;

		const play = document.querySelector("#play");
		if (play) play.textContent = langTranslations.play_button;

		const stop = document.querySelector("#stop");
		if (stop) stop.textContent = langTranslations.stop_button;

		const timeWindowAcc = document.querySelector("#timeWindowAcc span");
		if (timeWindowAcc) timeWindowAcc.textContent = langTranslations.time_window;

		const timeRangeLabel = document.querySelector("#timeRangeLabel");
		if (timeRangeLabel) timeRangeLabel.textContent = langTranslations.time_range_label;

		const timeOffsetLabel = document.querySelector("#timeOffsetLabel");
		if (timeOffsetLabel) timeOffsetLabel.textContent = langTranslations.time_offset_label;

		const holeCountLabel = document.querySelector("#holeCountLabel");
		if (holeCountLabel) holeCountLabel.textContent = langTranslations.hole_count_label;

		const measuredMassLabel = document.querySelector("#measuredMassLabel");
		if (measuredMassLabel) measuredMassLabel.textContent = langTranslations.measured_mass_label;

		const drawingTools = document.querySelector("#drawingTools span");
		if (drawingTools) drawingTools.textContent = langTranslations.drawing_tools;

		const elevationName = document.querySelector("#elevationName");
		if (elevationName) elevationName.textContent = langTranslations.elevation_label;

		const colorLabel = document.querySelector("#colorLabel");
		if (colorLabel) colorLabel.textContent = langTranslations.drawing_color_label;

		const lineWidthLabel = document.querySelector("#lineWidthLabel");
		if (lineWidthLabel) lineWidthLabel.textContent = langTranslations.line_width_label;

		const pointDraw = document.querySelector("#pointDraw");
		if (pointDraw) pointDraw.textContent = langTranslations.point_draw_label;

		const lineDraw = document.querySelector("#lineDraw");
		if (lineDraw) lineDraw.textContent = langTranslations.line_draw_label;

		const polyDraw = document.querySelector("#polyDraw");
		if (polyDraw) polyDraw.textContent = langTranslations.poly_draw_label;

		const circleDraw = document.querySelector("#circleDraw");
		if (circleDraw) circleDraw.textContent = langTranslations.circle_draw_label;

		const drawingRadiusLabel = document.querySelector("#drawingRadiusLabel");
		if (drawingRadiusLabel) drawingRadiusLabel.textContent = langTranslations.drawing_radius_label;

		const textDraw = document.querySelector("#textDraw");
		if (textDraw) textDraw.textContent = langTranslations.text_draw_label;

		const textLabel = document.querySelector("#textLabel");
		if (textLabel) textLabel.textContent = langTranslations.text_label;

		const commonMath1 = document.querySelector("#commonMath1");
		if (commonMath1) commonMath1.textContent = langTranslations.common_math_label;

		const commonMath2 = document.querySelector("#commonMath2");
		if (commonMath2) commonMath2.innerHTML = langTranslations.common_math_examples;

		const createRadiiFromBlastHoles = document.querySelector("#createRadiiFromBlastHoles");
		if (createRadiiFromBlastHoles) createRadiiFromBlastHoles.textContent = langTranslations.create_radii_button;

		const radiiStepsLabel = document.querySelector("#radiiStepsLabel");
		if (radiiStepsLabel) radiiStepsLabel.textContent = langTranslations.radii_steps_label;

		const drawingPolygonRadiusLabel = document.querySelector("#drawingPolygonRadiusLabel");
		if (drawingPolygonRadiusLabel) drawingPolygonRadiusLabel.textContent = langTranslations.drawing_polygon_radius_label;

		const drawingRemovalAcc = document.querySelector("#drawingRemovalAcc span");
		if (drawingRemovalAcc) drawingRemovalAcc.textContent = langTranslations.drawing_removal;

		const pointDeleteLabel = document.querySelector("#pointDeleteLabel");
		if (pointDeleteLabel) pointDeleteLabel.textContent = langTranslations.drawing_delete_label;

		const deletePointButton = document.querySelector("#deletePointButton");
		if (deletePointButton) deletePointButton.textContent = langTranslations.delete_point_button;

		const deleteObjectButton = document.querySelector("#deleteObjectButton");
		if (deleteObjectButton) deleteObjectButton.textContent = langTranslations.delete_object_button;

		const deleteAllButton = document.querySelector("#deleteAllButton");
		if (deleteAllButton) deleteAllButton.textContent = langTranslations.delete_all_button;

		const voronoiOptionsAcc = document.querySelector("#voronoiOptionsAcc span");
		if (voronoiOptionsAcc) voronoiOptionsAcc.textContent = langTranslations.voronoi_options;

		const voronoiLabel = document.querySelector("#voronoiLabel");
		if (voronoiLabel) voronoiLabel.textContent = langTranslations.voronoi_display_label;

		const voronoiLegendLabel = document.querySelector("#voronoiLegendLabel");
		if (voronoiLegendLabel) voronoiLegendLabel.textContent = langTranslations.voronoi_legend_label;

		const voronoiBoundaryLabel = document.querySelector("#voronoiBoundaryLabel");
		if (voronoiBoundaryLabel) voronoiBoundaryLabel.textContent = langTranslations.voronoi_boundary_label;

		// Update select options
		const voronoiSelect = document.querySelector("#voronoiSelect");
		if (voronoiSelect) {
			const options = voronoiSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "powderFactor":
						option.textContent = langTranslations.powder_factor;
						break;
					case "mass":
						option.textContent = langTranslations.mass;
						break;
					case "volume":
						option.textContent = langTranslations.volume;
						break;
					case "area":
						option.textContent = langTranslations.area;
						break;
					case "measuredLength":
						option.textContent = langTranslations.measured_length;
						break;
					case "designedLength":
						option.textContent = langTranslations.designed_length;
						break;
					case "holeFiringTime":
						option.textContent = langTranslations.hole_firing_time;
						break;
					case "heelanVibration":
						option.textContent = langTranslations.heelan_vibration;
						break;
					case "unknown":
						option.textContent = langTranslations.unknown;
						break;
				}
			});
		}

		// Update legend select options
		const voronoiLegendSelect = document.querySelector("#voronoiLegendSelect");
		if (voronoiLegendSelect) {
			const options = voronoiLegendSelect.querySelectorAll("option");
			options.forEach((option) => {
				switch (option.value) {
					case "minmax":
						option.textContent = langTranslations.min_max;
						break;
					case "fixed":
						option.textContent = langTranslations.fixed;
						break;
				}
			});
		}

		const buymeaCoffeeLabel = document.querySelector("#buymeacoffeelabel");
		if (buymeaCoffeeLabel) buymeaCoffeeLabel.textContent = langTranslations.buy_coffee_alt;

		const bugButton = document.querySelector("#bugButton");
		if (bugButton) bugButton.textContent = langTranslations.report_bug_button;

		// Floating toolbar
		const dragLabel = document.querySelector("#dragLabel");
		if (dragLabel) dragLabel.textContent = langTranslations.drag_label;

		const selectLabel = document.querySelector("#selectLabel");
		if (selectLabel) selectLabel.textContent = langTranslations.select_label;

		const selectPointerLabel = document.querySelector("label[for='selectPointer']");
		if (selectPointerLabel) selectPointerLabel.title = langTranslations.select_pointer;

		const selectByPolygonLabel = document.querySelector("label[for='selectByPolygon']");
		if (selectByPolygonLabel) selectByPolygonLabel.title = langTranslations.select_by_polygon;

		const createLabel = document.querySelector("#createLabel");
		if (createLabel) createLabel.textContent = langTranslations.create_label;

		const patternInPolygonLabel = document.querySelector("label[for='patternInPolygonTool']");
		if (patternInPolygonLabel) patternInPolygonLabel.title = langTranslations.pattern_in_polygon;

		const holesAlongLineLabel = document.querySelector("label[for='holesAlongLineTool']");
		if (holesAlongLineLabel) holesAlongLineLabel.title = langTranslations.holes_along_line;

		const holesAlongPolyLineLabel = document.querySelector("label[for='holesAlongPolyLineTool']");
		if (holesAlongPolyLineLabel) holesAlongPolyLineLabel.title = langTranslations.holes_along_polyline;

		// Triangulation tool translations
		const triangulateLabel = document.querySelector("#triangulateLabel");
		if (triangulateLabel) triangulateLabel.textContent = langTranslations.triangulate_label;

		const triangulateTool = document.querySelector("label[for='triangulateTool']");
		if (triangulateTool) triangulateTool.title = langTranslations.triangulate_tooltip;

		// drawing tool translations
		const drawLabel = document.querySelector("#addKADLabel");
		if (drawLabel) drawLabel.textContent = langTranslations.draw_label;

		const addKADPointsTool = document.querySelector("label[for='addKADPointsTool']");
		if (addKADPointsTool) addKADPointsTool.title = langTranslations.add_kad_points_tooltip;

		const addKADLineTool = document.querySelector("label[for='addKADLineTool']");
		if (addKADLineTool) addKADLineTool.title = langTranslations.add_kad_line_tooltip;

		const addKADPolygonTool = document.querySelector("label[for='addKADPolygonTool']");
		if (addKADPolygonTool) addKADPolygonTool.title = langTranslations.add_kad_polygon_tooltip;

		const addKADCircleTool = document.querySelector("label[for='addKADCircleTool']");
		if (addKADCircleTool) addKADCircleTool.title = langTranslations.add_kad_circle_tooltip;

		const addKADTextTool = document.querySelector("label[for='addKADTextTool']");
		if (addKADTextTool) addKADTextTool.title = langTranslations.add_kad_text_tooltip;

		// Modify Section
		const modifyLabel = document.querySelector("#modifyLabel");
		if (modifyLabel) modifyLabel.textContent = langTranslations.modify_label;

		const moveToLabel = document.querySelector("label[for='moveToTool']");
		if (moveToLabel) moveToLabel.title = langTranslations.move_to;

		const bearingToolLabel = document.querySelector("label[for='bearingTool']");
		if (bearingToolLabel) bearingToolLabel.title = langTranslations.hole_bearing;

		const assignSurfaceLabel = document.querySelector("label[for='assignSurfaceTool']");
		if (assignSurfaceLabel) assignSurfaceLabel.title = langTranslations.assign_surface;

		const assignGradeLabel = document.querySelector("label[for='assignGradeTool']");
		if (assignGradeLabel) assignGradeLabel.title = langTranslations.assign_grade;

		const offsetKADTool = document.querySelector("label[for='offsetKADTool']");
		if (offsetKADTool) offsetKADTool.title = langTranslations.offset_kad_tooltip;

		const radiiHolesOrKADTool = document.querySelector("label[for='radiiHolesOrKADTool']");
		if (radiiHolesOrKADTool) radiiHolesOrKADTool.title = langTranslations.radii_holes_or_kad_tooltip;

		// Connectors Section
		const connectLabelFloating = document.querySelector("#toolbarPanel #connectLabel");
		if (connectLabelFloating) connectLabelFloating.textContent = langTranslations.connect_label;

		const tieConnectLabel = document.querySelector("label[for='tieConnectTool']");
		if (tieConnectLabel) tieConnectLabel.title = langTranslations.tie_connect;

		const tieConnectMultiLabel = document.querySelector("label[for='tieConnectMultiTool']");
		if (tieConnectMultiLabel) tieConnectMultiLabel.title = langTranslations.tie_connect_multi;

		const floatingConnectorColor = document.querySelector("#floatingConnectorColor");
		if (floatingConnectorColor) floatingConnectorColor.title = langTranslations.connector_color;

		// Measure Section
		const measureLabel = document.querySelector("#measureLabel");
		if (measureLabel) measureLabel.textContent = langTranslations.measure_label;

		const rulerLabel = document.querySelector("label[for='rulerTool']");
		if (rulerLabel) rulerLabel.title = langTranslations.ruler;

		const rulerProtractorLabel = document.querySelector("label[for='rulerProtractorTool']");
		if (rulerProtractorLabel) rulerProtractorLabel.title = langTranslations.ruler_protractor;

		const viewLabel = document.querySelector("#viewLabel");
		if (viewLabel) viewLabel.textContent = langTranslations.view_label;

		const resetViewLabel = document.querySelector("label[for='resetViewTool']");
		if (resetViewLabel) resetViewLabel.title = langTranslations.reset_view;
	} else {
		console.error("Translations for language ", language, " not found.");
	}
}

function getDarkModeSettings() {
	// Add safety checks for all elements
	const darkModeToggle = document.getElementById("darkModeToggle");
	const body = document.body;
	const sidenavLeft = document.getElementById("sidenavLeft");
	const canvas = document.getElementById("canvas");

	// Check if all required elements exist
	if (!darkModeToggle || !body || !sidenavLeft || !canvas) {
		console.warn("üö® Dark mode elements not ready yet, skipping...");
		return;
	}

	darkModeEnabled = localStorage.getItem("darkMode") === "true";

	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}
	// Update color variables based on dark mode
	updateColorsForDarkMode();
}

document.getElementById("buttonGoBack").addEventListener("click", function () {
	// Step 1) Create detailed message content
	const message = "You might lose unsaved data." + "<br><br>Make sure to save any important work before leaving." + '<br><br><div class="labelWhite15" style="text-align: left;">' + "<strong>Consider saving your work first:</strong>" + '<ul style="margin: 20px 0; padding-left: 20px;">' + "<li>Save holes to CSV file</li>" + "<li>Save drawing to KAD file</li>" + "<li>Export your current work</li>" + "</ul></div>";

	// Step 2) Show confirmation dialog
	showConfirmationDialog(
		"Leave Kirra?",
		message,
		"Leave",
		"Stay",
		() => {
			// Step 3) Handle leave confirmation
			window.location.href = "https://blastingapps.com/index.html";
		},
		() => {
			// Step 4) Handle stay (cancel) - nothing needed
			console.log("User chose to stay in Kirra");
		}
	);
});

// Tie Connect Tool event listener
const tieConnectTool = document.getElementById("tieConnectTool");
tieConnectTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		// Activate the right side nav "tie in one by one" switch
		addConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

// Tie Connect Multi Tool event listener
const tieConnectMultiTool = document.getElementById("tieConnectMultiTool");
tieConnectMultiTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		// Trigger the change event to activate the functionality
		addMultiConnectorButton.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		resetFloatingToolbarButtons("none");
		addMultiConnectorButton.checked = false;
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

const addKADPointsTool = document.getElementById("addKADPointsTool");
addKADPointsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPointsTool");
		addPointDraw.checked = true;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPointDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPointDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADLineTool = document.getElementById("addKADLineTool");
addKADLineTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADLineTool");
		addPointDraw.checked = false;
		addLineDraw.checked = true;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addLineDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addLineDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADPolygonTool = document.getElementById("addKADPolygonTool");
addKADPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADPolygonTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = true;
		addCircleDraw.checked = false;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addPolyDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addPolyDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADCircleTool = document.getElementById("addKADCircleTool");
addKADCircleTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADCircleTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = true;
		addTextDraw.checked = false;
		// Trigger the change event to activate the functionality
		addCircleDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addCircleDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});
const addKADTextTool = document.getElementById("addKADTextTool");
addKADTextTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("addKADTextTool");
		addPointDraw.checked = false;
		addLineDraw.checked = false;
		addPolyDraw.checked = false;
		addCircleDraw.checked = false;
		addTextDraw.checked = true;
		// Trigger the change event to activate the functionality
		addTextDraw.dispatchEvent(new Event("change"));
	} else {
		// Important: Handle unchecked state
		addTextDraw.checked = false;
		resetFloatingToolbarButtons("none");
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

// Step #) Floating Toolbar holesAddingTool - syncs with sidenav addHoleSwitch
const holesAddingTool = document.getElementById("holesAddingTool");
holesAddingTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("holesAddingTool");
		// Activate the sidenav addHoleSwitch
		addHoleSwitch.checked = true;
		// Trigger the change event to activate the functionality
		addHoleSwitch.dispatchEvent(new Event("change"));
	} else {
		// Handle unchecked state
		resetFloatingToolbarButtons("none");
		addHoleSwitch.checked = false;
		addHoleSwitch.dispatchEvent(new Event("change"));
		// Make sure we redraw the data
		drawData(allBlastHoles, selectedHole);
	}
});

//Selection Mode
selectionModeButton.addEventListener("change", function () {
	if (this.checked) {
		//set all the other switches to false
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== editHolesToggle) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning on: " + switchElement.id);
			}
		});
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		selectionModeButton.checked = true;
		isMultiHoleSelectionEnabled = true;

		if (selectedHole && !selectedMultipleHoles.includes(selectedHole)) {
			selectedMultipleHoles.push(selectedHole);
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		console.log("selectionModeButton.addEventListener checked");
	} else {
		console.log("selectionModeButton.addEventListener unchecked");
		isMultiHoleSelectionEnabled = false;
		selectionModeButton.checked = false;
		selectedMultipleHoles = [];
		switches.forEach((switchElement) => {
			if (switchElement) {
				switchElement.checked = false;
				console.log("switchElements set to false when turning off: " + switchElement.id);
			}
		});

		drawData(allBlastHoles, selectedHole);
	}
});

function setMultipleSelectionModeToFalse() {
	// resetFloatingToolbarButtons("none");
	isMultiHoleSelectionEnabled = false;
	selectedMultipleHoles = [];
	timingWindowHolesSelected = [];
	console.log("selectionModeSettings set to false");
}

//Resizing the Navbar on the right
resizeRight.addEventListener("mousedown", function (e) {
	isResizingRight = true;
	e.preventDefault(); // Prevent text selection during drag

	// Define cleanup function
	const cleanupResize = function () {
		isResizingRight = false;
		document.removeEventListener("mousemove", handleMouseMove);
		document.removeEventListener("mouseup", cleanupResize);
		document.removeEventListener("mouseleave", cleanupResize);
	};

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", cleanupResize);
	document.addEventListener("mouseleave", cleanupResize); // Handle mouse leaving window
});
//Resizing the Navbar on the left
resizeLeft.addEventListener("mousedown", function (e) {
	isResizingLeft = true;
	e.preventDefault(); // Prevent text selection during drag

	// Define cleanup function
	const cleanupResize = function () {
		isResizingLeft = false;
		document.removeEventListener("mousemove", handleMouseMove);
		document.removeEventListener("mouseup", cleanupResize);
		document.removeEventListener("mouseleave", cleanupResize);
	};

	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("mouseup", cleanupResize);
	document.addEventListener("mouseleave", cleanupResize); // Handle mouse leaving window
});
renumberHoles.addEventListener("click", function () {
	isRenumberingHoles = this.checked;
});
renumberStartListener.addEventListener("change", function () {
	//Allow Alpha numeric values
	deleteRenumberStart = this.value;
});

measuredLengthSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		// Remove all listeners except move tool
		isMeasureRecording = true;
		measuredLengthSwitch.checked = true;
		displayHoleId.checked = true;
		displayMLength.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredLengthClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredLengthClick);
		canvas.addEventListener("touchstart", handleMeasuredLengthClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredLengthClick);
		canvas.removeEventListener("touchstart", handleMeasuredLengthClick);
		measuredMassSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredMassSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredMassSwitch.checked = true;
		displayHoleId.checked = true;
		displayMMass.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredMassClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredMassClick);
		canvas.addEventListener("touchstart", handleMeasuredMassClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredMassClick);
		canvas.removeEventListener("touchstart", handleMeasuredMassClick);
		measuredLengthSwitch.checked = false;
		measuredCommentSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
measuredCommentSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetFloatingToolbarButtons("none");
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		isMeasureRecording = true;
		measuredCommentSwitch.checked = true;
		displayHoleId.checked = true; // Set display mode to hole Id
		displayMComment.checked = true; // Set display mode to hole Length
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["measuredCommentClick", "defaultListeners"]);
		canvas.addEventListener("click", handleMeasuredCommentClick);
		canvas.addEventListener("touchstart", handleMeasuredCommentClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isMeasureRecording = false;
		canvas.removeEventListener("click", handleMeasuredCommentClick);
		canvas.removeEventListener("touchstart", handleMeasuredCommentClick);
		measuredMassSwitch.checked = false;
		measuredLengthSwitch.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

addPointDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPointsTool");
		isDrawingPoint = true;
		addPointDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["pointDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		//Add event listeners
		canvas.addEventListener("click", handleKADPointClick);
		canvas.addEventListener("touchstart", handleKADPointClick);
	} else {
		isDrawingPoint = false;
		canvas.removeEventListener("click", handleKADPointClick);
		canvas.removeEventListener("touchstart", handleKADPointClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADPointsTool when sidenav is turned off
		var addKADPointsToolRef = document.getElementById("addKADPointsTool");
		if (addKADPointsToolRef) addKADPointsToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addLineDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADLineTool");
		isDrawingLine = true;
		addLineDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["lineDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADLineClick);
		canvas.addEventListener("touchstart", handleKADLineClick);
	} else {
		isDrawingLine = false;
		canvas.removeEventListener("click", handleKADLineClick);
		canvas.removeEventListener("touchstart", handleKADLineClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADLineTool when sidenav is turned off
		var addKADLineToolRef = document.getElementById("addKADLineTool");
		if (addKADLineToolRef) addKADLineToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addPolyDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADPolygonTool");
		isDrawingPoly = true;
		addPolyDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["polygonDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADPolyClick);
		canvas.addEventListener("touchstart", handleKADPolyClick);
	} else {
		isDrawingPoly = false;
		canvas.removeEventListener("click", handleKADPolyClick);
		canvas.removeEventListener("touchstart", handleKADPolyClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADPolygonTool when sidenav is turned off
		var addKADPolygonToolRef = document.getElementById("addKADPolygonTool");
		if (addKADPolygonToolRef) addKADPolygonToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addCircleDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADCircleTool");
		isDrawingCircle = true;
		addCircleDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["circleDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADCircleClick);
		canvas.addEventListener("touchstart", handleKADCircleClick);
	} else {
		isDrawingCircle = false;
		canvas.removeEventListener("click", handleKADCircleClick);
		canvas.removeEventListener("touchstart", handleKADCircleClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADCircleTool when sidenav is turned off
		var addKADCircleToolRef = document.getElementById("addKADCircleTool");
		if (addKADCircleToolRef) addKADCircleToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});
addTextDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("addKADTextTool");
		//If font is less than 20pt set the Font size slider to 20pt and and update
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		isDrawingText = true;
		addTextDraw.checked = true;
		createNewEntity = true; // ? ADD THIS LINE
		lastKADDrawPoint = null; // Reset preview line when tool is activated
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["textDrawing", "rulerTool", "rulerProtractorTool", "defaultListeners"]);
		canvas.addEventListener("click", handleKADTextClick);
		canvas.addEventListener("touchstart", handleKADTextClick);
	} else {
		isDrawingText = false;
		canvas.removeEventListener("click", handleKADTextClick);
		canvas.removeEventListener("touchstart", handleKADTextClick);
		createNewEntity = true;
		// Step #) Uncheck floating toolbar addKADTextTool when sidenav is turned off
		var addKADTextToolRef = document.getElementById("addKADTextTool");
		if (addKADTextToolRef) addKADTextToolRef.checked = false;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteKADDraw.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("selectPointer", "selectByPolyhon");
		isDeletingKAD = true;
		deleteKADDraw.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", getClickedPoint);
		canvas.addEventListener("touchstart", getClickedPoint);
	} else {
		isDeletingKAD = false;
		canvas.removeEventListener("click", getClickedPoint);
		canvas.removeEventListener("touchstart", getClickedPoint);
		drawData(allBlastHoles, selectedHole);
	}
});

addConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectTool");
		isAddingConnector = true;
		addConnectorButton.checked = true;
		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;

		// Step: Force Holes radio to be selected for connector tools
		if (selectHolesRadio) {
			selectHolesRadio.checked = true;
			selectHolesRadio.dispatchEvent(new Event("change"));
		}

		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConnectTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		// Step #) Also add listener to 3D canvas for 3D mode
		if (threeRenderer && threeRenderer.getCanvas()) {
			threeRenderer.getCanvas().addEventListener("click", handleConnectorClick);
			threeRenderer.getCanvas().addEventListener("touchstart", handleConnectorClick);
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		// Step #) Also remove listener from 3D canvas
		if (threeRenderer && threeRenderer.getCanvas()) {
			threeRenderer.getCanvas().removeEventListener("click", handleConnectorClick);
			threeRenderer.getCanvas().removeEventListener("touchstart", handleConnectorClick);
		}
		// Step #) Uncheck floating toolbar tieConnectTool when sidenav is turned off
		var tieConnectToolRef = document.getElementById("tieConnectTool");
		if (tieConnectToolRef) tieConnectToolRef.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});
addMultiConnectorButton.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(true);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("tieConnectMultiTool");

		addMultiConnectorButton.checked = true;
		isAddingMultiConnector = true;

		isPolygonSelectionActive = false;
		isSelectionPointerActive = false;
		selectedMultipleHoles = [];
		selectByPolygonTool.checked = false;
		selectPointerTool.checked = false;

		// Step: Force Holes radio to be selected for connector tools
		if (selectHolesRadio) {
			selectHolesRadio.checked = true;
			selectHolesRadio.dispatchEvent(new Event("change"));
		}

		displayConnectors.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["tieConectMultiTool", "defaultListeners"]);
		canvas.addEventListener("click", handleConnectorClick);
		canvas.addEventListener("touchstart", handleConnectorClick);
		// Step #) Also add listener to 3D canvas for 3D mode
		if (threeRenderer && threeRenderer.getCanvas()) {
			threeRenderer.getCanvas().addEventListener("click", handleConnectorClick);
			threeRenderer.getCanvas().addEventListener("touchstart", handleConnectorClick);
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingMultiConnector = false;
		canvas.removeEventListener("click", handleConnectorClick);
		canvas.removeEventListener("touchstart", handleConnectorClick);
		// Step #) Also remove listener from 3D canvas
		if (threeRenderer && threeRenderer.getCanvas()) {
			threeRenderer.getCanvas().removeEventListener("click", handleConnectorClick);
			threeRenderer.getCanvas().removeEventListener("touchstart", handleConnectorClick);
		}
		// Step #) Uncheck floating toolbar tieConnectMultiTool when sidenav is turned off
		var tieConnectMultiToolRef = document.getElementById("tieConnectMultiTool");
		if (tieConnectMultiToolRef) tieConnectMultiToolRef.checked = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

deleteHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		deleteHoleSwitch.checked = true;
		isDeletingHole = true;
		isAddingPattern = false;
		isAddingHole = false;
		displayHoleId.checked = true;
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;
			drawData(allBlastHoles, selectedHole);
		}
		canvas.addEventListener("click", handleHoleDeletingClick);
		canvas.addEventListener("touchstart", handleHoleDeletingClick);
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isDeletingHole = false;
		canvas.removeEventListener("click", handleHoleDeletingClick);
		canvas.removeEventListener("touchstart", handleHoleDeletingClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addHoleSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("holesAddingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}

		addHoleSwitch.checked = true;

		isAddingHole = true;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handleHoleAddingClick);
		canvas.addEventListener("touchstart", handleHoleAddingClick);
		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingHole = false;
		isAddingPattern = false;
		isDeletingHole = false;
		isDeletingPattern = false;
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);

		// Step #) Uncheck floating toolbar holesAddingTool when sidenav is turned off
		var holesAddingToolRef = document.getElementById("holesAddingTool");
		if (holesAddingToolRef) holesAddingToolRef.checked = false;

		// Clear multiple mode data when tool is turned off
		if (window.isAddingSingleHole !== undefined) {
			window.isAddingSingleHole = false;
		}
		if (window.multipleAddHoleFormData !== undefined) {
			window.multipleAddHoleFormData = null;
		}

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY); //TODO: check if this is correct
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});
addPatternSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		addPatternSwitch.checked = true;
		isAddingPattern = true;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		displayHoleId.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["defaultListeners"]);
		canvas.addEventListener("click", handlePatternAddingClick);
		canvas.addEventListener("touchstart", handlePatternAddingClick);
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	} else {
		isAddingPattern = false;
		isAddingHole = false;
		isDeletingHole = false;
		isDeletingPattern = false;

		// ensure the Adding Pattern and adding a hole are off and their switches are off
		addHoleSwitch.checked = false;
		addPatternSwitch.checked = false;
		canvas.removeEventListener("click", handlePatternAddingClick);
		canvas.removeEventListener("touchstart", handlePatternAddingClick);
		//Just in case this sliped through
		canvas.removeEventListener("click", handleHoleAddingClick);
		canvas.removeEventListener("touchstart", handleHoleAddingClick);

		deleteHoleSwitch.disabled = false;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles === null) {
			allBlastHoles = [];
		}
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		drawData(allBlastHoles, selectedHole);
	}
});

editHoleTypePopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//resetFloatingToolbarButtons("rulerTool", "bearingTool");
		resetSwitchesTogglesOptionalDisplay(true);
		if (currentFontSize < 14) {
			currentFontSize = 14;
			fontSlider.value = 14;

			drawData(allBlastHoles, selectedHole);
		}
		//setSelectionModeToFalse();
		isTypeEditing = true;
		editHoleTypePopupSwitch.checked = true;
		displayHoleId.checked = true;
		displayHoleType.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editHoleTypeSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleTypeEditClick);
		canvas.addEventListener("touchstart", handleHoleTypeEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isTypeEditing = false;
		canvas.removeEventListener("click", handleHoleTypeEditClick);
		canvas.removeEventListener("touchstart", handleHoleTypeEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editBlastNameSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		editBlastNameSwitch.checked = true;
		isBlastNameEditing = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editBlastNameSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleBlastNameClick);
		canvas.addEventListener("touchstart", handleBlastNameClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isBlastNameEditing = false;
		canvas.removeEventListener("click", handleBlastNameClick);
		canvas.removeEventListener("touchstart", handleBlastNameClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

editLengthPopupSwitch.addEventListener("change", function () {
	if (this.checked) {
		switches.forEach((switchElement) => {
			if (switchElement) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		//setSelectionModeToFalse();
		editLengthPopupSwitch.checked = true;
		isLengthPopupEditing = true;
		displayHoleLength.checked = true;
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["editLengthPopupSwitch", "defaultListeners"]);
		canvas.addEventListener("click", handleHoleLengthEditClick);
		canvas.addEventListener("touchstart", handleHoleLengthEditClick);
		drawData(allBlastHoles, selectedHole);
	} else {
		isLengthPopupEditing = false;
		canvas.removeEventListener("click", handleHoleLengthEditClick);
		canvas.removeEventListener("touchstart", handleHoleLengthEditClick);
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		drawData(allBlastHoles, selectedHole);
	}
});

/// Event listener for the edit hole Easting switch
// All previous slider enabling toggles/switches will be grouped into one switch
// isHoleEditing will be used to determine if the hole is being edited
editHolesToggle.addEventListener("change", function () {
	if (this.checked) {
		console.log("editHolesToggle checked");
		isHoleEditing = true;
		//use the set all switches to false function
		booleans.forEach((bool) => {
			if (bool !== isHoleEditing || bool != isMultiHoleSelectionEnabled) bool = false;
		});
		//turn all the switches off
		switches.forEach((switchElement) => {
			if (switchElement && (switchElement !== selectionModeButton || switchElement !== editHolesToggle)) switchElement.checked = false;
		});
		//turn on the edit holes toggle
		editHolesToggle.checked = true;
		//attach all the event listeners to the canvas
		canvas.addEventListener("click", handleHoleEditingSelection);
		canvas.addEventListener("touchstart", handleHoleEditingSelection);

		//draw the canvas
		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("editHolesToggle unchecked");
		isHoleEditing = false;
		//remove all the event listeners from the canvas
		canvas.removeEventListener("click", handleHoleEditingSelection);
		canvas.removeEventListener("touchstart", handleHoleEditingSelection);
		//turn off the edit holes toggle
		editHolesToggle.checked = false;
		//reset the selected hole
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		firstSelectedHole = null;
		secondSelectedHole = null;
		fromHoleStore = null;
		clickedHole = null;
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
		drawData(allBlastHoles, selectedHole);
	}
});

const holeEastingSlider = document.getElementById("holeEastingSlider");
holeEastingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleEasting = parseFloat(holeEastingSlider.value);
		holeEastingLabel.textContent = "Hole Easting (X): " + newHoleEasting.toFixed(2) + "mE";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 4 (easting)
				calculateHoleGeometry(clickedHole, newHoleEasting, 4);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average easting of all selected holes
			let sumEasting = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startXLocation, 0);
			let averageEasting = sumEasting / selectedMultipleHoles.length;
			let eastingDelta = newHoleEasting - averageEasting;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleX = hole.startXLocation + eastingDelta;
				calculateHoleGeometry(hole, newHoleX, 4);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

const holeNorthingSlider = document.getElementById("holeNorthingSlider");
holeNorthingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleNorthing = parseFloat(holeNorthingSlider.value);
		holeNorthingLabel.textContent = "Hole Northing (Y): " + newHoleNorthing.toFixed(2) + "mN";

		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				// Use calculateHoleGeometry with mode 5 (northing)
				calculateHoleGeometry(clickedHole, newHoleNorthing, 5);
				drawData(allBlastHoles, selectedHole);
			}
		} else if (selectedMultipleHoles) {
			// Calculate the average northing of all selected holes
			let sumNorthing = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startYLocation, 0);
			let averageNorthing = sumNorthing / selectedMultipleHoles.length;
			let northingDelta = newHoleNorthing - averageNorthing;

			selectedMultipleHoles.forEach((hole) => {
				// Apply the delta to each hole's current position
				let newHoleY = hole.startYLocation + northingDelta;
				calculateHoleGeometry(hole, newHoleY, 5);
			});
			drawData(allBlastHoles, null);
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}
});

// Access the slider element and add an event listener to track changes
const holeElevationSlider = document.getElementById("holeElevationSlider");
holeElevationSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleElevation = parseFloat(holeElevationSlider.value);
		holeElevationLabel.textContent = "Hole Elevation (Z): " + newHoleElevation.toFixed(2) + "m";

		if (selectedHole) {
			// Update the easting of the individual selected hole
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (fixToeLocation == true) {
				if (index !== -1) {
					allBlastHoles[index].startZLocation = newHoleElevation;
					// Assuming endZLocation should also be updated based on the new easting
					allBlastHoles[index].endZLocation += newHoleElevation - allBlastHoles[index].startZLocation;
					calculateHoleGeometry(allBlastHoles[index], allBlastHoles[index].length, 1);
					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			} else {
				if (index !== -1) {
					// Calculate the original delta between startZLocation and endZLocation
					let originalDeltaZ = allBlastHoles[index].endZLocation - allBlastHoles[index].startZLocation;

					// Update startZLocation
					allBlastHoles[index].startZLocation = newHoleElevation;

					// Update endZLocation based on the new startZLocation and original delta
					allBlastHoles[index].endZLocation = newHoleElevation + originalDeltaZ;

					// Redraw the updated data
					drawData(allBlastHoles, selectedHole);
				}
			}
		} else if (selectedMultipleHoles) {
			// Update the elevation of multiple selected holes
			let sumElevation = selectedMultipleHoles.reduce((sum, hole) => sum + hole.startZLocation, 0);
			let averageElevation = sumElevation / selectedMultipleHoles.length;
			let elevationDelta = newHoleElevation - averageElevation;

			selectedMultipleHoles.forEach((hole) => {
				hole.startZLocation += elevationDelta;
				// Assuming endZLocation should also be updated based on the new elevation
				hole.endZLocation += elevationDelta;
			});

			// Redraw the updated data for multiple holes
			drawData(allBlastHoles, null); // Pass null as the selected hole might not be relevant
		}

		// Recalculate dependent data structures if necessary
		if (allBlastHoles.length > 0) {
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing
		}
	}
});

const holeLengthSlider = document.getElementById("holeLengthSlider");
holeLengthSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleLength = parseFloat(holeLengthSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
				// Step 7) TreeView refresh bug fix - update tree after property change
				if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newHoleLength).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleLength, 1);
				drawData(allBlastHoles, selectedHole);
			});
			// Step 7) TreeView refresh bug fix - update tree after property change
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		}
	}
});

const holeAngleSlider = document.getElementById("holeAngleSlider");
holeAngleSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleAngle = parseFloat(holeAngleSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(clickedHole, newHoleAngle, 2);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
				// Step 7) TreeView refresh bug fix - update tree after property change
				if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeAngleLabel.textContent = "Hole Angle : " + parseFloat(newHoleAngle).toFixed(0) + "\u00B0";
				calculateHoleGeometry(hole, newHoleAngle, 2);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
			// Step 7) TreeView refresh bug fix - update tree after property change
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		}
	}
});

const holeDiameterSlider = document.getElementById("holeDiameterSlider");
holeDiameterSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleDiameter = parseFloat(holeDiameterSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(clickedHole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
				// Step 7) TreeView refresh bug fix - update tree after property change
				if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeDiameterLabel.textContent = "Hole Diameter : " + parseFloat(newHoleDiameter).toFixed(0) + "mm";
				calculateHoleGeometry(hole, newHoleDiameter, 7);
				drawData(allBlastHoles, selectedHole);
			});
			// Step 7) TreeView refresh bug fix - update tree after property change
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		}
	}
});

const holeBearingSlider = document.getElementById("holeBearingSlider");
holeBearingSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleBearing = parseFloat(holeBearingSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(clickedHole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
				// Step 7) TreeView refresh bug fix - update tree after property change
				if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				//console.log("clickedHole - " + "Hole Bearing : " + newHoleBearing + "\u00B0");
				holeBearingLabel.textContent = "Hole Bearing : " + parseFloat(newHoleBearing).toFixed(1) + "\u00B0";

				// Calculate endXYZ and draw allBlastHoles
				calculateHoleGeometry(hole, newHoleBearing, 3);
				drawData(allBlastHoles, selectedHole);
			});
			// Step 7) TreeView refresh bug fix - update tree after property change
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		}
	}
});

const holeSubdrillSlider = document.getElementById("holeSubdrillSlider");
holeSubdrillSlider.addEventListener("input", function () {
	if (isHoleEditing) {
		let newHoleSubdrill = parseFloat(holeSubdrillSlider.value);
		if (selectedHole) {
			const index = allBlastHoles.findIndex((hole) => hole === selectedHole);
			if (index !== -1) {
				clickedHole = allBlastHoles[index];
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(clickedHole, newHoleSubdrill, 8);

				// Update hole length slider to reflect the new calculated length
				const newLength = clickedHole.holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";

				drawData(allBlastHoles, selectedHole);
				// Step 7) TreeView refresh bug fix - update tree after property change
				if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
			}
		}
		if (selectedMultipleHoles != null) {
			selectedMultipleHoles.forEach((hole) => {
				holeSubdrillLabel.textContent = "Hole Subdrill : " + parseFloat(newHoleSubdrill).toFixed(1) + "m";
				calculateHoleGeometry(hole, newHoleSubdrill, 8);
				drawData(allBlastHoles, selectedHole);
			});

			// For multiple holes, use the first hole's length for the slider display
			if (selectedMultipleHoles.length > 0) {
				const newLength = selectedMultipleHoles[0].holeLengthCalculated;
				holeLengthSlider.value = newLength;
				holeLengthLabel.textContent = "Hole Length : " + parseFloat(newLength).toFixed(1) + "m";
			}
			// Step 7) TreeView refresh bug fix - update tree after property change
			if (typeof debouncedUpdateTreeView === "function") debouncedUpdateTreeView();
		}
	}
});

function resizeChart() {
	if (Array.isArray(holeTimes) && timeChartObject) {
		// Check if the chart has been created by Plotly
		const chart = document.getElementById("timeChart");
		if (chart && chart._fullLayout) {
			const newWidth = document.documentElement.clientWidth;
			// Use the string ID instead of the DOM element
			Plotly.relayout("timeChart", {
				width: newWidth,
			});
		} else {
			console.warn("resizeChart skipped: timeChart not yet initialized by Plotly");
		}
	} else {
		console.warn("resizeChart skipped: invalid holeTimes or timeChartObject");
	}
}

// Add event listener for window resize
function handleThreeJSResize() {
	if (threeInitialized && threeRenderer && canvas) {
		const width = canvas.clientWidth;
		const height = canvas.clientHeight;
		threeRenderer.resize(width, height);
		console.log("üîÑ Three.js canvas resized:", width, height);
	}
}

// Handle base canvas resize
function handleBaseCanvasResize() {
	if (window.baseCanvas && window.baseCtx && canvas) {
		const width = canvas.clientWidth;
		const height = canvas.clientHeight;

		// Step 1) Resize base canvas to match main canvas
		window.baseCanvas.width = width;
		window.baseCanvas.height = height;

		// Step 2) Redraw background color
		const isDark = document.body.classList.contains("dark-mode");
		window.baseCtx.fillStyle = isDark ? "#000000" : "#FFFFFF";
		window.baseCtx.fillRect(0, 0, width, height);
	}
}

window.addEventListener("resize", resizeChart);
window.addEventListener("resize", handleThreeJSResize);
window.addEventListener("resize", handleBaseCanvasResize);

// Step A5) Reusable function to update LineMaterial resolution for all fat lines
// This traverses the ENTIRE scene ONCE to catch all fat lines (kadGroup, pattern tools, etc.)
// CRITICAL: Must use canvas dimensions, NOT window dimensions, for LineMaterial resolution
// PERFORMANCE FIX: Removed console.log inside loops - was freezing browser with large DXFs
function updateAllLineMaterialResolution() {
	if (!window.threeRenderer) return;

	// Step A5.0) Use window dimensions for LineMaterial resolution
	// LineMaterial expects CSS pixel dimensions matching the DOM viewport
	var res = new THREE.Vector2(window.innerWidth, window.innerHeight);
	var updateCount = 0;

	// Step A5.0a) Log only in developer mode (avoid spam on every resize)
	if (developerModeEnabled) {
		console.log("üîß Updating LineMaterial resolution to:", window.innerWidth, "x", window.innerHeight);
	}

	// Step A5.1) Traverse entire scene ONCE (includes kadGroup, surfacesGroup, etc.)
	// No need to traverse kadGroup separately since it's part of the scene
	if (window.threeRenderer.scene) {
		window.threeRenderer.scene.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
				updateCount++;
			}
		});
	}

	// Step A5.2) Also update any pattern tool 3D groups (these may not be in scene)
	if (window.patternTool3DGroup) {
		window.patternTool3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
				updateCount++;
			}
		});
	}
	if (window.holesAlongLine3DGroup) {
		window.holesAlongLine3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
				updateCount++;
			}
		});
	}
	if (window.holesAlongPolyline3DGroup) {
		window.holesAlongPolyline3DGroup.traverse(function (child) {
			if (child.material && child.material.isLineMaterial) {
				child.material.resolution.copy(res);
				updateCount++;
			}
		});
	}

	// Step A5.3) Single summary log (only if developerModeEnabled or updateCount > 0)
	if (updateCount > 0 && developerModeEnabled) {
		console.log("üîß Updated " + updateCount + " LineMaterial resolutions to: " + window.innerWidth + " x " + window.innerHeight);
	}
}

// Expose globally for use in other modules
window.updateAllLineMaterialResolution = updateAllLineMaterialResolution;

// Step A5.4) Update LineMaterial resolution on resize
window.addEventListener("resize", updateAllLineMaterialResolution);
var acc = document.getElementsByClassName("accordion");
var i;
for (i = 0; i < acc.length; i++) {
	acc[i].addEventListener("click", function () {
		/* Toggle between adding and removing the "active" class,
	to highlight the button that controls the panel */
		this.classList.toggle("active");
		/* Toggle between hiding and showing the active panel */
		var panel = this.nextElementSibling;
		if (panel.style.display === "block") {
			panel.style.display = "none";
		} else {
			panel.style.display = "block";
			resizeChart(); // Call the resizeChart function to adjust the chart layout
			timeChart();
			//Plotly.relayout("timeChart", {
			//	width: newWidthRight - 50
			//});
		}
	});
}

const voronoiMetricDropdown = document.getElementById("voronoiSelect");
if (voronoiMetricDropdown) {
	voronoiMetricDropdown.addEventListener("change", function (e) {
		selectedVoronoiMetric = e.target.value;
		drawData(allBlastHoles, selectedHole); // Redraw with the new metric
	});
}

function isIOS() {
	const userAgent = navigator.userAgent.toLowerCase();
	return /iphone|ipad|ipod/.test(userAgent);
}
document.getElementById("saveKAD").addEventListener("click", function () {
	exportKADFile(mapData);
});
document.getElementById("saveHoles").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsTo14ColumnCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 1) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsTo14ColumnCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA14_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});

document.getElementById("saveAll").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToAllDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 2) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsToAllDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_ALL_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
document.getElementById("saveIREDES").addEventListener("click", function () {
	saveIREDESPopup();
});
document.getElementById("saveAQM").addEventListener("click", function () {
	saveAQMPopup();
});
document.getElementById("saveMeasures").addEventListener("click", function () {
	if (isIOS()) {
		const csv = convertPointsToActualDataCSV();

		// Create a Blob with the CSV data
		const blob = new Blob([csv], {
			type: "text/csv;charset=utf-8",
		});

		// Create a URL for the Blob
		const url = URL.createObjectURL(blob);

		// Create an anchor element with the download link
		const link = document.createElement("a");
		link.href = url;
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";
		link.textContent = "Click here to download";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);

		// Step 3) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const csv = convertPointsToActualDataCSV();

		// Create an invisible anchor element
		const link = document.createElement("a");
		link.style.display = "none";

		// Set the CSV data as the "href" attribute
		link.href = "data:text/csv;charset=utf-8," + encodeURIComponent(csv);

		// Prompt the user to save the file
		// Name the file "blastingapps_output" with today's date and time
		link.download = "KIRRA_MEASURED_output_" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".csv";

		// Append the link to the document
		document.body.appendChild(link);

		// Programmatically trigger the click event on the link
		link.click();

		// Remove the link from the document
		document.body.removeChild(link);
	}
});
// Update the event listener to filter visible holes first
document.getElementById("exportHolesDXF").addEventListener("click", function () {
	// ? Filter allBlastHoles to only include visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

	if (visibleBlastHoles.length === 0) {
		showModalMessage("No Data", "No visible holes to export", "warning");
		return;
	}

	console.log(`Exporting ${visibleBlastHoles.length} visible holes out of ${allBlastHoles.length} total holes`);

	// Step 1) Get entity name from first visible blast hole
	var entityName = visibleBlastHoles.length > 0 && visibleBlastHoles[0].entityName ? visibleBlastHoles[0].entityName : "Blast";

	// Step 2) Generate timestamp and default filename
	var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
	var defaultFilename = "DXF_" + entityName + "_" + timestamp + ".dxf";

	// Step 3) Show filename dialog
	showConfirmationDialogWithInput(
		"Export DXF Holes",
		"Enter filename for DXF holes export",
		"Filename:",
		"text",
		defaultFilename,
		"Export",
		"Cancel",
		function (filename) {
			// User confirmed
			if (!filename || filename.trim() === "") {
				showModalMessage("Export Cancelled", "No filename provided", "warning");
				return;
			}

			if (!filename.toLowerCase().endsWith(".dxf")) {
				filename += ".dxf";
			}

			// Step 4) Generate DXF content
			const dxf = exportHolesDXF(visibleBlastHoles);

			// Step 5) Check if File System Access API is available
			if (window.showSaveFilePicker) {
				// Use File System Access API for save location browsing
				exportDXFWithFilePicker(dxf, filename);
			} else {
				// Fallback to standard download
				downloadDXF(dxf, filename);
			}
		},
		function () {
			// User cancelled
			console.log("DXF holes export cancelled by user");
		}
	);
});

document.getElementById("exportDrawingDXF").addEventListener("click", function () {
	// Step 1) Check if there are drawings to export
	if (!window.allKADDrawingsMap || window.allKADDrawingsMap.size === 0) {
		showModalMessage("No Data", "No drawings to export. Please create some drawings first.", "warning");
		return;
	}

	// Step 2) Generate timestamp and default filename
	var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
	var defaultFilename = "KIRRA_DXF_Drawings_" + timestamp + ".dxf";

	// Step 3) Show filename dialog
	showConfirmationDialogWithInput(
		"Export DXF Drawings",
		"Enter filename for DXF drawings export",
		"Filename:",
		"text",
		defaultFilename,
		"Export",
		"Cancel",
		async function (filename) {
			// User confirmed
			if (!filename || filename.trim() === "") {
				showModalMessage("Export Cancelled", "No filename provided", "warning");
				return;
			}

			if (!filename.toLowerCase().endsWith(".dxf")) {
				filename += ".dxf";
			}

			try {
				// Step 4) Get DXF KAD writer from FileManager
				var Writer = window.fileManager.writers.get("dxf-kad");
				if (!Writer) {
					throw new Error("DXF KAD writer not found in FileManager");
				}

				// Step 5) Filter visible KAD entities
				var visibleKADMap = new Map();
				window.allKADDrawingsMap.forEach(function (entity, entityName) {
					if (window.isEntityVisible && !window.isEntityVisible(entityName)) {
						return; // Skip hidden entities
					}
					visibleKADMap.set(entityName, entity);
				});

				if (visibleKADMap.size === 0) {
					showModalMessage("No Visible Data", "No visible drawings to export", "warning");
					return;
				}

				// Step 6) Generate DXF content
				var writer = new Writer();
				var blob = await writer.write({ kadDrawingsMap: visibleKADMap });

				// Step 7) Use File System Access API if available
				if (window.showSaveFilePicker) {
					try {
						var handle = await window.showSaveFilePicker({
							suggestedName: filename,
							types: [{
								description: "DXF Files",
								accept: { "application/dxf": [".dxf"] }
							}]
						});
						var writable = await handle.createWritable();
						await writable.write(blob);
						await writable.close();
						showModalMessage("Export Success", "Exported " + visibleKADMap.size + " drawings to " + filename, "success");
					} catch (err) {
						if (err.name !== "AbortError") {
							throw err;
						}
					}
				} else {
					// Fallback to standard download
					writer.downloadFile(blob, filename);
					showModalMessage("Export Success", "Exported " + visibleKADMap.size + " drawings to " + filename, "success");
				}

				console.log("Exported " + visibleKADMap.size + " KAD entities to DXF");
			} catch (error) {
				console.error("DXF KAD export error:", error);
				showModalMessage("Export Failed", error.message, "error");
			}
		},
		function () {
			// User cancelled
			console.log("DXF drawings export cancelled by user");
		}
	);
});

//=================================================
// NEW FileManager-based Export Buttons
//=================================================



// Step 8) KAD Export button - using FileManager KADWriter
document.querySelectorAll(".kad-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		console.log("KAD export button clicked");

		try {
			// Step 9) Get writer from FileManager
			var Writer = window.fileManager.writers.get("kad");
			if (!Writer) {
				throw new Error("KAD writer not registered");
			}

			var writer = new Writer();

			// Step 10) Write KAD data
			var result = await writer.write({ kadDrawingsMap: window.allKADDrawingsMap });

			// Step 11) Download both files
			writer.downloadFile(result.kadFile, result.kadFilename);
			writer.downloadFile(result.txtFile, result.txtFilename);

			console.log("KAD export completed");
		} catch (error) {
			console.error("KAD export error:", error);
			alert("Error exporting KAD file: " + error.message);
		}
	});
});

// Step 12) DXF Holes Export button - using FileManager DXFHOLESWriter
document.querySelectorAll(".dxf-holes-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		console.log("DXF Holes export button clicked");

		// Step 13) Filter visible holes
		var visibleHoles = window.allBlastHoles.filter((hole) => window.isHoleVisible(hole));

		if (visibleHoles.length === 0) {
			showModalMessage("No Data", "No visible holes to export", "warning");
			return;
		}

		// Step 14) Generate default filename
		var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
		var entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Holes";
		var defaultFilename = "KIRRA_" + entityName + "_DXF_" + timestamp + ".dxf";

		// Step 15) Show filename dialog
		showConfirmationDialogWithInput(
			"Export DXF Holes",
			"Enter filename for DXF export",
			"Filename:",
			"text",
			defaultFilename,
			"Export",
			"Cancel",
			async function (filename) {
				if (!filename || filename.trim() === "") {
					showModalMessage("Export Cancelled", "No filename provided", "warning");
					return;
				}

				if (!filename.toLowerCase().endsWith(".dxf")) {
					filename += ".dxf";
				}

				try {
					// Step 16) Get writer from FileManager
					var Writer = window.fileManager.writers.get("dxf-holes");
					if (!Writer) {
						throw new Error("DXF Holes writer not registered");
					}

					var writer = new Writer();

					// Step 17) Generate DXF content
					var blob = await writer.write({ holes: visibleHoles });

					// Step 18) Use File System Access API if available
					if (window.showSaveFilePicker) {
						try {
							var handle = await window.showSaveFilePicker({
								suggestedName: filename,
								types: [{
									description: "DXF Files",
									accept: { "application/dxf": [".dxf"] }
								}]
							});
							var writable = await handle.createWritable();
							await writable.write(blob);
							await writable.close();
							showModalMessage("Export Success", "Exported " + visibleHoles.length + " holes to " + filename, "success");
						} catch (err) {
							if (err.name !== "AbortError") {
								throw err;
							}
						}
					} else {
						// Fallback to standard download
						writer.downloadFile(blob, filename);
						showModalMessage("Export Success", "Exported " + visibleHoles.length + " holes to " + filename, "success");
					}

					console.log("Exported " + visibleHoles.length + " holes to compact 2-layer DXF");
				} catch (error) {
					console.error("DXF export error:", error);
					showModalMessage("Export Failed", error.message, "error");
				}
			},
			function () {
				console.log("DXF Holes export cancelled by user");
			}
		);
	});
});

//=============================================================
// COMPREHENSIVE IMPORT/EXPORT BUTTON WIRING
//=============================================================
// Step 1) Wire up ALL import/export buttons for the new file I/O section
// Step 2) Created: 2026-01-03

// HOLES CSV IMPORT - Using FileManager BlastHoleCSVParser
document.querySelectorAll(".holes-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		// Step 1) Check if there's a format dropdown to determine import type
		var formatDropdown = document.getElementById("holesColumnFormat") || document.getElementById("holesFormat") || document.getElementById("csvFormat");
		var format = formatDropdown ? formatDropdown.value : null;

		// Step 2) If custom CSV format selected, trigger the custom CSV file input
		if (format === "custom-csv") {
			var customCsvInput = document.getElementById("fileInputCustomCSV");
			if (customCsvInput) {
				customCsvInput.click();
				return;
			} else {
				showModalMessage("Not Found", "Custom CSV import not available", "warning");
				return;
			}
		}

		// Step 3) Otherwise, use standard CSV import
		var input = document.createElement("input");
		input.type = "file";
		input.accept = ".csv,.txt";
		input.onchange = function (e) {
			var file = e.target.files[0];
			if (!file) return;

			var reader = new FileReader();
			reader.onload = async function (event) {
				try {
					var result = await parseK2Dcsv(event.target.result);

					// Show conditional message based on import result
					var message;
					if (result.cancelled) {
						message = "Import cancelled. Imported " + result.imported + " of " + (result.imported + result.skipped) + " holes from " + file.name;
						showModalMessage("CSV Import Cancelled", message, "warning");
					} else if (result.skipped > 0) {
						message = "Imported " + result.imported + " holes, skipped " + result.skipped + " (proximity conflicts) from " + file.name;
						showModalMessage("CSV Import Complete", message, "success");
					} else {
						message = "Imported " + result.imported + " holes from " + file.name;
						showModalMessage("CSV Import Success", message, "success");
					}

					// Update TreeView to show imported data
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}
				} catch (error) {
					showModalMessage("Import Failed", "Error importing CSV: " + error.message, "error");
				}
			};
			reader.readAsText(file);
		};
		input.click();
	});
});

// HOLES CSV EXPORT - Using FileManager BlastHoleCSVWriter with dropdown format selection
document.querySelectorAll(".holes-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		// Step 1) Check if there's a format dropdown (new UI) or use data-target (old UI)
		var formatDropdown = document.getElementById("holesColumnFormat") || document.getElementById("holesFormat") || document.getElementById("csvFormat");
		var format = formatDropdown ? formatDropdown.value : null;

		console.log("CSV Export - Dropdown found:", formatDropdown ? "YES" : "NO");
		console.log("CSV Export - Selected format value:", format);

		// Step 2) Handle custom CSV format - show column selection dialog
		if (format === "custom-csv") {
			showCustomCsvExportModal();
			return;
		}

		// Step 3) If no dropdown, check data-target attribute (backward compatibility)
		if (!format) {
			var target = button.getAttribute("data-target");
			if (target) {
				// Step 3) Map old data-target values to format strings
				if (target.includes("4Column")) format = "4column";
				else if (target.includes("7Column")) format = "7column";
				else if (target.includes("9Column")) format = "9column";
				else if (target.includes("12Column")) format = "12column";
				else if (target.includes("14Column")) format = "14column";
				else if (target.includes("30Column")) format = "30column";
				else if (target.includes("32Column")) format = "32column";
				else if (target.includes("35Column") || target.includes("AllColumns")) format = "35column";
				else format = "35column"; // default
			} else {
				format = "35column"; // default if nothing specified
			}
		}

		// Step 3a) Convert dropdown numeric values to format strings
		if (format === "4" || format === "7" || format === "9" || format === "12" || format === "14" || format === "30" || format === "32" || format === "35") {
			format = format + "column";
		}

		// Step 4) Map "all" or "allcolumns" to dynamic all-columns format
		if (format === "all" || format === "allcolumns" || format === "all-columns") {
			format = "allcolumns";
		}

		// Step 4a) Ensure we have a valid format
		var validFormats = ["4column", "7column", "9column", "12column", "14column", "30column", "32column", "35column", "actual", "allcolumns", "all"];
		if (!validFormats.includes(format)) {
			console.warn("CSV Export - Unknown format '" + format + "', defaulting to 35column");
			format = "35column";
		}

		console.log("CSV Export - Format selected:", format);

		// Step 5) Filter visible holes
		var visibleHoles = window.allBlastHoles.filter(function (hole) {
			return window.isHoleVisible(hole);
		});

		if (visibleHoles.length === 0) {
			showModalMessage("No Data", "No visible holes to export", "warning");
			return;
		}

		try {
			// Step 6) Get writer from FileManager
			var Writer = window.fileManager.writers.get("blasthole-csv-35");
			if (!Writer) {
				throw new Error("CSV writer not found in FileManager");
			}

			// Step 7) Generate default filename with entity name
			var entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Blast";
			var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
			var formatLabel;
			if (format === "allcolumns") {
				formatLabel = "ALL";
			} else {
				formatLabel = format.replace("column", "").toUpperCase();
			}
			var defaultFilename = "CSV_" + entityName + "_" + formatLabel + "COL_" + timestamp + ".csv";

			// Step 8) Show filename dialog
			showConfirmationDialogWithInput(
				"Export CSV (" + formatLabel + " Columns)",
				"Enter filename for CSV export",
				"Filename:",
				"text",
				defaultFilename,
				"Export",
				"Cancel",
				async function (filename) {
					// User confirmed
					if (!filename || filename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					if (!filename.toLowerCase().endsWith(".csv")) {
						filename += ".csv";
					}

					try {
						// Step 9) Create writer with selected format
						var writer = new Writer({ format: format });

						// Step 10) Generate CSV content
						var blob = await writer.write({ holes: visibleHoles });

						// Step 11) Check if File System Access API is available
						if (window.showSaveFilePicker) {
							// Use File System Access API
							exportCSVWithFilePicker(blob, filename);
						} else {
							// Fallback to standard download
							writer.downloadFile(blob, filename);
						}

						console.log("Exported " + visibleHoles.length + " holes in " + format + " format");
					} catch (error) {
						console.error("CSV export error:", error);
						showModalMessage("Export Failed", "Error exporting CSV: " + error.message, "error");
					}
				},
				function () {
					// User cancelled
					console.log("CSV export cancelled by user");
				}
			);
		} catch (error) {
			console.error("CSV export error:", error);
			showModalMessage("Export Failed", "Error exporting CSV: " + error.message, "error");
		}
	});
});

// KAD IMPORT - Using FileManager KADParser
document.querySelectorAll(".kad-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		var input = document.createElement("input");
		input.type = "file";
		input.accept = ".kad,.txt";
		input.onchange = function (e) {
			var file = e.target.files[0];
			if (!file) return;

			var reader = new FileReader();
			reader.onload = function (event) {
				try {
					parseKADFile(event.target.result);
					// Update TreeView to show imported KAD entities
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}
				} catch (error) {
					showModalMessage("Import Failed", "Error importing KAD: " + error.message, "error");
				}
			};
			reader.readAsText(file);
		};
		input.click();
	});
});

// DXF IMPORT - Using existing handleDXFUpload
document.querySelectorAll(".dxf-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		var input = document.createElement("input");
		input.type = "file";
		input.accept = ".dxf,.dwg";
		input.onchange = handleDXFUpload;
		input.click();
	});
});

// DXF EXPORT - Unified dialog with radio buttons
// Dialog and export handlers now in src/dialog/popups/export/DXFExportDialog.js
document.querySelectorAll(".dxf-output-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		window.showDXFExportDialog();
	});
});

// SURPAC STR/DTM - Export
document.querySelectorAll(".surpac-output-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		try {
			// Step 1) Get format and data type selection
			var formatSelect = document.getElementById("surpacFormat");
			var formatValue = formatSelect ? formatSelect.value : "str";

			// Step 2) Determine file format and data type
			// Support both old format ("str", "dtm") and new format ("str-blastholes", "str-kad", etc.)
			var fileFormat = "str";
			var dataType = "blastholes";

			if (formatValue.indexOf("-") !== -1) {
				// New format: "str-blastholes", "str-kad", "str-surfaces", "dtm-surfaces"
				var parts = formatValue.split("-");
				fileFormat = parts[0];
				dataType = parts[1] || "blastholes";
			} else {
				// Old format: "str" or "dtm"
				fileFormat = formatValue;
				// For old format, default to surfaces for DTM, blastholes for STR
				dataType = (fileFormat === "dtm") ? "surfaces" : "blastholes";
			}

			// Step 3) Validate based on data type
			var exportData = {};
			var filename = "";
			var timestamp = new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_");

			if (fileFormat === "dtm") {
				// Step 4a) DTM - Export BOTH DTM and STR files for visible surfaces only
				if (!window.loadedSurfaces || window.loadedSurfaces.size === 0) {
					showModalMessage("No Data", "No surfaces loaded. Please load a surface first (OBJ, DXF, PLY).", "warning");
					return;
				}

				// Filter visible surfaces only
				var visibleSurfaces = new Map();
				window.loadedSurfaces.forEach(function (surface, key) {
					if (surface.visible) {
						visibleSurfaces.set(key, surface);
					}
				});

				if (visibleSurfaces.size === 0) {
					showModalMessage("No Visible Surfaces", "No visible surfaces to export. Please make some surfaces visible first.", "warning");
					return;
				}

				exportData = {
					surfaces: visibleSurfaces,
					fileName: "surface"
				};

				// Step 4a.1) Get writers
				var DTMWriter = window.fileManager.writers.get("surpac-dtm");
				if (!DTMWriter) {
					showModalMessage("Error", "Surpac DTM writer not found", "error");
					return;
				}

				var STRWriter = window.fileManager.writers.get("surpac-str");
				if (!STRWriter) {
					showModalMessage("Error", "Surpac STR writer not found", "error");
					return;
				}

				// Step 4a.2) Generate default filenames
				var dtmFilename = "SURPAC_DTM_Surface_" + timestamp + ".dtm";
				var strFilename = "SURPAC_STR_Surface_" + timestamp + ".str";

				// Step 4a.3) Show filename dialog for DTM export
				showConfirmationDialogWithInput(
					"Export Surpac DTM+STR",
					"This will export both .dtm and .str files. Enter base filename (extensions will be added automatically):",
					"Base Filename:",
					"text",
					"SURPAC_Surface_" + timestamp,
					"Export",
					"Cancel",
					function (baseFilename) {
						if (!baseFilename || baseFilename.trim() === "") {
							showModalMessage("Export Cancelled", "No filename provided", "warning");
							return;
						}

						// Remove any extensions user might have added
						baseFilename = baseFilename.replace(/\.(dtm|str)$/i, "");

						var finalDtmFilename = baseFilename + ".dtm";
						var finalStrFilename = baseFilename + ".str";

						// Step 4a.4) CRITICAL: Pass baseFileName to both writers for cross-referencing
						exportData.baseFileName = baseFilename;

						var dtmWriter = new DTMWriter();
						var strWriter = new STRWriter();

						// Generate and export both files
						Promise.all([
							dtmWriter.write(exportData),
							strWriter.write(exportData)
						])
							.then(function (results) {
								var dtmBlob = results[0];
								var strBlob = results[1];

								// Export both files with File System Access API
								if (window.showSaveFilePicker) {
									exportSurpacWithFilePicker(dtmBlob, finalDtmFilename, strBlob, finalStrFilename);
								} else {
									// Fallback to standard download
									dtmWriter.downloadFile(dtmBlob, finalDtmFilename);
									strWriter.downloadFile(strBlob, finalStrFilename);
									showModalMessage("Export Complete", "Exported both " + finalDtmFilename + " and " + finalStrFilename, "success");
								}

								console.log("Surpac DTM+STR export completed: " + finalDtmFilename + " + " + finalStrFilename);
							})
							.catch(function (error) {
								console.error("Error exporting Surpac DTM+STR:", error);
								showModalMessage("Export Error", error.message, "error");
							});
					},
					function () {
						console.log("Surpac DTM+STR export cancelled by user");
					}
				);

				return; // Exit early since we handled both exports
			} else if (dataType === "blastholes") {
				// Step 4b) STR Blastholes - Export blast holes
				if (!allBlastHoles || allBlastHoles.length === 0) {
					showModalMessage("No Data", "No blast holes to export. Please import or create blast holes first.", "warning");
					return;
				}

				var visibleHoles = allBlastHoles.filter(function (hole) {
					return hole.visible !== false;
				});

				if (visibleHoles.length === 0) {
					showModalMessage("No Visible Holes", "No visible holes to export. Please make some holes visible first.", "warning");
					return;
				}

				var entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Blast";

				exportData = {
					holes: visibleHoles,
					fileName: "blastmaster"
				};
				filename = "SURPAC_STR_" + entityName + "_" + timestamp + ".str";
			} else if (dataType === "kad") {
				// Step 4c) STR KAD - Export visible KAD drawings only
				if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
					showModalMessage("No Data", "No KAD drawings to export. Please create some drawings first.", "warning");
					return;
				}

				// Filter to only visible KAD entities
				var allKADArray = Array.from(allKADDrawingsMap.values());
				var visibleElements = getVisibleHolesAndKADDrawings([], allKADArray);
				var visibleKADEntities = visibleElements.visibleKADDrawings;

				if (visibleKADEntities.length === 0) {
					showModalMessage("No Visible KAD", "No visible KAD drawings to export. Please make some KAD entities visible first.", "warning");
					return;
				}

				// Convert back to Map for writer
				var visibleKADMap = new Map();
				visibleKADEntities.forEach(function (entity) {
					if (entity.entityName) {
						visibleKADMap.set(entity.entityName, entity);
					}
				});

				exportData = {
					kadDrawingsMap: visibleKADMap,
					fileName: "drawing"
				};
				filename = "SURPAC_STR_Drawings_" + timestamp + ".str";
			} else if (dataType === "surfaces") {
				// Step 4d) STR Surfaces - This option removed, use DTM instead
				showModalMessage("Info", "To export surfaces, please use DTM format which exports both .dtm and .str files.", "info");
				return;
			} else {
				showModalMessage("Error", "Unknown data type: " + dataType, "error");
				return;
			}

			// Step 5) Get writer
			var writerFormat = fileFormat === "dtm" ? "surpac-dtm" : "surpac-str";
			var Writer = window.fileManager.writers.get(writerFormat);

			if (!Writer) {
				showModalMessage("Error", "Surpac " + fileFormat.toUpperCase() + " writer not found", "error");
				return;
			}

			// Step 6) Show filename dialog and export
			showConfirmationDialogWithInput(
				"Export Surpac " + fileFormat.toUpperCase(),
				"Enter filename for Surpac export",
				"Filename:",
				"text",
				filename,
				"Export",
				"Cancel",
				function (userFilename) {
					if (!userFilename || userFilename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					if (!userFilename.toLowerCase().endsWith(".str")) {
						userFilename += ".str";
					}

					var writer = new Writer();
					writer.write(exportData)
						.then(function (blob) {
							// Use File System Access API if available
							if (window.showSaveFilePicker) {
								exportSurpacSTRWithFilePicker(blob, userFilename);
							} else {
								// Fallback to standard download
								writer.downloadFile(blob, userFilename);
								showModalMessage("Export Success", "Exported to " + userFilename, "success");
							}
							console.log("Surpac " + fileFormat.toUpperCase() + " export completed: " + userFilename);
						})
						.catch(function (error) {
							console.error("Error exporting Surpac " + fileFormat.toUpperCase() + ":", error);
							showModalMessage("Export Error", error.message, "error");
						});
				},
				function () {
					console.log("Surpac export cancelled by user");
				}
			);
		} catch (error) {
			console.error("Error in Surpac export:", error);
			showModalMessage("Export Error", error.message, "error");
		}
	});
});

// SURPAC STR/DTM - Import
document.querySelectorAll(".surpac-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		try {
			// Step 1) Get format selection (str or dtm)
			var formatSelect = document.getElementById("surpacFormat");
			var formatValue = formatSelect ? formatSelect.value : "str-blastholes";

			// Step 2) Determine file format
			var fileFormat = "str";
			if (formatValue.indexOf("-") !== -1) {
				fileFormat = formatValue.split("-")[0];
			} else {
				fileFormat = formatValue;
			}

			// Step 3) Determine file extension and parser based on format selection
			var extension, parserFormat, multiple;

			// Determine if DTM (surfaces) or STR (holes/KAD)
			var isDTM = fileFormat.startsWith("dtm");

			if (isDTM) {
				extension = ".dtm,.str";
				parserFormat = "surpac-surface";
				multiple = true; // Need both .dtm and .str files
			} else {
				extension = ".str";
				parserFormat = "surpac-str";
				multiple = false;
			}

			// Step 4) Create file input
			var input = document.createElement("input");
			input.type = "file";
			input.accept = extension;
			input.multiple = multiple;

			// Step 5) Handle file selection
			input.onchange = function (e) {
				var files = e.target.files;
				if (!files || files.length === 0) return;

				// Step 6) Handle DTM surface (requires both .dtm and .str files)
				if (fileFormat === "dtm" && parserFormat === "surpac-surface") {
					// Step 6a) Check that we have both files
					var dtmFile = null;
					var strFile = null;

					for (var i = 0; i < files.length; i++) {
						var fileName = files[i].name.toLowerCase();
						if (fileName.endsWith(".dtm")) {
							dtmFile = files[i];
						} else if (fileName.endsWith(".str")) {
							strFile = files[i];
						}
					}

					if (!dtmFile || !strFile) {
						showModalMessage("Missing Files", "Please select both .dtm and .str files for surface import", "warning");
						return;
					}

					// Step 6b) Read both files
					var dtmReader = new FileReader();
					var strReader = new FileReader();

					var dtmContent = null;
					var strContent = null;

					dtmReader.onload = function (event) {
						dtmContent = event.target.result;
						// Check if both files are loaded
						if (dtmContent && strContent) {
							parseSurface(dtmContent, strContent, dtmFile.name);
						}
					};

					strReader.onload = function (event) {
						strContent = event.target.result;
						// Check if both files are loaded
						if (dtmContent && strContent) {
							parseSurface(dtmContent, strContent, dtmFile.name);
						}
					};

					// Read as ArrayBuffer to support both text and binary formats
					dtmReader.readAsArrayBuffer(dtmFile);
					strReader.readAsArrayBuffer(strFile);

					// Step 6c) Parse surface function
					function parseSurface(dtmContent, strContent, fileName) {
						var Parser = window.fileManager.parsers.get("surpac-surface");
						if (!Parser) {
							showModalMessage("Error", "Surpac surface parser not found", "error");
							return;
						}

						var parser = new Parser();
						var surfaceName = fileName.replace(/\.(dtm|str)$/i, "");

						parser.parse({
							dtmContent: dtmContent,
							strContent: strContent,
							surfaceName: surfaceName,
							color: "#00FF00"
						})
							.then(function (data) {
								if (data.surfaces && data.surfaces.length > 0) {
									// Add surfaces to loadedSurfaces
									if (!window.loadedSurfaces) {
										window.loadedSurfaces = new Map();
									}

									// Step 21) Create surface layer for DTM import
									var dtmLayer = getOrCreateLayerForImport("surface", fileName);
									var dtmLayerId = dtmLayer ? dtmLayer.layerId : null;

									data.surfaces.forEach(function (surface) {
										// Step 6c) Create a proper surface record with id and points for TreeView/DB
										var surfaceId = surface.name || ("DTM_Surface_" + Date.now());

										// Ensure points exist; if not, derive unique points from triangles
										var points = surface.points;
										if (!points || !Array.isArray(points) || points.length === 0) {
											var pointsMap = new Map();
											if (surface.triangles && Array.isArray(surface.triangles)) {
												surface.triangles.forEach(function (tri) {
													if (tri.vertices && Array.isArray(tri.vertices)) {
														tri.vertices.forEach(function (v) {
															if (v && typeof v.x === "number" && typeof v.y === "number" && typeof v.z === "number") {
																var key = v.x + "_" + v.y + "_" + v.z;
																if (!pointsMap.has(key)) {
																	pointsMap.set(key, { x: v.x, y: v.y, z: v.z });
																}
															}
														});
													}
												});
											}
											points = Array.from(pointsMap.values());
										}

										var surfaceData = {
											id: surfaceId,
											name: surface.name,
											points: points,
											triangles: surface.triangles || [],
											visible: surface.visible !== false,
											gradient: "default",
											color: surface.color || "#00FF00",
											transparency: 1.0,
											layerId: dtmLayerId  // Step 21a) Assign layer ID
										};

										window.loadedSurfaces.set(surfaceId, surfaceData);

										// Step 21b) Add surface to layer's entities set
										if (dtmLayer) {
											dtmLayer.entities.add(surfaceId);
										}

										console.log("Imported surface: " + surfaceId + " (" + surfaceData.points.length + " points, " + surfaceData.triangles.length + " triangles)");

										// Step 6c.1) Save surface to IndexedDB
										setTimeout(async function () {
											try {
												await saveSurfaceToDB(surfaceId);
												console.log("STR+DTM surface saved to database: " + surfaceId);
											} catch (saveError) {
												console.error("Failed to save STR+DTM surface:", saveError);
											}
										}, 0);
									});

									showModalMessage("Import Complete", "Imported " + data.surfaces.length + " surface(s)", "success");

									// Step 21c) Save layers after import
									if (typeof debouncedSaveLayers === "function") {
										debouncedSaveLayers();
									}

									// Update display
									// Step #) Trigger 3D rebuild to show imported Surpac surface data
									window.threeDataNeedsRebuild = true;
									drawData();

									// Update tree view if available
									if (typeof debouncedUpdateTreeView === "function") {
										debouncedUpdateTreeView();
									}
								} else {
									showModalMessage("No Data", "No surfaces found in files", "warning");
								}
							})
							.catch(function (error) {
								console.error("Error parsing Surpac surface:", error);
								showModalMessage("Parse Error", error.message, "error");
							});
					}

					return; // Exit early for surface import
				}

				// Step 7) Handle single file import (STR blast holes or DTM point cloud)
				var file = files[0];
				if (!file) return;

				// Step 8) Read file
				var reader = new FileReader();
				reader.onload = function (event) {
					var content = event.target.result;

					// Step 9) Parse using FileManager
					var Parser = window.fileManager.parsers.get(parserFormat);
					if (!Parser) {
						showModalMessage("Error", "Surpac " + fileFormat.toUpperCase() + " parser not found", "error");
						return;
					}

					var parser = new Parser();
					parser.parse(content)
						.then(function (data) {
							// Step 8) Process parsed data
							// NOTE: Surpac STR files contain KAD geometry only (polylines, points)
							// Blast holes use CSV or IREDES format instead

							// Add KAD entities if any
							if (data.kadEntities && data.kadEntities.length > 0) {
								if (!allKADDrawingsMap) allKADDrawingsMap = new Map();

								// Step 22) Create drawing layer for STR import using filename
								var strFileName = file.name;
								var strLayer = getOrCreateLayerForImport("drawing", strFileName);
								var strLayerId = strLayer ? strLayer.layerId : null;
								console.log("‚úÖ [Layer] Created drawing layer for STR import:", strFileName, "->", strLayerId);

								// Step 6a) Chunk large polylines/lines BEFORE storing in database
								// This prevents GPU exhaustion and database bloat
								// CRITICAL: This is about SINGLE entity size, not total file size!
								// GPU has limits on single buffer allocation (~10k-20k vertices depending on GPU)
								var MAX_VERTICES_PER_ENTITY = 10000; // Reduced from 15k for better compatibility
								var chunkedCount = 0;
								var totalOriginalVertices = 0;

								data.kadEntities.forEach(function (entity) {
									// Step 22a) Assign layer ID to entity
									entity.layerId = strLayerId;

									// Step 6a.1) Check if entity needs chunking (lines/polys with >10k vertices)
									if ((entity.entityType === "line" || entity.entityType === "poly") && entity.data && entity.data.length > MAX_VERTICES_PER_ENTITY) {
										totalOriginalVertices += entity.data.length;

										// Step 6a.2) Split into chunks
										var numChunks = Math.ceil(entity.data.length / MAX_VERTICES_PER_ENTITY);
										console.warn("‚ö†Ô∏è Large entity detected: " + entity.entityName + " (" + entity.data.length.toLocaleString() + " vertices)");
										console.warn("   ‚Üí Splitting into " + numChunks + " chunks of ~" + Math.ceil(entity.data.length / numChunks).toLocaleString() + " vertices each");
										console.warn("   ‚Üí Why: GPU single-buffer limit (~10k vertices), not file size limit");

										for (var chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
											var startIdx = chunkIdx * MAX_VERTICES_PER_ENTITY;
											var endIdx = Math.min(startIdx + MAX_VERTICES_PER_ENTITY + 1, entity.data.length); // +1 for overlap
											var chunkData = entity.data.slice(startIdx, endIdx);

											// Step 6a.3) Create unique name for chunk (check for collisions with existing entities)
											var baseChunkName = entity.entityName + "_chunk" + (chunkIdx + 1) + "of" + numChunks;
											var chunkName = getUniqueEntityName(baseChunkName, entity.entityType);

											// Step 6a.4) Store chunk as separate entity with layerId
											allKADDrawingsMap.set(chunkName, {
												entityName: chunkName,
												entityType: entity.entityType,
												layerId: strLayerId,
												data: chunkData,
												isChunk: true,
												originalEntity: entity.entityName,
												chunkIndex: chunkIdx,
												totalChunks: numChunks
											});

											// Step 22b) Add to layer entities set
											if (strLayer) {
												strLayer.entities.add(chunkName);
											}
											chunkedCount++;
										}
									} else {
										// Step 6a.5) Normal-sized entity - check for name collision before storing
										var uniqueName = getUniqueEntityName(entity.entityName, entity.entityType);
										if (uniqueName !== entity.entityName) {
											// Name collision detected - update entity's internal name
											entity.entityName = uniqueName;
										}
										allKADDrawingsMap.set(uniqueName, entity);

										// Step 22c) Add to layer entities set
										if (strLayer) {
											strLayer.entities.add(uniqueName);
										}
									}
								});

								if (chunkedCount > 0) {
									console.log("‚úÇÔ∏è Chunked " + chunkedCount + " large entities at storage level");
									console.log("   üìä Total vertices chunked: " + totalOriginalVertices.toLocaleString());
									console.log("   üíæ Database now has " + allKADDrawingsMap.size + " entities (prevents GPU single-buffer exhaustion)");

									// Step 6a.6) Store chunking info for dialog message
									window.lastKadImportInfo = {
										originalCount: data.kadEntities.length,
										chunkedEntities: chunkedCount,
										finalCount: allKADDrawingsMap.size,
										totalVertices: totalOriginalVertices
									};
								} else {
									window.lastKadImportInfo = null; // No chunking
								}
								console.log("Imported " + data.kadEntities.length + " KAD entities from STR (" + allKADDrawingsMap.size + " entities after chunking)");

								// Step 6a.7) Store for dialog
								if (chunkedCount > 0) {
									window.lastKadImportInfo = {
										originalCount: data.kadEntities.length,
										chunkedEntities: chunkedCount,
										finalCount: allKADDrawingsMap.size,
										totalVertices: totalOriginalVertices
									};
								} else {
									window.lastKadImportInfo = null;
								}

								// Save KAD entities to IndexedDB
								if (typeof debouncedSaveKAD === "function") {
									debouncedSaveKAD();
								}

								// Step 22d) Save layers after STR import
								if (typeof debouncedSaveLayers === "function") {
									debouncedSaveLayers();
								}

								// Update TreeView to show new KAD entities
								if (typeof debouncedUpdateTreeView === "function") {
									debouncedUpdateTreeView();
								}

								// Show success message
								var message = "Imported " + data.kadEntities.length + " KAD entit" + (data.kadEntities.length === 1 ? "y" : "ies");
								if (window.lastKadImportInfo && window.lastKadImportInfo.chunkedEntities > 0) {
									message += " (split into " + window.lastKadImportInfo.chunkedEntities + " chunks, " + window.lastKadImportInfo.totalVertices.toLocaleString() + " vertices total)";
								}
								showModalMessage("Import Complete", message, "success");
							} else if (isDTM && data.surfaces && data.surfaces.length > 0) {
								// Import DTM surfaces properly to loadedSurfaces Map

								data.surfaces.forEach(function (surface) {
									// Generate unique surface ID
									var surfaceId = surface.name || ("DTM_Surface_" + Date.now());

									// Extract all unique points from triangles
									var pointsMap = new Map();
									surface.triangles.forEach(function (tri) {
										tri.vertices.forEach(function (v) {
											var key = v.x + "_" + v.y + "_" + v.z;
											if (!pointsMap.has(key)) {
												pointsMap.set(key, { x: v.x, y: v.y, z: v.z });
											}
										});
									});
									var points = Array.from(pointsMap.values());

									// Create proper surface structure
									var surfaceData = {
										id: surfaceId,
										name: surface.name,
										points: points,
										triangles: surface.triangles,
										visible: surface.visible !== false, // Default to true
										gradient: "default",
										color: surface.color || "#00FF00",
										transparency: 1.0
									};

									// Add to loadedSurfaces Map
									loadedSurfaces.set(surfaceId, surfaceData);

									console.log("Added surface '" + surfaceId + "' with " + points.length + " points and " + surface.triangles.length + " triangles");

									// Save surface to IndexedDB
									setTimeout(async function () {
										try {
											await saveSurfaceToDB(surfaceId);
											console.log("DTM surface saved to database: " + surfaceId);
										} catch (saveError) {
											console.error("Failed to save DTM surface:", saveError);
										}
									}, 0);
								});

								console.log("Imported " + data.surfaces.length + " surfaces with " +
									data.surfaces.reduce(function (sum, s) { return sum + s.triangles.length; }, 0) + " triangles from DTM");

								// Draw the imported data
								// Step #) Trigger 3D rebuild to show imported DTM surface data
								window.threeDataNeedsRebuild = true;
								drawData(allBlastHoles, selectedHole);

								// Update tree view if available
								if (typeof debouncedUpdateTreeView === "function") {
									debouncedUpdateTreeView();
								}

								showModalMessage("Import Complete",
									"Imported " + data.surfaces.length + " surfaces from DTM/STR pair",
									"success");
							} else if (data.kadEntities && data.kadEntities.length > 0) {
								// Import KAD entities only (no blast holes)
								if (!allKADDrawingsMap) allKADDrawingsMap = new Map();

								// Step 6b) Chunk large polylines/lines BEFORE storing in database
								// This prevents GPU exhaustion and database bloat
								// CRITICAL: GPU has limits on single buffer size, not total file size
								var MAX_VERTICES_PER_ENTITY = 10000; // Single buffer limit
								var chunkedCount = 0;
								var totalOriginalVertices = 0;

								data.kadEntities.forEach(function (entity) {
									// Step 6b.1) Check if entity needs chunking (lines/polys with >10k vertices)
									if ((entity.entityType === "line" || entity.entityType === "poly") &&
										entity.data && entity.data.length > MAX_VERTICES_PER_ENTITY) {

										totalOriginalVertices += entity.data.length;

										// Step 6b.2) Split into chunks
										var numChunks = Math.ceil(entity.data.length / MAX_VERTICES_PER_ENTITY);
										console.warn("‚ö†Ô∏è Large entity detected: " + entity.entityName + " (" + entity.data.length.toLocaleString() + " vertices)");
										console.warn("   ‚Üí Splitting into " + numChunks + " chunks of ~" + Math.ceil(entity.data.length / numChunks).toLocaleString() + " vertices each");

										for (var chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
											var startIdx = chunkIdx * MAX_VERTICES_PER_ENTITY;
											var endIdx = Math.min(startIdx + MAX_VERTICES_PER_ENTITY + 1, entity.data.length); // +1 for overlap
											var chunkData = entity.data.slice(startIdx, endIdx);

											// Step 6b.3) Create unique name for chunk (check for collisions with existing entities)
											var baseChunkName = entity.entityName + "_chunk" + (chunkIdx + 1) + "of" + numChunks;
											var chunkName = getUniqueEntityName(baseChunkName, entity.entityType);

											// Step 6b.4) Store chunk as separate entity
											allKADDrawingsMap.set(chunkName, {
												entityName: chunkName,
												entityType: entity.entityType,
												data: chunkData,
												isChunk: true,
												originalEntity: entity.entityName,
												chunkIndex: chunkIdx,
												totalChunks: numChunks
											});
											chunkedCount++;
										}
									} else {
										// Step 6b.5) Normal-sized entity - check for name collision before storing
										var uniqueName = getUniqueEntityName(entity.entityName, entity.entityType);
										if (uniqueName !== entity.entityName) {
											// Name collision detected - update entity's internal name
											entity.entityName = uniqueName;
										}
										allKADDrawingsMap.set(uniqueName, entity);
									}
								});

								if (chunkedCount > 0) {
									console.log("‚úÇÔ∏è Chunked " + chunkedCount + " large entities at storage level");
									console.log("   üìä Total vertices chunked: " + totalOriginalVertices.toLocaleString());
								}
								console.log("Imported " + data.kadEntities.length + " KAD entities from STR (" + allKADDrawingsMap.size + " entities after chunking)");

								// Update UI elements (same as DXF import)
								updateCentroids();
								// Step #) Trigger 3D rebuild to show imported STR KAD data
								window.threeDataNeedsRebuild = true;
								drawData(allBlastHoles, selectedHole);
								debouncedSaveKAD();
								zoomToFitAll();

								// Update tree view if available
								if (typeof debouncedUpdateTreeView === "function") {
									debouncedUpdateTreeView();
								}

								showModalMessage("Import Complete",
									"Imported " + data.kadEntities.length + " KAD entit" + (data.kadEntities.length === 1 ? "y" : "ies") +
									(window.lastKadImportInfo && window.lastKadImportInfo.chunkedEntities > 0 ?
										" (split into " + window.lastKadImportInfo.chunkedEntities + " chunks, " +
										window.lastKadImportInfo.totalVertices.toLocaleString() + " vertices total)" : ""),
									"success");
							} else {
								showModalMessage("No Data", "No data found in file", "warning");
								return;
							}

							// Step 9) Update tree view if available
							if (typeof debouncedUpdateTreeView === "function") {
								debouncedUpdateTreeView();
							}
						})
						.catch(function (error) {
							console.error("Error parsing Surpac " + fileFormat.toUpperCase() + ":", error);
							showModalMessage("Parse Error", error.message, "error");
						});
				};

				reader.onerror = function () {
					showModalMessage("File Error", "Failed to read file", "error");
				};

				reader.readAsText(file);
			};

			// Step 11) Trigger file picker
			input.click();
		} catch (error) {
			console.error("Error importing Surpac file:", error);
			showModalMessage("Import Error", error.message, "error");
		}
	});
});

// GEOTIFF/IMAGE IMPORT - Using existing loadGeoTIFF
document.querySelectorAll(".image-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		var format = document.getElementById("imageFormat").value;

		if (format === "geo-tiff" || format === "elevation-tiff") {
			// Use existing GeoTIFF loader
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".tif,.tiff";
			input.onchange = handleGeotiffUpload;
			input.click();
		} else if (format === "jpg") {
			showModalMessage("Coming Soon", "JPG import will be available in a future update", "info");
		}
	});
});

// GEOTIFF/IMAGE EXPORT
document.querySelectorAll(".image-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Get selected format from dropdown
			var format = document.getElementById("imageFormat").value;

			if (format === "geo-tiff") {
				// Export cached canvases and loaded images as RGB GeoTIFF
				await exportImagesAsGeoTIFF(surface2DCache, loadedSurfaces, loadedImages, window.fileManager, showModalMessage);
			} else if (format === "elevation-tiff") {
				// Export surfaces as elevation GeoTIFF
				await exportSurfacesAsElevationGeoTIFF(loadedSurfaces, window.fileManager, showModalMessage);
			}
		} catch (error) {
			console.error("Error exporting image:", error);
			showModalMessage("Export Error", error.message, "error");
		}
	});
});

// OBJ/GLTF IMPORT - Using existing loadOBJWithMTL via handleSurfaceUpload
document.querySelectorAll(".obj-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		// Step 1) Show helpful message about selecting multiple files
		showModalMessage(
			"OBJ File Selection",
			"Please select ALL related files:\n\n" +
			"‚Ä¢ .obj file (required)\n" +
			"‚Ä¢ .mtl file (if textured)\n" +
			"‚Ä¢ .jpg/.png texture files (if any)\n\n" +
			"Use Ctrl+Click (Cmd+Click on Mac) to select multiple files together.",
			"info"
		);

		// Step 2) Open file picker with multiple selection enabled
		setTimeout(function () {
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".obj,.gltf,.ply,.mtl,.jpg,.jpeg,.png,.gif,.bmp";
			input.multiple = true; // CRITICAL: Allows selecting OBJ + MTL + textures together
			input.onchange = handleSurfaceUpload;
			input.click();
		}, 100);
	});
});

// OBJ EXPORT
document.querySelectorAll(".obj-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Check if surfaces are loaded
			if (!window.loadedSurfaces || window.loadedSurfaces.size === 0) {
				showModalMessage("No Data", "No surfaces loaded. Please load a surface first (OBJ, DXF, PLY).", "warning");
				return;
			}

			// Step 2) Get OBJ writer
			var Writer = window.fileManager.writers.get("obj");
			if (!Writer) {
				showModalMessage("Error", "OBJ writer not found", "error");
				return;
			}

			// Step 3) Convert surfaces to OBJ format - only export visible surfaces
			var surfaces = Array.from(window.loadedSurfaces.values()).filter(function (surface) {
				return surface.visible;
			});

			if (surfaces.length === 0) {
				showModalMessage("No Data", "No visible surfaces to export", "warning");
				return;
			}

			// Step 3a) Build vertices, normals, and faces from triangles with deduplication
			var vertices = [];
			var normals = [];
			var faces = [];
			var vertexMap = new Map(); // Deduplicate vertices
			var normalMap = new Map(); // Deduplicate normals

			surfaces.forEach(function (surface) {
				if (!surface.triangles || !Array.isArray(surface.triangles)) {
					return;
				}

				surface.triangles.forEach(function (triangle) {
					// Validate triangle structure
					if (!triangle.vertices || triangle.vertices.length !== 3) {
						return;
					}

					// Validate all 3 vertices are valid before processing
					var allValid = true;
					for (var v = 0; v < 3; v++) {
						var vert = triangle.vertices[v];
						if (!vert || vert.x === undefined || vert.y === undefined || vert.z === undefined) {
							allValid = false;
							break;
						}
					}

					if (!allValid) {
						console.warn("Skipping triangle with invalid vertices");
						return;
					}

					// Step 3b) Calculate face normal
					var v0 = triangle.vertices[0];
					var v1 = triangle.vertices[1];
					var v2 = triangle.vertices[2];

					// Edge vectors
					var e1x = v1.x - v0.x;
					var e1y = v1.y - v0.y;
					var e1z = v1.z - v0.z;
					var e2x = v2.x - v0.x;
					var e2y = v2.y - v0.y;
					var e2z = v2.z - v0.z;

					// Cross product
					var nx = e1y * e2z - e1z * e2y;
					var ny = e1z * e2x - e1x * e2z;
					var nz = e1x * e2y - e1y * e2x;

					// Normalize
					var len = Math.sqrt(nx * nx + ny * ny + nz * nz);
					if (len > 0) {
						nx /= len;
						ny /= len;
						nz /= len;
					}

					// Step 3c) Add or find normal
					var normalKey = nx.toFixed(6) + "," + ny.toFixed(6) + "," + nz.toFixed(6);
					var normalIndex;
					if (normalMap.has(normalKey)) {
						normalIndex = normalMap.get(normalKey);
					} else {
						normalIndex = normals.length;
						normals.push({ x: nx, y: ny, z: nz });
						normalMap.set(normalKey, normalIndex);
					}

					// Step 3d) Add or find vertices and build face
					var faceIndices = [];
					for (var v = 0; v < 3; v++) {
						var vert = triangle.vertices[v];
						var vertKey = vert.x.toFixed(6) + "," + vert.y.toFixed(6) + "," + vert.z.toFixed(6);

						var vertexIndex;
						if (vertexMap.has(vertKey)) {
							vertexIndex = vertexMap.get(vertKey);
						} else {
							vertexIndex = vertices.length;
							vertices.push({ x: vert.x, y: vert.y, z: vert.z });
							vertexMap.set(vertKey, vertexIndex);
						}
						faceIndices.push(vertexIndex);
					}

					// Step 3e) Add face with vertex and normal indices
					faces.push({
						indices: faceIndices,
						normalIndex: normalIndex
					});
				});
			});

			if (vertices.length === 0) {
				showModalMessage("No Data", "No vertices found in surfaces", "warning");
				return;
			}

			// Step 3f) Write OBJ with proper data structure including normals
			var writer = new Writer();
			var blob = await writer.write({
				vertices: vertices,
				normals: normals,
				faces: faces
			});

			// Step 4) Download file
			var uid = Math.random().toString(36).slice(2, 6);
			var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
			writer.downloadFile(blob, "KIRRA_OBJ_" + uid + ".obj");

			console.log("OBJ export completed: " + vertices.length + " vertices, " + normals.length + " normals, " + faces.length + " faces from " + surfaces.length + " surface(s)");
			showModalMessage("Export Complete", "Exported " + vertices.length + " vertices, " + normals.length + " normals, " + faces.length + " faces to OBJ", "success");
		} catch (error) {
			console.error("OBJ export error:", error);
			showModalMessage("Export Failed", "Error: " + error.message, "error");
		}
	});
});

// POINT CLOUD IMPORT - Using existing loadPointCloudFile via handleSurfaceUpload
document.querySelectorAll(".pointcloud-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		var input = document.createElement("input");
		input.type = "file";
		input.accept = ".xyz,.txt,.csv,.ply,.pts";
		input.onchange = handleSurfaceUpload;
		input.click();
	});
});

// POINT CLOUD EXPORT
document.querySelectorAll(".pointcloud-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Check if surfaces are loaded
			if (!window.loadedSurfaces || window.loadedSurfaces.size === 0) {
				showModalMessage("No Data", "No surfaces loaded. Please load a surface first to export as point cloud.", "warning");
				return;
			}

			// Step 2) Get Point Cloud writer
			var Writer = window.fileManager.writers.get("pointcloud-xyz");
			if (!Writer) {
				showModalMessage("Error", "Point Cloud writer not found", "error");
				return;
			}

			// Step 3) Extract all vertices from visible surfaces only as points
			var points = [];
			window.loadedSurfaces.forEach(function (surface) {
				if (surface.visible && surface.triangles && Array.isArray(surface.triangles)) {
					surface.triangles.forEach(function (triangle) {
						if (triangle.vertices) {
							triangle.vertices.forEach(function (vertex) {
								points.push({
									x: vertex.x,
									y: vertex.y,
									z: vertex.z || 0
								});
							});
						}
					});
				}
			});

			if (points.length === 0) {
				showModalMessage("No Data", "No vertices found in surfaces", "warning");
				return;
			}

			// Step 4) Generate default filename
			var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
			var defaultFilename = "POINTCLOUD_Surface_" + timestamp + ".xyz";

			// Step 5) Show filename dialog
			showConfirmationDialogWithInput(
				"Export Point Cloud XYZ",
				"Enter filename for point cloud export (" + points.length + " points)",
				"Filename:",
				"text",
				defaultFilename,
				"Export",
				"Cancel",
				async function (filename) {
					if (!filename || filename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					if (!filename.toLowerCase().endsWith(".xyz")) {
						filename += ".xyz";
					}

					try {
						// Step 6) Export as XYZ
						var writer = new Writer();
						var blob = await writer.write({
							points: points
						});

						// Step 7) Use File System Access API if available
						if (window.showSaveFilePicker) {
							exportPointCloudWithFilePicker(blob, filename);
						} else {
							// Fallback to standard download
							writer.downloadFile(blob, filename);
							showModalMessage("Export Complete", "Exported " + points.length + " points to " + filename, "success");
						}

						console.log("Point Cloud export completed: " + points.length + " points");
					} catch (error) {
						console.error("Point Cloud export error:", error);
						showModalMessage("Export Failed", "Error: " + error.message, "error");
					}
				},
				function () {
					console.log("Point Cloud export cancelled by user");
				}
			);
		} catch (error) {
			console.error("Point Cloud export error:", error);
			showModalMessage("Export Failed", "Error: " + error.message, "error");
		}
	});
});

// KML/KMZ IMPORT - Import blast holes or geometry from Google Earth
document.querySelectorAll(".kml-input-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Create file input for KML/KMZ files
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".kml,.kmz";
			input.multiple = false;

			input.onchange = async function (e) {
				var file = e.target.files[0];
				if (!file) return;

				try {
					// Step 2) Use FileManager to parse KML/KMZ
					if (window.fileManager) {
						var parser = window.fileManager.getParser("kml-kmz");
						if (!parser) {
							throw new Error("KML/KMZ parser not found in FileManager");
						}

						// Step 3) Show progress message
						showStatusMessage("Importing " + file.name + "...");

						// Step 4) Parse the file
						var result = await parser.parse(file);

						if (!result || result.cancelled) {
							showModalMessage("Import Cancelled", "KML/KMZ import was cancelled", "info");
							return;
						}

						if (!result.success) {
							throw new Error(result.message || "Failed to parse KML/KMZ file");
						}

						// Step 5) Handle the imported data based on type
						if (result.dataType === "blastholes") {
							// Step 6) Import blast holes
							if (result.holes && result.holes.length > 0) {
								// Add holes to allBlastHoles array
								for (var i = 0; i < result.holes.length; i++) {
									window.allBlastHoles.push(result.holes[i]);
								}

								// Step 7) Update centroids and trigger 3D rebuild
								updateCentroids();
								window.threeDataNeedsRebuild = true;

								// Step 7a) Update UI and redraw
								window.drawData(window.allBlastHoles, window.selectedHole);

								// Step 7b) Save holes to IndexedDB
								if (typeof debouncedSaveHoles === "function") {
									debouncedSaveHoles();
								}

								// Update tree view if available
								if (window.debouncedUpdateTreeView) {
									window.debouncedUpdateTreeView();
								}

								// Show success message
								showModalMessage(
									"Import Successful",
									"Imported " + result.holes.length + " blast holes from " + file.name,
									"success"
								);

								console.log("KML/KMZ import: Added " + result.holes.length + " blast holes");
							} else {
								showModalMessage("No Data", "No blast holes found in file", "warning");
							}
						} else if (result.dataType === "geometry") {
							// Step 8) Import geometry (KAD entities)
							if (result.kadEntities && result.kadEntities.size > 0) {
								// Step 23) Create layer for KML import
								var kmlLayer = window.getOrCreateLayerForImport("drawing", file.name);
								var kmlLayerId = kmlLayer ? kmlLayer.layerId : null;
								console.log("‚úÖ [Layer] Created drawing layer for KML import:", file.name, "->", kmlLayerId);

								// Add entities to allKADDrawingsMap with layer assignment
								for (var [entityName, entityData] of result.kadEntities.entries()) {
									// Step 23a) Assign layerId to entity
									entityData.layerId = kmlLayerId;
									window.allKADDrawingsMap.set(entityName, entityData);
									// Step 23b) Add to layer entities set
									if (kmlLayer) {
										kmlLayer.entities.add(entityName);
									}
								}

								// Step 9) Update centroids and trigger 3D rebuild
								updateCentroids();
								window.threeDataNeedsRebuild = true;

								// Step 9a) Update UI and redraw
								window.drawData(window.allBlastHoles, window.selectedHole);

								// Step 23c) Save KAD entities to IndexedDB
								if (typeof debouncedSaveKAD === "function") {
									debouncedSaveKAD();
								}

								// Step 23d) Save layers
								if (window.debouncedSaveLayers) {
									window.debouncedSaveLayers();
								}

								// Update tree view if available
								if (window.debouncedUpdateTreeView) {
									window.debouncedUpdateTreeView();
								}

								// Show success message
								showModalMessage(
									"Import Successful",
									"Imported " + result.kadEntities.size + " geometry entities from " + file.name,
									"success"
								);

								console.log("KML/KMZ import: Added " + result.kadEntities.size + " KAD entities");
							} else {
								showModalMessage("No Data", "No geometry found in file", "warning");
							}
						}

						// Clear status message
						clearStatus();

					} else {
						throw new Error("FileManager not initialized");
					}
				} catch (error) {
					console.error("KML/KMZ import error:", error);
					showModalMessage("Import Failed", error.message, "error");
					clearStatus();
				}
			};

			// Step 10) Trigger file picker
			input.click();

		} catch (error) {
			console.error("KML/KMZ import error:", error);
			showModalMessage("Import Failed", error.message, "error");
		}
	});
});

// KML/KMZ EXPORT - Export visible blast holes or geometry to Google Earth
document.querySelectorAll(".kml-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Show projection configuration dialog
			var config = await window.promptForKMLExportProjection("blastholes");

			if (config.cancelled) {
				return;
			}

			// Step 2) Prepare data based on export type
			var data = {};
			var entityName = "Export";

			if (config.exportType === "blastholes") {
				// Step 3) Filter visible holes
				var visibleHoles = window.allBlastHoles.filter(function (hole) {
					return window.isHoleVisible(hole);
				});

				if (visibleHoles.length === 0) {
					showModalMessage("No Data", "No visible holes to export", "warning");
					return;
				}

				data.holes = visibleHoles;
				entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Blast";
			} else if (config.exportType === "geometry") {
				// Step 4) Get visible KAD entities from kadDrawingsMap
				var visibleEntities = [];

				if (window.allKADDrawingsMap && window.allKADDrawingsMap.size > 0) {
					for (var [entityName, entityData] of window.allKADDrawingsMap.entries()) {
						// Check visibility
						if (window.isEntityVisible && !window.isEntityVisible(entityName)) {
							continue;
						}

						// Convert KAD format to entities array for KML export
						if (entityData && entityData.data && Array.isArray(entityData.data)) {
							// Create entity object compatible with KML writer
							var entity = {
								name: entityName,
								entityName: entityName,
								type: entityData.entityType,
								entityType: entityData.entityType,
								// Use first item's properties as defaults for entity level
								color: entityData.data.length > 0 ? entityData.data[0].color : "#FFFFFF",
								lineWidth: entityData.data.length > 0 ? (entityData.data[0].lineWidth || 1) : 1,
								coordinates: []
							};

							// Map coordinates based on entity type
							// IMPORTANT: Each coordinate carries its own color and lineWidth (and text/radius where applicable)
							for (var i = 0; i < entityData.data.length; i++) {
								var item = entityData.data[i];
								var coord = {
									x: item.pointXLocation || 0,
									y: item.pointYLocation || 0,
									z: item.pointZLocation || 0,
									id: item.pointID,
									color: item.color || entity.color,  // Each coord has its own color!
									lineWidth: item.lineWidth || entity.lineWidth  // Each coord has its own lineWidth!
								};

								// Add text property only for text entities
								if (entityData.entityType === "text" && item.text !== undefined) {
									coord.text = item.text;
								}

								// Add radius property only for circle entities
								if (entityData.entityType === "circle" && item.radius !== undefined) {
									coord.radius = item.radius;
								}

								entity.coordinates.push(coord);
							}

							// Add entity-level properties for circles and text
							if (entityData.entityType === "circle" && entityData.data.length > 0) {
								entity.radius = entityData.data[0].radius || 10;
							}
							if (entityData.entityType === "text" && entityData.data.length > 0) {
								entity.text = entityData.data[0].text || "";
								entity.fontHeight = entityData.data[0].fontHeight || 12;
							}

							visibleEntities.push(entity);
						}
					}
				}

				if (visibleEntities.length === 0) {
					showModalMessage("No Data", "No visible geometry to export", "warning");
					return;
				}

				data.entities = visibleEntities;
				entityName = "Geometry";
			}

			// Step 5) Generate default filename
			var timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, "");
			var extension = config.compressed ? ".kmz" : ".kml";
			var defaultFilename = "KIRRA_" + entityName + "_" + timestamp + extension;

			// Step 6) Show filename dialog
			showConfirmationDialogWithInput(
				"Export " + (config.compressed ? "KMZ" : "KML"),
				"Enter filename for export",
				"Filename:",
				"text",
				defaultFilename,
				"Export",
				"Cancel",
				async function (filename) {
					// User confirmed
					if (!filename || filename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					// Ensure correct extension
					var ext = config.compressed ? ".kmz" : ".kml";
					if (!filename.toLowerCase().endsWith(ext)) {
						filename += ext;
					}

					try {
						// Step 7) Get writer from FileManager
						var Writer = window.fileManager.writers.get("kml-kmz");
						if (!Writer) {
							throw new Error("KML/KMZ writer not found in FileManager");
						}

						// Step 8) Create writer instance with configuration
						var writer = new Writer({
							exportType: config.exportType,
							compressed: config.compressed,
							epsgCode: config.epsgCode,
							proj4Source: config.proj4Source
						});

						// Step 9) Add document name to data
						data.documentName = filename.replace(ext, "");

						// Step 10) Generate file
						var blob = await writer.write(data);

						// Step 11) Download file
						writer.downloadFile(blob, filename);

						// Step 12) Show success message
						showModalMessage(
							"Export Successful",
							"Exported " + (config.exportType === "blastholes" ? visibleHoles.length + " holes" : visibleEntities.length + " entities") + " to " + filename,
							"success"
						);
					} catch (error) {
						console.error("KML/KMZ export error:", error);
						showModalMessage("Export Failed", error.message, "error");
					}
				},
				function () {
					// User cancelled
					console.log("KML/KMZ export cancelled by user");
				}
			);

		} catch (error) {
			console.error("KML/KMZ export error:", error);
			showModalMessage("Export Failed", error.message, "error");
		}
	});
});

// EPIROC SURFACE MANAGER (IREDES) - Import and Export
document.querySelectorAll(".surfaceManager-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		// Step 1) Get selected format
		var format = document.getElementById("surfaceManagerFormat").value;

		if (format === "iredes") {
			// Step 2) Create file input for IREDES XML import
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".xml";
			input.multiple = false;

			input.onchange = function (e) {
				var file = e.target.files[0];
				if (!file) return;

				// Step 3) Use FileManager to parse IREDES XML
				if (window.fileManager) {
					var parser = window.fileManager.getParser("iredes-xml");
					if (parser) {
						parser
							.parse(file)
							.then(function (result) {
								// Step 4) Extract holes from result
								var holes = result.holes;
								var metadata = result.metadata;

								if (!holes || holes.length === 0) {
									showModalMessage("No Holes Found", "The IREDES file does not contain any holes.", "warning");
									return;
								}

								// Step 5) RULE #9: Use addHole() to create proper hole geometry
								// Get entity name from filename
								var entityName = file.name || "IREDES_Import";
								if (entityName.indexOf(".") !== -1) {
									entityName = entityName.substring(0, entityName.lastIndexOf("."));
								}

								if (!allBlastHoles || !Array.isArray(allBlastHoles)) allBlastHoles = [];

								// Step 6) Call addHole() for each parsed hole to create proper geometry
								for (var i = 0; i < holes.length; i++) {
									var h = holes[i];

									// addHole() will calculate: benchHeight, gradeXYZ, endXYZ, subdrillLength
									addHole(
										true, // useCustomHoleID = true (use parsed holeID)
										true, // useGradeZ = true (calculate from gradeZLocation)
										entityName, // entity name from filename
										h.holeID, // parsed hole ID
										h.startXLocation, // collar X
										h.startYLocation, // collar Y
										h.startZLocation, // collar Z
										h.gradeZLocation, // grade Z (= toe Z for IREDES)
										h.holeDiameter, // diameter (may be 0)
										h.holeType, // hole type
										h.holeLengthCalculated, // calculated length
										h.subdrillAmount, // 0 for IREDES
										h.holeAngle, // angle from vertical
										h.holeBearing, // bearing
										null, // rowID = null (will be assigned by HDBSCAN)
										null, // posID = null (will be assigned by HDBSCAN)
										h.burden, // 1 (default)
										h.spacing // 1 (default)
									);

									// CRITICAL FIX: Copy IREDES-specific fields that addHole() doesn't accept
									var createdHole = allBlastHoles.find(function (hole) {
										return hole.entityName === entityName && hole.holeID === h.holeID;
									});

									if (createdHole) {
										// IREDES provides measuredComment (comment field)
										if (h.measuredComment && h.measuredComment !== "None") {
											createdHole.measuredComment = h.measuredComment;
										}
									}
								}

								// Step 7) Get all holes for this entity for HDBSCAN
								var importedHoles = allBlastHoles.filter(function (hole) {
									return hole.entityName === entityName;
								});

								// Step 8) CRITICAL: Assign rowID and posID using smart row detection BEFORE calculating burden/spacing
								// This uses HDBSCAN clustering to detect rows in the blast pattern
								if (importedHoles.length > 0) {

									// Step 8a) Try improved smart row detection (multiple methods)
									if (typeof improvedSmartRowDetection === "function") {
										improvedSmartRowDetection(importedHoles, entityName);
										console.log("IREDES: Used improved smart row detection");
									} else if (typeof detectRowsUsingHDBSCAN === "function") {
										// Step 8b) Fallback to HDBSCAN if improved method not available
										detectRowsUsingHDBSCAN(importedHoles, entityName);
										console.log("IREDES: Used HDBSCAN row detection");
									} else {
										console.warn("IREDES: Row detection functions not available");
									}
								}

								// Step 9) Calculate burden and spacing (only if not already set)
								// CRITICAL: Preserve user-supplied burden/spacing values
								var needsBurdenCalc = importedHoles.filter(function (h) {
									return (h.burden === undefined || h.burden === null || h.burden === 1) &&
										(h.spacing === undefined || h.spacing === null || h.spacing === 1);
								});
								if (needsBurdenCalc.length > 0) {
									calculateBurdenAndSpacingForHoles(needsBurdenCalc);
								}

								// Step 9) Recalculate dependent data structures - ESSENTIAL for proper display
								if (allBlastHoles.length > 0) {
									var triangleResult = delaunayTriangles(allBlastHoles, maxEdgeLength);
									holeTimes = calculateTimes(allBlastHoles);

									// Recalculate contours
									var contourResult = recalculateContours(allBlastHoles, deltaX, deltaY);
									contourLinesArray = contourResult.contourLinesArray;
									directionArrows = contourResult.directionArrows;
								}

								// Step 10) Update centroids and trigger 3D rebuild
								updateCentroids();
								window.threeDataNeedsRebuild = true;

								// Step 10a) Update time chart
								timeChart();

								// Step 11) Draw the imported data
								drawData(allBlastHoles, selectedHole);

								// Step 12) Save to IndexedDB
								if (typeof debouncedSaveHoles === "function") {
									debouncedSaveHoles();
								}

								// Step 13) Update TreeView (will be triggered by debouncedSaveHoles, but call explicitly too)
								if (typeof debouncedUpdateTreeView === "function") {
									debouncedUpdateTreeView();
								}

								// Step 14) Show success message
								var successMsg = "Imported " + importedHoles.length + " holes from " + file.name;
								if (metadata && metadata.planId) {
									successMsg += "\n\nPlan ID: " + metadata.planId;
									if (metadata.project) successMsg += "\nProject: " + metadata.project;
								}
								showModalMessage("IREDES Import Success", successMsg, "success");
							})
							.catch(function (error) {
								console.error("IREDES import error:", error);
								showModalMessage("Import Error", "Failed to parse IREDES XML: " + error.message, "error");
							});
					} else {
						showModalMessage("Import Error", "IREDES parser not available", "error");
					}
				} else {
					showModalMessage("Import Error", "FileManager not available", "error");
				}
			};

			input.click();
		} else if (format === "geofence" || format === "hazard" || format === "socket") {
			// Step 7) Import geofence/hazard/socket files
			var input = document.createElement("input");
			input.type = "file";
			input.accept = "." + format + ",.txt";
			input.multiple = false;

			input.onchange = function (e) {
				var file = e.target.files[0];
				if (!file) return;

				// Step 8) Use FileManager to parse Surface Manager file
				if (window.fileManager) {
					var parser = window.fileManager.getParser("surface-manager");
					if (parser) {
						parser
							.parse(file)
							.then(function (result) {
								// Step 9) Result contains parsed points (without elevation yet)
								if (result && result.points && result.points.length > 0) {
									// Step 10) Ask user for elevation using FloatingDialog
									var fields = [
										{
											label: "Elevation (Z)",
											name: "elevation",
											value: "0",
											placeholder: "Enter elevation for all points"
										}
									];

									var formContent = window.createEnhancedFormContent(fields, false, false);

									var dialog = new window.FloatingDialog({
										title: "Set Elevation for " + format.charAt(0).toUpperCase() + format.slice(1),
										content: formContent,
										layoutType: "default",
										showConfirm: true,
										showCancel: true,
										confirmText: "Import",
										cancelText: "Cancel",
										width: 350,
										height: 150,
										onConfirm: function () {
											// Step 11) Get elevation value
											var formData = window.getFormData(formContent);
											var elevation = parseFloat(formData.elevation) || 0;

											// Step 12) Apply elevation to all points
											for (var i = 0; i < result.points.length; i++) {
												result.points[i].pointZLocation = elevation;
											}

											// Step 13) Create KAD entity based on format type
											var entityName = result.entityName || file.name.replace(/\.[^/.]+$/, "");
											var kadEntity = null;

											if (format === "socket") {
												// Step 14) Sockets = individual points (not connected)
												kadEntity = {
													entityName: entityName,
													entityType: "point",
													data: result.points.map(function (point, index) {
														return {
															entityName: entityName,
															entityType: "point",
															pointID: index + 1,
															pointXLocation: point.pointXLocation,
															pointYLocation: point.pointYLocation,
															pointZLocation: elevation,
															lineWidth: 1,
															color: "#FF0000", // Red for sockets
															connected: false,
															closed: false,
															visible: true
														};
													}),
													visible: true
												};
											} else {
												// Step 15) Geofence/Hazard = polyline (connected and closed)
												var color = format === "geofence" ? "#00FF00" : "#FF0000"; // Green for geofence, Red for hazard
												kadEntity = {
													entityName: entityName,
													entityType: "poly",
													data: result.points.map(function (point, index) {
														return {
															entityName: entityName,
															entityType: "poly",
															pointID: index + 1,
															pointXLocation: point.pointXLocation,
															pointYLocation: point.pointYLocation,
															pointZLocation: elevation,
															lineWidth: 2,
															color: color,
															connected: true,
															closed: true,
															visible: true
														};
													}),
													visible: true
												};
											}

											// Step 16) Add to KAD drawings map
											window.allKADDrawingsMap.set(entityName, kadEntity);

											// Step 17) Update centroids and trigger 3D rebuild
											updateCentroids();
											window.threeDataNeedsRebuild = true;

											// Step 17a) Redraw
											drawData(allBlastHoles, selectedHole);

											// Step 18) Save KAD entities to IndexedDB
											if (typeof debouncedSaveKAD === "function") {
												debouncedSaveKAD();
											}

											// Step 18a) Update TreeView
											if (typeof debouncedUpdateTreeView === "function") {
												debouncedUpdateTreeView();
											}

											showModalMessage("Import Success", "Imported " + result.points.length + " points from " + file.name + " at elevation " + elevation.toFixed(3), "success");
										}
									});

									dialog.show();
								} else {
									showModalMessage("No Points Found", "The file does not contain any valid points.", "warning");
								}
							})
							.catch(function (error) {
								console.error("Geofence import error:", error);
								showModalMessage("Import Error", "Failed to parse " + format + " file: " + error.message, "error");
							});
					} else {
						showModalMessage("Import Error", "Geofence parser not available", "error");
					}
				} else {
					showModalMessage("Import Error", "FileManager not available", "error");
				}
			};

			input.click();
		} else {
			showModalMessage("Coming Soon", "Epiroc " + format + " import will be available in a future update", "info");
		}
	});
});

document.querySelectorAll(".surfaceManager-output-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		// Step 1) Get selected format
		var format = document.getElementById("surfaceManagerFormat").value;

		if (format === "iredes") {
			// Step 2) Use existing IREDES export dialog
			if (typeof saveIREDESPopup === "function") {
				saveIREDESPopup();
			} else {
				showModalMessage("Export Error", "IREDES export function not loaded", "error");
			}
		} else if (format === "geofence" || format === "hazard" || format === "socket") {
			// Step 3) Export geofence/hazard/socket files
			// Step 4) Get all visible points based on format type
			var allPoints = [];
			var filterEntityType = format === "socket" ? "point" : "poly"; // Sockets = points, Geofence/Hazard = poly

			window.allKADDrawingsMap.forEach(function (entity) {
				// Step 5) Filter by entity type and visibility
				if (entity.entityType === filterEntityType && entity.visible !== false && entity.data) {
					entity.data.forEach(function (point) {
						if (point.visible !== false) {
							allPoints.push(point);
						}
					});
				}
			});

			if (allPoints.length === 0) {
				var entityTypeText = format === "socket" ? "points" : "polylines";
				showModalMessage("No " + entityTypeText, "There are no visible " + entityTypeText + " to export.", "warning");
				return;
			}

			// Step 6) Check point limit for geofence/hazard (150 max per reference file)
			if ((format === "geofence" || format === "hazard") && allPoints.length >= 150) {
				showModalMessage("Too Many Points", "Geofence and Hazard files are limited to 150 points. You have " + allPoints.length + " points. Please reduce the number of visible points.", "warning");
				return;
			}

			// Step 6) Use FileManager to export
			if (window.fileManager) {
				var writer = window.fileManager.getWriter("surface-manager");
				if (writer) {
					// Step 7) Prepare export data
					var exportData = {
						points: allPoints
					};

					// Step 8) Generate filename
					var timestamp = new Date().toISOString().slice(0, 10).replace(/-/g, "");
					var filename = format + "_export_" + timestamp + "." + format;

					writer
						.write(exportData)
						.then(function (blob) {
							// Step 9) Download the file
							writer.downloadFile(blob, filename);
							showModalMessage("Export Success", "Exported " + allPoints.length + " points to " + filename, "success");
						})
						.catch(function (error) {
							console.error("Geofence export error:", error);
							showModalMessage("Export Error", "Failed to export " + format + " file: " + error.message, "error");
						});
				} else {
					showModalMessage("Export Error", "Geofence writer not available", "error");
				}
			} else {
				showModalMessage("Export Error", "FileManager not available", "error");
			}
		} else {
			showModalMessage("Coming Soon", "Epiroc " + format + " export will be available in a future update", "info");
		}
	});
});

// MINESTAR AQM EXPORT - Using FileManager AQMWriter
document.querySelectorAll(".aqm-output-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		// Use existing AQM export dialog
		if (typeof saveAQMPopup === "function") {
			saveAQMPopup();
		} else {
			console.error("saveAQMPopup function not found!");
			showModalMessage("Export Error", "AQM export function not loaded", "error");
		}
	});
});

// MINESTAR AQM IMPORT - Coming Soon
document.querySelectorAll(".aqm-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		showModalMessage("Coming Soon", "AQM import will be available in a future update", "info");
	});
});

// WENCO NAV ASCII - Import/Export
document.querySelector(".wenco-input-btn")?.addEventListener("click", function () {
	// Step 1) Create file input for Wenco NAV import
	var input = document.createElement("input");
	input.type = "file";
	input.accept = ".nav";
	input.multiple = false;

	input.onchange = function (e) {
		var file = e.target.files[0];
		if (!file) return;

		// Step 2) Use FileManager to parse Wenco NAV
		if (window.fileManager) {
			var parser = window.fileManager.getParser("wenco-nav");
			if (parser) {
				parser
					.parse(file)
					.then(function (result) {
						var entities = result.entities || [];
						var surfaces = result.surfaces || [];

						if (entities.length === 0 && surfaces.length === 0) {
							showModalMessage("No Data Found", "The NAV file does not contain any entities or surfaces.", "warning");
							return;
						}

						// Step 3) Add entities to KAD map
						if (!allKADDrawingsMap) allKADDrawingsMap = new Map();

						var entityName = file.name || "Wenco_NAV";
						if (entityName.indexOf(".") !== -1) {
							entityName = entityName.substring(0, entityName.lastIndexOf("."));
						}

						entities.forEach(function (entity) {
							// Set entity name from file if not already set
							if (!entity.entityName || entity.entityName === "NAV_Import") {
								entity.entityName = entityName + "_" + (entity.layer || "default");
							}

							// Generate unique name if collision
							var uniqueName = getUniqueEntityName(entity.entityName, entity.entityType);
							if (uniqueName !== entity.entityName) {
								entity.entityName = uniqueName;
							}

							// Convert from points format (x, y, z) to KAD data format (pointXLocation, etc.)
							if (entity.points && Array.isArray(entity.points)) {
								entity.data = entity.points.map(function (point, index) {
									var dataPoint = {
										entityName: entity.entityName,
										entityType: entity.entityType,
										pointID: index + 1,
										pointXLocation: point.x,
										pointYLocation: point.y,
										pointZLocation: point.z,
										lineWidth: entity.lineWidth || 1,
										color: entity.colorHexDecimal || "#FF0000" // KAD uses hex color string
									};

									// Add entity-specific properties
									if (entity.entityType === "text") {
										dataPoint.text = entity.text || "";
										dataPoint.fontHeight = entity.textSize || 12; // KAD uses fontHeight
									} else if (entity.entityType === "circle") {
										dataPoint.radius = entity.radius || 1;
									} else if (entity.entityType === "poly" || entity.entityType === "line") {
										dataPoint.closed = entity.closed || false; // KAD needs closed property
									}

									return dataPoint;
								});
								// Remove points array and temporary properties after conversion
								delete entity.points;
								delete entity.textSize; // KAD uses fontHeight in data points
								delete entity.rotation; // Not part of KAD data point format
								delete entity.visible; // Not part of KAD format
								delete entity.connected; // Not part of KAD format
							}

							allKADDrawingsMap.set(entity.entityName, entity);
						});

						// Step 3a) Add surfaces to loadedSurfaces map
						if (surfaces.length > 0) {
							if (!window.loadedSurfaces) window.loadedSurfaces = new Map();

							surfaces.forEach(function (surface) {
								// Generate unique surface ID
								var surfaceId = surface.name || ("NAV_Surface_" + Date.now());
								var counter = 1;
								var baseSurfaceId = surfaceId;
								while (window.loadedSurfaces.has(surfaceId)) {
									surfaceId = baseSurfaceId + "_" + counter;
									counter++;
								}

								// Add surface to map
								window.loadedSurfaces.set(surfaceId, surface);
								console.log("Added NAV surface: " + surfaceId + " with " + surface.triangleCount + " triangles (hillshade: " + surface.hillshadeColor + ")");
							});
						}

						// Step 4) Update centroids and trigger 3D rebuild
						updateCentroids();
						window.threeDataNeedsRebuild = true;

						// Step 4a) Save and update
						if (typeof debouncedSaveKAD === "function") {
							debouncedSaveKAD();
						}

						if (surfaces.length > 0 && typeof debouncedSaveSurfaces === "function") {
							debouncedSaveSurfaces();
						}

						if (typeof debouncedUpdateTreeView === "function") {
							debouncedUpdateTreeView();
						}

						// Step 5) Redraw
						drawData(allBlastHoles, selectedHole);

						// Build success message
						var message = "Imported from " + file.name + ": ";
						var parts = [];
						if (entities.length > 0) {
							parts.push(entities.length + " entit" + (entities.length === 1 ? "y" : "ies"));
						}
						if (surfaces.length > 0) {
							var totalTriangles = surfaces.reduce(function (sum, s) { return sum + (s.triangleCount || 0); }, 0);
							parts.push(surfaces.length + " surface" + (surfaces.length === 1 ? "" : "s") + " (" + totalTriangles + " triangles)");
						}
						message += parts.join(", ");

						showModalMessage("Wenco NAV Import Success", message, "success");
					})
					.catch(function (error) {
						console.error("Wenco NAV import error:", error);
						showModalMessage("Import Error", "Failed to parse Wenco NAV: " + error.message, "error");
					});
			} else {
				showModalMessage("Import Error", "Wenco NAV parser not available", "error");
			}
		} else {
			showModalMessage("Import Error", "FileManager not available", "error");
		}
	};

	input.click();
});

document.querySelector(".wenco-output-btn")?.addEventListener("click", function () {
	// Step 1) Check if we have KAD entities to export
	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		showModalMessage("No Data", "No KAD entities available to export", "warning");
		return;
	}

	// Step 2) Filter to only visible KAD entities (NAV exports KAD + surfaces only)
	var allKADArray = Array.from(allKADDrawingsMap.values());
	var visibleElements = getVisibleHolesAndKADDrawings([], allKADArray);
	var visibleKADEntities = visibleElements.visibleKADDrawings;

	// Filter to only visible surfaces
	var visibleSurfaces = [];
	if (window.loadedSurfaces && window.loadedSurfaces.size > 0) {
		window.loadedSurfaces.forEach(function (surface) {
			if (surface.visible) {
				visibleSurfaces.push(surface);
			}
		});
	}

	// Check if we have any visible data to export
	if (visibleKADEntities.length === 0 && visibleSurfaces.length === 0) {
		showModalMessage("No Data", "No visible KAD entities or surfaces to export", "warning");
		return;
	}

	// Step 3) Generate default filename with timestamp
	var now = new Date();
	var timestamp = now.getFullYear() +
		String(now.getMonth() + 1).padStart(2, "0") +
		String(now.getDate()).padStart(2, "0") + "_" +
		String(now.getHours()).padStart(2, "0") +
		String(now.getMinutes()).padStart(2, "0") +
		String(now.getSeconds()).padStart(2, "0");
	var defaultFilename = "NAV_Export_" + timestamp + ".nav";

	// Step 4) Use FloatingDialog for filename input
	showConfirmationDialogWithInput(
		"Export Wenco NAV",
		"Enter filename for NAV export (" + visibleKADEntities.length + " visible KAD entities, " + visibleSurfaces.length + " visible surfaces)",
		"Filename:",
		"text",
		defaultFilename,
		"Export",
		"Cancel",
		function (filename) {
			// User confirmed - proceed with export
			if (!filename || filename.trim() === "") {
				showModalMessage("Export Cancelled", "No filename provided", "warning");
				return;
			}

			// Ensure .nav extension
			if (!filename.toLowerCase().endsWith(".nav")) {
				filename += ".nav";
			}

			// Check if File System Access API is available (modern browsers)
			if (window.showSaveFilePicker) {
				// Use File System Access API for save location browsing
				exportNAVWithFilePicker(visibleKADEntities, visibleSurfaces, filename);
			} else {
				// Fallback to standard download
				exportNAVStandard(visibleKADEntities, visibleSurfaces, filename);
			}
		},
		function () {
			// User cancelled
			console.log("NAV export cancelled by user");
		}
	);
});

// Helper function: Export NAV with File System Access API (save location browser)
function exportNAVWithFilePicker(entities, surfaces, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'Wenco NAV Files',
			accept: { 'text/plain': ['.nav'] }
		}]
	})
		.then(function (fileHandle) {
			// User selected save location
			return fileHandle.createWritable()
				.then(function (writable) {
					// Generate NAV content
					if (window.fileManager) {
						var writer = window.fileManager.getWriter("wenco-nav");
						if (writer) {
							writer.options.filename = fileHandle.name;

							// Generate NAV content (don't auto-download)
							var navContent = writer.generateNAV(entities, surfaces);

							// Count total items exported
							var totalTriangles = 0;
							if (surfaces && Array.isArray(surfaces)) {
								surfaces.forEach(function (surface) {
									if (surface.triangles) totalTriangles += surface.triangles.length;
								});
							}
							var totalItems = entities.length + totalTriangles;

							// Write to selected file
							return writable.write(navContent)
								.then(function () {
									return writable.close();
								})
								.then(function () {
									var message = "Exported " + entities.length + " entities";
									if (totalTriangles > 0) {
										message += " and " + totalTriangles + " triangles";
									}
									message += " to " + fileHandle.name;
									showModalMessage("Export Success", message, "success");
								});
						}
					}
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download
				exportNAVStandard(entities, surfaces, defaultFilename);
			}
		});
}

// Helper function: Export NAV with standard download (no location browser)
function exportNAVStandard(entities, surfaces, filename) {
	if (window.fileManager) {
		var writer = window.fileManager.getWriter("wenco-nav");
		if (writer) {
			try {
				// Set filename in writer options
				writer.options.filename = filename;

				// Prepare data object with entities and surfaces
				var data = {
					entities: entities,
					surfaces: surfaces
				};

				// Write NAV file (handles download internally)
				writer.write(data)
					.then(function (result) {
						// Count triangles
						var totalTriangles = 0;
						if (surfaces && Array.isArray(surfaces)) {
							surfaces.forEach(function (surface) {
								if (surface.triangles) totalTriangles += surface.triangles.length;
							});
						}

						var message = "Exported " + entities.length + " entities";
						if (totalTriangles > 0) {
							message += " and " + totalTriangles + " triangles";
						}
						message += " to " + filename;

						showModalMessage("Export Success", message, "success");
					})
					.catch(function (error) {
						console.error("Wenco NAV export error:", error);
						showModalMessage("Export Error", "Failed to export Wenco NAV: " + error.message, "error");
					});
			} catch (error) {
				console.error("Wenco NAV export error:", error);
				showModalMessage("Export Error", "Failed to export Wenco NAV: " + error.message, "error");
			}
		} else {
			showModalMessage("Export Error", "Wenco NAV writer not available", "error");
		}
	} else {
		showModalMessage("Export Error", "FileManager not available", "error");
	}
}

// CBLAST Import/Export
document.querySelector(".cblast-input-btn")?.addEventListener("click", function () {
	// Step 1) Create file input for CBLAST CSV import
	var input = document.createElement("input");
	input.type = "file";
	input.accept = ".csv";
	input.multiple = false;

	input.onchange = function (e) {
		var file = e.target.files[0];
		if (!file) return;

		// Step 2) Use FileManager to parse CBLAST CSV
		if (window.fileManager) {
			var parser = window.fileManager.getParser("cblast-csv");
			if (parser) {
				parser
					.parse(file)
					.then(async function (result) {
						var holes = result.holes;

						if (!holes || holes.length === 0) {
							showModalMessage("No Holes Found", "The CBLAST file does not contain any holes.", "warning");
							return;
						}

						// Step 3) RULE #9: Use addHole() to create proper hole geometry
						var entityName = file.name || "CBLAST_Import";
						if (entityName.indexOf(".") !== -1) {
							entityName = entityName.substring(0, entityName.lastIndexOf("."));
						}

						if (!allBlastHoles || !Array.isArray(allBlastHoles)) allBlastHoles = [];

						// Step 3a) Clear proximity Skip All flag for new import
						window.proximitySkipAll = false;
						window.holeGenerationCancelled = false;

						// Step 4) Call addHole() for each parsed hole
						for (var i = 0; i < holes.length; i++) {
							// Check if user cancelled the import
							if (window.holeGenerationCancelled) {
								console.log("Import cancelled by user at hole " + (i + 1) + " of " + holes.length);
								break;
							}

							var h = holes[i];

							await addHole(
								true, // useCustomHoleID
								true, // useGradeZ
								entityName,
								h.holeID,
								h.startXLocation,
								h.startYLocation,
								h.startZLocation,
								h.gradeZLocation,
								h.holeDiameter,
								h.holeType,
								h.holeLengthCalculated,
								h.subdrillAmount,
								h.holeAngle,
								h.holeBearing,
								null, // rowID
								null, // posID
								h.burden,
								h.spacing
							);

							// CRITICAL FIX: Copy CBLAST-specific fields that addHole() doesn't accept
							var createdHole = allBlastHoles.find(function (hole) {
								return hole.entityName === entityName && hole.holeID === h.holeID;
							});

							if (createdHole) {
								// CBLAST provides timeDelay (timing information)
								if (h.timeDelay !== undefined && h.timeDelay !== null) {
									createdHole.timingDelayMilliseconds = h.timeDelay;
								}
								// CBLAST provides detonator information
								if (h.detonatorType) createdHole.detonatorType = h.detonatorType;
								if (h.detonatorDepth !== undefined) createdHole.detonatorDepth = h.detonatorDepth;
								// CBLAST provides charge information
								if (h.stemHeight !== undefined) createdHole.stemHeight = h.stemHeight;
								if (h.chargeLength !== undefined) createdHole.chargeLength = h.chargeLength;
								if (h.products) createdHole.products = h.products;
							}
						}

						// Step 5) Get imported holes for HDBSCAN
						var importedHoles = allBlastHoles.filter(function (hole) {
							return hole.entityName === entityName;
						});

						// Step 5a) Calculate import statistics
						var totalHoles = holes.length;
						var importedCount = importedHoles.length;
						var skippedCount = totalHoles - importedCount;
						var wasCancelled = window.holeGenerationCancelled;

						// Step 5b) Clear proximity flags after import
						window.proximitySkipAll = false;
						window.holeGenerationCancelled = false;

						// Step 6) HDBSCAN row detection
						if (importedHoles.length > 0) {
							if (typeof improvedSmartRowDetection === "function") {
								improvedSmartRowDetection(importedHoles, entityName);
							} else if (typeof detectRowsUsingHDBSCAN === "function") {
								detectRowsUsingHDBSCAN(importedHoles, entityName);
							}
						}

						// Step 7) Calculate burden and spacing (only if not already set)
						// CRITICAL: Preserve user-supplied burden/spacing values
						var needsBurdenCalc = importedHoles.filter(function (h) {
							return (h.burden === undefined || h.burden === null || h.burden === 1) &&
								(h.spacing === undefined || h.spacing === null || h.spacing === 1);
						});
						if (needsBurdenCalc.length > 0) {
							calculateBurdenAndSpacingForHoles(needsBurdenCalc);
						}

						// Step 8) Recalculate dependent structures
						if (allBlastHoles.length > 0) {
							var triangleResult = delaunayTriangles(allBlastHoles, maxEdgeLength);
							holeTimes = calculateTimes(allBlastHoles);
							var contourResult = recalculateContours(allBlastHoles, deltaX, deltaY);
							contourLinesArray = contourResult.contourLinesArray;
							directionArrows = contourResult.directionArrows;
						}

						// Step 8a) Update centroids and trigger 3D rebuild
						updateCentroids();
						window.threeDataNeedsRebuild = true;

						// Step 9) Update displays
						timeChart();
						drawData(allBlastHoles, selectedHole);

						// Step 10) Save and update TreeView
						if (typeof debouncedSaveHoles === "function") {
							debouncedSaveHoles();
						}
						if (typeof debouncedUpdateTreeView === "function") {
							debouncedUpdateTreeView();
						}

						// Build import result message
						var message;
						if (wasCancelled) {
							message = "Import cancelled. Imported " + importedCount + " of " + totalHoles + " holes from " + file.name;
							showModalMessage("CBLAST Import Cancelled", message, "warning");
						} else if (skippedCount > 0) {
							message = "Imported " + importedCount + " holes, skipped " + skippedCount + " (proximity conflicts) from " + file.name;
							showModalMessage("CBLAST Import Complete", message, "success");
						} else {
							message = "Imported " + importedCount + " holes from " + file.name;
							showModalMessage("CBLAST Import Success", message, "success");
						}
					})
					.catch(function (error) {
						console.error("CBLAST import error:", error);
						showModalMessage("Import Error", "Failed to parse CBLAST CSV: " + error.message, "error");
					});
			} else {
				showModalMessage("Import Error", "CBLAST parser not available", "error");
			}
		} else {
			showModalMessage("Import Error", "FileManager not available", "error");
		}
	};

	input.click();
});

// CBLAST Export - Using FileManager CBLASTWriter
document.querySelector(".cblast-output-btn")?.addEventListener("click", function () {
	// Step 1) Check if we have holes to export
	if (!allBlastHoles || allBlastHoles.length === 0) {
		showModalMessage("No Data", "No blast holes available to export", "warning");
		return;
	}

	// Step 2) Filter to only visible blast holes (CBLAST is holes-only export)
	var visibleHoles = allBlastHoles.filter(function (hole) {
		return isHoleVisible(hole);
	});

	if (visibleHoles.length === 0) {
		showModalMessage("No Data", "No visible blast holes to export", "warning");
		return;
	}

	// Step 3) Generate default filename with blast name and timestamp
	var entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Blast";
	var now = new Date();
	var timestamp = now.getFullYear() +
		String(now.getMonth() + 1).padStart(2, "0") +
		String(now.getDate()).padStart(2, "0") + "_" +
		String(now.getHours()).padStart(2, "0") +
		String(now.getMinutes()).padStart(2, "0") +
		String(now.getSeconds()).padStart(2, "0");
	var defaultFilename = "CBLAST_" + entityName + "_" + timestamp + ".csv";

	// Step 4) Use FloatingDialog for filename input
	showConfirmationDialogWithInput(
		"Export CBLAST CSV",
		"Enter filename for CBLAST CSV export (" + visibleHoles.length + " visible holes)",
		"Filename:",
		"text",
		defaultFilename,
		"Export",
		"Cancel",
		function (filename) {
			// User confirmed
			if (!filename || filename.trim() === "") {
				showModalMessage("Export Cancelled", "No filename provided", "warning");
				return;
			}

			if (!filename.toLowerCase().endsWith(".csv")) {
				filename += ".csv";
			}

			// Step 5) Check if File System Access API is available (modern browsers)
			if (window.showSaveFilePicker) {
				// Use File System Access API for save location browsing
				exportCBLASTWithFilePicker(visibleHoles, filename);
			} else {
				// Fallback to standard download
				exportCBLASTStandard(visibleHoles, filename);
			}
		},
		function () {
			// User cancelled
			console.log("CBLAST export cancelled by user");
		}
	);
});

// Helper function: Export CBLAST with File System Access API (save location browser)
function exportCBLASTWithFilePicker(holes, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'CBLAST CSV Files',
			accept: { 'text/csv': ['.csv'] }
		}]
	})
		.then(function (fileHandle) {
			// User selected save location
			return fileHandle.createWritable()
				.then(function (writable) {
					// Generate CBLAST CSV content
					if (window.fileManager) {
						var writer = window.fileManager.getWriter("cblast-csv");
						if (writer) {
							writer.options.filename = fileHandle.name;

							// Generate CSV content (don't auto-download)
							var csvContent = writer.generateCSV(holes);

							// Write to selected file
							return writable.write(csvContent)
								.then(function () {
									return writable.close();
								})
								.then(function () {
									var message = "Exported " + holes.length + " blast holes";
									message += " (" + (holes.length * 4) + " records)";
									message += " to " + fileHandle.name;
									showModalMessage("Export Success", message, "success");
								});
						}
					}
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download
				exportCBLASTStandard(holes, defaultFilename);
			}
		});
}

// Helper function: Export CBLAST with standard download (no location browser)
function exportCBLASTStandard(holes, filename) {
	if (window.fileManager) {
		var writer = window.fileManager.getWriter("cblast-csv");
		if (writer) {
			try {
				// Set filename in writer options
				writer.options.filename = filename;

				// Prepare data object with holes
				var data = {
					holes: holes
				};

				// Write CBLAST CSV file (handles download internally)
				writer.write(data)
					.then(function (result) {
						var message = "Exported " + holes.length + " blast holes";
						message += " (" + (holes.length * 4) + " records)";
						message += " to " + filename;
						showModalMessage("Export Success", message, "success");
					})
					.catch(function (error) {
						console.error("CBLAST export error:", error);
						showModalMessage("Export Error", "Failed to export CBLAST CSV: " + error.message, "error");
					});
			} catch (error) {
				console.error("CBLAST export error:", error);
				showModalMessage("Export Error", "Failed to export CBLAST CSV: " + error.message, "error");
			}
		} else {
			showModalMessage("Export Error", "CBLAST writer not available", "error");
		}
	} else {
		showModalMessage("Export Error", "FileManager not available", "error");
	}
}

// Helper function: Export DXF with File System Access API (save location browser)
function exportDXFWithFilePicker(dxfContent, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'DXF Files',
			accept: { 'application/dxf': ['.dxf'] }
		}]
	})
		.then(function (fileHandle) {
			// User selected save location
			return fileHandle.createWritable()
				.then(function (writable) {
					// Write DXF content
					return writable.write(dxfContent)
						.then(function () {
							return writable.close();
						})
						.then(function () {
							showModalMessage("Export Success", "Exported DXF to " + fileHandle.name, "success");
						});
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download
				downloadDXF(dxfContent, defaultFilename);
			}
		});
}

// Helper function: Export CSV with File System Access API (save location browser)
function exportCSVWithFilePicker(blob, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'CSV Files',
			accept: { 'text/csv': ['.csv'] }
		}]
	})
		.then(function (fileHandle) {
			// User selected save location
			return fileHandle.createWritable()
				.then(function (writable) {
					// Write CSV content
					return writable.write(blob)
						.then(function () {
							return writable.close();
						})
						.then(function () {
							showModalMessage("Export Success", "Exported CSV to " + fileHandle.name, "success");
						});
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download (create temp link)
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				link.download = defaultFilename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
			}
		});
}

// Helper function: Export Surpac STR with File System Access API (save location browser)
function exportSurpacSTRWithFilePicker(blob, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'Surpac STR Files',
			accept: { 'application/octet-stream': ['.str'] }
		}]
	})
		.then(function (fileHandle) {
			return fileHandle.createWritable()
				.then(function (writable) {
					return writable.write(blob)
						.then(function () {
							return writable.close();
						})
						.then(function () {
							showModalMessage("Export Success", "Exported Surpac STR to " + fileHandle.name, "success");
						});
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				link.download = defaultFilename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
			}
		});
}

// Helper function: Export Surpac DTM+STR with File System Access API (2 files)
function exportSurpacWithFilePicker(dtmBlob, dtmFilename, strBlob, strFilename) {
	// Export DTM file first
	window.showSaveFilePicker({
		suggestedName: dtmFilename,
		types: [{
			description: 'Surpac DTM Files',
			accept: { 'application/octet-stream': ['.dtm'] }
		}]
	})
		.then(function (fileHandle) {
			return fileHandle.createWritable()
				.then(function (writable) {
					return writable.write(dtmBlob)
						.then(function () {
							return writable.close();
						});
				})
				.then(function () {
					// DTM saved, now save STR file
					return window.showSaveFilePicker({
						suggestedName: strFilename,
						types: [{
							description: 'Surpac STR Files',
							accept: { 'application/octet-stream': ['.str'] }
						}]
					});
				})
				.then(function (strFileHandle) {
					return strFileHandle.createWritable()
						.then(function (writable) {
							return writable.write(strBlob)
								.then(function () {
									return writable.close();
								})
								.then(function () {
									showModalMessage("Export Complete", "Exported both " + dtmFilename + " and " + strFilename, "success");
								});
						});
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download for both files
				var url1 = URL.createObjectURL(dtmBlob);
				var link1 = document.createElement("a");
				link1.href = url1;
				link1.download = dtmFilename;
				document.body.appendChild(link1);
				link1.click();
				document.body.removeChild(link1);
				URL.revokeObjectURL(url1);

				var url2 = URL.createObjectURL(strBlob);
				var link2 = document.createElement("a");
				link2.href = url2;
				link2.download = strFilename;
				document.body.appendChild(link2);
				link2.click();
				document.body.removeChild(link2);
				URL.revokeObjectURL(url2);

				showModalMessage("Export Complete", "Exported both " + dtmFilename + " and " + strFilename, "success");
			}
		});
}

// Helper function: Export Point Cloud with File System Access API (save location browser)
function exportPointCloudWithFilePicker(blob, defaultFilename) {
	window.showSaveFilePicker({
		suggestedName: defaultFilename,
		types: [{
			description: 'XYZ Point Cloud Files',
			accept: { 'text/plain': ['.xyz'] }
		}]
	})
		.then(function (fileHandle) {
			return fileHandle.createWritable()
				.then(function (writable) {
					return writable.write(blob)
						.then(function () {
							return writable.close();
						})
						.then(function () {
							showModalMessage("Export Success", "Exported point cloud to " + fileHandle.name, "success");
						});
				});
		})
		.catch(function (error) {
			if (error.name === 'AbortError') {
				console.log("User cancelled file picker");
			} else {
				console.error("File System Access API error:", error);
				// Fallback to standard download
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				link.download = defaultFilename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
			}
		});
}

// LAS POINT CLOUD IMPORT - Using FileManager LASParser
document.querySelectorAll(".las-input-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Create file input for LAS/LAZ files
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".las,.laz";
			input.multiple = false;

			input.onchange = async function (e) {
				var file = e.target.files[0];
				if (!file) return;

				try {
					// Step 2) Use FileManager to parse LAS file
					if (window.fileManager) {
						var parser = window.fileManager.getParser("las");
						if (!parser) {
							throw new Error("LAS parser not found in FileManager");
						}

						// Step 3) Show progress message
						showStatusMessage("Importing " + file.name + "...");

						// Step 4) Parse the file (includes projection dialog)
						var result = await parser.parse(file);

						if (!result || result.cancelled) {
							showModalMessage("Import Cancelled", "LAS import was cancelled", "info");
							return;
						}

						if (!result.success) {
							throw new Error(result.message || "Failed to parse LAS file");
						}

						// Step 5) Handle the imported data based on type
						if (result.dataType === "surfaces" && result.surfaces) {
							// Step 5a) Surface import - triangulated mesh from LAS points
							console.log("üî∫ Processing LAS surface import with " + result.surfaces.size + " surfaces");

							// Step 5b) Create surface layer for LAS import
							var surfaceLayer = window.getOrCreateLayerForImport("surface", file.name);
							var surfaceLayerId = surfaceLayer ? surfaceLayer.layerId : null;
							console.log("‚úÖ [Layer] Created surface layer for LAS import:", file.name, "->", surfaceLayerId);

							// Step 5c) Add surfaces to loadedSurfaces
							var totalTriangles = 0;
							for (var [surfaceId, surfaceData] of result.surfaces.entries()) {
								// Assign layerId to surface
								if (surfaceLayerId) {
									surfaceData.layerId = surfaceLayerId;
									if (surfaceLayer) {
										surfaceLayer.entities.add(surfaceId);
									}
								}

								window.loadedSurfaces.set(surfaceId, surfaceData);
								totalTriangles += surfaceData.triangles ? surfaceData.triangles.length : 0;

								// Save surface to database
								setTimeout(async function () {
									try {
										await saveSurfaceToDB(surfaceId);
										console.log("LAS surface saved to database: " + surfaceId);
									} catch (saveError) {
										console.error("Failed to save LAS surface:", saveError);
									}
								}, 100);
							}

							// Step 5d) Update UI and redraw
							updateCentroids();
							window.threeDataNeedsRebuild = true;
							window.drawData(window.allBlastHoles, window.selectedHole);

							// Step 5e) Save layers
							if (window.debouncedSaveLayers) {
								window.debouncedSaveLayers();
							}

							// Update tree view
							if (window.debouncedUpdateTreeView) {
								window.debouncedUpdateTreeView();
							}

							zoomToFitAll();

							// Show success message
							showModalMessage(
								"Import Successful",
								"Imported LAS surface from " + file.name + " (" + totalTriangles + " triangles)",
								"success"
							);

							console.log("LAS surface import completed: " + totalTriangles + " triangles");

						} else if (result.dataType === "pointcloud" && result.kadDrawingsMap) {
							// Step 6) Create layer for LAS point cloud import
							var lasLayer = window.getOrCreateLayerForImport("drawing", file.name);
							var lasLayerId = lasLayer ? lasLayer.layerId : null;
							console.log("‚úÖ [Layer] Created drawing layer for LAS import:", file.name, "->", lasLayerId);

							// Add entities to allKADDrawingsMap with layer assignment
							for (var [entityName, entityData] of result.kadDrawingsMap.entries()) {
								// Step 7) Assign layerId to entity
								entityData.layerId = lasLayerId;
								window.allKADDrawingsMap.set(entityName, entityData);
								// Step 8) Add to layer entities set
								if (lasLayer) {
									lasLayer.entities.add(entityName);
								}
							}

							// Step 9) Update centroids and trigger 3D rebuild
							updateCentroids();
							window.threeDataNeedsRebuild = true;
							window.drawData(window.allBlastHoles, window.selectedHole);

							// Step 10) Save KAD entities to IndexedDB
							if (typeof debouncedSaveKAD === "function") {
								debouncedSaveKAD();
							}

							// Step 10a) Save layers
							if (window.debouncedSaveLayers) {
								window.debouncedSaveLayers();
							}

							// Update tree view if available
							if (window.debouncedUpdateTreeView) {
								window.debouncedUpdateTreeView();
							}

							// Show success message
							showModalMessage(
								"Import Successful",
								"Imported LAS point cloud from " + file.name + " (" + result.successCount + " points)",
								"success"
							);

							console.log("LAS import completed: " + result.successCount + " points");
						} else {
							showModalMessage("Import Error", "Unexpected data format from LAS parser", "error");
						}
					} else {
						throw new Error("FileManager not available");
					}
				} catch (error) {
					console.error("LAS import error:", error);
					showModalMessage("Import Failed", "Error importing LAS file: " + error.message, "error");
				}
			};

			input.click();
		} catch (error) {
			console.error("LAS import setup error:", error);
			showModalMessage("Import Failed", "Error setting up LAS import: " + error.message, "error");
		}
	});
});

// LAS POINT CLOUD EXPORT - Using FileManager LASWriter
document.querySelectorAll(".las-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Check if we have any point cloud data to export
			var hasPointCloudData = false;
			window.loadedSurfaces.forEach(function (surface) {
				if (surface && surface.points && surface.points.length > 0) {
					hasPointCloudData = true;
				}
			});

			if (!hasPointCloudData && (!window.allKADDrawingsMap || window.allKADDrawingsMap.size === 0)) {
				showModalMessage("No Data", "No point cloud or surface data available to export. Please load surfaces or KAD drawings first.", "warning");
				return;
			}

			// Step 2) Get LAS writer from FileManager
			var Writer = window.fileManager.writers.get("las");
			if (!Writer) {
				showModalMessage("Error", "LAS writer not found", "error");
				return;
			}

			// Step 3) Show filename dialog first
			showConfirmationDialogWithInput(
				"Export LAS Point Cloud",
				"Enter filename for LAS export",
				"Filename:",
				"text",
				"POINTCLOUD_EXPORT_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_") + ".las",
				"Export",
				"Cancel",
				async function (filename) {
					if (!filename || filename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					if (!filename.toLowerCase().endsWith(".las")) {
						filename += ".las";
					}

					try {
						// Step 4) Collect point data from surfaces and KAD entities
						var allPoints = [];

						// From loaded surfaces
						window.loadedSurfaces.forEach(function (surface) {
							if (surface && surface.points && Array.isArray(surface.points)) {
								surface.points.forEach(function (point) {
									allPoints.push({
										x: point.x || point.pointXLocation || 0,
										y: point.y || point.pointYLocation || 0,
										z: point.z || point.pointZLocation || 0,
										classification: 1, // Unclassified
										intensity: 0,
										returnNumber: 1,
										numberOfReturns: 1
									});
								});
							}
						});

						// From KAD drawings (point entities)
						if (window.allKADDrawingsMap) {
							for (var [entityName, entityData] of window.allKADDrawingsMap.entries()) {
								if (entityData && entityData.data && Array.isArray(entityData.data)) {
									entityData.data.forEach(function (point) {
										if (point.visible !== false) {
											allPoints.push({
												x: point.pointXLocation || 0,
												y: point.pointYLocation || 0,
												z: point.pointZLocation || 0,
												classification: 1, // Unclassified
												intensity: 0,
												returnNumber: 1,
												numberOfReturns: 1
											});
										}
									});
								}
							}
						}

						if (allPoints.length === 0) {
							showModalMessage("No Data", "No points found to export", "warning");
							return;
						}

						// Step 5) Show projection dialog (placeholder for now)
						showModalMessage("Coming Soon", "LAS export with projection settings will be available soon. Using default settings.", "info");

						// Step 6) Export using default settings for now
						var writer = new Writer();
						var result = await writer.write({
							points: allPoints
						});

						// Step 7) Use File System Access API if available
						if (window.showSaveFilePicker) {
							var fileHandle = await window.showSaveFilePicker({
								suggestedName: filename,
								types: [{
									description: 'LAS Files',
									accept: { 'application/octet-stream': ['.las'] }
								}]
							});
							var writable = await fileHandle.createWritable();
							await writable.write(result.lasFile);
							await writable.close();

							showModalMessage("Export Complete", "Exported " + allPoints.length + " points to " + fileHandle.name, "success");
						} else {
							// Fallback to standard download
							writer.downloadFile(result.lasFile, filename);
							showModalMessage("Export Complete", "Exported " + allPoints.length + " points to " + filename, "success");
						}

						console.log("LAS export completed: " + allPoints.length + " points");
					} catch (error) {
						console.error("LAS export error:", error);
						showModalMessage("Export Failed", "Error: " + error.message, "error");
					}
				},
				function () {
					console.log("LAS export cancelled by user");
				}
			);
		} catch (error) {
			console.error("LAS export error:", error);
			showModalMessage("Export Failed", "Error: " + error.message, "error");
		}
	});
});

// ESRI SHAPEFILE IMPORT - Using FileManager SHPFileParser
document.querySelectorAll(".shape-input-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Create file input for shapefile components
			var input = document.createElement("input");
			input.type = "file";
			input.accept = ".shp,.shx,.dbf,.prj,.cpg";
			input.multiple = true; // Allow multiple files

			input.onchange = async function (e) {
				var files = Array.from(e.target.files);
				if (files.length === 0) return;

				try {
					// Step 2) Organize files by extension
					var fileMap = {};
					files.forEach(function (file) {
						var ext = file.name.toLowerCase().split('.').pop();
						fileMap[ext] = file;
					});

					// Step 3) Check for required .shp file
					if (!fileMap.shp) {
						showModalMessage("Error", "Shapefile (.shp) file is required for import", "error");
						return;
					}

					// Step 4) Use FileManager to parse shapefile
					if (window.fileManager) {
						var parser = window.fileManager.getParser("shapefile");
						if (!parser) {
							throw new Error("Shapefile parser not found in FileManager");
						}

						// Step 5) Show progress message
						showStatusMessage("Importing " + fileMap.shp.name + "...");

						// Step 6) Read all files as ArrayBuffers
						var fileData = {};
						var readPromises = [];

						Object.keys(fileMap).forEach(function (ext) {
							var promise = fileMap[ext].arrayBuffer().then(function (buffer) {
								if (ext === 'prj') {
									// Read PRJ as text
									return fileMap[ext].text().then(function (text) {
										fileData.prjString = text;
									});
								} else {
									fileData[ext + 'Buffer'] = buffer;
								}
							});
							readPromises.push(promise);
						});

						await Promise.all(readPromises);

						// Step 7) Parse the shapefile (includes projection dialog)
						var result = await parser.parse(fileData);

						if (!result || result.cancelled) {
							showModalMessage("Import Cancelled", "Shapefile import was cancelled", "info");
							return;
						}

						if (!result.success) {
							throw new Error(result.message || "Failed to parse shapefile");
						}

						// Step 8) Handle the imported shapefile data
						if (result.kadDrawingsMap && result.kadDrawingsMap.size > 0) {
							// Step 9) Create layer for shapefile import
							var shpLayer = window.getOrCreateLayerForImport("drawing", fileMap.shp.name);
							var shpLayerId = shpLayer ? shpLayer.layerId : null;
							console.log("‚úÖ [Layer] Created drawing layer for shapefile import:", fileMap.shp.name, "->", shpLayerId);

							// Add entities to allKADDrawingsMap with layer assignment
							for (var [entityName, entityData] of result.kadDrawingsMap.entries()) {
								// Step 10) Assign layerId to entity
								entityData.layerId = shpLayerId;
								window.allKADDrawingsMap.set(entityName, entityData);
								// Step 11) Add to layer entities set
								if (shpLayer) {
									shpLayer.entities.add(entityName);
								}
							}

							// Step 12) Update centroids and trigger 3D rebuild
							updateCentroids();
							window.threeDataNeedsRebuild = true;
							window.drawData(window.allBlastHoles, window.selectedHole);

							// Step 13) Save KAD entities to IndexedDB
							if (typeof debouncedSaveKAD === "function") {
								debouncedSaveKAD();
							}

							// Step 13a) Save layers
							if (window.debouncedSaveLayers) {
								window.debouncedSaveLayers();
							}

							// Update tree view if available
							if (window.debouncedUpdateTreeView) {
								window.debouncedUpdateTreeView();
							}

							// Show success message
							showModalMessage(
								"Import Successful",
								"Imported shapefile from " + fileMap.shp.name + " (" + result.kadDrawingsMap.size + " entities)",
								"success"
							);

							console.log("Shapefile import completed: " + result.kadDrawingsMap.size + " entities");
						} else {
							showModalMessage("No Data", "No geometry found in shapefile", "warning");
						}
					} else {
						throw new Error("FileManager not available");
					}
				} catch (error) {
					console.error("Shapefile import error:", error);
					showModalMessage("Import Failed", "Error importing shapefile: " + error.message, "error");
				}
			};

			input.click();
		} catch (error) {
			console.error("Shapefile import setup error:", error);
			showModalMessage("Import Failed", "Error setting up shapefile import: " + error.message, "error");
		}
	});
});

// ESRI SHAPEFILE EXPORT - Using FileManager SHPFileWriter
document.querySelectorAll(".shape-output-btn").forEach(function (button) {
	button.addEventListener("click", async function () {
		try {
			// Step 1) Check if we have any KAD data to export
			if (!window.allKADDrawingsMap || window.allKADDrawingsMap.size === 0) {
				showModalMessage("No Data", "No KAD drawings available to export. Please create or import some geometry first.", "warning");
				return;
			}

			// Step 2) Get shapefile writer from FileManager
			var Writer = window.fileManager.writers.get("shapefile");
			if (!Writer) {
				showModalMessage("Error", "Shapefile writer not found", "error");
				return;
			}

			// Step 3) Show filename dialog first
			showConfirmationDialogWithInput(
				"Export Shapefile",
				"Enter base filename for shapefile export (will create .shp, .shx, .dbf, .prj files)",
				"Filename:",
				"text",
				"SHAPEFILE_EXPORT_" + new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_"),
				"Export",
				"Cancel",
				async function (filename) {
					if (!filename || filename.trim() === "") {
						showModalMessage("Export Cancelled", "No filename provided", "warning");
						return;
					}

					if (filename.toLowerCase().endsWith('.shp')) {
						filename = filename.slice(0, -4); // Remove .shp extension
					}

					try {
						// Step 4) Collect KAD entities for export
						var kadEntities = new Map();

						// Only export visible entities
						for (var [entityName, entityData] of window.allKADDrawingsMap.entries()) {
							if (entityData.visible !== false) {
								kadEntities.set(entityName, entityData);
							}
						}

						if (kadEntities.size === 0) {
							showModalMessage("No Data", "No visible KAD entities to export", "warning");
							return;
						}

						// Step 5) Show projection dialog (placeholder for now)
						showModalMessage("Coming Soon", "Shapefile export with projection settings will be available soon. Using default settings.", "info");

						// Step 6) Export using default settings for now
						var writer = new Writer();
						var result = await writer.write({
							kadDrawingsMap: kadEntities
						});

						if (!result.shp || !result.shx || !result.dbf) {
							throw new Error("Shapefile writer did not return all required files");
						}

						// Step 7) Use File System Access API if available
						if (window.showSaveFilePicker) {
							// For shapefiles, we need to save multiple files
							// This is complex with the File System Access API, so fall back to download for now
							showModalMessage("Export Info", "Shapefile export uses ZIP download due to multiple files. Individual file saving coming soon.", "info");
						}

						// Step 8) Create ZIP file containing all shapefile components
						if (typeof JSZip !== "undefined") {
							var zip = new JSZip();

							// Add files to ZIP
							var baseName = filename;
							zip.file(baseName + ".shp", result.shp);
							zip.file(baseName + ".shx", result.shx);
							zip.file(baseName + ".dbf", result.dbf);
							if (result.prj) {
								zip.file(baseName + ".prj", result.prj);
							}
							if (result.cpg) {
								zip.file(baseName + ".cpg", result.cpg);
							}

							var zipBlob = await zip.generateAsync({ type: "blob" });

							// Trigger download
							var link = document.createElement("a");
							link.href = URL.createObjectURL(zipBlob);
							link.download = baseName + ".zip";
							document.body.appendChild(link);
							link.click();
							document.body.removeChild(link);
							URL.revokeObjectURL(link.href);

							showModalMessage("Export Complete", "Exported " + kadEntities.size + " entities to " + baseName + ".zip", "success");
						} else {
							showModalMessage("Export Error", "JSZip library required for shapefile export", "error");
						}

						console.log("Shapefile export completed: " + kadEntities.size + " entities");
					} catch (error) {
						console.error("Shapefile export error:", error);
						showModalMessage("Export Failed", "Error: " + error.message, "error");
					}
				},
				function () {
					console.log("Shapefile export cancelled by user");
				}
			);
		} catch (error) {
			console.error("Shapefile export error:", error);
			showModalMessage("Export Failed", "Error: " + error.message, "error");
		}
	});
});

// MEASURED DATA (Mass, Length, Comment) - Import measured values for existing holes
document.querySelectorAll(".measured-input-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		var input = document.createElement("input");
		input.type = "file";
		input.accept = ".csv,.txt";
		input.onchange = async function (e) {
			await handleMeasuredUpload(e);
			showModalMessage("Measured Data Import", "Measured values updated successfully", "success");
		};
		input.click();
	});
});

document.querySelectorAll(".measured-output-btn").forEach(function (button) {
	button.addEventListener("click", function () {
		saveMeasuredDataPopup();
	});
});

//=============================================================
// END OF COMPREHENSIVE BUTTON WIRING
//=============================================================

function downloadDXF(content, filename) {
	if (isIOS()) {
		const blob = new Blob([content], {
			type: "text/dxf;charset=utf-8",
		});
		const url = URL.createObjectURL(blob);
		const link = document.createElement("a");
		link.href = url;
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		// Step 4) Revoke blob URL after download starts to prevent memory leak
		setTimeout(function () {
			URL.revokeObjectURL(url);
		}, 100);
	} else {
		const link = document.createElement("a");
		link.style.display = "none";
		link.href = "data:text/dxf;charset=utf-8," + encodeURIComponent(content);
		link.download = filename;
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
	}
}

// Function to check if the mouse is inside the canvas
function isMouseInside(mouseX, mouseY, canvas) {
	const rect = canvas.getBoundingClientRect(); // Get the bounding rectangle of the canvas
	return mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom;
}
const canvasContainer = document.querySelector(".canvas-container");

canvasContainer.addEventListener(
	"wheel",
	function (event) {
		const mouseX = event.clientX;
		const mouseY = event.clientY;
		const isMouseInsideCanvas = isMouseInside(mouseX, mouseY, canvas);

		if (isMouseInsideCanvas) {
			event.preventDefault();
			const wheelDelta = event.deltaY;

			const zoomFactor = wheelDelta > 0 ? 0.95 : 1.05;

			// Calculate the mouse position in canvas coordinates
			const canvasRect = canvas.getBoundingClientRect();
			const canvasX = mouseX - canvasRect.left;
			const canvasY = mouseY - canvasRect.top;

			// Calculate the center of the canvas
			const centerX = canvasRect.width / 2;
			const centerY = canvasRect.height / 2;
			//make the canvas center the value of 0,0
			//const canvasCenterX = centerX - canvasX;
			//const canvasCenterY = centerY - canvasY;

			// Calculate the delta between the mouse position and the canvas center
			const deltaX = canvasX - centerX;
			const deltaY = canvasY - centerY;
			// Calculate the delta between the mouse position and the canvas center in negative on the left and positive on the right
			// and negative on the top and positive on the bottom
			//const deltaX = canvasCenterX - centerX;
			//const deltaY = canvasCenterY - centerY;

			// Calculate the position offsets from the center of the canvas
			const offsetX = canvasX - canvasRect.width / 2;
			const offsetY = canvasY - canvasRect.height / 2;

			// Calculate the new scale
			// Calculate the new scale
			// Calculate the new scale
			currentScale *= zoomFactor;

			// Step #) Only adjust font size if font lock is not checked
			const fontLock = document.getElementById("fontLock");
			if (!fontLock.checked) {
				currentFontSize = Math.min(Math.max(currentFontSize * zoomFactor, 0), 100);
			}

			// Adjust the centroid position based on the offsets and zoom direction
			if (deltaX < 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Left Quadrant: Mouse is above and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX < 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Left Quadrant: Mouse is below and to the left of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY < 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Upper Right Quadrant: Mouse is above and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else if (deltaX > 0 && deltaY > 0) {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Lower Right Quadrant: Mouse is below and to the right of the canvas center");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY += (offsetY / currentScale) * (1 - zoomFactor);
			} else {
				// console.log("Delta X: " + deltaX + " Delta Y: " + deltaY);
				// console.log("Center: Mouse is in the center region of the canvas");
				centroidX -= (offsetX / currentScale) * (1 - zoomFactor);
				centroidY -= (offsetY / currentScale) * (1 - zoomFactor);
			}

			// Ensure the currentScale does not go below a minimum value
			currentScale = Math.max(currentScale, 0.000001);

			// Recalculate contours when zoom changes to keep worker in sync
			if (allBlastHoles && allBlastHoles.length > 0) {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				if (result && result.contourLinesArray) {
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}
			}

			drawData(allBlastHoles, selectedHole);

			// Step #) Update contour overlay after zoom - this ensures contours redraw with new scale
			if (typeof updateOverlayColorsForTheme === "function") {
				updateOverlayColorsForTheme();
			}
		}
	},
	{
		passive: false,
	}
);

document.addEventListener("DOMContentLoaded", function () {
	// Access the slider element and add an event listener to track changes
	const toeSlider = document.getElementById("toeSlider");
	toeSlider.addEventListener("input", function () {
		// Calculate the toe size in meters by using the slider value directly
		const toeSizeInMeters = parseFloat(this.value);

		// Update the label with the calculated toe size
		toeLabel.textContent = "Toe Size: " + toeSizeInMeters.toFixed(2) + "m";

		// Call the drawData function with the updated toe size in meters
		drawData(allBlastHoles, selectedHole, toeSizeInMeters);
	});
	const holeSlider = document.getElementById("holeSlider");
	holeSlider.addEventListener("input", function () {
		////console.log('Slider value:', this.value);
		holeScale = document.getElementById("holeSlider").value;
		holeLabel.textContent = "Hole Adjust : " + parseFloat(holeScale).toFixed(1);
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const connSlider = document.getElementById("connSlider");
	connSlider.addEventListener("input", function () {
		////console.log('Connector value:', this.value);
		connScale = document.getElementById("connSlider").value;
		connLabel.textContent = "Tie Size : " + parseFloat(connScale).toFixed(1);
		// Step #) Trigger 3D rebuild when connector size changes
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	// Step #) Font lock checkbox event listener
	const fontLock = document.getElementById("fontLock");
	const fontSlider = document.getElementById("fontSlider");

	fontLock.addEventListener("change", function () {
		// Step #) Enable/disable slider based on checkbox state
		fontSlider.disabled = this.checked;
	});

	fontSlider.min = "0";
	fontSlider.max = "100";
	fontSlider.addEventListener("input", function () {
		currentFontSize = this.value;
		currentFontSize = document.getElementById("fontSlider").value;
		window.currentFontSize = currentFontSize; // Step #) Update global for 3D text rendering
		fontLabel.textContent = "Font Size : " + currentFontSize + "px";
		// Step #) Clear text cache when font size changes so new text is created with new size
		if (window.threeRenderer && typeof window.threeRenderer.clearTextCacheOnDataChange === "function") {
			window.threeRenderer.clearTextCacheOnDataChange();
		}
		// Step #) Trigger 3D rebuild to update text with new font size
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	});

	// Access the slider element and add an event listener to track changes
	const intervalSlider = document.getElementById("intervalSlider");
	intervalSlider.addEventListener("input", function () {
		intervalAmount = document.getElementById("intervalSlider").value;
		intervalLabel.textContent = "Interval : " + intervalAmount + "ms";

		// Step 1) Invalidate cache by clearing cached data
		cachedContourLinesArray = null;
		cachedDirectionArrows = null;

		// Step 2) Recalculate contours with new interval
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// Step 3) Update overlay system if active
		if (useContourOverlay && typeof drawContoursOnOverlayFixed === "function") {
			drawContoursOnOverlayFixed();
		}

		// Step 4) Redraw main canvas
		drawData(allBlastHoles, selectedHole);
	});
	// Access the slider element and add an event listener to track changes
	const firstMovementSlider = document.getElementById("firstMovementSlider");
	firstMovementSlider.addEventListener("input", function () {
		firstMovementSize = document.getElementById("firstMovementSlider").value;
		firstMovementLabel.textContent = "First Movement Size : " + firstMovementSize;

		// Step 1) Update window global for 3D rendering
		window.firstMovementSize = firstMovementSize;

		// Step 2) Invalidate cache
		cachedContourLinesArray = null;
		cachedDirectionArrows = null;

		// Step 3) Recalculate contours/arrows
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// Step 4) Redraw
		drawData(allBlastHoles, selectedHole);
	});
	//snap tolerance - UPDATED TO USE PIXELS
	const snapToleranceSlider = document.getElementById("snapToleranceSlider");
	snapToleranceSlider.addEventListener("input", function () {
		snapRadiusPixels = parseFloat(this.value);
		document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

		// Save to localStorage
		localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
	});

	// Access the slider element and add an event listener to track changes
	const connectSlider = document.getElementById("connectSlider");
	connectSlider.addEventListener("input", function () {
		updateConnectDistance(); // Step 7) Use the new logarithmic update function
	});
});

// Connector Distance Log Helper Functions (Base 5)
function connectDistanceLogScale(sliderValue) {
	if (sliderValue <= 33.33) {
		// First third: 0.2m to 1.0m (5^0.43 to 5^0.86 approximately)
		const normalizedValue = sliderValue / 33.33;
		const minLog = Math.log(0.2) / Math.log(5); // log5(0.2)
		const maxLog = Math.log(1.0) / Math.log(5); // log5(1.0)
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else if (sliderValue <= 66.66) {
		// Second third: 1.0m to 5.0m (5^0 to 5^1)
		const normalizedValue = (sliderValue - 33.33) / 33.33;
		const minLog = Math.log(1.0) / Math.log(5); // log5(1.0) = 0
		const maxLog = Math.log(5.0) / Math.log(5); // log5(5.0) = 1
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	} else {
		// Last third: 5.0m to 25.0m (5^1 to 5^2)
		const normalizedValue = (sliderValue - 66.66) / 33.34;
		const minLog = Math.log(5.0) / Math.log(5); // log5(5.0) = 1
		const maxLog = Math.log(25.0) / Math.log(5); // log5(25.0) = 2
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(5, minLog + scale);
	}
}

function updateConnectDistance() {
	const connectSlider = document.getElementById("connectSlider");
	const sliderValue = parseFloat(connectSlider.value);

	// Step 4) Use logarithmic scaling instead of direct value
	connectAmount = connectDistanceLogScale(sliderValue);

	// Step 5) Snap to 0.1m increments
	connectAmount = Math.round(connectAmount * 10) / 10;

	// Step 6) Update label with actual distance
	const connectLabel = document.getElementById("connectLabel");
	connectLabel.textContent = "Connect Distance : " + connectAmount.toFixed(1) + "m";
}

// Step 6) Optional: Add visual markers to show the scale divisions
function addConnectDistanceMarkers() {
	const slider = document.getElementById("connectSlider");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.2m</span><span>1m</span><span>5m</span><span>25m</span>";
	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}
const timeSlider = document.getElementById("timeRange");
timeSlider.addEventListener("input", function () {
	const timeRange = document.getElementById("timeRange").value;
	timeRangeLabel.textContent = "Time window :" + timeRange + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true, // Adjust the y-axis range to fit the data
		},
	});
});

// Access the slider element and add an event listener to track changes
const timeOffsetSlider = document.getElementById("timeOffset");
timeOffsetSlider.addEventListener("input", function () {
	const timeOffset = document.getElementById("timeOffset").value;
	timeOffsetLabel.textContent = "Time Offset : " + timeOffset + "ms";
	timeChart();
	Plotly.relayout("timeChart", {
		width: newWidthRight - 50,
		yaxis: {
			autorange: true, // Adjust the y-axis range to fit the data
		},
	});
});

//floating connector color
const floatingConnectorColor = document.getElementById("floatingConnectorColor");
floatingConnectorColor.addEventListener("change", function () {
	floatingConnectorColor.jscolor.fromString(floatingConnectorColor.value);
});
//Color Wells not sliders but JScolor buttons
const connectorColor = document.getElementById("connectorColor");
connectorColor.addEventListener("change", function () {
	connectorColor.jscolor.fromString(connectorColor.value);
});
const drawingColor = document.getElementById("drawingColor");
drawingColor.addEventListener("change", function () {
	drawingColor.jscolor.fromString(drawingColor.value);
});

const connectorDelay = document.getElementById("delay");
connectorDelay.addEventListener("change", function () {
	connectorDelay.value = parseFloat(connectorDelay.value);
});
const floatingDelay = document.getElementById("floatingDelay");
floatingDelay.addEventListener("change", function () {
	floatingDelay.value = parseFloat(floatingDelay.value);
});

let drawingZValue = 0.0;
//Numbers like elevation and circle radius and polygon radius
const drawingElevation = document.getElementById("drawingElevation");
// Step #) Initialize drawingZValue to match the HTML input's initial value
drawingZValue = parseFloat(drawingElevation.value) || 0.0;
drawingElevation.addEventListener("change", function () {
	drawingZValue = parseFloat(drawingElevation.value);
});

const lineThickness = document.getElementById("drawingLineWidth");
lineThickness.addEventListener("input", function () {
	lineThickness.value = parseFloat(lineThickness.value);
	// Step #) Sync with floating toolbar
	const toolbarLineWidth = document.getElementById("drawingKADSizeToolbar");
	if (toolbarLineWidth) {
		toolbarLineWidth.value = lineThickness.value;
	}
});
lineThickness.addEventListener("change", function () {
	lineThickness.value = parseFloat(lineThickness.value);
	// Step #) Sync with floating toolbar
	const toolbarLineWidth = document.getElementById("drawingKADSizeToolbar");
	if (toolbarLineWidth) {
		toolbarLineWidth.value = lineThickness.value;
	}
});

// Step #) Sync floating toolbar line width back to sidebar
const drawingKADSizeToolbar = document.getElementById("drawingKADSizeToolbar");
if (drawingKADSizeToolbar) {
	drawingKADSizeToolbar.addEventListener("input", function () {
		const sidebarLineWidth = document.getElementById("drawingLineWidth");
		if (sidebarLineWidth) {
			sidebarLineWidth.value = drawingKADSizeToolbar.value;
		}
	});
	drawingKADSizeToolbar.addEventListener("change", function () {
		const sidebarLineWidth = document.getElementById("drawingLineWidth");
		if (sidebarLineWidth) {
			sidebarLineWidth.value = drawingKADSizeToolbar.value;
		}
	});

	// Step #) Initial sync to ensure values match on load
	const sidebarLineWidth = document.getElementById("drawingLineWidth");
	if (sidebarLineWidth && sidebarLineWidth.value !== drawingKADSizeToolbar.value) {
		sidebarLineWidth.value = drawingKADSizeToolbar.value;
	}
}

const circleRadius = document.getElementById("drawingRadius");
circleRadius.addEventListener("change", function () {
	circleRadius.value = parseFloat(circleRadius.value);
});
const polygonRadius = document.getElementById("drawingPolygonRadius");
polygonRadius.addEventListener("change", function () {
	polygonRadius.value = parseFloat(polygonRadius.value);
});
const radiiSteps = document.getElementById("radiiSteps");
radiiSteps.addEventListener("change", function () {
	radiiSteps.value = parseInt(radiiSteps.value);
});
const drawingText = document.getElementById("drawingText");
drawingText.addEventListener("change", function () {
	drawingText.value = String(drawingText.value);
});

// Create array of options and their corresponding flags
const optionConfigs = [
	{
		option: displayHoleId,
	},
	{
		option: displayHoleLength,
	},
	{
		option: displayHoleDiameter,
	},
	{
		option: displayHoleAngle,
	},
	{
		option: displayHoleDip,
	},
	{
		option: displayHoleBearing,
	},
	{
		option: displayHoleSubdrill,
	},
	{
		option: displayConnectors,
	},
	{
		option: displayDelays,
	},
	{
		option: displayTimes,
	},
	{
		option: displayContours,
		flag: "isDisplayingContours",
	},
	{
		option: displaySlope,
		flag: "isDisplayingSlopeTriangles",
	},
	{
		option: displayRelief,
		flag: "isDisplayingReliefTriangles",
	},
	{
		option: displayFirstMovements,
		flag: "isDisplayingDirectionArrows",
	},
	{
		option: displayXLocation,
	},
	{
		option: displayYLocation,
	},
	{
		option: displayElevation,
	},
	{
		option: displayHoleType,
	},
	{
		option: displayMLength,
	},
	{
		option: displayMMass,
	},
	{
		option: displayMComment,
	},
	{
		option: displayVoronoiCells,
	},
	{
		option: displayRowAndPosId,
	},
];

// Step 1: Add throttling variables at the top of your file (near other global variables)
//let contourUpdatePending = false;

// Step 2: Create throttled function
function throttledRecalculateContours() {
	if (contourUpdatePending) return;
	contourUpdatePending = true;

	requestAnimationFrame(function () {
		if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
			contourUpdatePending = false;
			// Step 2c) Redraw even when nothing is displayed to clear old data
			drawData(allBlastHoles, selectedHole);
			return;
		}

		// Step 2a) Check if we can use cache - need BOTH contours AND arrows if arrows are requested
		var needsArrows = displayFirstMovements && displayFirstMovements.checked;
		var hasValidCache = cachedContourLinesArray && cachedContourLinesArray.length > 0;
		var hasValidArrowCache = cachedDirectionArrows && cachedDirectionArrows.length > 0;

		// Step 2b) Use cache only if it has what we need, otherwise recalculate
		if (hasValidCache && (!needsArrows || hasValidArrowCache)) {
			contourLinesArray = cachedContourLinesArray;
			directionArrows = cachedDirectionArrows;
		} else {
			// Step 2c) Recalculate - cache is incomplete or doesn't have arrows when needed
			var result = recalculateContours(allBlastHoles, 0, 0);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
		updateOverlayColorsForTheme();
		contourUpdatePending = false;

		// Step 2d) Redraw after contours/arrows are calculated to ensure immediate rendering
		drawData(allBlastHoles, selectedHole);
	});
}

// Step 3: Replace the calculation in your existing event listener
optionConfigs.forEach((config) => {
	if (config.option) {
		config.option.addEventListener("change", function () {
			if (config.flag) {
				window[config.flag] = true;
			}

			// REPLACE THIS SECTION:
			/*
			// Calculate contours when any of these displays are turned on
			if ((config.option === displayContours && displayContours.checked) || 
				(config.option === displayFirstMovements && displayFirstMovements.checked) || 
				(config.option === displayRelief && displayRelief.checked)) {
				const result = recalculateContours(allBlastHoles, 0, 0);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			}
			*/

			// WITH THIS THROTTLED VERSION:
			if ((config.option === displayContours && displayContours.checked) || (config.option === displayFirstMovements && displayFirstMovements.checked) || (config.option === displayRelief && displayRelief.checked)) {
				throttledRecalculateContours(); // Use throttled version
			}

			// Your existing overlay integration code...
			if (config.option === displayContours) {
				if (displayContours.checked) {
					if (!useContourOverlay) {
						toggleContourOverlayFixed();
					} else {
						updateOverlayColorsForTheme();
					}
				} else {
					if (contourOverlayCanvas) {
						contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
					}
				}
			}

			drawData(allBlastHoles, selectedHole);
		});
	}
});

let touchStartTime;
let touchDuration;
const longPressDuration = 200; // Adjust this duration as needed
let isTouchDragging = false;
let longPressTimeout;
let isUpdatingSelectionFromMove = false;
let newWidthRight = 350;
let newWidthLeft = 350;

function handleMouseDown(event) {
	// Debug log for 2D pan troubleshooting
	console.log("‚¨áÔ∏è [2D] handleMouseDown fired", {
		button: event.button,
		ctrlKey: event.ctrlKey,
		shiftKey: event.shiftKey,
		altKey: event.altKey,
		onlyShowThreeJS: onlyShowThreeJS,
	});

	if (onlyShowThreeJS) {
		// In 3D mode, let camera controls handle it (except for selection which is handled by click)
		return;
	}

	// Prevent context menu if we are panning or interacting
	if (event.button === 2) {
		// Right-click is for context menus only - don't set up any drag/pan behavior
		// The context menu handler will manage this
		return; // Exit early for right-clicks
	}

	// Step 1) Handle dragging functionality (Pan)
	// Only start pan if NOT clicking on a handle or control
	if (!isResizingRight && !isResizingLeft) {
		// Step 1a) Middle mouse button - immediate pan
		if (event.button === 1) {
			isDragging = true;
			startPanX = event.clientX;
			startPanY = event.clientY;
			// console.log("üëã 2D Pan started");
		}
		// Step 1b) Left mouse button - check tool state
		else if (event.button === 0) {
			// Step 1b.1) Tools that suspend dragging: Move and Bearing tools
			// These tools handle their own dragging behavior and should not trigger panning
			const toolsThatSuspendDragging = isMoveToolActive || isBearingToolActive;

			// Step 1b.2) Tools that allow immediate panning (no delay needed)
			const toolsThatAllowImmediatePan = !isAddingConnector && !isAddingMultiConnector && !isAddingPoint && !isAddingLine && !isAddingPoly && !isAddingCircle && !isAddingText && !isAssignSurfaceActive && !isAssignGradeActive && !isOffsetKADActive && !isRadiiHolesOrKADActive && !isRulerToolActive && !isRulerProtractorToolActive && !isPatternInPolygonActive && !isHolesAlongLineActive && !isHolesAlongPolyLineActive;

			// Step 1b.3) selectPointer allows panning after 300ms delay (single click = selection, long press = pan)
			if (isSelectionPointerActive && !toolsThatSuspendDragging) {
				// Store initial mouse position for drag detection
				startPanX = event.clientX;
				startPanY = event.clientY;
				// Delay panning for selectPointer - allows single clicks for selection
				// Pan will be enabled after 300ms if mouse is still down
				window.selectPointerPanTimeout = setTimeout(() => {
					if (!isDraggingBearing && !isDraggingHole) {
						isDragging = true;
						// console.log("üëã 2D Pan started (selectPointer delayed)");
					}
				}, 300); // 300ms delay for selectPointer panning
			}
			// Step 1b.4) Other tools - immediate panning if allowed
			else if (!isSelectionPointerActive && toolsThatAllowImmediatePan && !toolsThatSuspendDragging) {
				isDragging = true;
				startPanX = event.clientX;
				startPanY = event.clientY;
				// console.log("üëã 2D Pan started");
			}
		}
	}

	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	// BUT NOT for right-click (button 2) - that's for context menus
	if (event.button !== 2) {
		longPressTimeout = setTimeout(() => {
			isDragging = true; // Set isDragging to true after 500ms
		}, longPressDuration);
	}

	// Convert to canvas coordinates (consistent with handleMouseMove)
	const rect = canvas.getBoundingClientRect();
	lastMouseX = event.clientX - rect.left;
	lastMouseY = event.clientY - rect.top;
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
}

function handleMouseMove(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Update global mouse tracking for interactive previews
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;

	// Convert to world coordinates with snapping for HUD display
	const snapResult = canvasToWorldWithSnap(mouseX, mouseY);
	currentMouseWorldX = snapResult.worldX;
	currentMouseWorldY = snapResult.worldY;
	// Step #) Validate Z to prevent extreme values (2D canvas path)
	currentMouseWorldZ = validateWorldZ(snapResult.worldZ, dataCentroidZ);

	// Update snapHighlight for HUD display (magnet icon)
	snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;

	// Step 1) For selectPointer, if mouse moves significantly before timeout, start panning immediately
	if (isSelectionPointerActive && window.selectPointerPanTimeout && !isDragging) {
		const deltaX = Math.abs(event.clientX - startPanX);
		const deltaY = Math.abs(event.clientY - startPanY);
		// If mouse moved more than 5 pixels, start panning immediately
		if (deltaX > 5 || deltaY > 5) {
			clearTimeout(window.selectPointerPanTimeout);
			window.selectPointerPanTimeout = null;
			if (!isDraggingBearing && !isDraggingHole) {
				isDragging = true;
				startPanX = event.clientX;
				startPanY = event.clientY;
			}
		}
	}

	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;

		// Recalculate contours during drag to keep them in sync
		if (allBlastHoles && allBlastHoles.length > 0 && (displayContours.checked || displayFirstMovements.checked)) {
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			if (result && result.contourLinesArray) {
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			}
		}
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	if (isResizingRight) {
		newWidthRight = window.innerWidth - event.clientX;
		Plotly.relayout("timeChart", {
			width: newWidthRight - 50,
		});
		document.getElementById("sidenavRight").style.width = newWidthRight + "px";
	}
	if (isResizingLeft) {
		newWidthLeft = event.clientX;
		document.getElementById("sidenavLeft").style.width = newWidthLeft + "px";
	}

	// If in selection mode and there's a selection, prevent getMultipleClickedHoles from re-evaluating during this move
	if (isMultiHoleSelectionEnabled && selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		isUpdatingSelectionFromMove = true; // Flag to prevent re-evaluating selection during mouse move
	}

	// Only redraw during active interactions to improve performance
	//if (isDragging || isAddingHole || isDeletingHole || isAddingConnector || isAddingMultiConnector || isDrawingText || isDrawingLine || isDrawingPoly || isDrawingCircle || isMeasureRecording) {
	drawData(allBlastHoles, selectedHole);
	//}

	// Step #) Update contour overlay when panning - ensures contours stay in sync with canvas position
	if (isDragging && typeof updateOverlayColorsForTheme === "function") {
		updateOverlayColorsForTheme();
	}

	isUpdatingSelectionFromMove = false; // Reset the flag after drawData
}

function handleMouseUp(event) {
	// Debug log for 2D pan troubleshooting
	if (isDragging) {
		console.log("üñêÔ∏è [2D] handleMouseUp fired - Releasing Pan");
	}

	if (onlyShowThreeJS) {
		return;
	}

	// Stop 2D Pan
	if (isDragging) {
		isDragging = false;
		canvas.style.cursor = "default";
	}

	// Stop resizing (cleanup now handled by dedicated cleanup functions in mousedown handlers)

	clearTimeout(longPressTimeout); // Clear the long press timeout
	// Step 2) Clear selectPointer pan timeout if it exists
	if (window.selectPointerPanTimeout) {
		clearTimeout(window.selectPointerPanTimeout);
		window.selectPointerPanTimeout = null;
	}
	// Block tool-specific behaviors only if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;
	//touchDuration = Date.now() - touchStartTime;

	// Note: Add hole dialog is now shown in handleHoleAddingClick, not here
	// This prevents duplicate dialogs
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.clientX;
		touchStartY = event.clientY;
		// Log the values of worldX and worldY
	}
	drawData(allBlastHoles, selectedHole);
	// Note: Sidebar resize cleanup now handled by dedicated cleanup functions in mousedown handlers
}

// Rest of the code for touch events is unchanged

function handleTouchStart(event) {
	touchStartTime = Date.now();
	touchDuration = 0; // Reset touch duration on touch start

	// Set a timeout to trigger a long press event
	longPressTimeout = setTimeout(() => {
		isTouchDragging = true; // Set isTouchDragging to true after 500ms
	}, longPressDuration);

	// Continue handling the touch start event as before
	if (event.touches.length === 1) {
		if (!isDraggingBearing && !isDraggingHole) {
			isTouchDragging = true;
		}
		touchStartX = event.touches[0].clientX;
		touchStartY = event.touches[0].clientY;
	} else if (event.touches.length === 2) {
		// Pinch
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
}

function handleTouchEnd(event) {
	// Clear the long press timeout
	clearTimeout(longPressTimeout);

	// Only set isTouchDragging to false on touch end
	isTouchDragging = false;

	touchDuration = Date.now() - touchStartTime;
	// Block tool-specific behaviors if tools are dragging
	if (isDraggingBearing || isDraggingHole) return;

	// Note: Add hole dialog is now shown in handleHoleAddingClick, not here
	// This prevents duplicate dialogs
	if (event.touches.length === 1) {
		initialPinchDistance = null;
		initialScale = currentScale;
		initialFontSize = currentFontSize;
	}
	if (isAddingPattern && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoint && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingLine && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingPoly && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingCircle && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
	if (isDrawingText && touchDuration <= longPressDuration) {
		touchStartX = event.changedTouches[0].clientX;
		touchStartY = event.changedTouches[0].clientY;
	}
}

function handleTouchMove(event) {
	if (event.touches.length === 1 && isTouchDragging && !isDraggingBearing && !isDraggingHole) {
		// Only do canvas panning if tools aren't dragging
		event.preventDefault();
		let touchX = event.touches[0].clientX;
		let touchY = event.touches[0].clientY;
		deltaX = touchX - touchStartX;
		deltaY = touchY - touchStartY;
		touchStartX = touchX;
		touchStartY = touchY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		drawData(allBlastHoles, selectedHole);
	} else if (event.touches.length === 2) {
		event.preventDefault();

		deltaX = event.touches[0].clientX - event.touches[1].clientX;
		deltaY = event.touches[0].clientY - event.touches[1].clientY;
		const currentPinchDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

		if (initialPinchDistance === null) {
			initialPinchDistance = currentPinchDistance;
		} else {
			const pinchDelta = currentPinchDistance - initialPinchDistance;
			currentScale = initialScale + pinchDelta * 0.05;
			currentScale = Math.max(currentScale, 0.000001);
			currentFontSize = initialFontSize * (currentScale / initialScale);

			drawData(allBlastHoles, selectedHole);
		}
	}
}

async function handleFileUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();

	reader.onload = async function (event) {
		const data = event.target.result;

		if (file.name.endsWith(".kad") || file.name.endsWith(".KAD") || file.name.endsWith(".txt") || file.name.endsWith(".TXT")) {
			parseKADFile(data);
			// Step 1) Clear text cache when data changes
			if (window.threeRenderer && typeof window.threeRenderer.clearTextCacheOnDataChange === "function") {
				window.threeRenderer.clearTextCacheOnDataChange();
			}
			// Step #) Trigger 3D rebuild to show imported KAD data
			window.threeDataNeedsRebuild = true;
			drawData(allBlastHoles, selectedHole);
		} else if (file.name.endsWith(".csv") || file.name.endsWith(".CSV")) {
			try {
				var parseResult = await parseK2Dcsv(data);
				allBlastHoles = parseResult.holes;

				// Log import results
				if (parseResult.cancelled) {
					console.log("CSV import cancelled. Imported " + parseResult.imported + " of " + (parseResult.imported + parseResult.skipped) + " holes");
				} else if (parseResult.skipped > 0) {
					console.log("CSV import complete. Imported " + parseResult.imported + " holes, skipped " + parseResult.skipped + " (proximity conflicts)");
				}

				// Step 1) Save loaded file to IndexedDB
				debouncedSaveHoles();

				// Calculate centroid
				let sumX = 0;
				let sumY = 0;
				for (let i = 0; i < allBlastHoles.length; i++) {
					sumX += allBlastHoles[i].startXLocation;
					sumY += allBlastHoles[i].startYLocation;
				}
				centroidX = sumX / allBlastHoles.length;
				centroidY = sumY / allBlastHoles.length;

				// Step 1a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
				var fullCentroid = calculateDataCentroid();
				emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

				// Recalculate contours and triangles
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
				// Step 1) Clear text cache when data changes
				if (window.threeRenderer && typeof window.threeRenderer.clearTextCacheOnDataChange === "function") {
					window.threeRenderer.clearTextCacheOnDataChange();
				}
				// Step #) Trigger 3D rebuild to show imported CSV data
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, selectedHole);
				countAllBlastHoles = allBlastHoles.length;
			} catch (error) {
				console.error("Error during CSV handling:", error);
				fileFormatPopup(error);
			}
		}
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

let randomHex = Math.floor(Math.random() * 16777215).toString(16);

// DUPLICATE ID DETECTION AND RESOLUTION SYSTEM
// Enhanced duplicate checking that handles all ID formats
async function checkAndResolveDuplicateHoleIDs(allBlastHoles, actionType = "import") {
	const duplicateReport = {
		hasDuplicates: false,
		duplicates: [],
		resolved: [],
		errors: [],
	};

	// Group holes by entity name
	const entitiesMap = new Map();

	allBlastHoles.forEach((hole, index) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, []);
		}
		entitiesMap.get(hole.entityName).push({
			hole,
			originalIndex: index,
		});
	});

	// Check each entity for duplicate IDs
	entitiesMap.forEach((holes, entityName) => {
		const idMap = new Map();

		holes.forEach(({ hole, originalIndex }) => {
			const holeID = hole.holeID.toString(); // Convert to string for comparison

			if (idMap.has(holeID)) {
				// Duplicate found!
				duplicateReport.hasDuplicates = true;

				const existingHole = idMap.get(holeID);
				const duplicateInfo = {
					entityName,
					holeID,
					existing: {
						hole: existingHole.hole,
						index: existingHole.originalIndex,
					},
					duplicate: {
						hole,
						index: originalIndex,
					},
				};

				duplicateReport.duplicates.push(duplicateInfo);
			} else {
				idMap.set(holeID, {
					hole,
					originalIndex,
				});
			}
		});
	});

	// If duplicates found, resolve them
	if (duplicateReport.hasDuplicates) {
		console.warn("‚ö†Ô∏è DUPLICATE HOLE IDs DETECTED:", duplicateReport.duplicates.length, "conflicts found");

		// Show user dialog for resolution strategy
		const resolution = await showDuplicateResolutionDialog(duplicateReport, actionType);

		switch (resolution.strategy) {
			case "auto-renumber":
				resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport);
				break;
			case "keep-first":
				resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport);
				break;
			case "keep-last":
				resolveDuplicatesKeepLast(allBlastHoles, duplicateReport);
				break;
			case "manual":
				// Let user manually resolve - return for manual handling
				return duplicateReport;
			case "abort":
				// Return special value indicating user cancelled
				console.log("‚úÖ User cancelled duplicate resolution");
				return { cancelled: true };
		}
	}

	return duplicateReport;
}

function showDuplicateResolutionDialog(duplicateReport, actionType) {
	const duplicateCount = duplicateReport.duplicates.length;
	const entitiesAffected = [...new Set(duplicateReport.duplicates.map((d) => d.entityName))];

	// Build content using CSS classes that handle dark/light mode automatically
	const contentDiv = document.createElement("div");
	contentDiv.className = "button-container-2col";
	contentDiv.style.padding = "10px";
	contentDiv.style.minHeight = "200px";

	// Warning header - uses labelWhite18 class
	const warningHeader = document.createElement("label");
	warningHeader.className = "labelWhite15"; // Using existing CSS class
	warningHeader.style.gridColumn = "1 / -1";
	warningHeader.style.textAlign = "center";
	warningHeader.style.marginBottom = "10px";
	warningHeader.style.fontSize = "14px";
	warningHeader.style.fontWeight = "bold";
	warningHeader.textContent = "‚ö†Ô∏è Duplicate Hole IDs Detected";
	contentDiv.appendChild(warningHeader);

	// Conflict count - uses labelWhite15 class
	const conflictLabel = document.createElement("label");
	conflictLabel.className = "labelWhite15";
	conflictLabel.style.gridColumn = "1 / -1";
	conflictLabel.style.marginBottom = "5px";
	conflictLabel.textContent = "Found: " + duplicateCount + " conflicts";
	contentDiv.appendChild(conflictLabel);

	// Affected blasts - uses labelWhite15 class
	const blastsLabel = document.createElement("label");
	blastsLabel.className = "labelWhite15";
	blastsLabel.style.gridColumn = "1 / -1";
	blastsLabel.style.marginBottom = "10px";
	blastsLabel.textContent = "Blasts: " + entitiesAffected.join(", ");
	contentDiv.appendChild(blastsLabel);

	// Examples header - uses labelWhite12 class
	const examplesHeader = document.createElement("label");
	examplesHeader.className = "labelWhite12";
	examplesHeader.style.gridColumn = "1 / -1";
	examplesHeader.style.marginTop = "10px";
	examplesHeader.style.marginBottom = "5px";
	examplesHeader.textContent = "Examples:";
	contentDiv.appendChild(examplesHeader);

	// Example entries - uses labelWhite12 class
	duplicateReport.duplicates.slice(0, 3).forEach((dup) => {
		const exampleLabel = document.createElement("label");
		exampleLabel.className = "labelWhite12";
		exampleLabel.style.gridColumn = "1 / -1";
		exampleLabel.style.marginBottom = "2px";
		exampleLabel.textContent = "? " + dup.entityName + " - ID: " + dup.holeID;
		contentDiv.appendChild(exampleLabel);
	});

	// More indicator - uses labelWhite12 class
	if (duplicateReport.duplicates.length > 3) {
		const moreLabel = document.createElement("label");
		moreLabel.className = "labelWhite12";
		moreLabel.style.gridColumn = "1 / -1";
		moreLabel.textContent = "... and " + (duplicateReport.duplicates.length - 3) + " more";
		contentDiv.appendChild(moreLabel);
	}

	// Return promise exactly like original Swal2 version
	return new Promise((resolve) => {
		const dialog = new FloatingDialog({
			title: "Duplicate Resolution",
			content: contentDiv,
			width: 450,
			height: 350,
			layoutType: "default",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false,
			showConfirm: true,
			showCancel: true,
			showOption1: true,
			showOption2: true,
			confirmText: "Renumber",
			option1Text: "Keep First",
			option2Text: "Keep Last",
			cancelText: "Cancel",
			onConfirm: () => {
				resolve({
					strategy: "auto-renumber",
				});
			},
			onOption1: () => {
				resolve({
					strategy: "keep-first",
				});
			},
			onOption2: () => {
				resolve({
					strategy: "keep-last",
				});
			},
			onCancel: () => {
				resolve({
					strategy: "abort",
				});
			},
		});

		dialog.show();
	});
}

// Enhanced auto-renumbering that handles all ID formats
function resolveDuplicatesAutoRenumber(allBlastHoles, duplicateReport) {
	// For each entity, analyze existing ID patterns and generate appropriate new IDs
	const entitiesMap = new Map();

	// Group allBlastHoles by entity and analyze ID patterns
	allBlastHoles.forEach((hole) => {
		if (!entitiesMap.has(hole.entityName)) {
			entitiesMap.set(hole.entityName, {
				holes: [],
				numericIDs: [],
				alphaIDs: [],
				maxNumeric: 0,
				maxAlphaRow: "A",
				maxAlphaNum: 0,
			});
		}
		const entity = entitiesMap.get(hole.entityName);
		entity.holes.push(hole);

		const holeID = hole.holeID.toString();

		// Check if it's purely numeric
		const numericMatch = holeID.match(/^(\d+)$/);
		if (numericMatch) {
			const num = parseInt(numericMatch[1]);
			entity.numericIDs.push(num);
			entity.maxNumeric = Math.max(entity.maxNumeric, num);
		}
		// Check if it's alphanumeric (like A1, B2, AA1, etc.)
		else {
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);
				entity.alphaIDs.push({
					letters,
					number,
					full: holeID,
				});

				// Track highest letter combination and number
				if (letters.localeCompare(entity.maxAlphaRow) > 0) {
					entity.maxAlphaRow = letters;
					entity.maxAlphaNum = number;
				} else if (letters === entity.maxAlphaRow) {
					entity.maxAlphaNum = Math.max(entity.maxAlphaNum, number);
				}
			}
		}
	});

	// Renumber duplicates using appropriate format
	duplicateReport.duplicates.forEach((duplicate) => {
		const entity = entitiesMap.get(duplicate.entityName);
		const oldID = duplicate.duplicate.hole.holeID.toString();
		let newID;

		// Determine what format to use for the new ID
		const numericMatch = oldID.match(/^(\d+)$/);
		const alphaMatch = oldID.match(/^([A-Z]+)(\d+)$/);

		if (numericMatch) {
			// Generate new numeric ID
			newID = (++entity.maxNumeric).toString();
		} else if (alphaMatch) {
			// For true alphanumeric (A1, B2 style), maintain the letter prefix
			const letters = alphaMatch[1];

			// Find max number for this specific letter prefix
			let maxNumForPrefix = 0;
			entity.holes.forEach((h) => {
				const match = h.holeID.toString().match(/^([A-Z]+)(\d+)$/);
				if (match && match[1] === letters) {
					maxNumForPrefix = Math.max(maxNumForPrefix, parseInt(match[2]));
				}
			});

			newID = letters + (maxNumForPrefix + 1);
		} else {
			// Fallback: use numeric
			newID = (++entity.maxNumeric).toString();
		}

		// Update the hole ID
		duplicate.duplicate.hole.holeID = newID;

		// Update fromHoleID references if they point to this hole
		allBlastHoles.forEach((hole) => {
			if (hole.fromHoleID === duplicate.entityName + ":::" + oldID) {
				hole.fromHoleID = duplicate.entityName + ":::" + newID;
			}
		});

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			oldID: oldID,
			newID: newID,
			action: "renumbered",
		});

		console.log("üîß Renumbered duplicate hole:", duplicate.entityName + ":" + oldID, "‚Üí", newID);
	});
}

function resolveDuplicatesKeepFirst(allBlastHoles, duplicateReport) {
	// Remove duplicate holes (keep the first occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.duplicate.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-duplicate",
		});

		console.log("üóëÔ∏è Removed duplicate hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

function resolveDuplicatesKeepLast(allBlastHoles, duplicateReport) {
	// Remove original holes (keep the duplicate/last occurrence)
	const indicesToRemove = [];

	duplicateReport.duplicates.forEach((duplicate) => {
		indicesToRemove.push(duplicate.existing.index);

		duplicateReport.resolved.push({
			entityName: duplicate.entityName,
			holeID: duplicate.holeID,
			action: "removed-original",
		});

		console.log("üóëÔ∏è Removed original hole:", duplicate.entityName + ":" + duplicate.holeID);
	});

	// Remove holes in reverse order to maintain indices
	indicesToRemove
		.sort((a, b) => b - a)
		.forEach((index) => {
			allBlastHoles.splice(index, 1);
		});
}

// Enhanced unique ID validation for any format
function validateUniqueHoleID(entityName, holeID, excludeHole = null) {
	const holeIDStr = holeID.toString();

	const existing = allBlastHoles.find((hole) => hole.entityName === entityName && hole.holeID.toString() === holeIDStr && hole !== excludeHole);

	if (existing) {
		const newID = generateUniqueHoleID(entityName, holeIDStr);
		console.warn("‚ö†Ô∏è Duplicate hole ID detected:", entityName + ":" + holeIDStr, "‚úÖ Auto-assigned:", newID);
		return newID;
	}

	return holeIDStr;
}
// Enhanced unique ID generation for any format
function generateUniqueHoleID(entityName, baseID) {
	const baseIDStr = baseID.toString();

	// Analyze existing IDs in this entity
	const existingIDs = new Set();
	let maxNumeric = 0;
	let maxAlphaRow = "A";
	let maxAlphaNum = 0;

	allBlastHoles.forEach((hole) => {
		if (hole.entityName === entityName) {
			const holeID = hole.holeID.toString();
			existingIDs.add(holeID);

			// Track numeric IDs
			const numericMatch = holeID.match(/^(\d+)$/);
			if (numericMatch) {
				maxNumeric = Math.max(maxNumeric, parseInt(numericMatch[1]));
			}

			// Track alphanumeric IDs
			const alphaMatch = holeID.match(/^([A-Z]+)(\d+)$/);
			if (alphaMatch) {
				const letters = alphaMatch[1];
				const number = parseInt(alphaMatch[2]);

				if (letters.localeCompare(maxAlphaRow) > 0) {
					maxAlphaRow = letters;
					maxAlphaNum = number;
				} else if (letters === maxAlphaRow) {
					maxAlphaNum = Math.max(maxAlphaNum, number);
				}
			}
		}
	});

	// Determine format of base ID and generate appropriate new ID
	const numericMatch = baseIDStr.match(/^(\d+)$/);
	const alphaMatch = baseIDStr.match(/^([A-Z]+)(\d+)$/);

	if (numericMatch) {
		// Generate next numeric ID
		return (maxNumeric + 1).toString();
	} else if (alphaMatch) {
		// Generate next alphanumeric ID in same pattern
		const letters = alphaMatch[1];
		let newID;

		// Try incrementing the number first
		for (let num = 1; num <= maxAlphaNum + 10; num++) {
			newID = letters + num;
			if (!existingIDs.has(newID)) {
				return newID;
			}
		}

		// If that fails, increment the letter
		const nextLetter = incrementLetter(letters);
		return nextLetter + "1";
	} else {
		// Fallback: generate numeric ID
		return (maxNumeric + 1).toString();
	}
}

//=============================================================
// VERBOSE REMOVAL COMMENT - parseK2Dcsv function extracted
//=============================================================
// Step 1) Function (317 lines, lines 8455-8772) was extracted to src/fileIO/TextIO/BlastHoleCSVParser.js
// Step 2) Reason: Part of FileManager IO System modularization (Phase 1)
// Step 3) Date: 2026-01-03
// Step 4) The function is now exposed via FileManager.parse() with format "blasthole-csv"
// Step 5) Supports 4, 7, 9, 12, 14, 20, 25, 30, 32, 35 column formats
// Step 6) Returns structured data: { holes: [], warnings: [] }
// Step 7) Backward compatibility maintained via wrapper function below

async function parseK2Dcsv(data) {
	try {
		// Step 1) Use FileManager to parse CSV data
		var BlastHoleCSVParser = window.fileManager.parsers.get("blasthole-csv");
		if (!BlastHoleCSVParser) {
			throw new Error("BlastHole CSV parser not found in FileManager. Ensure init.js is loaded.");
		}

		var parser = new BlastHoleCSVParser();
		var result = parser.parseCSVData(data);
		var holes = result.holes;

		if (!holes || holes.length === 0) {
			console.warn("No holes found in CSV");
			return allBlastHoles;
		}

		// Step 2) RULE #9: Use addHole() to create proper hole geometry
		if (!allBlastHoles || !Array.isArray(allBlastHoles)) allBlastHoles = [];

		// Step 3) Group holes by entity for processing
		var entitiesBefore = new Set(allBlastHoles.map(function (h) { return h.entityName; }));

		// Step 3a) Clear proximity Skip All flag for new import
		window.proximitySkipAll = false;
		window.holeGenerationCancelled = false;
		var totalHoles = holes.length;

		// Step 4) Call addHole() for each parsed hole
		for (var i = 0; i < holes.length; i++) {
			// Check if user cancelled the import
			if (window.holeGenerationCancelled) {
				console.log("CSV import cancelled by user at hole " + (i + 1) + " of " + totalHoles);
				break;
			}

			var h = holes[i];

			// addHole() will calculate: benchHeight, gradeXYZ, endXYZ, subdrillLength
			await addHole(
				true, // useCustomHoleID = true (use parsed holeID)
				true, // useGradeZ = true (calculate from gradeZLocation)
				h.entityName,
				h.holeID,
				h.startXLocation,
				h.startYLocation,
				h.startZLocation,
				h.gradeZLocation, // Grade Z elevation
				h.holeDiameter,
				h.holeType,
				h.holeLengthCalculated,
				h.subdrillAmount,
				h.holeAngle,
				h.holeBearing,
				h.rowID, // May be null (HDBSCAN will assign)
				h.posID, // May be null (HDBSCAN will assign)
				h.burden,
				h.spacing
			);

			// CRITICAL FIX: Copy timing/connector fields that addHole() doesn't accept
			// Find the hole that was just created and update it with additional fields
			var createdHole = allBlastHoles.find(function (hole) {
				return hole.entityName === h.entityName && hole.holeID === h.holeID;
			});

			if (createdHole) {
				// Copy timing and connector fields from parsed data
				if (h.fromHoleID && h.fromHoleID !== "") {
					createdHole.fromHoleID = h.fromHoleID;
				}
				if (h.timingDelayMilliseconds !== undefined && h.timingDelayMilliseconds !== null) {
					createdHole.timingDelayMilliseconds = h.timingDelayMilliseconds;
				}
				if (h.colorHexDecimal && h.colorHexDecimal !== "") {
					createdHole.colorHexDecimal = h.colorHexDecimal;
				}
				if (h.connectorCurve !== undefined && h.connectorCurve !== null) {
					createdHole.connectorCurve = h.connectorCurve;
				}
				if (h.measuredLength !== undefined && h.measuredLength !== null) {
					createdHole.measuredLength = h.measuredLength;
				}
				if (h.measuredLengthTimeStamp && h.measuredLengthTimeStamp !== "") {
					createdHole.measuredLengthTimeStamp = h.measuredLengthTimeStamp;
				}
				if (h.measuredMass !== undefined && h.measuredMass !== null) {
					createdHole.measuredMass = h.measuredMass;
				}
				if (h.measuredMassTimeStamp && h.measuredMassTimeStamp !== "") {
					createdHole.measuredMassTimeStamp = h.measuredMassTimeStamp;
				}
				if (h.measuredComment && h.measuredComment !== "") {
					createdHole.measuredComment = h.measuredComment;
				}
				if (h.measuredCommentTimeStamp && h.measuredCommentTimeStamp !== "") {
					createdHole.measuredCommentTimeStamp = h.measuredCommentTimeStamp;
				}
			}
		}

		// Step 5) Get all imported holes for post-processing
		var entitiesAfter = new Set(allBlastHoles.map(function (h) { return h.entityName; }));
		var newEntities = Array.from(entitiesAfter).filter(function (e) { return !entitiesBefore.has(e); });

		// Step 5a) Calculate import statistics
		var importedCount = allBlastHoles.filter(function (h) {
			return newEntities.some(function (e) { return h.entityName === e; });
		}).length;
		var skippedCount = totalHoles - importedCount;
		var wasCancelled = window.holeGenerationCancelled;

		// Step 5b) Clear proximity flags after import
		window.proximitySkipAll = false;
		window.holeGenerationCancelled = false;

		// Step 6) Calculate burden and spacing for new entities
		newEntities.forEach(function (entityName) {
			var entityHoles = allBlastHoles.filter(function (h) { return h.entityName === entityName; });
			if (entityHoles.length > 0) {
				// Only calculate if not already set (default is 1, so recalculate ONLY if exactly 1)
				// CRITICAL: Preserve user-supplied 0 values (0 means "no burden/spacing")
				var needsCalculation = entityHoles.filter(function (h) {
					return (h.burden === undefined || h.burden === null || h.burden === 1) &&
						(h.spacing === undefined || h.spacing === null || h.spacing === 1);
				});
				if (needsCalculation.length > 0) {
					calculateBurdenAndSpacingForHoles(needsCalculation);
				}
			}
		});

		// Step 7) Calculate times and redraw
		holeTimes = calculateTimes(allBlastHoles);
		drawData(allBlastHoles, selectedHole);

		// Step 8) Save to DB
		if (typeof debouncedSaveHoles === "function") {
			debouncedSaveHoles();
		}

		// Step 9) Update TreeView
		if (typeof debouncedUpdateTreeView === "function") {
			debouncedUpdateTreeView();
		}

		// Step 10) Return holes and import statistics
		return {
			holes: allBlastHoles,
			imported: importedCount,
			skipped: skippedCount,
			cancelled: wasCancelled
		};
	} catch (error) {
		console.error("Error during CSV parsing:", error);
		alert("Error importing CSV file: " + error.message);
		throw error;
	}
}

// REMOVED OLD IMPLEMENTATION (317 lines) - Now using FileManager BlastHoleCSVParser
// Old code handled: 4, 7, 9, 12, 14, 20, 25, 30, 32, 35 column formats
// All parsing logic moved to src/fileIO/TextIO/BlastHoleCSVParser.js

async function handleDXFUpload(event) {
	var file = event.target.files[0];
	if (!file) return;

	var fileName = file.name;
	var reader = new FileReader();
	reader.onload = async function (e) {
		var dxfContent = e.target.result;
		try {
			var parser = new DxfParser();
			var dxf = parser.parseSync(dxfContent);
			// Step 15) Pass filename for layer creation
			await parseDXFtoKadMaps(dxf, fileName);
		} catch (error) {
			console.error("DXF parsing failed:", error);
			alert("Error parsing DXF file.");
		}
	};
	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}
// Add this helper function to generate unique entity names
function getUniqueEntityName(baseName, entityType) {
	// If baseName doesn't exist in the map, use it as-is
	if (!allKADDrawingsMap.has(baseName)) {
		return baseName;
	}

	// Otherwise, increment until we find a unique name
	let counter = 1;
	let uniqueName = baseName + "_" + counter;

	while (allKADDrawingsMap.has(uniqueName)) {
		counter++;
		uniqueName = baseName + "_" + counter;
	}

	console.log("‚ö†Ô∏è Entity name collision avoided: '" + baseName + "' ‚Üí '" + uniqueName + "'");
	return uniqueName;
}

//=============================================================
// VERBOSE REMOVAL COMMENT - parseDXFtoKadMaps function extracted
//=============================================================
// Step 1) Function (428 lines, lines 8813-9241) was extracted to src/fileIO/AutoCadIO/DXFParser.js
// Step 2) Reason: Part of FileManager IO System modularization (Phase 2)
// Step 3) Date: 2026-01-03
// Step 4) The function is now exposed via FileManager.parse() with format "dxf"
// Step 5) Handles 9 DXF entity types: POINT, INSERT, LINE, POLYLINE, CIRCLE, ELLIPSE, TEXT, MTEXT, 3DFACE
// Step 6) Returns structured data: { kadDrawings: Map, surfaces: Map, entityCounts: {} }
// Step 7) Backward compatibility maintained via wrapper function below

async function parseDXFtoKadMaps(dxf, fileName) {
	try {
		// Step 1) Use FileManager to parse DXF data
		var DXFParser = window.fileManager.parsers.get("dxf");
		if (!DXFParser) {
			throw new Error("DXF parser not found in FileManager. Ensure init.js is loaded.");
		}

		var parser = new DXFParser();
		var result = await parser.parse({ dxfData: dxf });

		// Step 15a) Layer System - Create layer for this DXF import
		var layerId = null;
		var layer = null;
		if (fileName) {
			layer = getOrCreateLayerForImport("drawing", fileName);
			if (layer) {
				layerId = layer.layerId;
				console.log("‚úÖ [Layer] Created drawing layer for DXF import:", fileName, "->", layerId);
			}
		}

		// Step 2) Merge parsed KAD drawings into global allKADDrawingsMap with chunking
		var MAX_VERTICES_PER_ENTITY = 10000; // GPU single buffer limit
		var chunkedCount = 0;
		var totalOriginalVertices = 0;

		for (var [entityName, entityData] of result.kadDrawings.entries()) {
			// Step 15b) Assign layerId to entity
			if (layerId) {
				entityData.layerId = layerId;
			}

			// Step 2a) Check if entity needs chunking (lines/polys with >10k vertices)
			if ((entityData.entityType === "line" || entityData.entityType === "poly") &&
				entityData.data && entityData.data.length > MAX_VERTICES_PER_ENTITY) {

				totalOriginalVertices += entityData.data.length;

				// Step 2b) Split into chunks
				var numChunks = Math.ceil(entityData.data.length / MAX_VERTICES_PER_ENTITY);
				console.warn("‚ö†Ô∏è Large DXF entity detected: " + entityName + " (" + entityData.data.length.toLocaleString() + " vertices)");
				console.warn("   ‚Üí Splitting into " + numChunks + " chunks of ~" + Math.ceil(entityData.data.length / numChunks).toLocaleString() + " vertices each");

				for (var chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) {
					var startIdx = chunkIdx * MAX_VERTICES_PER_ENTITY;
					var endIdx = Math.min(startIdx + MAX_VERTICES_PER_ENTITY + 1, entityData.data.length); // +1 for overlap
					var chunkData = entityData.data.slice(startIdx, endIdx);

					// Step 2c) Create unique name for chunk (check for collisions with existing entities)
					var baseChunkName = entityName + "_chunk" + (chunkIdx + 1) + "of" + numChunks;
					var chunkName = getUniqueEntityName(baseChunkName, entityData.entityType);

					// Step 2d) Store chunk as separate entity with layerId
					var chunkEntity = {
						entityName: chunkName,
						entityType: entityData.entityType,
						layerId: layerId,
						data: chunkData,
						isChunk: true,
						originalEntity: entityName,
						chunkIndex: chunkIdx,
						totalChunks: numChunks
					};
					allKADDrawingsMap.set(chunkName, chunkEntity);

					// Step 15c) Add entity to layer
					if (layer) {
						layer.entities.add(chunkName);
					}
					chunkedCount++;
				}
			} else {
				// Step 2e) Normal-sized entity - check for name collision before storing
				var uniqueName = getUniqueEntityName(entityName, entityData.entityType);
				if (uniqueName !== entityName) {
					// Name collision detected - update entity's internal name
					entityData.entityName = uniqueName;
				}
				allKADDrawingsMap.set(uniqueName, entityData);

				// Step 15d) Add entity to layer
				if (layer) {
					layer.entities.add(uniqueName);
				}
			}
		}

		if (chunkedCount > 0) {
			console.log("‚úÇÔ∏è Chunked " + chunkedCount + " large DXF entities at storage level");
			console.log("   üìä Total vertices chunked: " + totalOriginalVertices.toLocaleString());
		}

		// Step 3) Merge parsed surfaces into global loadedSurfaces Map
		// Step 15e) Create surface layer if there are surfaces
		var surfaceLayerId = null;
		var surfaceLayer = null;
		if (result.surfaces.size > 0 && fileName) {
			surfaceLayer = getOrCreateLayerForImport("surface", fileName);
			if (surfaceLayer) {
				surfaceLayerId = surfaceLayer.layerId;
				console.log("‚úÖ [Layer] Created surface layer for DXF import:", fileName, "->", surfaceLayerId);
			}
		}

		for (var [surfaceId, surfaceData] of result.surfaces.entries()) {
			// Step 15f) Assign layerId to surface
			if (surfaceLayerId) {
				surfaceData.layerId = surfaceLayerId;
				if (surfaceLayer) {
					surfaceLayer.entities.add(surfaceId);
				}
			}
			loadedSurfaces.set(surfaceId, surfaceData);

			// Step 4) Save surface to database using async pattern
			setTimeout(async function () {
				try {
					await saveSurfaceToDB(surfaceId);
					console.log("DXF surface saved to database: " + surfaceId);
					debouncedUpdateTreeView();
				} catch (saveError) {
					console.error("Failed to save DXF surface:", saveError);
				}
			}, 100);
		}

		// Step 5) Update UI elements
		updateCentroids();
		// Step #) Trigger 3D rebuild to show imported DXF data
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		// Step 15g) Save layers after import
		debouncedSaveLayers();
		zoomToFitAll();

		// Step 5a) Update TreeView to show new KAD entities
		if (typeof debouncedUpdateTreeView === "function") {
			debouncedUpdateTreeView();
		}

		// Step 6) Log import summary
		console.log("DXF import complete. Entities imported:", result.entityCounts);
		console.log("Appended to KAD maps:", {
			drawings: allKADDrawingsMap,
		});
	} catch (error) {
		console.error("Error during DXF parsing:", error);
		alert("Error importing DXF file: " + error.message);
		throw error;
	}
}

function addUniquePoint(pointsArray, newPoint, tolerance = 0.001) {
	// Check if point already exists within tolerance
	for (let i = 0; i < pointsArray.length; i++) {
		const existingPoint = pointsArray[i];
		const dx = Math.abs(existingPoint.x - newPoint.x);
		const dy = Math.abs(existingPoint.y - newPoint.y);
		const dz = Math.abs(existingPoint.z - newPoint.z);

		if (dx < tolerance && dy < tolerance && dz < tolerance) {
			return i; // Return existing point index
		}
	}

	// Point doesn't exist, add it
	pointsArray.push({
		...newPoint,
	}); // Create a copy to avoid reference issues
	return pointsArray.length - 1; // Return new point index
}

async function handleGeotiffUpload(event) {
	const file = event.target.files[0];
	if (!file) return;

	try {
		updateStatusMessage("Loading GeoTIFF: " + file.name);

		// Step 1) Get IMGParser from FileManager
		var parser = window.fileManager.getParser("geotiff");
		if (!parser) {
			showModalMessage("Error", "GeoTIFF parser not found in FileManager", "error");
			return;
		}

		// Step 2) Parse GeoTIFF file
		var result = await parser.parse(file);

		// Step 3) Process result based on type
		if (result.type === "imagery") {
			// Create background image from canvas
			await createImageSurfaceFromParser(result);
		} else {
			// Create elevation surface from raster data
			await createElevationSurfaceFromParser(result);
		}

		debouncedUpdateTreeView();
		updateStatusMessage("GeoTIFF loaded successfully: " + file.name);
	} catch (error) {
		console.error("Error loading GeoTIFF:", error);
		updateStatusMessage("Error loading GeoTIFF: " + error.message);
		showModalMessage("GeoTIFF Import Error", error.message, "error");
	}
}

// Helper: Create image surface from IMGParser result
async function createImageSurfaceFromParser(result) {
	try {
		// Step 1) Generate unique ID for this image
		var imageId = "image_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);

		// Step 2) Store in loadedImages Map
		loadedImages.set(imageId, {
			id: imageId,
			name: result.filename || imageId,
			canvas: result.canvas,
			bbox: result.bbox,
			type: "imagery",
			visible: true,
			transparency: 1.0
		});

		// Step 3) Update centroids to include GeoTIFF extents
		updateCentroidsWithBBox(result.bbox);

		// Step 3a) Trigger 3D rebuild
		window.threeDataNeedsRebuild = true;

		// Step 4) Update display
		drawData(allBlastHoles, selectedHole);

		// Step 5) Save to database
		try {
			await saveImageToDB(imageId);
			console.log("Image saved to database:", result.filename);
		} catch (saveError) {
			console.error("Failed to save image to database:", saveError);
		}
	} catch (error) {
		console.error("Error creating image surface:", error);
		throw error;
	}
}

// Helper: Create elevation surface from IMGParser result
async function createElevationSurfaceFromParser(result) {
	try {
		// Step 1) Create point cloud from elevation raster (sampled)
		var elevationData = result.rasters[0];
		var bbox = result.bbox;
		var width = result.width;
		var height = result.height;
		var points = [];
		var sampleRate = Math.max(1, Math.floor(Math.sqrt(width * height) / 1000));

		// Step 2) Sample elevation grid
		for (var y = 0; y < height; y += sampleRate) {
			for (var x = 0; x < width; x += sampleRate) {
				var elevation = elevationData[y * width + x];
				if (elevation !== null && !isNaN(elevation) && elevation !== -9999) {
					var worldX = bbox[0] + (x / width) * (bbox[2] - bbox[0]);
					var worldY = bbox[3] - (y / height) * (bbox[3] - bbox[1]);

					points.push({
						x: worldX,
						y: worldY,
						z: elevation
					});
				}
			}
		}

		// Step 3) Create triangulated surface using existing function
		var surfaceName = result.filename || "elevation_" + Date.now();
		createSurfaceFromPoints(points, surfaceName, true);

		// Step 4) Update centroids
		updateCentroidsWithBBox(bbox);

		updateStatusMessage("Elevation surface loaded: " + points.length + " points + full raster interpolation");
	} catch (error) {
		console.error("Error creating elevation surface:", error);
		throw error;
	}
}

function handleSurfaceUpload(event) {
	var allFiles = event.target.files;
	if (!allFiles || allFiles.length === 0) return;

	// Step 1) Categorize selected files
	var objFiles = [];
	var pointCloudFiles = [];
	var companionFiles = []; // MTL, JPG, PNG, etc.
	var pointCloudExtensions = ["xyz", "csv", "txt", "asc", "ply", "pts"];
	var companionExtensions = ["mtl", "jpg", "jpeg", "png", "gif", "bmp"];

	for (var i = 0; i < allFiles.length; i++) {
		var file = allFiles[i];
		var ext = file.name.split(".").pop().toLowerCase();

		if (ext === "obj") {
			objFiles.push(file);
		} else if (pointCloudExtensions.indexOf(ext) !== -1) {
			pointCloudFiles.push(file);
		} else if (companionExtensions.indexOf(ext) !== -1) {
			companionFiles.push(file);
		}
	}

	// Step 2) OBJ file(s) selected - load with MTL/texture support
	if (objFiles.length > 0) {
		// Load each OBJ with all selected files (for MTL/texture matching)
		objFiles.forEach(function (objFile) {
			updateStatusMessage("Loading OBJ surface: " + objFile.name);
			loadOBJWithMTL(objFile, allFiles);
		});
	}
	// Step 3) No OBJ but point cloud files selected - load those
	else if (pointCloudFiles.length > 0) {
		pointCloudFiles.forEach(function (pcFile) {
			updateStatusMessage("Loading surface: " + pcFile.name);
			loadPointCloudFile(pcFile);
		});
	}
	// Step 4) Only MTL/JPG files without OBJ - ignore with message
	else if (companionFiles.length > 0) {
		updateStatusMessage("?? Please select an OBJ file along with MTL/texture files");
		console.warn(
			"MTL/texture files selected without OBJ - ignoring. Selected:",
			companionFiles
				.map(function (f) {
					return f.name;
				})
				.join(", ")
		);
	}
	// Step 5) No valid files
	else {
		updateStatusMessage("No valid surface files found");
	}

	debouncedUpdateTreeView();
}

// ENHANCED: Update OBJ loading to pass texture data
async function loadOBJWithMTL(objFile, allFiles) {
	try {
		// Step 1) Read OBJ file content
		var objContent = await readFileAsText(objFile);
		var baseName = objFile.name.replace(/\.obj$/i, "");

		// Step 2) Look for MTL file
		var mtlContent = null;
		var mtlFile = null;
		for (var i = 0; i < allFiles.length; i++) {
			var file = allFiles[i];
			if (file.name.toLowerCase() === baseName.toLowerCase() + ".mtl") {
				mtlContent = await readFileAsText(file);
				mtlFile = file;
				updateStatusMessage("Found material file: " + file.name);
				break;
			}
		}

		// Step 3) Look for texture files (JPG, PNG, etc.)
		var textureFiles = [];
		var textureBlobs = {};
		for (var j = 0; j < allFiles.length; j++) {
			var texFile = allFiles[j];
			var ext = texFile.name.split(".").pop().toLowerCase();
			if (ext === "jpg" || ext === "jpeg" || ext === "png" || ext === "gif" || ext === "bmp") {
				textureFiles.push(texFile);
				// Read texture as blob for storage
				textureBlobs[texFile.name] = await readFileAsBlob(texFile);
				updateStatusMessage("Found texture file: " + texFile.name);
			}
		}

		// Step 4) ALWAYS use Three.js OBJLoader (for both textured and non-textured)
		// This ensures reliable triangle topology preservation
		console.log("üî∑ Loading OBJ with Three.js loader: " + objFile.name);
		await loadOBJWithTextureThreeJS(objFile.name, objContent, mtlContent, textureBlobs, null);

	} catch (error) {
		console.error("‚ùå Error loading OBJ with MTL:", error);
		// If anything fails, use normal OBJ loading
		loadPointCloudFile(objFile);
	}
}

// Step 1) Read file as Text helper function
async function readFileAsText(file) {
	return new Promise(function (resolve, reject) {
		var reader = new FileReader();
		reader.onload = function (e) {
			resolve(e.target.result);
		};
		reader.onerror = function (e) {
			reject(e);
		};
		reader.readAsText(file);
	});
}

// Step 2) Read file as Blob helper function
async function readFileAsBlob(file) {
	return new Promise(function (resolve, reject) {
		var reader = new FileReader();
		reader.onload = function (e) {
			resolve(new Blob([e.target.result], { type: file.type }));
		};
		reader.onerror = function (e) {
			reject(e);
		};
		reader.readAsArrayBuffer(file);
	});
}

// Step 3) Load OBJ with texture using Three.js loaders
// Step 0) Extract triangles from Three.js mesh geometry
function extractTrianglesFromThreeJSMesh(object3D) {
	var triangles = [];
	var points = [];
	var vertexMap = new Map(); // For deduplication

	object3D.traverse(function (child) {
		if (child.isMesh && child.geometry) {
			var geometry = child.geometry;

			// Step 0a) Get position attribute
			var positions = geometry.attributes.position;
			if (!positions) {
				console.warn("Mesh has no position attribute");
				return;
			}

			// Step 0b) Check if indexed or non-indexed geometry
			var indices = geometry.index;
			var faceCount = 0;

			if (indices) {
				// Indexed geometry
				faceCount = indices.count / 3;

				for (var i = 0; i < faceCount; i++) {
					var i0 = indices.array[i * 3];
					var i1 = indices.array[i * 3 + 1];
					var i2 = indices.array[i * 3 + 2];

					var v0 = {
						x: positions.array[i0 * 3],
						y: positions.array[i0 * 3 + 1],
						z: positions.array[i0 * 3 + 2]
					};
					var v1 = {
						x: positions.array[i1 * 3],
						y: positions.array[i1 * 3 + 1],
						z: positions.array[i1 * 3 + 2]
					};
					var v2 = {
						x: positions.array[i2 * 3],
						y: positions.array[i2 * 3 + 1],
						z: positions.array[i2 * 3 + 2]
					};

					// Add to points with deduplication
					[v0, v1, v2].forEach(function (v) {
						var key = v.x.toFixed(6) + "," + v.y.toFixed(6) + "," + v.z.toFixed(6);
						if (!vertexMap.has(key)) {
							vertexMap.set(key, v);
							points.push(v);
						}
					});

					triangles.push({
						vertices: [v0, v1, v2],
						uvs: [],
						normals: [],
						material: null
					});
				}
			} else {
				// Non-indexed geometry (each 3 vertices = 1 triangle)
				faceCount = positions.count / 3;

				for (var i = 0; i < faceCount; i++) {
					var v0 = {
						x: positions.array[i * 9],
						y: positions.array[i * 9 + 1],
						z: positions.array[i * 9 + 2]
					};
					var v1 = {
						x: positions.array[i * 9 + 3],
						y: positions.array[i * 9 + 4],
						z: positions.array[i * 9 + 5]
					};
					var v2 = {
						x: positions.array[i * 9 + 6],
						y: positions.array[i * 9 + 7],
						z: positions.array[i * 9 + 8]
					};

					// Add to points with deduplication
					[v0, v1, v2].forEach(function (v) {
						var key = v.x.toFixed(6) + "," + v.y.toFixed(6) + "," + v.z.toFixed(6);
						if (!vertexMap.has(key)) {
							vertexMap.set(key, v);
							points.push(v);
						}
					});

					triangles.push({
						vertices: [v0, v1, v2],
						uvs: [],
						normals: [],
						material: null
					});
				}
			}
		}
	});

	console.log("üî∑ Extracted " + triangles.length + " triangles, " + points.length + " unique points from Three.js mesh");
	return { triangles: triangles, points: points };
}

async function loadOBJWithTextureThreeJS(fileName, objContent, mtlContent, textureBlobs, objData) {
	// Step 1) Create progress dialog
	const progressContent = document.createElement("div");
	progressContent.style.textAlign = "center";
	progressContent.innerHTML = "<p>Loading OBJ File: " + fileName + '</p><p>Please wait...</p><div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;"><div id="objProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div></div><p id="objProgressText">Initializing...</p>';

	const progressDialog = new FloatingDialog({
		title: "Loading OBJ",
		content: progressContent,
		layoutType: "standard",
		width: 350,
		height: 200,
		showConfirm: false,
		showCancel: false,
		allowOutsideClick: false,
	});

	progressDialog.show();

	const bar = document.getElementById("objProgressBar");
	const text = document.getElementById("objProgressText");

	return new Promise(function (resolve, reject) {
		try {
			// Step 2) Check if we have textures
			var hasTextures = textureBlobs && Object.keys(textureBlobs).length > 0;

			// Step 3) Handle textured OBJ (with MTL and textures)
			if (hasTextures && mtlContent) {
				// Step 3a) Create texture URLs from blobs
				var textureURLs = {};
				var blobURLs = []; // Track for cleanup
				text.textContent = "Creating texture URLs...";
				bar.style.width = "10%";

				Object.keys(textureBlobs).forEach(function (texName) {
					var url = URL.createObjectURL(textureBlobs[texName]);
					textureURLs[texName] = url;
					blobURLs.push(url);
					console.log("üé® Created blob URL for texture: " + texName);
				});

				// Step 4) Extract texture references directly from MTL content
				// This is more reliable than depending on MTLLoader's internal structure
				var textureRefs = extractTextureRefsFromMTL(mtlContent);
				console.log("üé® Texture references from MTL: " + textureRefs.join(", "));
				text.textContent = "Loading textures (" + Object.keys(textureBlobs).length + ")...";
				bar.style.width = "20%";

				// Step 5) Pre-load all textures into a map
				var textureLoader = new THREE.TextureLoader();
				var loadedTextures = {};
				var texturePromises = [];

				// Step 5a) Load each texture blob we have
				Object.keys(textureBlobs).forEach(function (texName) {
					var texturePromise = new Promise(function (resolveTexture) {
						textureLoader.load(
							textureURLs[texName],
							function (texture) {
								// Step 5b) Texture loaded successfully
								texture.wrapS = THREE.RepeatWrapping;
								texture.wrapT = THREE.RepeatWrapping;
								texture.flipY = true; // Standard UV convention
								// Step 5b-1) CRITICAL: Set sRGB encoding for correct color space
								texture.colorSpace = THREE.SRGBColorSpace;
								texture.needsUpdate = true;
								loadedTextures[texName] = texture;
								loadedTextures[texName.toLowerCase()] = texture; // Also store lowercase for matching
								console.log("üé® Texture pre-loaded: " + texName);
								// Update progress
								const loadedCount = Object.keys(loadedTextures).length / 2; // Divide by 2 (we store twice)
								const totalCount = Object.keys(textureBlobs).length;
								const progress = 20 + (loadedCount / totalCount) * 30; // 20% to 50%
								bar.style.width = progress + "%";
								text.textContent = "Loaded texture " + loadedCount + " of " + totalCount;
								resolveTexture();
							},
							undefined, // onProgress
							function (error) {
								console.warn("üö® Failed to pre-load texture: " + texName, error);
								resolveTexture();
							}
						);
					});
					texturePromises.push(texturePromise);
				});

				// Step 6) Wait for ALL textures to pre-load
				Promise.all(texturePromises).then(function () {
					console.log("üé® All " + Object.keys(loadedTextures).length + " textures pre-loaded for: " + fileName);
					text.textContent = "Parsing MTL materials...";
					bar.style.width = "55%";

					// Step 7) Parse MTL content
					var mtlLoader = new MTLLoader();
					mtlLoader.setResourcePath("");
					var materials = mtlLoader.parse(mtlContent);
					materials.preload();

					text.textContent = "Parsing OBJ geometry...";
					bar.style.width = "70%";

					// Step 8) Parse OBJ content with materials
					var objLoader = new OBJLoader();
					objLoader.setMaterials(materials);
					var object3D = objLoader.parse(objContent);
					object3D.name = fileName;

					text.textContent = "Applying textures to mesh...";
					bar.style.width = "85%";

					// Step 9) Extract material properties from MTL for storage
					var materialProperties = extractMaterialProperties(mtlContent);
					console.log("üé® Extracted material properties: " + Object.keys(materialProperties).length + " materials");

					// Step 9a) Apply textures to mesh materials by matching texture filenames
					// Also collect final material properties (after texture application) for storage
					var finalMaterialProperties = {};
					object3D.traverse(function (child) {
						if (child.isMesh) {
							// DIAGNOSTIC: Log initial material type from MTLLoader
							console.log("üé® INITIAL LOAD: Material type from MTLLoader: " + child.material.type);
							console.log("üé® INITIAL LOAD: Material color: rgb(" + (child.material.color.r * 255).toFixed(0) + ", " + (child.material.color.g * 255).toFixed(0) + ", " + (child.material.color.b * 255).toFixed(0) + ")");
							console.log("üé® INITIAL LOAD: Has map: " + !!child.material.map + ", map colorSpace: " + (child.material.map ? child.material.map.colorSpace : "N/A"));
							console.log("üé® INITIAL LOAD: Has emissive: " + child.material.emissive.getHexString() + ", emissiveIntensity: " + child.material.emissiveIntensity);
							if (child.material.type === "MeshPhongMaterial") {
								console.log("üé® INITIAL LOAD: Phong shininess: " + child.material.shininess + ", specular: " + child.material.specular.getHexString());
								console.log("üé® INITIAL LOAD: Phong emissiveMap: " + !!child.material.emissiveMap + ", lightMap: " + !!child.material.lightMap);
							}
							console.log("üé® INITIAL LOAD: Material side: " + child.material.side + ", depthTest: " + child.material.depthTest + ", depthWrite: " + child.material.depthWrite);

							child.material.side = THREE.DoubleSide;

							// Step 9a.1) Find matching texture for this material
							var appliedTexture = false;
							var appliedTextureName = null;

							// Try to find texture by checking each loaded texture
							Object.keys(loadedTextures).forEach(function (texKey) {
								if (!appliedTexture && loadedTextures[texKey]) {
									// Apply the first available texture
									child.material.map = loadedTextures[texKey];
									child.material.needsUpdate = true;
									appliedTexture = true;
									appliedTextureName = texKey;
									console.log("üé® Applied texture '" + texKey + "' to mesh: " + (child.name || "unnamed"));
								}
							});

							if (!appliedTexture) {
								console.warn("üö® No texture applied to mesh: " + (child.name || "unnamed"));
							}

							// Step 9a.2) Store final material properties (after texture application)
							var materialName = child.name || "default";
							var matProps = materialProperties[materialName] ||
								materialProperties[Object.keys(materialProperties)[0]] || {
								Kd: [1, 1, 1],
								Ns: 0,
								map_Kd: appliedTextureName,
							};

							finalMaterialProperties[materialName] = {
								name: materialName,
								Ka: matProps.Ka || [0, 0, 0],
								Kd: matProps.Kd || [1, 1, 1],
								Ks: matProps.Ks || [0, 0, 0],
								Ns: matProps.Ns || 0,
								map_Kd: appliedTextureName || matProps.map_Kd || null,
								illum: matProps.illum || 2,
							};
						}
					});

					// Step 12) Extract points and triangles from Three.js mesh (reliable topology)
					text.textContent = "Extracting mesh data...";
					bar.style.width = "90%";

					var extracted = extractTrianglesFromThreeJSMesh(object3D);
					var triangles = extracted.triangles;
					var points = extracted.points;

					console.log("üî∑ Extracted from Three.js: " + points.length + " points, " + triangles.length + " triangles");

					// Step 13) Calculate mesh bounds from extracted points
					var minX = Infinity, maxX = -Infinity;
					var minY = Infinity, maxY = -Infinity;
					var minZ = Infinity, maxZ = -Infinity;
					for (var i = 0; i < points.length; i++) {
						var pt = points[i];
						if (pt.x < minX) minX = pt.x;
						if (pt.x > maxX) maxX = pt.x;
						if (pt.y < minY) minY = pt.y;
						if (pt.y > maxY) maxY = pt.y;
						if (pt.z < minZ) minZ = pt.z;
						if (pt.z > maxZ) maxZ = pt.z;
					}
					var meshBounds = { minX: minX, maxX: maxX, minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ };
					console.log("üìê Calculated meshBounds: " + minX.toFixed(2) + " " + maxX.toFixed(2) + " " + minY.toFixed(2) + " " + maxY.toFixed(2));

					// Step 14) Create surface ID
					var surfaceId = fileName;

					// Step 24) Create layer for OBJ import
					var objLayer = getOrCreateLayerForImport("surface", fileName);
					var objLayerId = objLayer ? objLayer.layerId : null;
					if (objLayer) {
						objLayer.entities.add(surfaceId);
					}

					// Step 15) Store in loadedSurfaces with all necessary data
					loadedSurfaces.set(surfaceId, {
						// Standard surface fields for Data Explorer
						id: surfaceId,
						name: fileName,
						points: points,
						triangles: triangles,
						visible: true,
						gradient: "texture", // Default to "texture" to show JPG texture if available
						transparency: 1.0,
						layerId: objLayerId, // Step 24a) Assign layer ID

						// Textured mesh specific fields
						isTexturedMesh: true,
						threeJSMesh: object3D,
						meshBounds: meshBounds,

						// Raw data for IndexedDB persistence
						objContent: objContent,
						mtlContent: mtlContent,
						textureBlobs: textureBlobs,
						materialProperties: finalMaterialProperties, // Store serializable material properties
					});

					console.log("üé® Textured OBJ loaded: " + fileName + " (" + points.length + " points, " + triangles.length + " triangles)");

					// Step 15) Create flattened 2D image for canvas rendering
					// This is now called AFTER textures are loaded
					flattenTexturedMeshToImage(surfaceId, object3D, meshBounds, fileName);

					// Step 16) Save to database
					saveSurfaceToDB(surfaceId)
						.then(function () {
							console.log("üíæ Textured surface saved to database: " + surfaceId);
						})
						.catch(function (err) {
							console.error("‚ùå Failed to save textured surface:", err);
						});

					// Step 17) Update UI
					updateCentroids();
					// Step #) Trigger 3D rebuild to show imported textured OBJ surface
					window.threeDataNeedsRebuild = true;
					drawData(allBlastHoles, selectedHole);
					debouncedUpdateTreeView();
					// Step 24b) Save layers
					debouncedSaveLayers();
					updateStatusMessage("Loaded textured surface: " + fileName);

					// Step 18) Cleanup blob URLs after a delay (textures are now loaded)
					setTimeout(function () {
						blobURLs.forEach(function (url) {
							URL.revokeObjectURL(url);
						});
					}, 5000);

					// Step 19) Close progress dialog
					text.textContent = "Complete!";
					bar.style.width = "100%";
					setTimeout(function () {
						progressDialog.close();
					}, 500);

					resolve(object3D);
				});
			} else {
				// Step 20) No textures - parse OBJ without materials and create regular surface
				console.log("üî∑ No textures - loading as regular surface");
				text.textContent = "Parsing OBJ geometry...";
				bar.style.width = "50%";

				var objLoader = new OBJLoader();
				var object3D = objLoader.parse(objContent);
				object3D.name = fileName;

				// Step 21) Extract triangles from Three.js mesh
				text.textContent = "Extracting triangles...";
				bar.style.width = "75%";

				var extracted = extractTrianglesFromThreeJSMesh(object3D);
				var triangles = extracted.triangles;
				var points = extracted.points;

				console.log("üî∑ Extracted from Three.js: " + points.length + " points, " + triangles.length + " triangles");

				// Step 22) Calculate bounds
				var minX = Infinity, maxX = -Infinity;
				var minY = Infinity, maxY = -Infinity;
				var minZ = Infinity, maxZ = -Infinity;
				for (var i = 0; i < points.length; i++) {
					var pt = points[i];
					if (pt.x < minX) minX = pt.x;
					if (pt.x > maxX) maxX = pt.x;
					if (pt.y < minY) minY = pt.y;
					if (pt.y > maxY) maxY = pt.y;
					if (pt.z < minZ) minZ = pt.z;
					if (pt.z > maxZ) maxZ = pt.z;
				}
				var meshBounds = { minX: minX, maxX: maxX, minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ };

				// Step 23) Store as regular surface
				var surfaceId = fileName;

				// Step 25) Create layer for non-textured OBJ import
				var objLayer2 = getOrCreateLayerForImport("surface", fileName);
				var objLayerId2 = objLayer2 ? objLayer2.layerId : null;
				if (objLayer2) {
					objLayer2.entities.add(surfaceId);
				}

				loadedSurfaces.set(surfaceId, {
					id: surfaceId,
					name: fileName,
					points: points,
					triangles: triangles,
					visible: true,
					gradient: "default",
					transparency: 1.0,
					isTexturedMesh: false,
					meshBounds: meshBounds,
					layerId: objLayerId2, // Step 25a) Assign layer ID
				});

				console.log("‚úÖ OBJ loaded (non-textured): " + fileName + " (" + points.length + " points, " + triangles.length + " triangles)");

				// Step 24) Save to database
				saveSurfaceToDB(surfaceId)
					.then(function () {
						console.log("üíæ Surface saved to database: " + surfaceId);
					})
					.catch(function (err) {
						console.error("‚ùå Failed to save surface:", err);
					});

				// Step 25) Update UI
				updateCentroids();
				// Step #) Trigger 3D rebuild to show imported OBJ surface
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				// Step 25b) Save layers
				debouncedSaveLayers();
				updateStatusMessage("Loaded OBJ surface: " + fileName + " (" + triangles.length + " triangles)");

				// Step 26) Close progress dialog
				text.textContent = "Complete!";
				bar.style.width = "100%";
				setTimeout(function () {
					progressDialog.close();
				}, 500);

				resolve(object3D);
			}
		} catch (error) {
			console.error("‚ùå Error in loadOBJWithTextureThreeJS:", error);
			// Close progress dialog on error
			if (progressDialog) {
				progressDialog.close();
			}
			reject(error);
		}
	});
}

// Step 1) Rebuild textured mesh from stored data (called on app reload)
function rebuildTexturedMesh(surfaceId) {
	var surface = loadedSurfaces.get(surfaceId);
	if (!surface || !surface.isTexturedMesh) {
		console.warn("üö® Cannot rebuild mesh - not a textured surface:", surfaceId);
		return;
	}

	if (!surface.objContent) {
		console.warn("üö® Cannot rebuild mesh - missing OBJ content:", surfaceId);
		return;
	}

	// Step 1a) Prevent multiple rebuilds - if mesh already exists, skip
	if (surface.threeJSMesh) {
		console.log("üé® Mesh already rebuilt for: " + surfaceId + ", skipping rebuild");
		return;
	}

	try {
		// Step 2) Create texture URLs from stored blobs
		var textureURLs = {};
		var blobURLs = [];

		if (surface.textureBlobs) {
			console.log("üé® REBUILD: Found " + Object.keys(surface.textureBlobs).length + " texture blob(s) for " + surfaceId);
			Object.keys(surface.textureBlobs).forEach(function (texName) {
				var blob = surface.textureBlobs[texName];
				if (blob) {
					console.log("üé® REBUILD: Creating URL for texture: " + texName + ", blob size: " + blob.size + " bytes");
					var url = URL.createObjectURL(blob);
					textureURLs[texName] = url;
					blobURLs.push(url);
				}
			});
		}
		else {
			console.warn("üö® REBUILD: NO TEXTURE BLOBS found for " + surfaceId + " - mesh will have no textures!");
		}

		// Step 3) Pre-load all textures into a map (same approach as initial load)
		var textureLoader = new THREE.TextureLoader();
		var loadedTextures = {};
		var texturePromises = [];

		Object.keys(textureURLs).forEach(function (texName) {
			var texturePromise = new Promise(function (resolveTexture) {
				textureLoader.load(
					textureURLs[texName],
					function (texture) {
						texture.wrapS = THREE.RepeatWrapping;
						texture.wrapT = THREE.RepeatWrapping;
						texture.flipY = true;
						// CRITICAL: Set sRGB encoding for correct color space
						texture.colorSpace = THREE.SRGBColorSpace;
						texture.needsUpdate = true;
						loadedTextures[texName] = texture;
						loadedTextures[texName.toLowerCase()] = texture;

						// DIAGNOSTIC: Check if image data is valid
						if (texture.image) {
							console.log("üé® REBUILD TEXTURE: Image loaded - width: " + texture.image.width + ", height: " + texture.image.height + ", complete: " + texture.image.complete);
						} else {
							console.error("üö® REBUILD TEXTURE: No image data in texture!");
						}

						resolveTexture();
					},
					undefined,
					function (error) {
						console.warn("üö® Failed to pre-load texture during rebuild: " + texName, error);
						resolveTexture();
					}
				);
			});
			texturePromises.push(texturePromise);
		});

		// Step 4) Wait for ALL textures to pre-load before proceeding
		Promise.all(texturePromises).then(function () {
			// Step 5) Parse OBJ WITHOUT materials (we'll apply materials manually from stored properties)
			var objLoader = new OBJLoader();
			var object3D = objLoader.parse(surface.objContent);
			object3D.name = surface.name;

			// Step 5a) CRITICAL FIX: Transform OBJ vertices from world coordinates to mesh-centered coordinates
			// The OBJ file stores vertices in world coordinates (UTM)
			// We need to center them around the mesh origin (like OBJLoader does on first load)
			// Then the mesh group will be positioned at mesh center in local Three.js space
			var meshCenterX = surface.meshBounds ? (surface.meshBounds.minX + surface.meshBounds.maxX) / 2 : 0;
			var meshCenterY = surface.meshBounds ? (surface.meshBounds.minY + surface.meshBounds.maxY) / 2 : 0;

			console.log("üé® REBUILD: Centering OBJ vertices around mesh center: (" + meshCenterX.toFixed(2) + ", " + meshCenterY.toFixed(2) + ")");

			object3D.traverse(function (child) {
				if (child.isMesh && child.geometry) {
					var positions = child.geometry.attributes.position;
					if (positions) {
						var posArray = positions.array;
						// Transform each vertex: subtract mesh center from X and Y to center around origin
						for (var i = 0; i < posArray.length; i += 3) {
							posArray[i] -= meshCenterX;     // X coordinate
							posArray[i + 1] -= meshCenterY;  // Y coordinate
							// Z coordinate stays as-is (elevation)
						}
						positions.needsUpdate = true;
						child.geometry.computeBoundingSphere(); // Recompute bounding sphere after transform
						console.log("üé® REBUILD: Centered " + (posArray.length / 3) + " vertices around mesh origin");
					}

					// DIAGNOSTIC: Check if geometry has UV coordinates
					var hasUV = child.geometry.attributes.uv !== undefined;
					console.log("üé® REBUILD: Mesh geometry hasUV: " + hasUV + ", uvCount: " + (hasUV ? child.geometry.attributes.uv.count : 0));
				}
			});

			// Step 5a) Create materials from stored properties + texture blobs
			// This is more reliable than MTLLoader which expects file URLs
			var materialMap = {};
			if (surface.materialProperties && Object.keys(surface.materialProperties).length > 0) {
				console.log("üé® Creating materials from stored properties");
				Object.keys(surface.materialProperties).forEach(function (matName) {
					var matProps = surface.materialProperties[matName];
					var textureName = matProps.map_Kd;
					// Find texture from already-loaded textures map (textures loaded from blobs above)
					var texture = null;
					if (textureName && loadedTextures[textureName]) {
						texture = loadedTextures[textureName];
					} else if (textureName && loadedTextures[textureName.toLowerCase()]) {
						texture = loadedTextures[textureName.toLowerCase()];
					} else {
						// Use first available texture
						var firstTexKey = Object.keys(loadedTextures)[0];
						if (firstTexKey) {
							texture = loadedTextures[firstTexKey];
							console.log("üé® Using first available loaded texture: " + firstTexKey);
						}
					}

					console.log("üé® REBUILD: Created " + Object.keys(materialMap).length + " material(s) from properties");
					materialMap[matName] = createMaterialFromProperties(matProps, texture, textureName);
					console.log("üé® Created material '" + matName + "' with texture: " + (texture ? textureName : "none"));
				});
			} else {
				// Fallback: Create default material with first available loaded texture
				console.warn("üö® No material properties found, creating default material");
				var firstTexKey = Object.keys(loadedTextures)[0];
				var firstTexture = firstTexKey ? loadedTextures[firstTexKey] : null;
				materialMap["default"] = createMaterialFromProperties(null, firstTexture, firstTexKey);
			}

			// Step 7) Apply materials to mesh (from materialMap created from stored properties)
			var texturesApplied = 0;
			var texturesFailed = 0;
			object3D.traverse(function (child) {
				if (child.isMesh) {
					// Find matching material from materialMap
					var materialName = child.name || "default";
					var material = materialMap[materialName] || materialMap["default"] || materialMap[Object.keys(materialMap)[0]];

					if (material) {
						// CRITICAL FIX: Don't clone - preserve texture reference
						// Each mesh child can share the same material instance
						child.material = material;
						child.material.side = THREE.DoubleSide;
						console.log("üé® REBUILD: Applied material to mesh child");
						console.log("üé® REBUILD: Material type: " + child.material.type);
						console.log("üé® REBUILD: Material color: rgb(" + (child.material.color.r * 255).toFixed(0) + ", " + (child.material.color.g * 255).toFixed(0) + ", " + (child.material.color.b * 255).toFixed(0) + ")");
						console.log("üé® REBUILD: Has map: " + !!child.material.map + ", map colorSpace: " + (child.material.map ? child.material.map.colorSpace : "N/A"));
						console.log("üé® REBUILD: Has emissive: " + child.material.emissive.getHexString() + ", emissiveIntensity: " + (child.material.emissiveIntensity || 1));
						if (child.material.type === "MeshPhongMaterial") {
							console.log("üé® REBUILD: Phong shininess: " + child.material.shininess + ", specular: " + child.material.specular.getHexString());
							console.log("üé® REBUILD: Phong emissiveMap: " + !!child.material.emissiveMap + ", lightMap: " + !!child.material.lightMap);
						}
						console.log("üé® REBUILD: Material side: " + child.material.side + ", depthTest: " + child.material.depthTest + ", depthWrite: " + child.material.depthWrite);
						texturesApplied++;
					} else {
						// Fallback: use default material (MeshPhongMaterial to match MTLLoader)
						child.material = new THREE.MeshPhongMaterial({
							color: 0xffffff,
							side: THREE.DoubleSide,
						});
						texturesFailed++;
					}
				}
			});

			// Step 8) Remove old mesh from scene if it exists (ensures new mesh with textures replaces old one)
			if (window.threeRenderer && window.threeRenderer.surfaceMeshMap) {
				var oldMesh = window.threeRenderer.surfaceMeshMap.get(surfaceId);
				if (oldMesh) {
					// Remove old mesh from scene
					if (window.threeRenderer.surfacesGroup) {
						window.threeRenderer.surfacesGroup.remove(oldMesh);
					}
					// Dispose old mesh to free resources
					oldMesh.traverse(function (child) {
						if (child.geometry) child.geometry.dispose();
						if (child.material) {
							if (Array.isArray(child.material)) {
								child.material.forEach(function (mat) {
									mat.dispose();
								});
							} else {
								child.material.dispose();
							}
						}
					});
					// Remove from map
					window.threeRenderer.surfaceMeshMap.delete(surfaceId);
					console.log("üßπ Removed old mesh from scene - will be re-added with textures on next render");
				}
			}

			// Step 8a) Store rebuilt mesh
			surface.threeJSMesh = object3D;

			console.log("üé® Rebuilt textured mesh: " + surfaceId);

			// Step 8a) CRITICAL: Force gradient to "texture" for textured meshes (overrides any saved gradient)
			// Textured meshes MUST use "texture" gradient to show JPG textures, not color gradients
			var oldGradient = surface.gradient;
			if (surface.gradient !== "texture") {
				surface.gradient = "texture";
				console.log("üîª FORCED gradient to 'texture' for rebuilt textured mesh: " + surfaceId + " (was: " + (oldGradient || "default") + ")");
			}

			// Step 8b) Mesh is rebuilt - it will render automatically on next drawData call
			// Don't force redraw here to avoid excessive redraws - let natural rendering cycle handle it

			// Step 9) Cleanup blob URLs after delay
			setTimeout(function () {
				blobURLs.forEach(function (url) {
					URL.revokeObjectURL(url);
				});
			}, 5000);

			// Step 10) Recreate flattened image for 2D canvas
			// This is now called AFTER textures are loaded
			// Step 10a) Check if we have a saved flattened image first
			if (surface.flattenedImageDataURL && surface.flattenedImageBounds && surface.flattenedImageDimensions) {
				console.log("üèûÔ∏è Reusing saved flattened image for: " + surfaceId);
				loadFlattenedImageFromData(surfaceId, surface.flattenedImageDataURL, surface.flattenedImageBounds, surface.flattenedImageDimensions, surface.name);
			} else if (surface.meshBounds && threeInitialized && !threeInitializationFailed) {
				// Step 10b) Only flatten if ThreeJS is initialized and no saved image exists
				console.log("üèûÔ∏è  Creating new flattened image for: " + surfaceId);
				flattenTexturedMeshToImage(surfaceId, object3D, surface.meshBounds, surface.name);
			} else if (!threeInitialized || threeInitializationFailed) {
				console.warn("üö® Skipping texture flattening - ThreeJS not available, will retry when ThreeJS initializes");
			}
		});
	} catch (error) {
		console.error("‚ùå Error rebuilding textured mesh:", error);
	}
}

// Step 0) Load flattened image from saved data URL (avoids WebGL context creation)
function loadFlattenedImageFromData(surfaceId, imageDataURL, meshBounds, dimensions, fileName) {
	try {
		console.log("üèûÔ∏è Loading flattened image from saved data for: " + surfaceId);

		var imageId = "flattened_" + surfaceId;
		var imageCanvas = document.createElement("canvas");
		imageCanvas.width = dimensions.width;
		imageCanvas.height = dimensions.height;
		var imageCtx = imageCanvas.getContext("2d");

		var img = new Image();
		img.onload = function () {
			imageCtx.drawImage(img, 0, 0);

			var worldWidth = meshBounds.maxX - meshBounds.minX;
			var worldHeight = meshBounds.maxY - meshBounds.minY;

			var imageEntry = {
				id: imageId,
				name: fileName + "_flattened",
				canvas: imageCanvas,
				bbox: [meshBounds.minX, meshBounds.minY, meshBounds.maxX, meshBounds.maxY],
				width: dimensions.width,
				height: dimensions.height,
				visible: true,
				transparency: 1.0,
				zElevation: window.drawingZLevel || meshBounds.minZ || 0,
				isGeoReferenced: true,
				bounds: {
					minX: meshBounds.minX,
					maxX: meshBounds.maxX,
					minY: meshBounds.minY,
					maxY: meshBounds.maxY,
				},
				pixelWidth: worldWidth / dimensions.width,
				pixelHeight: worldHeight / dimensions.height,
				sourceType: "flattened_obj",
				sourceSurfaceId: surfaceId,
			};

			loadedImages.set(imageId, imageEntry);
			console.log("üèûÔ∏è Loaded flattened image from saved data: " + imageId);
			debouncedUpdateTreeView();
		};
		img.onerror = function () {
			console.error("‚ùå Failed to load flattened image from saved data");
		};
		img.src = imageDataURL;
	} catch (error) {
		console.error("‚ùå Error loading flattened image from data:", error);
	}
}

// Step 1) Flatten textured mesh to 2D image for canvas rendering
function flattenTexturedMeshToImage(surfaceId, mesh, meshBounds, fileName) {
	try {
		// Step 1a) Check WebGL availability before attempting to create offscreen renderer
		// This prevents context exhaustion errors on page reload when OBJ is in IndexedDB
		if (!threeInitialized) {
			console.warn("üö® Skipping texture flattening - ThreeJS not initialized yet for: " + surfaceId);
			return;
		}

		// Step 1b) Additional check - don't create offscreen renderer if main renderer failed
		if (threeInitializationFailed) {
			console.warn("üö® Skipping texture flattening - ThreeJS initialization previously failed for: " + surfaceId);
			return;
		}

		// Step 2) Calculate image dimensions based on mesh bounds
		var worldWidth = meshBounds.maxX - meshBounds.minX;
		var worldHeight = meshBounds.maxY - meshBounds.minY;

		// Step 3) Determine resolution for high quality (300 DPI equivalent)
		// For mine site data, assume coordinates are in meters
		// 300 DPI at 1:1000 scale = 300 * (1/1000) * 39.37 = ~11.8 pixels per meter
		// For better quality, use higher resolution: 4096px max, minimum 1024px
		var maxResolution = 4096; // Increased from 2048 for better quality
		var minResolution = 1024; // Minimum size for reasonable quality
		var targetPixelsPerMeter = 15; // Higher for better detail

		var aspectRatio = worldWidth / worldHeight;
		var imgWidth, imgHeight;

		// Calculate based on target pixels per meter, clamped to max/min
		if (aspectRatio > 1) {
			imgWidth = Math.min(maxResolution, Math.max(minResolution, Math.ceil(worldWidth * targetPixelsPerMeter)));
			imgHeight = Math.ceil(imgWidth / aspectRatio);
		} else {
			imgHeight = Math.min(maxResolution, Math.max(minResolution, Math.ceil(worldHeight * targetPixelsPerMeter)));
			imgWidth = Math.ceil(imgHeight * aspectRatio);
		}

		// Ensure minimum size for reasonable quality
		imgWidth = Math.max(minResolution, imgWidth);
		imgHeight = Math.max(minResolution, imgHeight);

		console.log("üèûÔ∏è Creating flattened image: " + imgWidth + "x" + imgHeight + " for mesh bounds: " + worldWidth.toFixed(2) + "x" + worldHeight.toFixed(2));

		// Step 4) Create offscreen renderer
		var offscreenRenderer = new THREE.WebGLRenderer({
			antialias: true,
			preserveDrawingBuffer: true,
		});
		offscreenRenderer.setSize(imgWidth, imgHeight);
		offscreenRenderer.setClearColor(0xffffff, 0); // Transparent background

		// Step 4a) Calculate mesh center as local origin for this specific render
		// CRITICAL: Use mesh's own center as origin, NOT threeLocalOriginX/Y
		// This makes the flattening self-contained and independent of external state
		// Centers the mesh at (0,0) for optimal GPU precision during rendering
		var meshCenterX = (meshBounds.minX + meshBounds.maxX) / 2;
		var meshCenterY = (meshBounds.minY + meshBounds.maxY) / 2;
		var halfWidth = worldWidth / 2;
		var halfHeight = worldHeight / 2;

		console.log("üéØ Mesh center for flattening: (" + meshCenterX.toFixed(2) + ", " + meshCenterY.toFixed(2) + "), half-extents: " + halfWidth.toFixed(2) + " x " + halfHeight.toFixed(2));

		// Step 5) Create orthographic camera looking down (top-down view)
		// Use SYMMETRIC frustum centered at 0 - mesh will be transformed to match
		var camera = new THREE.OrthographicCamera(
			-halfWidth, // left
			halfWidth, // right
			halfHeight, // top
			-halfHeight, // bottom
			-10000, // near
			10000 // far
		);
		// Camera at origin looking down
		camera.position.set(0, 0, meshBounds.maxZ + 1000);
		camera.lookAt(0, 0, 0);
		camera.up.set(0, 1, 0); // Y is North

		// Step 6) Create scene with the mesh
		var scene = new THREE.Scene();
		scene.background = null; // Transparent

		// Add ambient light
		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(ambientLight);

		// Clone mesh for rendering - ensure textures are preserved
		var meshClone = mesh.clone();

		// Step 6a) Deep copy materials and TRANSFORM VERTEX POSITIONS to be centered at origin
		// CRITICAL: Subtract mesh center from all vertices so mesh is centered at (0,0)
		meshClone.traverse(function (child) {
			if (child.isMesh) {
				// Clone material and ensure texture references are maintained
				if (child.material) {
					if (Array.isArray(child.material)) {
						child.material = child.material.map(function (mat) {
							var clonedMat = mat.clone();
							if (mat.map) {
								clonedMat.map = mat.map;
								clonedMat.needsUpdate = true;
							}
							return clonedMat;
						});
					} else {
						var originalMat = child.material;
						child.material = originalMat.clone();
						if (originalMat.map) {
							child.material.map = originalMat.map;
							child.material.needsUpdate = true;
						}
					}
					child.material.side = THREE.DoubleSide;
				}

				// Step 6b) Transform vertex positions to center mesh at origin
				if (child.geometry && child.geometry.attributes && child.geometry.attributes.position) {
					var positions = child.geometry.attributes.position;
					var posArray = positions.array;

					for (var i = 0; i < posArray.length; i += 3) {
						posArray[i] -= meshCenterX; // X - subtract center
						posArray[i + 1] -= meshCenterY; // Y - subtract center
						// Z stays unchanged
					}

					positions.needsUpdate = true;
					child.geometry.computeBoundingBox();
					child.geometry.computeBoundingSphere();
				}
			}
		});

		scene.add(meshClone);

		// Step 7) Render the scene
		offscreenRenderer.render(scene, camera);

		// Step 8) Extract image data as dataURL for creating canvas
		var rendererCanvas = offscreenRenderer.domElement;
		var imageDataURL = rendererCanvas.toDataURL("image/png");

		// Step 9) Create an HTMLCanvasElement from the rendered image
		// NOTE: loadedImages entries MUST have a 'canvas' property (HTMLCanvasElement)
		// and 'bbox' in array format [minX, minY, maxX, maxY] for drawing functions
		var imageId = "flattened_" + surfaceId;
		var imageCanvas = document.createElement("canvas");
		imageCanvas.width = imgWidth;
		imageCanvas.height = imgHeight;
		var imageCtx = imageCanvas.getContext("2d");

		// Step 10) Load the rendered image into the canvas
		var img = new Image();
		img.onload = function () {
			imageCtx.drawImage(img, 0, 0);

			// Step 11) Create georeferenced image entry for loadedImages
			var imageEntry = {
				id: imageId,
				name: fileName + "_flattened",
				canvas: imageCanvas, // HTMLCanvasElement - required by drawBackgroundImageThreeJS
				bbox: [meshBounds.minX, meshBounds.minY, meshBounds.maxX, meshBounds.maxY], // Array format [minX, minY, maxX, maxY]
				width: imgWidth,
				height: imgHeight,
				visible: true,
				transparency: 1.0,
				zElevation: window.drawingZLevel || meshBounds.minZ || 0, // Z elevation for 3D positioning

				// Georeferencing data
				isGeoReferenced: true,
				bounds: {
					minX: meshBounds.minX,
					maxX: meshBounds.maxX,
					minY: meshBounds.minY,
					maxY: meshBounds.maxY,
				},

				// Pixel to world transformation
				pixelWidth: worldWidth / imgWidth,
				pixelHeight: worldHeight / imgHeight,

				// Source info
				sourceType: "flattened_obj",
				sourceSurfaceId: surfaceId,
			};

			// Step 12) Store in loadedImages
			loadedImages.set(imageId, imageEntry);

			console.log("üèûÔ∏è Created flattened image for 2D canvas: " + imageId);

			// Step 12a) Save flattened image data URL back to surface for IndexedDB persistence
			var surface = loadedSurfaces.get(surfaceId);
			if (surface) {
				surface.flattenedImageDataURL = imageDataURL;
				surface.flattenedImageBounds = meshBounds;
				surface.flattenedImageDimensions = { width: imgWidth, height: imgHeight };

				// Step 12b) Save to IndexedDB
				saveSurfaceToDB(surfaceId).catch(function (err) {
					console.warn("üö® Failed to save flattened image to DB:", err);
				});
			}

			// Step 13) Update tree view to show new image
			debouncedUpdateTreeView();
		};
		img.onerror = function () {
			console.error("‚ùå Failed to create canvas from flattened image");
		};
		img.src = imageDataURL;

		// Step 14) Cleanup offscreen renderer
		offscreenRenderer.dispose();
		scene.clear();
	} catch (error) {
		console.error("? Error flattening textured mesh:", error);
	}
}

async function handleMeasuredUpload(event) {
	// Measured data format: EntityName,EntityType,PointID,MeasuredLength,MeasuredLengthTimeStamp,MeasuredMass,MeasuredMassTimeStamp,MeasuredComment,MeasuredCommentTimeStamp

	if (!event.target.files[0].name.endsWith(".csv")) {
		fileFormatPopup("1");
		return;
	}
	if (allBlastHoles.length === 0) {
		fileFormatPopup("2");
		return;
	}

	const file = event.target.files[0];
	if (!file) return;

	const reader = new FileReader();
	reader.onload = function (e) {
		const fileContent = e.target.result;
		const lines = fileContent.split("\n").filter((line) => line.trim().length > 0);

		// Skip header if present
		const header = lines[0].toLowerCase();
		const startIndex = header.includes("entityname") ? 1 : 0;

		for (let i = startIndex; i < lines.length; i++) {
			const cols = lines[i].split(",");
			if (cols.length < 9) continue; // Skip malformed lines

			const entityName = cols[0].trim();
			const holeID = cols[2].trim();

			// Find matching point
			const point = allBlastHoles.find((p) => p.entityName === entityName && p.holeID === holeID);
			if (point) {
				point.measuredLength = parseFloat(cols[3]) || 0;
				point.measuredLengthTimeStamp = cols[4].trim() || "09/05/1975 00:00:00";
				point.measuredMass = parseFloat(cols[5]) || 0;
				point.measuredMassTimeStamp = cols[6].trim() || "09/05/1975 00:00:00";
				point.measuredComment = cols[7].trim();
				point.measuredCommentTimeStamp = cols[8].trim() || "09/05/1975 00:00:00";
			}
		}

		drawData(allBlastHoles, selectedHole); // Redraw to reflect updated values
	};

	reader.readAsText(file);
	debouncedUpdateTreeView(); // Use debounced version
}

function fileFormatPopup(error) {
	console.log("File format error");
	showModalMessage("Error " + error, "This could be related to the data structure or file.<br><br>" + "Or there are NO blasts or Holes yet, if so ignore.<br><br>" + "Only files with 4, 7, 9, 14, 30, 32 and 35 columns are Accepted<br><br>" + "Column Order and Types are important.", "error");
}
// Create a Map for each entity type to store entities by name

let allKADDrawingsMap = new Map();

// Step 1) Layer System - Added 2026-01-16
// Maps to store layer information for Drawings and Surfaces
// Layer structure: { layerId, layerName, visible, sourceFile, importDate, entities: Set<entityName> }
let allDrawingLayers = new Map();  // layerId -> Layer object for KAD drawings
let allSurfaceLayers = new Map();  // layerId -> Layer object for surfaces

// Step 2) Default layer ID constant
var DEFAULT_DRAWING_LAYER_ID = "layer_default_drawings";
var DEFAULT_SURFACE_LAYER_ID = "layer_default_surfaces";

// Step 18) Active layer tracking - which layer new entities are added to
var activeDrawingLayerId = DEFAULT_DRAWING_LAYER_ID;
var activeSurfaceLayerId = DEFAULT_SURFACE_LAYER_ID;

// Step #) Convert CSS color names to hex for 3D compatibility
// Three.js batched rendering only handles hex colors, not named colors
function cssColorToHex(colorInput) {
	if (!colorInput) return "#FF0000"; // Default red

	var color = String(colorInput).trim();

	// Already a hex color
	if (color.charAt(0) === "#") return color;

	// RGB/RGBA format
	if (color.toLowerCase().startsWith("rgb")) return color;

	// CSS color name lookup table (common colors)
	var colorNames = {
		"red": "#FF0000",
		"green": "#008000",
		"blue": "#0000FF",
		"yellow": "#FFFF00",
		"orange": "#FFA500",
		"purple": "#800080",
		"pink": "#FFC0CB",
		"cyan": "#00FFFF",
		"magenta": "#FF00FF",
		"black": "#000000",
		"white": "#FFFFFF",
		"gray": "#808080",
		"grey": "#808080",
		"brown": "#A52A2A",
		"lime": "#00FF00",
		"limegreen": "#32CD32",
		"navy": "#000080",
		"teal": "#008080",
		"maroon": "#800000",
		"olive": "#808000",
		"aqua": "#00FFFF",
		"fuchsia": "#FF00FF",
		"silver": "#C0C0C0",
		"gold": "#FFD700",
		"coral": "#FF7F50",
		"crimson": "#DC143C",
		"darkblue": "#00008B",
		"darkgreen": "#006400",
		"darkred": "#8B0000",
		"lightblue": "#ADD8E6",
		"lightgreen": "#90EE90",
		"lightgray": "#D3D3D3",
		"lightgrey": "#D3D3D3",
		"darkgray": "#A9A9A9",
		"darkgrey": "#A9A9A9",
		"skyblue": "#87CEEB",
		"steelblue": "#4682B4",
		"turquoise": "#40E0D0",
		"violet": "#EE82EE",
		"indigo": "#4B0082",
		"tan": "#D2B48C",
		"beige": "#F5F5DC",
		"salmon": "#FA8072",
		"khaki": "#F0E68C"
	};

	var hex = colorNames[color.toLowerCase()];
	if (hex) return hex;

	// Fallback: try to use browser canvas to convert (handles any CSS color)
	try {
		var tempCanvas = document.createElement("canvas");
		tempCanvas.width = 1;
		tempCanvas.height = 1;
		var tempCtx = tempCanvas.getContext("2d");
		tempCtx.fillStyle = color;
		// Get the computed color (will be in rgb format)
		var computedColor = tempCtx.fillStyle;
		if (computedColor.charAt(0) === "#") return computedColor;
		// Parse rgb(r,g,b) format
		var match = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
		if (match) {
			var r = parseInt(match[1]).toString(16).padStart(2, "0");
			var g = parseInt(match[2]).toString(16).padStart(2, "0");
			var b = parseInt(match[3]).toString(16).padStart(2, "0");
			return "#" + r + g + b;
		}
	} catch (e) {
		console.warn("Could not convert color:", color, e);
	}

	return "#FF0000"; // Default to red if all else fails
}

function parseKADFile(fileData) {
	let minX = Infinity;
	let minY = Infinity;
	let pointID, pointXLocation, pointYLocation, pointZLocation, text, radius, color, closed, lineWidth;

	try {
		// ? Use PapaParse with error handling
		const parseResult = Papa.parse(fileData, {
			delimiter: "", // Auto-detect delimiter
			skipEmptyLines: true,
			trimHeaders: true,
			transform: (value) => value.trim(),
		});

		// ? Check for critical parsing errors
		const criticalErrors = parseResult.errors.filter((error) => error.type === "Delimiter" || error.type === "Quotes");

		if (criticalErrors.length > 0) {
			showModalMessage("File Parsing Error", "Failed to parse the file properly:<br><br>" + criticalErrors.map((error) => "<li>" + error.message + "</li>").join("") + "<br><br>" + "Common causes:<br><br>" + "<li>Mixed delimiters (commas and tabs in same file)</li>" + "<li>Unescaped quotes in text fields</li>" + "<li>Inconsistent number of columns</li>" + "<br><br>" + "Please check your file format and try again.", "error");
			return; // Exit early
		}

		// ? Warn about minor parsing issues but continue
		if (parseResult.errors.length > 0) {
			console.warn("CSV parsing warnings:", parseResult.errors);

			const additionalErrors = parseResult.errors.length > 5 ? "<li>... and " + (parseResult.errors.length - 5) + " more</li>" : "";
			showModalMessage(
				"File Import Warning",
				"The file was imported but there were " +
				parseResult.errors.length +
				" parsing warnings:<br><br>" +
				parseResult.errors
					.slice(0, 5)
					.map((error) => "<li>Row " + error.row + ": " + error.message + "</li>")
					.join("") +
				additionalErrors +
				"<br><br>" +
				"Some data may have been skipped. Check your results carefully.",
				"warning"
			);
		}

		const dataRows = parseResult.data;

		// ? Check if we got any data
		if (dataRows.length === 0) {
			showModalMessage("Empty File", "The file appears to be empty or contains no valid data.", "warning");
			return;
		}

		console.log("Parsed " + dataRows.length + " rows with delimiter: " + parseResult.meta.delimiter);

		let successCount = 0;
		let errorCount = 0;
		let errorDetails = [];

		// Parse each row with individual error handling
		for (let i = 0; i < dataRows.length; i++) {
			try {
				const row = dataRows[i];

				// Skip rows that don't have enough columns
				if (row.length < 3) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Too few columns (" + row.length + ")");
					continue;
				}

				const entityName = row[0];
				const entityType = row[1];

				// Skip if missing essential data
				if (!entityName || !entityType) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Missing entity name or type");
					continue;
				}

				// ? Validate entity type
				const validTypes = ["point", "line", "poly", "circle", "text"];
				if (!validTypes.includes(entityType)) {
					errorCount++;
					errorDetails.push("Row " + (i + 1) + ": Invalid entity type '" + entityType + "'");
					continue;
				}

				// ? Your existing parsing logic here (same as before)
				switch (entityType) {
					case "point":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "point",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]) || 1;
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							connected: false,
							closed: false,
						});
						break;

					case "poly":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: entityType,
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));
						closed = String(row[8]).trim().toLowerCase() === "true";

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: entityType,
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: closed,
						});
						break;

					case "line":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "line",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						lineWidth = parseFloat(row[6]);
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "line",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							lineWidth: lineWidth,
							color: color,
							closed: false,
						});
						break;

					case "circle":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "circle",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						radius = parseFloat(row[6]);
						lineWidth = parseFloat(row[7]) || 1;
						color = cssColorToHex((row[8] || "#FF0000").replace(/\r$/, ""));

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "circle",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							radius: radius,
							lineWidth: lineWidth,
							color: color,
						});
						break;

					case "text":
						if (!allKADDrawingsMap.has(entityName)) {
							allKADDrawingsMap.set(entityName, {
								entityName: entityName,
								entityType: "text",
								data: [],
							});
						}

						pointID = parseInt(row[2]);
						pointXLocation = parseFloat(row[3]);
						pointYLocation = parseFloat(row[4]);
						pointZLocation = parseFloat(row[5]);
						text = row[6] || "";
						color = cssColorToHex((row[7] || "#FF0000").replace(/\r$/, ""));
						// Step B1) Read fontHeight from column 8, default to 12 for backward compatibility
						var textFontHeight = row[8] ? parseFloat(row[8]) : 12;

						allKADDrawingsMap.get(entityName).data.push({
							entityName: entityName,
							entityType: "text",
							pointID: pointID,
							pointXLocation: pointXLocation,
							pointYLocation: pointYLocation,
							pointZLocation: pointZLocation,
							text: text,
							color: color,
							fontHeight: textFontHeight,
						});
						break;
				}

				successCount++;
			} catch (rowError) {
				errorCount++;
				errorDetails.push("Row " + (i + 1) + ": " + rowError.message);
				console.error("Error parsing row " + (i + 1) + ":", rowError);
			}
		}

		// ? Show import results
		if (successCount > 0) {
			let message = "Successfully imported " + successCount + " items.";

			if (errorCount > 0) {
				message += "\n" + errorCount + " items failed to import.";
			}

			const errorDetailsHtml =
				errorCount > 0
					? "<details>" +
					"<summary>View Error Details (" +
					errorCount +
					" errors)</summary>" +
					'<ul style="max-height: 200px; overflow-y: auto; text-align: left;">' +
					errorDetails
						.slice(0, 10)
						.map((error) => "<li>" + error + "</li>")
						.join("") +
					(errorDetails.length > 10 ? "<li>... and " + (errorDetails.length - 10) + " more errors</li>" : "") +
					"</ul>" +
					"</details>"
					: "";

			showModalMessage(errorCount > 0 ? "Import Completed with Errors" : "Import Successful", message + errorDetailsHtml, errorCount > 0 ? "warning" : "success");
		} else {
			// ? Complete failure
			const errorDetailsHtml =
				'<div style="text-align: left;">' +
				"<p><strong>No items could be imported.</strong></p>" +
				"<p><strong>Common issues:</strong></p>" +
				"<ul>" +
				"<li>Wrong file format or column order</li>" +
				"<li>Missing required columns</li>" +
				"<li>Invalid data types</li>" +
				"</ul>" +
				"<details>" +
				"<summary>View Error Details</summary>" +
				'<ul style="max-height: 200px; overflow-y: auto;">' +
				errorDetails
					.slice(0, 10)
					.map((error) => "<li>" + error + "</li>")
					.join("") +
				"</ul>" +
				"</details>" +
				"</div>";

			showModalMessage("Import Failed", errorDetailsHtml, "error");
			return;
		}

		// Calculate centroid (existing logic)
		let sumX = 0;
		let sumY = 0;
		let count = 0;

		for (let [key, value] of allKADDrawingsMap) {
			for (let i = 0; i < value.data.length; i++) {
				sumX += value.data[i].pointXLocation;
				sumY += value.data[i].pointYLocation;
				count++;
			}
		}

		if (count > 0) {
			centroidX = sumX / count;
			centroidY = sumY / count;
		}

		console.log(allKADDrawingsMap);
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	} catch (error) {
		// ? Catch any unexpected errors
		console.error("Unexpected error during KAD file parsing:", error);

		showModalMessage("Unexpected Error", '<div style="text-align: left;">' + "<p><strong>An unexpected error occurred while importing the file:</strong></p>" + "<p><code>" + error.message + "</code></p>" + "<p>Please check the file format and try again. If the problem persists, contact support.</p>" + "</div>", "error");
	}
}

let mapData = [allKADDrawingsMap];

function exportKADFile() {
	// First, check if we have data to export
	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		alert("No data to export. Please add some drawings first.");
		return;
	}

	console.log("Exporting KAD data, map size:", allKADDrawingsMap.size);

	// Prepare the CSV content for .kad file
	let csvContentKAD = "";
	let csvContentTXT = "";

	try {
		// Directly iterate through the allKADDrawingsMap
		for (const [entityName, entityData] of allKADDrawingsMap.entries()) {
			// ? ONLY ADD THIS LINE - check visibility using your existing function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity:", entityName);
				continue;
			}
			// Log each entity we're processing
			console.log(`Processing entity: ${entityName}, type: ${entityData.entityType}`);

			if (!entityData || !entityData.entityType) {
				console.warn(`Skipping invalid entity: ${entityName}`);
				continue;
			}

			if (entityData.entityType.trim() === "point") {
				for (const point of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${point.pointID},${point.pointXLocation},${point.pointYLocation},${point.pointZLocation},${point.lineWidth || 1},${point.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "poly") {
				for (let i = 0; i < entityData.data.length; i++) {
					const polygon = entityData.data[i];
					const isLast = i === entityData.data.length - 1;
					const csvLine = `${entityName},${entityData.entityType},${polygon.pointID},${polygon.pointXLocation},${polygon.pointYLocation},${polygon.pointZLocation},${polygon.lineWidth},${polygon.color},${isLast ? "1" : "0"}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "line") {
				for (const entityLine of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${entityLine.pointID},${entityLine.pointXLocation},${entityLine.pointYLocation},${entityLine.pointZLocation},${entityLine.lineWidth},${entityLine.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "circle") {
				for (const circle of entityData.data) {
					const csvLine = `${entityName},${entityData.entityType},${circle.pointID},${circle.pointXLocation},${circle.pointYLocation},${circle.pointZLocation},${circle.radius},${circle.lineWidth},${circle.color}\n`;
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			} else if (entityData.entityType.trim() === "text") {
				for (const text of entityData.data) {
					// Step B4) Include fontHeight in export (column 8), default to 12 for backward compatibility
					var exportFontHeight = text.fontHeight || 12;
					const csvLine = entityName + "," + entityData.entityType + "," + text.pointID + "," + text.pointXLocation + "," + text.pointYLocation + "," + text.pointZLocation + "," + text.text + "," + text.color + "," + exportFontHeight + "\n";
					csvContentKAD += csvLine;
					csvContentTXT += csvLine;
				}
			}
		}
	} catch (error) {
		console.error("Error generating KAD export:", error);
		alert("Error exporting KAD file: " + error.message);
		return;
	}

	// If we generated any content, create and download the files
	if (csvContentKAD) {
		// Create a Blob with the CSV content for .kad file
		const blobKAD = new Blob([csvContentKAD], {
			type: "text/csv",
		});

		// Create a Blob with the CSV content for .txt file
		const blobTXT = new Blob([csvContentTXT], {
			type: "text/plain",
		});

		// Create temporary anchor elements to trigger the download for both files
		const aKAD = document.createElement("a");
		const aTXT = document.createElement("a");

		// Set the content for the anchor elements
		aKAD.href = URL.createObjectURL(blobKAD);
		aKAD.download = "KAD_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".kad";

		aTXT.href = URL.createObjectURL(blobTXT);
		aTXT.download = "TXT_EXPORT" + new Date().toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", "_") + ".txt";

		// Simulate clicks on both anchor elements to trigger the downloads
		aKAD.click();
		aTXT.click();

		console.log("KAD export completed successfully");
	} else {
		alert("No data to export. Please add some drawings first.");
	}
}

function getNearestNeighborDistancesByAggregation(allBlastHoles, mode, useToeLocation) {
	// Step 1: Compute nearest neighbor distances for each point
	const nearestDistances = allBlastHoles.map((pt, idx) => {
		let minDist = Infinity;
		for (let j = 0; j < allBlastHoles.length; j++) {
			if (j === idx) continue;
			const otherPt = allBlastHoles[j];

			const dx = useToeLocation ? otherPt.endXLocation - pt.endXLocation : otherPt.startXLocation - pt.startXLocation;
			const dy = useToeLocation ? otherPt.endYLocation - pt.endYLocation : otherPt.startYLocation - pt.startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			if (dist < minDist) minDist = dist;
		}
		return minDist;
	});
	// Step 2: Determine the distance to use based on the mode
	let chosenDistance;
	if (mode === "min") {
		chosenDistance = Math.min(...nearestDistances);
	} else if (mode === "max") {
		chosenDistance = Math.max(...nearestDistances);
	} else if (mode === "average" || mode === "mean") {
		const sum = nearestDistances.reduce((a, b) => a + b, 0);
		chosenDistance = sum / nearestDistances.length;
	} else if (mode === "mode") {
		// Find the most common value (rounded to nearest cm for stability)
		const freq = {};
		let maxFreq = 0,
			modeValue = nearestDistances[0];
		nearestDistances.forEach((d) => {
			const rounded = Math.round(d * 100); // round to cm
			freq[rounded] = (freq[rounded] || 0) + 1;
			if (freq[rounded] > maxFreq) {
				maxFreq = freq[rounded];
				modeValue = rounded / 100;
			}
		});
		chosenDistance = modeValue;
	} else {
		console.warn("Unknown mode for getRadiiBlastHolesPolygon:", mode, "Defaulting to  min.");
		chosenDistance = Math.min(...nearestDistances);
	}
	return chosenDistance;
}

/**
 * Get the unioned polygon of circles around blast holes, with radius based on nearest neighbor distances.
 * @param {Array} allBlastHoles - Array of allBlastHoles, each with startXLocation, startYLocation, startZLocation, endXLocation, endYLocation, endZLocation.
 * @param {number} percentDistance - Percentage to scale the chosen distance metric.
 * @param {number} steps - Number of steps for circle polygon-isation.
 * @param {string} mode - One of "min", "max", "average", "mode" (statistical mode of distances).
 * @returns {Array} Array of {x, y, z} points representing the unioned polygon.
 */
function getRadiiBlastHolesPolygon(allBlastHoles, percentDistance, steps, mode = "min") {
	const scale = 100000; // Clipper uses integers; scale meters to avoid precision loss

	// Step 2: Use the helper function to determine distance
	const chosenDistance = getNearestNeighborDistancesByAggregation(allBlastHoles, mode);

	// Step 3: Calculate the radius to use
	const radius = chosenDistance * (percentDistance / 100);

	// Step 4: Build circle polygons for each point
	const circlePolygons = allBlastHoles.map((pt) => {
		const centerX = pt.endXLocation;
		const centerY = pt.endYLocation;
		const centerZ = pt.endZLocation;
		const path = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = centerX + radius * Math.cos(angle);
			const y = centerY + radius * Math.sin(angle);
			const z = centerZ; // keep flat for now
			path.push({
				X: Math.round(x * scale),
				Y: Math.round(y * scale),
				Z: z,
			});
		}
		return path;
	});

	// Step 5: Perform union using clipper-lib
	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(circlePolygons, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		console.warn("Clipper union failed or returned empty result.");
		return [];
	}

	// Step 6: Return the unioned polygon as an array of {x, y, z}
	return solution[0].map((pt) => {
		const realX = pt.X / scale;
		const realY = pt.Y / scale;
		// Nearest Z from original centers
		let nearestZ = 0;
		let minDist = Infinity;
		allBlastHoles.forEach((p) => {
			const dx = p.startXLocation - realX;
			const dy = p.startYLocation - realY;
			const dist = dx * dx + dy * dy;
			if (dist < minDist) {
				minDist = dist;
				nearestZ = p.startZLocation;
			}
		});
		return {
			x: realX,
			y: realY,
			z: nearestZ,
		};
	});
}

document.getElementById("createRadiiFromBlastHoles").addEventListener("click", function () {
	// Get the values from the input fields
	const radius = parseFloat(document.getElementById("drawingPolygonRadius").value);
	const lineWidth = parseFloat(document.getElementById("drawingLineWidth").value);
	const color = getJSColorHexDrawing();
	const steps = parseInt(document.getElementById("radiiSteps").value);
	const union = true;
	const addToMaps = true;

	// Check if the radius is a valid number
	if (isNaN(radius) || radius <= 0) {
		alert("Please enter a valid radius.");
		return;
	}
	// Check if the line width is a valid number
	if (isNaN(lineWidth) || lineWidth <= 0) {
		alert("Please enter a valid line width.");
		return;
	}

	// Determine which holes to process
	let targetHoles = allBlastHoles;
	let datasetDescription = "all holes";

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		targetHoles = selectedMultipleHoles;
		datasetDescription = "selected holes";
	} else if (selectedHole) {
		targetHoles = [selectedHole];
		datasetDescription = "selected hole";
	}

	// Add performance warning for large number of holes
	if (targetHoles.length > 1000) {
		Swal.fire({
			title: "Performance Warning",
			html: `
				<div style="text-align: center;">
					<p><strong>?? Large Dataset Detected</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p style="color: #f39c12;"><strong>Warning:</strong><br>
					This may take significant time and could cause<br>
					the browser to become unresponsive.</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Recommendations:</strong></p>
					<p style="text-align: left; margin: 0 auto; display: inline-block;">
						? Reduce steps (current: ${steps})<br>
						? Process smaller sections<br>
						? Save work before continuing
					</p>
				</div>
			`,
			icon: "warning",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container",
			},
		}).then((result) => {
			if (result.isConfirmed) {
				// Show progress message
				updateStatusMessage("Processing radii polygons for " + targetHoles.length + " " + datasetDescription + "... This may take a while.");

				// Use setTimeout to allow UI to update before processing
				setTimeout(() => {
					try {
						const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
						drawData(allBlastHoles, selectedHole);
						updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
					} catch (error) {
						console.error("Error creating radii polygons:", error);
						updateStatusMessage("Error creating radii polygons. Please try with fewer holes or reduced steps.");
						Swal.fire({
							title: "Error",
							html: `
								<div style="text-align: center;">
									<p><strong>Failed to create radii polygons.</strong></p>
									<hr style="border-color: #555; margin: 15px 0;">
									<p><strong>Try:</strong></p>
									<p style="text-align: left; margin: 0 auto; display: inline-block;">
										? Reducing steps<br>
										? Processing fewer holes<br>
										? Refreshing browser
									</p>
								</div>
							`,
							icon: "error",
							customClass: {
								container: "custom-popup-container",
								confirmButton: "confirm",
							},
						});
					}
				}, 100);
			}
		});
	} else if (targetHoles.length > 500) {
		// Medium warning for 500-1000 holes
		Swal.fire({
			title: "Performance Notice",
			html: `
				<div style="text-align: center;">
					<p><strong>Medium Dataset</strong></p>
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Processing:</strong> ${targetHoles.length} ${datasetDescription}</p>
					<p><strong>Steps:</strong> ${steps}</p>
					
					<hr style="border-color: #555; margin: 15px 0;">
					
					<p><strong>Note:</strong><br>Processing may take a few moments.</p>
				</div>
			`,
			icon: "info",
			showCancelButton: true,
			confirmButtonText: "Ok",
			cancelButtonText: "Cancel",
			customClass: {
				container: "custom-popup-container",
				title: "swal2-title",
				confirmButton: "confirm",
				cancelButton: "cancel",
				content: "swal2-content",
				htmlContainer: "swal2-html-container",
			},
		}).then((result) => {
			if (result.isConfirmed) {
				processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
				debouncedUpdateTreeView(); // Use debounced version
			}
		});
	} else {
		// Process normally for smaller datasets
		processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription);
		debouncedUpdateTreeView(); // Use debounced version
	}
});
// Helper function to check if an entity is effectively visible (including parent groups)
function isEntityEffectivelyVisible(entityName, entityType, entityVisible = true) {
	// Check blast holes
	if (entityType === "hole") {
		return blastGroupVisible && entityVisible !== false;
	}

	// Check drawings
	if (!drawingsGroupVisible) return false;

	// Check specific drawing type groups
	if (entityType === "points") return pointsGroupVisible && entityVisible !== false;
	if (entityType === "lines") return linesGroupVisible && entityVisible !== false;
	if (entityType === "polygons") return polygonsGroupVisible && entityVisible !== false;
	if (entityType === "circles") return circlesGroupVisible && entityVisible !== false;
	if (entityType === "texts") return textsGroupVisible && entityVisible !== false;

	return entityVisible !== false;
}
// Helper function to process radii polygons
function processRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, datasetDescription) {
	try {
		updateStatusMessage("Creating radii polygons for " + targetHoles.length + " " + datasetDescription + "...");
		const polygon = getRadiiPolygons(targetHoles, steps, radius, union, addToMaps, color, lineWidth, useToeLocation);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".");
		// Step 1) Create success message content
		const successContent = '<div style="text-align: center;">' + "<p><strong>Radii polygons created successfully for " + targetHoles.length + " " + datasetDescription + ".</strong></p>" + "<p><strong>Zoom or Scroll to see the results.</strong></p>" + "<p><strong>The radii is at " + radius + "m from the hole(s).</strong></p>" + "</div>";

		// Step 2) Show success modal and handle saving
		showModalMessage("Success", successContent, "success");

		// Step 3) Save the drawing and update tree view
		debouncedSaveKAD();
		debouncedUpdateTreeView(); // Use debounced version
	} catch (error) {
		console.error("Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");
		// Step 1) Create error message content
		const errorContent = '<div style="text-align: center;">' + "<p><strong>Failed to create radii polygons.</strong></p>" + '<hr style="border-color: #555; margin: 15px 0;">' + "<p><strong>Error:</strong><br>" + (error.message || "Unknown error occurred") + "</p>" + "</div>";

		// Step 2) Show error modal using showModalMessage
		showModalMessage("Error", errorContent, "error");
	}
}

// Convert hex color (e.g., #FF0000) to a DXF color index (1-255, never 0 or 256)
function getColorInteger(hex) {
	// Remove the '#' character if present
	if (hex.startsWith("#")) {
		hex = hex.slice(1);
	}
	// Parse the hex string as an integer
	const intValue = parseInt(hex, 16);
	const r = (intValue >> 16) & 0xff;
	const g = (intValue >> 8) & 0xff;
	const b = intValue & 0xff;

	// Basic mapping for common colors
	if (r === 255 && g === 0 && b === 0) return 1; // red
	if (r === 255 && g === 255 && b === 0) return 2; // yellow
	if (r === 0 && g === 255 && b === 0) return 3; // green
	if (r === 0 && g === 255 && g === 255) return 4; // cyan
	if (r === 0 && g === 0 && b === 255) return 5; // blue
	if (r === 255 && g === 0 && b === 255) return 6; // magenta
	if (r === 255 && g === 255 && g === 255) return 7; // white

	// For other colors, approximate to 8-255 (never 0 or 256)
	const gray = Math.round((r + g + b) / 3);
	const index = Math.max(8, Math.min(255, Math.round((gray / 255) * 247) + 8));
	return index;
}

/**
 * Exports map data to a DXF (Drawing Exchange Format) string and creates a Blob for download.
 *
 * The function iterates through the provided map data and converts supported entities
 * (point, line, poly, circle, text) into their corresponding DXF representations.
 * Each entity is added to the DXF content string, which is then used to create a Blob.
 *
 * @param {Array<Map<string, Object>>} mapData - An array of Map objects, where each Map contains
 *   entity names as keys and entity data objects as values. Each entity data object should have:
 *   - {string} entityType - The type of the entity ("point", "line", "poly", "circle", "text").
 *   - {Array<Object>} data - An array of entity?specific data objects.
 *
 * Entity data object structure varies by entityType:
 *   - "point": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "line": { pointXLocation, pointYLocation, pointZLocation, pointXTarget, pointYTarget, pointZTarget, color }
 *   - "poly": { pointXLocation, pointYLocation, pointZLocation, color }
 *   - "circle": { pointXLocation, pointYLocation, pointZLocation, radius, color }
 *   - "text": { pointXLocation, pointYLocation, pointZLocation, text, color }
 *
 * @returns {void}
 */
function exportKADDXF() {
	// DEBUG: Check if data is duplicating
	console.log("exportKADDXF: allKADDrawingsMap.size =", allKADDrawingsMap.size);
	var totalPoints = 0;
	allKADDrawingsMap.forEach(function (entity) {
		totalPoints += entity.data ? entity.data.length : 0;
	});
	console.log("exportKADDXF: Total points across all entities =", totalPoints);

	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	const allMaps = [allKADDrawingsMap];

	for (const map of allMaps) {
		for (const [entityName, entityData] of map.entries()) {
			// ? ADD: Check if entity is visible using existing visibility function
			if (!isEntityVisible(entityName)) {
				console.log("Skipping hidden entity for DXF export:", entityName);
				continue;
			}

			const type = entityData.entityType.trim();
			const data = entityData.data;

			data.forEach((item, index) => {
				// ? ADD: Check individual element visibility
				if (item.visible === false) {
					return; // Skip hidden elements
				}

				//get the first color of the first point in the item
				let color = 1;
				color = typeof item.color === "string" ? getColorInteger(item.color) : 1; // default to red if no color is provided
				if (type === "point") {
					dxf += "0\nPOINT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "line") {
					if (index === 0 && data.length > 1) {
						// ? ADD: Filter visible points for polyline (open)
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n0\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "poly") {
					if (index === 0 && data.length > 1) {
						// ? ADD: Filter visible points for polyline
						const visiblePoints = data.filter((pt) => pt.visible !== false);
						if (visiblePoints.length > 1) {
							dxf += "0\nPOLYLINE\n8\n" + entityName + "\n66\n1\n70\n1\n";
							dxf += "62\n" + color + "\n";
							visiblePoints.forEach((pt) => {
								dxf += "0\nVERTEX\n8\n" + entityName + "\n";
								dxf += "10\n" + pt.pointXLocation + "\n20\n" + pt.pointYLocation + "\n30\n" + pt.pointZLocation + "\n";
							});
							dxf += "0\nSEQEND\n8\n" + entityName + "\n";
						}
					}
				} else if (type === "circle") {
					dxf += "0\nCIRCLE\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n" + item.radius + "\n";
					dxf += "62\n" + color + "\n";
				} else if (type === "text") {
					dxf += "0\nTEXT\n8\n" + entityName + "\n";
					dxf += "10\n" + item.pointXLocation + "\n20\n" + item.pointYLocation + "\n30\n" + item.pointZLocation + "\n";
					dxf += "40\n0.5\n"; // text height
					dxf += "50\n0.0\n"; // rotation
					dxf += "1\n" + item.text + "\n";
					dxf += "62\n" + color + "\n";
				}
			});
		}
	}

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

/**
 * Exports visible holes as a structured DXF file with proper layer organization
 *
 * Structure:
 * - EntityName_HoleID_Collar: Green collar circle
 * - EntityName_HoleID_Track: Grey hole track line (full length)
 * - EntityName_HoleID_Grade: Orange grade circle
 * - EntityName_HoleID_Toe: Red toe circle
 * - EntityName_HoleID_Text: Grey hole ID text
 */
function exportHolesDXF(visibleBlastHoles) {
	let dxf = "0\nSECTION\n2\nHEADER\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nTABLES\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nBLOCKS\n0\nENDSEC\n";
	dxf += "0\nSECTION\n2\nENTITIES\n";

	visibleBlastHoles.forEach((hole) => {
		const entityName = hole.entityName || "Unknown";
		const holeID = hole.holeID || "Unknown";
		const baseLayerName = entityName + "_" + holeID;

		// Calculate hole geometry
		const startX = hole.startXLocation || 0;
		const startY = hole.startYLocation || 0;
		const startZ = hole.startZLocation || 0;

		// Calculate end point based on hole parameters
		const length = hole.holeLengthCalculated || 0;
		const angle = (hole.holeAngle || 0) * (Math.PI / 180); // Convert to radians
		const bearing = (hole.holeBearing || 0) * (Math.PI / 180); // Convert to radians
		const subdrill = hole.subdrillAmount || 0;

		// Calculate actual hole end (planned end without subdrill)
		const plannedLength = length - subdrill;
		const endX = startX + plannedLength * Math.sin(bearing) * Math.sin(angle);
		const endY = startY + plannedLength * Math.cos(bearing) * Math.sin(angle);
		const endZ = startZ - plannedLength * Math.cos(angle);

		// Calculate toe point (actual end with subdrill)
		const toeX = startX + length * Math.sin(bearing) * Math.sin(angle);
		const toeY = startY + length * Math.cos(bearing) * Math.sin(angle);
		const toeZ = startZ - length * Math.cos(angle);

		// Circle sizes
		const collarRadius = hole.holeDiameter ? hole.holeDiameter / 1000 / 2 : 0.1; // Convert mm to meters or default 0.1m
		const gradeRadius = 0.08; // 8cm radius for grade circle
		const toeRadius = 0.06; // 6cm radius for toe circle

		// 1. COLLAR CIRCLE (Green)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Collar\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n" + collarRadius + "\n";
		dxf += "420\n65280\n"; // Green (0,255,0)

		// 2. HOLE TRACK LINE (Grey - full length from collar to toe)
		dxf += "0\nLINE\n8\n" + baseLayerName + "_Track\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n"; // Start (collar)
		dxf += "11\n" + toeX + "\n21\n" + toeY + "\n31\n" + toeZ + "\n"; // End (toe)
		dxf += "420\n9868950\n"; // Grey (150,150,150)

		// 3. GRADE CIRCLE (Orange - end of planned hole)
		if (plannedLength > 0) {
			dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Grade\n";
			dxf += "10\n" + endX + "\n20\n" + endY + "\n30\n" + endZ + "\n";
			dxf += "40\n" + gradeRadius + "\n";
			dxf += "420\n16753920\n"; // Orange (255,165,0)
		}

		// 4. TOE CIRCLE (Red)
		dxf += "0\nCIRCLE\n8\n" + baseLayerName + "_Toe\n";
		dxf += "10\n" + toeX + "\n20\n" + toeY + "\n30\n" + toeZ + "\n";
		dxf += "40\n" + toeRadius + "\n";
		dxf += "420\n16711680\n"; // Red (255,0,0)

		// 5. HOLE ID TEXT (Grey)
		dxf += "0\nTEXT\n8\n" + baseLayerName + "_Text\n";
		dxf += "10\n" + startX + "\n20\n" + startY + "\n30\n" + startZ + "\n";
		dxf += "40\n0.5\n"; // Text height (0.5m)
		dxf += "50\n0.0\n"; // Text rotation (0?)
		dxf += "1\n" + holeID + "\n";
		dxf += "420\n9868950\n"; // Grey (150,150,150)
	});

	dxf += "0\nENDSEC\n0\nEOF\n";
	return dxf;
}

function convertPointsTo14ColumnCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	// Iterate over the visible allBlastHoles array
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsTo12ColumnCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToAllDataCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	let csv = "";
	const header =
		"entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,holeTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID, burden, spacing, connectorCurve";
	csv += header + "\n";
	const decimalPlaces = 4;

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation.toFixed(decimalPlaces)},${hole.startYLocation.toFixed(decimalPlaces)},${hole.startZLocation},${hole.endXLocation.toFixed(decimalPlaces)},${hole.endYLocation.toFixed(decimalPlaces)},${hole.endZLocation.toFixed(decimalPlaces)},${hole.gradeXLocation.toFixed(decimalPlaces)},${hole.gradeYLocation.toFixed(decimalPlaces)},${hole.gradeZLocation.toFixed(decimalPlaces)},${hole.subdrillAmount.toFixed(
			decimalPlaces
		)},${hole.subdrillLength.toFixed(decimalPlaces)},${hole.benchHeight.toFixed(decimalPlaces)},${hole.holeDiameter.toFixed(decimalPlaces)},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated.toFixed(decimalPlaces)},${hole.holeAngle.toFixed(decimalPlaces)},${hole.holeBearing.toFixed(decimalPlaces)},${hole.holeTime},${hole.measuredLength.toFixed(decimalPlaces)},${hole.measuredLengthTimeStamp},${hole.measuredMass.toFixed(
			decimalPlaces
		)},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}`;
		csv += row + "\n";
	}
	return csv;
}

function convertPointsToActualDataCSV() {
	// ? Filter to only visible holes
	const visibleBlastHoles = allBlastHoles.filter((hole) => blastGroupVisible && hole.visible !== false);

	if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return;

	let csv = "";
	const header = "entityName,entityType,holeID,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp";
	csv += header + "\n";

	for (let i = 0; i < visibleBlastHoles.length; i++) {
		const hole = visibleBlastHoles[i];
		const row = `${hole.entityName},${hole.entityType},${hole.holeID},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp}`;
		csv += row + "\n";
	}
	return csv;
}

//=============================================================
// VERBOSE REMOVAL COMMENT - convertPointsToAQMCSV function extracted
//=============================================================
// Step 1) Function (73 lines, lines 10973-11045) was extracted to src/fileIO/MinestarIO/AQMWriter.js
// Step 2) Reason: Part of FileManager IO System modularization (Phase 2)
// Step 3) Date: 2026-01-03
// Step 4) The function is now exposed via FileManager.write() with format "aqm-csv"
// Step 5) Handles 11 columns: Pattern, Blast, Name, Easting, Northing, Elevation, Angle, Azimuth, Diameter, Material Type, Instruction
// Step 6) Dynamic column ordering via columnOrderArray parameter
// Step 7) Special azimuth calculation: (holeBearing - 180) % 360
// Step 8) Backward compatibility maintained via wrapper function below

function convertPointsToAQMCSV(allBlastHoles, fileNameValue, blastName, patternName, materialType, instructionValue, useHoleTypeAsInstruction, writeIgnoreColumn, columnOrderArray) {
	try {
		// Step 1) Filter input allBlastHoles to only visible ones
		var visibleBlastHoles = allBlastHoles.filter(function (hole) {
			return blastGroupVisible && hole.visible !== false;
		});

		if (!visibleBlastHoles || !Array.isArray(visibleBlastHoles) || visibleBlastHoles.length === 0) return "";

		// Step 2) Use FileManager to generate AQM CSV
		var AQMWriter = window.fileManager.writers.get("aqm-csv");
		if (!AQMWriter) {
			throw new Error("AQM CSV writer not found in FileManager. Ensure init.js is loaded.");
		}

		var writer = new AQMWriter();
		var csvContent = writer.generateAQMCSV(visibleBlastHoles, blastName, patternName, materialType, instructionValue, useHoleTypeAsInstruction, writeIgnoreColumn, columnOrderArray);

		// Step 3) Return the CSV content (backward compatible)
		return csvContent;
	} catch (error) {
		console.error("Error during AQM CSV generation:", error);
		throw error;
	}
}

//-----------------------------------------------------------------------------//
// ----------------------// START IREDES EPIROC SECTION //---------------------//
//#region  --------------------------------------------------------------------//

/**
 * Using SweetAlert Library Create a popup that gets input from the user.
 * @param {object[]} allBlastHoles - The allBlastHoles to convert
 * @param {string} filename - The filename to use
 * @param {string} planID - The plan ID to use
 * @param {string} siteID - The site ID to use
 * @param {boolean} holeOptions - Whether the hole options are on
 * @param {boolean} mwd - Whether the mwd is on
 * @param {string} chksumType - The type of checksum to calculate
 * @returns {void}
 */
// ‚úÖ VERBOSE REMOVAL COMMENT - IREDES export functions removed
// Step 1) 10 functions (717 lines, lines 10237-10953) were extracted to src/dialog/popups/generic/ExportDialogs.js
// Step 2) Reason: Part of Phase 2.5 export dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Functions extracted:
//        - saveIREDESPopup() - 358 lines - Main IREDES export dialog
//        - convertPointsToIREDESXML() - 190 lines - XML generation
//        - crc32() - 34 lines - CRC32 checksum calculation
//        - validateIREDESXML() - 46 lines - XML validation
//        - testIREDESChecksumDebug() - 46 lines - Checksum debug test
//        - testEpirocCRC() - 16 lines - Epiroc CRC test
//        - decimalChecksum() - 8 lines - Decimal checksum
//        - calculateMD5Checksum() - 5 lines - MD5 hash
//        - calculateSHA1Checksum() - 5 lines - SHA1 hash
//        - calculateSHA256Checksum() - 9 lines - SHA256 hash
// Step 5) All functions are exposed globally via window.functionName in ExportDialogs.js

function calculateTimes(allBlastHoles) {
	if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) return;

	//console.log("Calculating times...");
	try {
		const surfaces = {};
		holeTimes = {};

		// Build initial structures for surfaces and hole times
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			if (hole.entityName && hole.holeID && !isNaN(hole.timingDelayMilliseconds)) {
				const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
				const combinedFromHoleID = hole.fromHoleID;
				surfaces[combinedFromHoleID + ">=|=<" + combinedHoleID] = {
					time: 0,
					delay: hole.timingDelayMilliseconds,
				};

				holeTimes[combinedHoleID] = null;
			} else {
				console.log("Invalid hole data:", hole);
			}
		}

		// Calculate times for each surface
		for (let i = 0; i < allBlastHoles.length; i++) {
			const hole = allBlastHoles[i];
			const combinedHoleID = `${hole.entityName}:::${hole.holeID}`;
			const combinedFromHoleID = hole.fromHoleID;
			if (combinedFromHoleID === combinedHoleID) {
				if (holeTimes[combinedHoleID] === null || hole.timingDelayMilliseconds < holeTimes[combinedHoleID]) {
					holeTimes[combinedHoleID] = hole.timingDelayMilliseconds;
				}
				updateSurfaceTimes(combinedHoleID, hole.timingDelayMilliseconds, surfaces, holeTimes);
			}
		}

		// Log the final state of surfaces and holeTimes for debugging
		//console.log("Final Surfaces:", surfaces);
		//console.log("Final Hole Times:", holeTimes);

		// Create a result array from the holeTimes object
		const result = [];
		for (const combinedHoleID in holeTimes) {
			result.push([combinedHoleID, holeTimes[combinedHoleID]]);
		}

		// Update allBlastHoles with hole times
		for (const [combinedHoleID, time] of result) {
			const [entityName, holeID] = combinedHoleID.split(":::");
			const holeIndex = allBlastHoles.findIndex((h) => h.entityName === entityName && h.holeID === holeID);
			if (holeIndex !== -1) {
				allBlastHoles[holeIndex].holeTime = time;
			}
		}

		return result;
	} catch (err) {
		console.log("Error in calculateTimes:", err);
	}
}

function updateSurfaceTimes(combinedHoleID, time, surfaces, holeTimes, visited = new Set()) {
	visited.add(combinedHoleID);
	for (const id in surfaces) {
		const [fromHoleID, toHoleID] = id.split(">=|=<");
		if (fromHoleID === combinedHoleID) {
			const surface = surfaces[id];
			const delay = surface.delay;
			if (!isNaN(delay)) {
				const toTime = parseInt(time) + parseInt(delay);
				if (!visited.has(toHoleID) && (toTime < surface.time || surface.time === 0)) {
					surface.time = toTime;
					holeTimes[toHoleID] = toTime;
					updateSurfaceTimes(toHoleID, toTime, surfaces, holeTimes, visited);
				}
			} else {
				console.log("Invalid delay:", delay, "for surface:", id);
			}
		}
	}
	visited.delete(combinedHoleID);
}

// Note: Old delaunayContoursSync function removed - replaced by calculateContoursSync at end of file
// Note: Old interpolate function removed - replaced by interpolateContourPoint at end of file

function simplifyLine(line, epsilon) {
	if (line.length <= 2) return line;

	const firstPoint = line[0];
	const lastPoint = line[line.length - 1];
	const lineDistSq = (lastPoint.x - firstPoint.x) ** 2 + (lastPoint.y - firstPoint.y) ** 2;

	const { maxDist, maxDistPoint } = line.slice(1, -1).reduce(
		(result, point, i) => {
			const distSq = pointToLineDistanceSq(point, firstPoint, lastPoint, lineDistSq);
			if (distSq > result.maxDist) {
				return {
					maxDist: distSq,
					maxDistPoint: {
						index: i + 1,
						point,
					},
				};
			}
			return result;
		},
		{
			maxDist: 0,
			maxDistPoint: {
				index: 0,
				point: null,
			},
		}
	);

	if (Math.sqrt(maxDist) > epsilon) {
		const left = simplifyLine(line.slice(0, maxDistPoint.index + 1), epsilon);
		const right = simplifyLine(line.slice(maxDistPoint.index), epsilon);

		return left.slice(0, left.length - 1).concat(right);
	} else {
		return [firstPoint, lastPoint];
	}
}
// NEW: Pixel distance simplification function
function simplifyByPxDist(points, pxThreshold = 10) {
	if (!points || points.length < 2) return points;

	const pxThresholdSq = pxThreshold * pxThreshold;
	const simplified = [points[0]]; // Always keep first point

	let lastKeptPoint = points[0];
	let [lastKeptX, lastKeptY] = worldToCanvas(lastKeptPoint.pointXLocation, lastKeptPoint.pointYLocation);

	for (let i = 1; i < points.length; i++) {
		const currentPoint = points[i];
		const [currentX, currentY] = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);

		const dx = currentX - lastKeptX;
		const dy = currentY - lastKeptY;

		// Keep point if distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxThresholdSq || i === points.length - 1) {
			simplified.push(currentPoint);
			lastKeptPoint = currentPoint;
			lastKeptX = currentX;
			lastKeptY = currentY;
		}
	}

	return simplified;
}

// Step 1) 3D simplification using WORLD-SPACE distance based on camera zoom
// This is MUCH faster than screen projections - just simple distance math
// At scale 1:1000, a 0.5m segment is ~0.5px - not visible, so skip it
function simplifyByWorldDist3D(points, minWorldDistMeters) {
	// Step 1a) Early return if not enough points
	if (!points || points.length < 2) return points;

	var minDistSq = minWorldDistMeters * minWorldDistMeters;
	var simplified = [points[0]]; // Always keep first point

	var lastKeptPoint = points[0];
	var lastX = lastKeptPoint.pointXLocation;
	var lastY = lastKeptPoint.pointYLocation;
	var lastZ = lastKeptPoint.pointZLocation || 0;

	// Step 1b) Simple distance-based filtering - no expensive projections!
	for (var i = 1; i < points.length; i++) {
		var currentPoint = points[i];
		var currX = currentPoint.pointXLocation;
		var currY = currentPoint.pointYLocation;
		var currZ = currentPoint.pointZLocation || 0;

		// Step 1c) 3D distance calculation (XYZ)
		var dx = currX - lastX;
		var dy = currY - lastY;
		var dz = currZ - lastZ;
		var distSq = dx * dx + dy * dy + dz * dz;

		// Step 1d) Keep point if distance is significant OR if it's the last point
		if (distSq >= minDistSq || i === points.length - 1) {
			simplified.push(currentPoint);
			lastKeptPoint = currentPoint;
			lastX = currX;
			lastY = currY;
			lastZ = currZ;
		}
	}

	return simplified;
}

// Step 2) Calculate minimum visible world distance based on camera zoom
// Returns the world distance (meters) that would appear as ~1-2 pixels on screen
function getMinVisibleWorldDist() {
	if (!threeRenderer || !threeRenderer.camera) return 0.5; // Default fallback

	var camera = threeRenderer.camera;
	var threeCanvas = document.getElementById("threeCanvas");
	if (!threeCanvas) return 0.5;

	// Step 2a) For orthographic camera, calculate world units per pixel
	// camera.right - camera.left = total world width visible
	// canvas.width = total pixels
	var visibleWorldWidth = camera.right - camera.left;
	var canvasWidth = threeCanvas.width || 1920;

	// Step 2b) World meters per pixel (for 2 pixel threshold)
	var metersPerPixel = visibleWorldWidth / canvasWidth;
	var minVisibleDist = metersPerPixel * 2; // 2 pixel threshold

	// Step 2c) Clamp to reasonable bounds (0.1m to 50m)
	// At very zoomed out view, we don't want to skip more than 50m segments
	// At very zoomed in view, we still want at least 0.1m resolution
	if (minVisibleDist < 0.1) minVisibleDist = 0.1;
	if (minVisibleDist > 50) minVisibleDist = 50;

	return minVisibleDist;
}

// Step 3) Check if entity bounding box is visible and significant on screen
// Returns false if entity should be culled (too small or outside view)
function isEntityVisibleIn3D(points) {
	if (!points || points.length < 2) return false;
	if (!threeRenderer || !threeRenderer.camera) return true; // Draw if can't check

	var camera = threeRenderer.camera;

	// Step 3a) Calculate entity bounding box
	var minX = Infinity, maxX = -Infinity;
	var minY = Infinity, maxY = -Infinity;
	for (var i = 0; i < points.length; i++) {
		var p = points[i];
		if (p.pointXLocation < minX) minX = p.pointXLocation;
		if (p.pointXLocation > maxX) maxX = p.pointXLocation;
		if (p.pointYLocation < minY) minY = p.pointYLocation;
		if (p.pointYLocation > maxY) maxY = p.pointYLocation;
	}

	// Step 3b) Get camera view bounds (in local coordinates)
	var camLeft = camera.left + centroidX;
	var camRight = camera.right + centroidX;
	var camBottom = camera.bottom + centroidY;
	var camTop = camera.top + centroidY;

	// Step 3c) Check if entity is completely outside camera view (frustum culling)
	if (maxX < camLeft || minX > camRight || maxY < camBottom || minY > camTop) {
		return false; // Entity is outside view
	}

	// Step 3d) Check if entity is too small on screen (size culling)
	var entityWidth = maxX - minX;
	var entityHeight = maxY - minY;
	var entitySize = Math.max(entityWidth, entityHeight);

	// Get visible world width to calculate screen size
	var visibleWorldWidth = camera.right - camera.left;
	var threeCanvas = document.getElementById("threeCanvas");
	var canvasWidth = threeCanvas ? threeCanvas.width : 1920;

	// Entity size in pixels
	var entityScreenSize = (entitySize / visibleWorldWidth) * canvasWidth;

	// Step 3e) Skip entities smaller than 5 pixels on screen
	if (entityScreenSize < 5) {
		return false;
	}

	return true;
}

// Step 2) Helper: Project 3D world point to screen coordinates using camera projection
function worldToScreen3D(worldX, worldY, worldZ, camera, canvas) {
	// Step 2a) Convert world coordinates to local Three.js coordinates
	var local = worldToThreeLocal(worldX, worldY);

	// Step 2b) Create 3D vector and project to normalized device coordinates (NDC)
	var vector = new THREE.Vector3(local.x, local.y, worldZ);
	vector.project(camera);

	// Step 2c) Convert NDC (-1 to +1) to screen pixels
	return {
		x: (vector.x * 0.5 + 0.5) * canvas.width,
		y: (-vector.y * 0.5 + 0.5) * canvas.height
	};
}

//NEW: Add this hybrid simplification function that is WAY TOO AGGRESSIVE. - DO NOT USE.
function hybridSimplify(points, currentScale, isPolygon = false) {
	if (!points || points.length < 3) return points;

	const pxDistThresholdSq = 5 * 5; // pixel threshold squared
	const epsilon = 0.05 / currentScale; // RDP simplification tolerance

	// Convert to canvas coordinates for pixel distance calculations
	const canvasPoints = points.map((p) => {
		const [x, y] = worldToCanvas(p.pointXLocation, p.pointYLocation);
		return {
			...p,
			_cx: x,
			_cy: y,
		};
	});

	// Detect closed & small polygon/shape - preserve important small features
	const isClosed = isPolygon && points.length > 2;

	if (isClosed) {
		// Calculate approximate area in world coordinates
		let area = 0;
		for (let i = 0; i < points.length - 1; i++) {
			const p1 = points[i];
			const p2 = points[i + 1];
			area += p1.pointXLocation * p2.pointYLocation - p2.pointXLocation * p1.pointYLocation;
		}
		// If area is very small, preserve the shape without simplification
		if (Math.abs(area / 2) < 5 / currentScale) {
			return points;
		}
	}

	// Step 1: Pixel distance pre-filter - but keep consecutive points
	const pxFiltered = [canvasPoints[0]];
	for (let i = 1; i < canvasPoints.length; i++) {
		const current = canvasPoints[i];
		const previous = pxFiltered[pxFiltered.length - 1];
		const dx = current._cx - previous._cx;
		const dy = current._cy - previous._cy;

		// Keep point if pixel distance is significant OR if it's the last point
		if (dx * dx + dy * dy >= pxDistThresholdSq || i === canvasPoints.length - 1) {
			pxFiltered.push(current);
		}
	}

	// Step 2: Apply RDP only if we have enough points and they're not too simplified already
	if (pxFiltered.length < 3) {
		return points; // Return original if too few points
	}

	// Remove canvas coordinates before RDP
	const worldFiltered = pxFiltered.map((p) => {
		const { _cx, _cy, ...worldPoint } = p;
		return worldPoint;
	});

	const rdpSimplified = simplifyLine(worldFiltered, epsilon);
	return rdpSimplified;
}

function pointToLineDistanceSq(point, lineStart, lineEnd, lineDistSq) {
	const t = ((point.x - lineStart.x) * (lineEnd.x - lineStart.x) + (point.y - lineStart.y) * (lineEnd.y - lineStart.y)) / lineDistSq;

	if (t < 0) {
		return (lineStart.x - point.x) ** 2 + (lineStart.y - point.y) ** 2;
	} else if (t > 1) {
		return (lineEnd.x - point.x) ** 2 + (lineEnd.y - point.y) ** 2;
	} else {
		const projX = lineStart.x + t * (lineEnd.x - lineStart.x);
		const projY = lineStart.y + t * (lineEnd.y - lineStart.y);
		return (point.x - projX) ** 2 + (point.y - projY) ** 2;
	}
}

function getVisibleHolesAndKADDrawings(allBlastHoles, allKADDrawings) {
	try {
		const visibleHoles = allBlastHoles.filter((hole) => hole.visible);

		// Fix KAD drawings filtering - check if entity is visible using isEntityVisible
		const visibleKADDrawings = allKADDrawings.filter((drawing) => {
			// Check if the drawing has a visible property, or use isEntityVisible function
			if (drawing.visible !== undefined) {
				return drawing.visible;
			} else if (drawing.entityName) {
				return isEntityVisible(drawing.entityName);
			}
			// If no visibility info, assume it's visible
			return true;
		});

		console.log("üëÄ getVisibleHolesAndKADDrawings - allBlastHoles:", allBlastHoles.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - allKADDrawings:", allKADDrawings.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - visibleHoles:", visibleHoles.length);
		console.log("üëÄ getVisibleHolesAndKADDrawings - visibleKADDrawings:", visibleKADDrawings.length);

		return {
			visibleHoles,
			visibleKADDrawings,
		};
	} catch (err) {
		console.log("‚ùå Error in getVisibleHolesAndKADDrawings:", err);
		return {
			visibleHoles: [],
			visibleKADDrawings: [],
		};
	}
}

// make a global Earcut
const useEarcut = getEarcut();

// üîç ROBUST: Check how earcut is available
function getEarcut() {
	if (typeof earcut !== "undefined") {
		// Check if it's the direct function or has .default
		return typeof earcut === "function" ? earcut : earcut.default;
	}
	throw new Error("Earcut library not found");
}

// Unified point-in-polygon function that handles all data formats
// FIX FOR THE TRIANGULATION TOOL
function isPointInPolygonObject(x, y, polygon) {
	let inside = false;
	let vertices = [];

	// Handle different polygon formats
	if (Array.isArray(polygon)) {
		// Handle array of points (most common case)
		vertices = polygon.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	} else if (polygon.data) {
		// Handle KAD polygon with data property
		vertices = polygon.data.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	} else if (polygon.points) {
		// Handle polygon with points property
		vertices = polygon.points.map((point) => ({
			x: point.pointXLocation || point.x,
			y: point.pointYLocation || point.y,
		}));
	}

	// Ray casting algorithm
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		const xi = vertices[i].x;
		const yi = vertices[i].y;
		const xj = vertices[j].x;
		const yj = vertices[j].y;

		if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {
			inside = !inside;
		}
	}

	return inside;
}

//===========================
//#region DELAUNAY TRIANGULATION  - SURFACE TOOL - START
//===========================

const triangulateTool = document.getElementById("triangulateTool");

// Tool event listener
triangulateTool.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("triangulateTool");

		isTriangulateToolActive = true;
		triangulateTool.checked = true;

		//handleContourTriangulationAction();
		handleTriangulationAction();

		isTriangulateToolActive = false;
		triangulateTool.checked = false;
	}
});
// Check each entity individually
if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
	allKADDrawingsMap.forEach((entity, entityName) => {
		const isVisible = isEntityVisible(entityName);
		console.log(`üìã Entity "${entityName}": type=${entity.entityType}, points=${entity.data ? entity.data.length : 0}, visible=${isVisible}`);
		if (!isVisible) {
			console.log(`‚ùå Why not visible: drawingsGroupVisible=${drawingsGroupVisible}, entity.visible=${entity.visible}, typeGroupVisible=${getTypeGroupVisible(entity.entityType)}`);
		}
	});
}
function getTypeGroupVisible(entityType) {
	switch (entityType) {
		case "point":
			return pointsGroupVisible;
		case "line":
			return linesGroupVisible;
		case "poly":
			return polygonsGroupVisible;
		case "circle":
			return circlesGroupVisible;
		default:
			return true;
	}
}
function handleTriangulationAction() {
	console.log("üî∫ Delaunay triangulation action triggered");

	// Step 1) Debug visibility flags
	console.log("üîç Debugging triangulation visibility:");
	console.log("üìä allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
	console.log("üåç drawingsGroupVisible:", drawingsGroupVisible);
	console.log("üîò pointsGroupVisible:", pointsGroupVisible);
	console.log("üìè linesGroupVisible:", linesGroupVisible);
	console.log("üî∏ polygonsGroupVisible:", polygonsGroupVisible);
	console.log("üí• blastGroupVisible:", blastGroupVisible);

	// Check for any visible data
	let hasVisibleData = false;
	let visibleEntities = [];

	// Step 2) Check KAD drawings with detailed logging
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("üîç Checking KAD drawings for visibility:");
		allKADDrawingsMap.forEach((entity, key) => {
			// Use the map key instead of entity.entityName since some entityNames are corrupted
			const isVisible = isEntityVisible(key);
			console.log("  - Key: '" + key + "', entityName: '" + entity.entityName + "' (" + entity.entityType + "): " + (isVisible ? "? Visible" : "? Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(key);
			}
		});
	}

	// Step 3) Check blast holes with detailed logging
	if (!hasVisibleData && allBlastHoles && allBlastHoles.length > 0) {
		console.log("üîç Checking blast holes for visibility:");
		allBlastHoles.forEach((hole) => {
			const isVisible = isHoleVisible(hole);
			// Step 1) Fix the logging to use the correct property name
			const holeIdentifier = hole.entityName + ":" + hole.holeID || "Unknown";
			console.log("  - " + holeIdentifier + ": " + (isVisible ? "? Visible" : "? Hidden"));
			if (isVisible) {
				hasVisibleData = true;
				visibleEntities.push(holeIdentifier);
			}
		});
	}

	if (!hasVisibleData) {
		console.log("‚ùå No visible data found for triangulation");
		console.log("üìã Visible entities found:", visibleEntities);
		updateStatusMessage("No visible data found for triangulation");
		return;
	}

	console.log("‚úÖ Found visible data for triangulation:", visibleEntities);
	updateStatusMessage("Ready for triangulation ?");
	showTriangulationPopup();
}

//Take the visible veritces and filter any points the are within a 3D tolerance
// PERFORMANCE FIX 2025-12-28: Optimized from O(n¬≤) to O(n) using spatial hashing
// The original O(n¬≤) algorithm was impossibly slow for 310k+ points
// Now async with progress updates for large datasets
async function getUniqueElementVerticesAsync(xyzVertices, tolerance = 0.001, progressCallback = null) {
	// Step 1) Use spatial hash map for O(n) performance
	// Grid cell size slightly larger than tolerance to catch neighbors
	var cellSize = tolerance * 2;
	var spatialHash = new Map();
	var uniqueVertices = [];
	var totalVertices = xyzVertices.length;
	var lastProgressUpdate = Date.now();
	var BATCH_SIZE = 10000; // Process in batches to yield to UI

	// Step 2) Helper to get grid cell key
	function getCellKey(x, y) {
		var cellX = Math.floor(x / cellSize);
		var cellY = Math.floor(y / cellSize);
		return cellX + "," + cellY;
	}

	// Step 3) Helper to check if vertex is duplicate in neighboring cells
	function isDuplicateInNeighbors(vertex) {
		var cellX = Math.floor(vertex.x / cellSize);
		var cellY = Math.floor(vertex.y / cellSize);

		// Check 3x3 neighborhood of cells
		for (var dx = -1; dx <= 1; dx++) {
			for (var dy = -1; dy <= 1; dy++) {
				var neighborKey = (cellX + dx) + "," + (cellY + dy);
				var cellVertices = spatialHash.get(neighborKey);
				if (cellVertices) {
					for (var j = 0; j < cellVertices.length; j++) {
						var existing = cellVertices[j];
						var distX = vertex.x - existing.x;
						var distY = vertex.y - existing.y;
						var distSquared = distX * distX + distY * distY;
						if (distSquared <= tolerance * tolerance) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	// Step 4) Process all vertices in batches
	for (var i = 0; i < totalVertices; i++) {
		var vertex = xyzVertices[i];

		// Check if duplicate
		if (!isDuplicateInNeighbors(vertex)) {
			// Add to unique list
			uniqueVertices.push(vertex);

			// Add to spatial hash
			var cellKey = getCellKey(vertex.x, vertex.y);
			if (!spatialHash.has(cellKey)) {
				spatialHash.set(cellKey, []);
			}
			spatialHash.get(cellKey).push(vertex);
		}

		// Step 5) Yield to UI periodically
		if (i > 0 && i % BATCH_SIZE === 0) {
			var now = Date.now();
			if (now - lastProgressUpdate > 50 || progressCallback) { // Update every 50ms or if callback provided
				var progressPercent = Math.floor((i / totalVertices) * 100);
				if (progressCallback) {
					await progressCallback(progressPercent, "Deduplicating: " + i.toLocaleString() + " / " + totalVertices.toLocaleString() + " (" + uniqueVertices.length.toLocaleString() + " unique)");
				}
				lastProgressUpdate = now;
				// Yield to event loop
				await new Promise(function (resolve) { setTimeout(resolve, 0); });
			}
		}
	}

	return uniqueVertices;
}

// Synchronous version for backward compatibility (small datasets)
function getUniqueElementVertices(xyzVertices, tolerance = 0.001) {
	// For small datasets, use synchronous version
	var cellSize = tolerance * 2;
	var spatialHash = new Map();
	var uniqueVertices = [];

	function getCellKey(x, y) {
		var cellX = Math.floor(x / cellSize);
		var cellY = Math.floor(y / cellSize);
		return cellX + "," + cellY;
	}

	function isDuplicateInNeighbors(vertex) {
		var cellX = Math.floor(vertex.x / cellSize);
		var cellY = Math.floor(vertex.y / cellSize);

		for (var dx = -1; dx <= 1; dx++) {
			for (var dy = -1; dy <= 1; dy++) {
				var neighborKey = (cellX + dx) + "," + (cellY + dy);
				var cellVertices = spatialHash.get(neighborKey);
				if (cellVertices) {
					for (var j = 0; j < cellVertices.length; j++) {
						var existing = cellVertices[j];
						var distX = vertex.x - existing.x;
						var distY = vertex.y - existing.y;
						var distSquared = distX * distX + distY * distY;
						if (distSquared <= tolerance * tolerance) {
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	for (var i = 0; i < xyzVertices.length; i++) {
		var vertex = xyzVertices[i];
		if (!isDuplicateInNeighbors(vertex)) {
			uniqueVertices.push(vertex);
			var cellKey = getCellKey(vertex.x, vertex.y);
			if (!spatialHash.has(cellKey)) {
				spatialHash.set(cellKey, []);
			}
			spatialHash.get(cellKey).push(vertex);
		}
	}

	return uniqueVertices;
}

async function createDelaunayTriangulation(params, updateProgress = null) {
	// Add the getX and getY functions at the top of the function
	const getX = (point) => parseFloat(point.x);
	const getY = (point) => parseFloat(point.y);

	// Helper to update progress and yield to event loop
	async function reportProgress(percent, message) {
		if (updateProgress) {
			await updateProgress(percent, message);
		}
		// Always yield to event loop for large operations
		await new Promise(function (resolve) { setTimeout(resolve, 0); });
	}

	try {
		await reportProgress(5, "Collecting visible elements...");

		// Fix the function call by passing the required parameters
		let visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("üîç Debug - visibleElements:", visibleElements);
		console.log("üîç Debug - allKADDrawingsMap size:", allKADDrawingsMap ? allKADDrawingsMap.size : 0);
		console.log("üîç Debug - visibleKADDrawings count:", visibleElements.visibleKADDrawings ? visibleElements.visibleKADDrawings.length : 0);

		// Extract parameters
		const minAngleTolerance = params.minAngle || 0;
		const maxEdgeLength = params.maxEdgeLength || 0;
		const tolerance = params.tolerance || 0.001;

		await reportProgress(10, "Collecting vertices...");

		// Collect all vertices from visible elements
		let elementVertices = [];

		// Add blast hole vertices based on parameters
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			// Step 1) Fix property name mismatch - use visibleHoles instead of visibleBlastHoles
			const visibleHoles = visibleElements.visibleHoles || [];
			visibleHoles.forEach((hole) => {
				if (params.useCollars) {
					// Step 2) Map collar coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0,
					});
				}
				if (params.useGrade && hole.gradeXLocation !== undefined) {
					// Step 3) Map grade coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0,
					});
				}
				if (params.useToe && hole.endXLocation !== undefined) {
					// Step 4) Map toe coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0,
					});
				}
				if (params.useMLength && hole.mLengthXLocation !== undefined) {
					// Step 5) Map measured length coordinates correctly
					elementVertices.push({
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0,
					});
				}
			});
		}

		// Add KAD drawing vertices
		visibleElements.visibleKADDrawings.forEach((entity) => {
			if (entity.data && Array.isArray(entity.data)) {
				entity.data.forEach((point) => {
					elementVertices.push({
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0,
					});
				});
			}
		});

		await reportProgress(15, "Removing duplicate vertices from " + elementVertices.length.toLocaleString() + " points...");

		// Remove duplicate vertices within tolerance
		// Use async version for large datasets to keep UI responsive
		var LARGE_DATASET_THRESHOLD = 10000;
		if (elementVertices.length > LARGE_DATASET_THRESHOLD) {
			// Async version with progress
			elementVertices = await getUniqueElementVerticesAsync(elementVertices, tolerance, async function (percent, message) {
				// Map deduplication progress to 15-30% range
				var mappedPercent = 15 + Math.floor(percent * 0.15);
				await reportProgress(mappedPercent, message);
			});
		} else {
			// Sync version for small datasets
			elementVertices = getUniqueElementVertices(elementVertices, tolerance);
		}

		console.log("üéØ Unique vertices after deduplication:", elementVertices.length);

		if (elementVertices.length < 3) {
			console.warn("? Insufficient vertices for triangulation. Found:", elementVertices.length);
			return {
				resultTriangles: [],
				points: [],
			};
		}

		await reportProgress(30, "Creating triangulation with " + elementVertices.length + " vertices...");
		console.log("‚úÖ Creating triangulation with", elementVertices.length, "vertices");

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(elementVertices, getX, getY);

		await reportProgress(40, "Triangulation complete, processing triangles...");

		// Array to store valid triangles
		const resultTriangles = [];
		const totalTriangles = delaunay.triangles.length / 3;
		var lastProgressUpdate = Date.now();

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1.x - p2.x;
			const dy = p1.y - p2.y;
			return dx * dx + dy * dy;
		}

		// Process each triangle
		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			// Yield to event loop periodically for large datasets (every 100ms or 5000 triangles)
			var triangleIndex = i / 3;
			if (Date.now() - lastProgressUpdate > 100 || triangleIndex % 5000 === 0) {
				var progressPercent = 40 + Math.floor((triangleIndex / totalTriangles) * 25);
				await reportProgress(progressPercent, "Processing triangle " + triangleIndex.toLocaleString() + " of " + totalTriangles.toLocaleString() + "...");
				lastProgressUpdate = Date.now();
			}
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = elementVertices[p1Index];
			const p2 = elementVertices[p2Index];
			const p3 = elementVertices[p3Index];

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared(p1, p2);
			const edge2Squared = distanceSquared(p2, p3);
			const edge3Squared = distanceSquared(p3, p1);

			// Use user-defined max edge length or skip edge culling if 0
			const maxEdgeLengthSquared = maxEdgeLength > 0 ? maxEdgeLength ** 2 : Infinity;

			// Check if all edge lengths are within the limit (or skip if maxEdgeLength is 0)
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles
				if (minAngleTolerance > 0) {
					const edge1 = Math.sqrt(edge1Squared);
					const edge2 = Math.sqrt(edge2Squared);
					const edge3 = Math.sqrt(edge3Squared);

					// Calculate angles using law of cosines
					const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
					const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
					const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

					const minAngle = Math.min(angle1, angle2, angle3);

					// Reject very acute triangles
					if (minAngle < minAngleTolerance) {
						continue; // Skip this triangle
					}
				}

				// ? FIX: Create triangle in the CORRECT format that matches the rest of your system
				// This should match the format used in parseDXFToKAD and other parts
				resultTriangles.push({
					vertices: [
						{
							x: parseFloat(p1.x),
							y: parseFloat(p1.y),
							z: parseFloat(p1.z),
						}, // Vertex objects, not arrays
						{
							x: parseFloat(p2.x),
							y: parseFloat(p2.y),
							z: parseFloat(p2.z),
						},
						{
							x: parseFloat(p3.x),
							y: parseFloat(p3.y),
							z: parseFloat(p3.z),
						},
					],
					minZ: Math.min(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z)),
					maxZ: Math.max(parseFloat(p1.z), parseFloat(p2.z), parseFloat(p3.z)),
				});
			}
		}

		await reportProgress(65, "Generated " + resultTriangles.length.toLocaleString() + " triangles");
		console.log("üéâ Generated", resultTriangles.length, "triangles");

		// ? FIX: Return triangles in the correct format that matches your system
		return {
			resultTriangles: resultTriangles, // Already in correct format
			points: elementVertices, // Return the actual points used for triangulation
		};
	} catch (err) {
		console.error("? Error in createDelaunayTriangulation:", err);
		return {
			resultTriangles: [],
			points: [],
		};
	}
}

// ? FIX: Get the complete polygon data from allKADDrawingsMap
function deleteTrianglesByClippingPolygon(surfaceId, option = "outside") {
	console.log("üî™ Clipping triangles from surface:", surfaceId, "option:", option);

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// ? FIX: Get the complete polygon from allKADDrawingsMap using the entity name
	let selectedPolygon = null;
	if (selectedKADObject && selectedKADObject.entityType === "poly" && selectedKADObject.entityName) {
		selectedPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
		console.log("üîç Found polygon entity:", selectedKADObject.entityName, "with data:", selectedPolygon ? selectedPolygon.data?.length : "none");
	}

	if (!selectedPolygon || !selectedPolygon.data || selectedPolygon.data.length < 3) {
		console.error("? No valid polygon selected for clipping. Selected:", selectedKADObject?.entityName, "Found polygon:", !!selectedPolygon, "Data points:", selectedPolygon?.data?.length);
		return false;
	}

	console.log("üìê Clipping polygon:", selectedPolygon.entityName, "with", selectedPolygon.data.length, "points");

	// Filter triangles based on the option
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		// Calculate triangle centroid
		const centroidX = (parseFloat(triangle.vertices[0].x) + parseFloat(triangle.vertices[1].x) + parseFloat(triangle.vertices[2].x)) / 3;
		const centroidY = (parseFloat(triangle.vertices[0].y) + parseFloat(triangle.vertices[1].y) + parseFloat(triangle.vertices[2].y)) / 3;

		// Use your existing isPointInPolygonObject function with the complete polygon
		const isInside = isPointInPolygonObject(centroidX, centroidY, selectedPolygon);

		// Apply the clipping logic based on option
		if (option === "outside") {
			// Keep triangles inside the polygon (delete those outside)
			return isInside;
		} else if (option === "inside") {
			// Keep triangles outside the polygon (delete those inside)
			return !isInside;
		}

		// Default: keep all triangles
		return true;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("‚úÇÔ∏è Clipping complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.clippedTriangles = deletedCount;
		surface.metadata.clippingOption = option;
		surface.metadata.clippingPolygon = selectedPolygon.entityName;
	}

	return true;
}

// ? NEW: Delete triangles based on edge length criteria
function deleteTrianglesByEdgeLength(surfaceId, minEdgeLength = 0, maxEdgeLength = 0, use3DLength = false) {
	console.log("üìè Filtering triangles by edge length:", surfaceId, "min:", minEdgeLength, "max:", maxEdgeLength, "3D:", use3DLength);

	// Skip filtering if both min and max are 0
	if (minEdgeLength <= 0 && maxEdgeLength <= 0) {
		console.log("‚è≠Ô∏è Skipping edge length filtering (both min and max = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on edge lengths
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DLength) {
			// 3D edge lengths including Z
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only)
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		const edges = [edge1, edge2, edge3];
		const maxEdge = Math.max(...edges);
		const minEdge = Math.min(...edges);

		// Apply filtering criteria
		let keepTriangle = true;

		// Check minimum edge length
		if (minEdgeLength > 0 && minEdge < minEdgeLength) {
			keepTriangle = false;
		}

		// Check maximum edge length
		if (maxEdgeLength > 0 && maxEdge > maxEdgeLength) {
			keepTriangle = false;
		}

		return keepTriangle;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("üìè Edge length filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.edgeFilteredTriangles = deletedCount;
		surface.metadata.minEdgeLength = minEdgeLength;
		surface.metadata.maxEdgeLength = maxEdgeLength;
		surface.metadata.use3DLength = use3DLength;
	}

	return true;
}

// ? UPDATED: Delete triangles with internal angles smaller than minimum (2D or 3D)
function deleteTrianglesByInternalAngle(surfaceId, internalAngleMin = 0, use3DAngle = false) {
	console.log("üìê Filtering triangles by internal angle:", surfaceId, "min angle:", internalAngleMin + "¬∞", "3D:", use3DAngle);

	// Skip filtering if angle is 0
	if (internalAngleMin <= 0) {
		console.log("‚è≠Ô∏è Skipping angle filtering (min angle = 0)");
		return true;
	}

	// Get the surface
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		console.error("? Surface not found:", surfaceId);
		return false;
	}

	// Filter triangles based on internal angles
	const originalTriangleCount = surface.triangles.length;
	const filteredTriangles = surface.triangles.filter((triangle) => {
		const vertices = triangle.vertices;
		const p1 = vertices[0];
		const p2 = vertices[1];
		const p3 = vertices[2];

		// Calculate edge lengths (2D or 3D based on parameter)
		let edge1, edge2, edge3;

		if (use3DAngle) {
			// 3D edge lengths including Z for accurate 3D angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2) + Math.pow(p2.z - p1.z, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2) + Math.pow(p3.z - p2.z, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2) + Math.pow(p1.z - p3.z, 2));
		} else {
			// 2D edge lengths (XY only) for plan view angles
			edge1 = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			edge2 = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			edge3 = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
		}

		// Calculate internal angles using law of cosines
		const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2 * edge2 + edge3 * edge3 - edge1 * edge1) / (2 * edge2 * edge3)))) * (180 / Math.PI);
		const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge3 * edge3 - edge2 * edge2) / (2 * edge1 * edge3)))) * (180 / Math.PI);
		const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge2 * edge2 - edge3 * edge3) / (2 * edge1 * edge2)))) * (180 / Math.PI);

		const minAngle = Math.min(angle1, angle2, angle3);

		// Keep triangles with all angles >= minimum
		return minAngle >= internalAngleMin;
	});

	// Update the surface with filtered triangles
	surface.triangles = filteredTriangles;

	const deletedCount = originalTriangleCount - filteredTriangles.length;
	console.log("üìê Angle filtering complete:", deletedCount, "triangles deleted,", filteredTriangles.length, "triangles remaining");

	// Update the surface metadata
	if (surface.metadata) {
		surface.metadata.triangleCount = filteredTriangles.length;
		surface.metadata.angleFilteredTriangles = deletedCount;
		surface.metadata.minInternalAngle = internalAngleMin;
		surface.metadata.use3DAngle = use3DAngle;
	}

	return true;
}

// ? NEW: Get visible KAD entities filtered by clipping polygon if needed
function getVisibleKADEntitiesForConstraints(useClippingFilter = false) {
	const visibleEntities = [];

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		return visibleEntities;
	}

	// Get clipping polygon if needed
	let clippingPolygon = null;
	if (useClippingFilter && selectedKADObject && selectedKADObject.entityType === "poly") {
		clippingPolygon = allKADDrawingsMap.get(selectedKADObject.entityName);
	}

	allKADDrawingsMap.forEach((entity, entityName) => {
		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		// Check if entity is visible
		if (!isEntityVisible(entityName)) {
			return;
		}

		// Filter by clipping polygon if specified
		if (clippingPolygon && useClippingFilter) {
			if (!entityIntersectsClippingPolygon(entity, clippingPolygon)) {
				return;
			}
		}

		// Add valid constraint entity
		visibleEntities.push({
			...entity,
			entityName: entityName,
			pointList2D: entity.data.map((p) => ({
				x: parseFloat(p.pointXLocation),
				y: parseFloat(p.pointYLocation),
			})),
			pointList3D: entity.data.map((p) => ({
				x: parseFloat(p.pointXLocation),
				y: parseFloat(p.pointYLocation),
				z: parseFloat(p.pointZLocation) || 0,
			})),
			isLineOrPoly: entity.entityType,
		});
	});

	console.log("üìã Found", visibleEntities.length, "visible KAD entities for constraints");
	return visibleEntities;
}

// ? NEW: Check if entity intersects with clipping polygon
function entityIntersectsClippingPolygon(entity, clippingPolygon) {
	if (!entity.data || !clippingPolygon.data) return false;

	// Check if any point of the entity is inside or if any segment intersects the clipping polygon
	for (let i = 0; i < entity.data.length; i++) {
		const point = entity.data[i];
		const x = parseFloat(point.pointXLocation);
		const y = parseFloat(point.pointYLocation);

		// Check if point is inside clipping polygon
		if (isPointInPolygonObject(x, y, clippingPolygon)) {
			return true;
		}

		// Check if segment intersects clipping polygon boundary
		if (i < entity.data.length - 1) {
			const nextPoint = entity.data[i + 1];
			const x2 = parseFloat(nextPoint.pointXLocation);
			const y2 = parseFloat(nextPoint.pointYLocation);

			if (lineIntersectsPolygon(x, y, x2, y2, clippingPolygon)) {
				return true;
			}
		}
	}

	return false;
}

// ? NEW: Check if triangle intersects with KAD entity (line or polygon)
function checkTriangleIntersectsKADEntity(triangle, kadEntity) {
	const vertices = triangle.vertices;

	// For each segment in the KAD entity
	for (let i = 0; i < kadEntity.pointList2D.length - 1; i++) {
		const segStart = kadEntity.pointList2D[i];
		const segEnd = kadEntity.pointList2D[i + 1];

		// Check if KAD segment intersects any triangle edge
		for (let j = 0; j < 3; j++) {
			const triStart = vertices[j];
			const triEnd = vertices[(j + 1) % 3];

			if (lineSegmentsIntersect(segStart.x, segStart.y, segEnd.x, segEnd.y, triStart.x, triStart.y, triEnd.x, triEnd.y)) {
				return true;
			}
		}

		// Check if KAD segment passes through triangle interior
		if (lineIntersectsTriangle(segStart.x, segStart.y, segEnd.x, segEnd.y, vertices)) {
			return true;
		}
	}

	return false;
}

// ? HELPER: Check if two line segments intersect
function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
	if (Math.abs(denom) < 1e-10) return false; // Lines are parallel

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// ? HELPER: Check if line intersects polygon
function lineIntersectsPolygon(x1, y1, x2, y2, polygon) {
	if (!polygon.data) return false;

	for (let i = 0; i < polygon.data.length - 1; i++) {
		const p1 = polygon.data[i];
		const p2 = polygon.data[i + 1];

		if (lineSegmentsIntersect(x1, y1, x2, y2, parseFloat(p1.pointXLocation), parseFloat(p1.pointYLocation), parseFloat(p2.pointXLocation), parseFloat(p2.pointYLocation))) {
			return true;
		}
	}

	return false;
}

// ===================================================================
// =============================================================================
// STEP 1: REPLACE - New Constrained Delaunay Triangulation Function
// =============================================================================

async function createConstrainedDelaunayTriangulation(params, updateProgress = null) {
	console.log("üîó Using FIXED Constrained Delaunay Triangulation (Constrainautor)");

	try {
		// Get visible elements
		const visibleElements = getVisibleHolesAndKADDrawings(allBlastHoles || [], allKADDrawingsMap ? Array.from(allKADDrawingsMap.values()) : []);

		console.log("üìä Found " + (visibleElements.visibleHoles?.length || 0) + " visible holes, " + (visibleElements.visibleKADDrawings?.length || 0) + " visible KAD drawings");

		// Collect data points with source tracking
		let elementVertices = [];
		const kadSourceMap = new Map(); // Track which KAD entities contributed vertices

		// *** FIX 1: Standardized blast hole coordinate access ***
		if (params.useCollars || params.useGrade || params.useToe || params.useMLength) {
			const visibleHoles = visibleElements.visibleHoles || [];
			console.log("üï≥Ô∏è Processing " + visibleHoles.length + " blast holes");

			visibleHoles.forEach((hole, index) => {
				// Collar points (surface)
				if (params.useCollars && hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.startXLocation),
						y: parseFloat(hole.startYLocation),
						z: parseFloat(hole.startZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_collar",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid collar coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Grade points (mid-hole)
				if (params.useGrade && hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.gradeXLocation),
						y: parseFloat(hole.gradeYLocation),
						z: parseFloat(hole.gradeZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_grade",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid grade coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Toe points (bottom)
				if (params.useToe && hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.endXLocation),
						y: parseFloat(hole.endYLocation),
						z: parseFloat(hole.endZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_toe",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid toe coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}

				// Measured length points
				if (params.useMLength && hole.mLengthXLocation !== undefined && hole.mLengthYLocation !== undefined) {
					const coords = {
						x: parseFloat(hole.mLengthXLocation),
						y: parseFloat(hole.mLengthYLocation),
						z: parseFloat(hole.mLengthZLocation) || 0,
						id: "hole_" + (hole.holeID || index) + "_mlength",
						sourceType: "hole",
					};
					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
					} else {
						console.warn("?? Invalid mLength coordinates for hole " + (hole.holeID || index) + ":", coords);
					}
				}
			});
		}

		// *** FIX 2: KAD drawing vertices with constraint source tracking ***
		visibleElements.visibleKADDrawings.forEach((entity, entityIndex) => {
			if (entity.data && Array.isArray(entity.data)) {
				const entityName = entity.entityName || "entity_" + entityIndex;
				console.log('üìê Processing entity "' + entityName + '" (' + entity.entityType + ") with " + entity.data.length + " points");

				const entityVertices = [];

				entity.data.forEach((point, pointIndex) => {
					const coords = {
						x: parseFloat(point.pointXLocation) || parseFloat(point.x),
						y: parseFloat(point.pointYLocation) || parseFloat(point.y),
						z: parseFloat(point.pointZLocation) || parseFloat(point.z) || 0,
						id: "kad_" + entityName + "_" + pointIndex,
						sourceType: "kad",
						sourceEntityName: entityName,
						sourcePointIndex: pointIndex,
						originalPoint: point,
					};

					if (!isNaN(coords.x) && !isNaN(coords.y) && isFinite(coords.x) && isFinite(coords.y)) {
						elementVertices.push(coords);
						entityVertices.push({
							vertex: coords,
							originalIndex: pointIndex,
							originalPoint: point,
						});
					} else {
						console.warn("?? Invalid KAD coordinates for " + entityName + " point " + pointIndex + ":", coords);
					}
				});

				// Store for constraint extraction later
				if (entityVertices.length > 0 && (entity.entityType === "line" || entity.entityType === "poly")) {
					kadSourceMap.set(entityName, {
						entity: entity,
						vertices: entityVertices,
					});
				}
			}
		});

		console.log("üìä Collected " + elementVertices.length + " vertices before deduplication");

		// *** FIX 3: Deduplicate vertices (this changes coordinates) ***
		// PERFORMANCE FIX 2025-12-28: Use async version for large datasets
		const originalVertexCount = elementVertices.length;
		var LARGE_DATASET_THRESHOLD = 10000;
		if (originalVertexCount > LARGE_DATASET_THRESHOLD) {
			if (updateProgress) await updateProgress(15, "Deduplicating " + originalVertexCount.toLocaleString() + " vertices...");
			elementVertices = await getUniqueElementVerticesAsync(elementVertices, params.tolerance || 0.001, async function (percent, message) {
				// Map deduplication progress to 15-25% range
				var mappedPercent = 15 + Math.floor(percent * 0.10);
				if (updateProgress) await updateProgress(mappedPercent, message);
			});
		} else {
			elementVertices = getUniqueElementVertices(elementVertices, params.tolerance || 0.001);
		}

		console.log("üîÑ Deduplication: " + originalVertexCount + " ‚Üí " + elementVertices.length + " vertices");

		if (elementVertices.length < 3) {
			throw new Error(`Insufficient points for triangulation: ${elementVertices.length}`);
		}

		// *** FIX 4: Extract constraints AFTER deduplication using deduplicated vertices ***
		const constraintData = extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, params.tolerance || 0.001);
		const constraintSegments = constraintData.constraints || constraintData; // Handle both old and new format
		const entitiesWithUnmappedSegments = constraintData.entitiesWithUnmappedSegments || new Set();

		console.log("üîó Extracted " + constraintSegments.length + " constraints from deduplicated vertices");
		if (entitiesWithUnmappedSegments.size > 0) {
			console.warn("?? " + entitiesWithUnmappedSegments.size + " entities have unmapped segments: " + Array.from(entitiesWithUnmappedSegments).join(", "));
		}

		// Step 0c) Update progress - starting triangulation
		if (updateProgress) updateProgress(30, "Creating Delaunay triangulation...");

		// Create the constrained triangulation
		const result = await createConstrainautorTriangulation(elementVertices, constraintSegments, {
			tolerance: params.tolerance || 1e-10,
			updateProgress: updateProgress, // Pass progress callback
			entitiesWithUnmappedSegments: entitiesWithUnmappedSegments, // Pass problematic entities info
		});

		if (!result || !result.resultTriangles || result.resultTriangles.length === 0) {
			console.warn("üö® Constrainautor CDT failed, falling back to basic Delaunay");
			return createFallbackTriangulation(elementVertices);
		}

		console.log("‚úÖ CDT Success: " + result.resultTriangles.length + " triangles created with " + (result.stats?.constraints || 0) + " constraints applied");

		return {
			resultTriangles: result.resultTriangles,
			points: result.points,
			constraintCount: constraintSegments.length,
			stats: result.stats,
		};
	} catch (error) {
		console.error("‚ùå CDT Error:", error);
		console.warn("üö® Falling back to basic Delaunay triangulation");

		// Fallback to basic triangulation
		return createDelaunayTriangulation(params);
	}
}

// =============================================================================
// STEP 2: ADD - New constraint extraction from deduplicated vertices
// =============================================================================

function extractConstraintsFromDeduplicatedVertices(elementVertices, kadSourceMap, tolerance) {
	console.log("üîó Extracting constraints from deduplicated vertices...");

	const constraints = [];
	const entitiesWithUnmappedSegments = new Set(); // Track entities with mapping issues

	// *** FIX 5: Create spatial index for efficient vertex lookup ***
	const spatialIndex = createSpatialIndex(elementVertices, tolerance);

	// Extract constraints from each KAD entity
	kadSourceMap.forEach((entityData, entityName) => {
		const entity = entityData.entity;

		// Only process lines and polygons for constraints
		if (entity.entityType !== "line" && entity.entityType !== "poly") {
			return;
		}

		console.log("üîó Processing constraints for " + entity.entityType + ' "' + entityName + '"');

		const entityConstraints = [];
		let unmappedCount = 0;

		// Create segments between consecutive points
		for (let i = 0; i < entity.data.length - 1; i++) {
			const startPoint = entity.data[i];
			const endPoint = entity.data[i + 1];

			const startX = parseFloat(startPoint.pointXLocation) || parseFloat(startPoint.x);
			const startY = parseFloat(startPoint.pointYLocation) || parseFloat(startPoint.y);
			const endX = parseFloat(endPoint.pointXLocation) || parseFloat(endPoint.x);
			const endY = parseFloat(endPoint.pointYLocation) || parseFloat(endPoint.y);

			// Find corresponding deduplicated vertices
			const startIdx = findClosestVertexIndex(spatialIndex, startX, startY, tolerance);
			const endIdx = findClosestVertexIndex(spatialIndex, endX, endY, tolerance);

			if (startIdx !== null && endIdx !== null && startIdx !== endIdx) {
				const constraint = {
					start: elementVertices[startIdx],
					end: elementVertices[endIdx],
					startIndex: startIdx,
					endIndex: endIdx,
					entityName: entityName,
					segmentIndex: i,
				};

				entityConstraints.push(constraint);
				constraints.push(constraint);
			} else {
				unmappedCount++;
				console.warn("üö® Could not map constraint segment " + i + " for entity " + entityName);
				console.warn("  Start: (" + startX.toFixed(3) + ", " + startY.toFixed(3) + ") ? index " + startIdx);
				console.warn("  End: (" + endX.toFixed(3) + ", " + endY.toFixed(3) + ") ? index " + endIdx);
			}
		}

		// Close polygon for poly entities
		if (entity.entityType === "poly" && entity.data.length > 2) {
			const firstPoint = entity.data[0];
			const lastPoint = entity.data[entity.data.length - 1];

			const firstX = parseFloat(firstPoint.pointXLocation) || parseFloat(firstPoint.x);
			const firstY = parseFloat(firstPoint.pointYLocation) || parseFloat(firstPoint.y);
			const lastX = parseFloat(lastPoint.pointXLocation) || parseFloat(lastPoint.x);
			const lastY = parseFloat(lastPoint.pointYLocation) || parseFloat(lastPoint.y);

			// Only add closing segment if points are different
			if (Math.abs(firstX - lastX) > tolerance || Math.abs(firstY - lastY) > tolerance) {
				const firstIdx = findClosestVertexIndex(spatialIndex, firstX, firstY, tolerance);
				const lastIdx = findClosestVertexIndex(spatialIndex, lastX, lastY, tolerance);

				if (firstIdx !== null && lastIdx !== null && firstIdx !== lastIdx) {
					const closingConstraint = {
						start: elementVertices[lastIdx],
						end: elementVertices[firstIdx],
						startIndex: lastIdx,
						endIndex: firstIdx,
						entityName: entityName,
						segmentIndex: "closing",
					};

					entityConstraints.push(closingConstraint);
					constraints.push(closingConstraint);
				}
			}
		}

		// Track entities with unmapped segments (these can cause constraint intersection issues)
		if (unmappedCount > 0) {
			entitiesWithUnmappedSegments.add(entityName);
			console.warn("  üö® Entity " + entityName + " has " + unmappedCount + " unmapped segments - constraints from this entity may cause intersection issues");
		}

		console.log("  ‚úÖ Added " + entityConstraints.length + " constraints for entity " + entityName);
	});

	console.log("‚úÖ Total constraints extracted: " + constraints.length);

	// Return constraints along with tracking info for problematic entities
	return {
		constraints: constraints,
		entitiesWithUnmappedSegments: entitiesWithUnmappedSegments,
	};
}

// =============================================================================
// STEP 3: ADD - Spatial indexing for vertex lookup
// =============================================================================

function createSpatialIndex(vertices, tolerance) {
	console.log("üó∫Ô∏è Creating spatial index for " + vertices.length + " vertices with tolerance " + tolerance);

	const index = new Map();

	vertices.forEach((vertex, vertexIndex) => {
		// Create multiple grid keys around each vertex for tolerance-based lookup
		const baseX = Math.floor(vertex.x / tolerance) * tolerance;
		const baseY = Math.floor(vertex.y / tolerance) * tolerance;

		// Add to multiple grid cells to handle boundary cases
		for (let dx = -1; dx <= 1; dx++) {
			for (let dy = -1; dy <= 1; dy++) {
				const gridX = baseX + dx * tolerance;
				const gridY = baseY + dy * tolerance;
				const key = gridX.toFixed(10) + "_" + gridY.toFixed(10);

				if (!index.has(key)) {
					index.set(key, []);
				}
				index.get(key).push({ vertex, index: vertexIndex });
			}
		}

		// Also add exact coordinate key
		const exactKey = "exact_" + vertex.x.toFixed(10) + "_" + vertex.y.toFixed(10);
		if (!index.has(exactKey)) {
			index.set(exactKey, []);
		}
		index.get(exactKey).push({ vertex, index: vertexIndex });
	});

	console.log("üó∫Ô∏è Spatial index created with " + index.size + " grid cells");
	return index;
}

function findClosestVertexIndex(spatialIndex, targetX, targetY, tolerance) {
	// Try exact match first
	const exactKey = "exact_" + targetX.toFixed(10) + "_" + targetY.toFixed(10);
	const exactCandidates = spatialIndex.get(exactKey) || [];

	if (exactCandidates.length > 0) {
		return exactCandidates[0].index;
	}

	// Try grid-based lookup
	const gridX = Math.floor(targetX / tolerance) * tolerance;
	const gridY = Math.floor(targetY / tolerance) * tolerance;
	const gridKey = gridX.toFixed(10) + "_" + gridY.toFixed(10);
	const gridCandidates = spatialIndex.get(gridKey) || [];

	// Find closest candidate within tolerance
	let bestMatch = null;
	let bestDistance = Infinity;

	for (const candidate of gridCandidates) {
		const dx = candidate.vertex.x - targetX;
		const dy = candidate.vertex.y - targetY;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance && distance < bestDistance) {
			bestMatch = candidate;
			bestDistance = distance;
		}
	}

	return bestMatch ? bestMatch.index : null;
}

// =============================================================================
// STEP 4: REPLACE - Updated Constrainautor implementation
// =============================================================================

function createConstrainautorTriangulation(points, constraintSegments, options = {}) {
	return new Promise((resolve, reject) => {
		try {
			const updateProgress = options.updateProgress || null;
			const entitiesWithUnmappedSegments = options.entitiesWithUnmappedSegments || new Set();

			// Step 1) Check if Constrainautor is available (imported at top of file)
			if (typeof Constrainautor === "undefined") {
				throw new Error("Constrainautor library not loaded");
			}

			// Step 1a) Update progress
			if (updateProgress) updateProgress(35, "Initializing Constrainautor...");

			console.log("üî∫ Starting Constrainautor with " + points.length + " points, " + constraintSegments.length + " constraints");
			if (entitiesWithUnmappedSegments.size > 0) {
				console.warn("?? Will skip constraints from problematic entities in problematic range: " + Array.from(entitiesWithUnmappedSegments).join(", "));
			}

			// Step 2) Create basic Delaunay triangulation first
			const coords = new Float64Array(points.length * 2);
			for (let i = 0; i < points.length; i++) {
				coords[i * 2] = points[i].x;
				coords[i * 2 + 1] = points[i].y;
			}

			const delaunay = new Delaunator(coords);
			console.log("üî∫ Initial Delaunay: " + delaunay.triangles.length / 3 + " triangles");

			if (updateProgress) updateProgress(40, "Delaunay triangulation created");

			// Step 3) Use pre-calculated indices from constraint extraction
			const constraintEdges = [];
			const validConstraints = [];

			constraintSegments.forEach((segment, segmentIndex) => {
				const startIdx = segment.startIndex;
				const endIdx = segment.endIndex;

				// Indices should already be validated during extraction
				if (startIdx !== undefined && endIdx !== undefined && startIdx !== endIdx && startIdx >= 0 && startIdx < points.length && endIdx >= 0 && endIdx < points.length) {
					constraintEdges.push([startIdx, endIdx]);
					validConstraints.push(segment);
				} else {
					console.warn("?? Invalid constraint indices: [" + startIdx + ", " + endIdx + "] for segment " + segmentIndex);
				}
			});

			console.log("üîó Prepared " + constraintEdges.length + " valid constraint edges");

			// Step 3a) Sort constraints to process problematic ones FIRST
			// Constraints from entities with unmapped segments should be processed early
			// when the triangulation is simpler and there are fewer existing constraints
			if (entitiesWithUnmappedSegments.size > 0) {
				console.log("üîÉ Reordering constraints - processing " + entitiesWithUnmappedSegments.size + " problematic entities first");

				// Create arrays for problematic and normal constraints
				const problematicEdges = [];
				const problematicConstraints = [];
				const normalEdges = [];
				const normalConstraints = [];

				// Separate constraints by entity type
				for (let i = 0; i < constraintEdges.length; i++) {
					const constraint = validConstraints[i];
					const edge = constraintEdges[i];

					if (constraint?.entityName && entitiesWithUnmappedSegments.has(constraint.entityName)) {
						problematicEdges.push(edge);
						problematicConstraints.push(constraint);
					} else {
						normalEdges.push(edge);
						normalConstraints.push(constraint);
					}
				}

				// Rebuild arrays with problematic constraints first
				constraintEdges.length = 0;
				validConstraints.length = 0;

				// Add problematic constraints first
				for (let i = 0; i < problematicEdges.length; i++) {
					constraintEdges.push(problematicEdges[i]);
					validConstraints.push(problematicConstraints[i]);
				}

				// Then add normal constraints
				for (let i = 0; i < normalEdges.length; i++) {
					constraintEdges.push(normalEdges[i]);
					validConstraints.push(normalConstraints[i]);
				}

				console.log("   ? Reordered: " + problematicEdges.length + " problematic constraints first, then " + normalEdges.length + " normal constraints");
			}

			// Step 4) Create Constrainautor instance (using imported module)
			const constrainautor = new Constrainautor(delaunay);

			if (updateProgress) updateProgress(45, "Applying constraints...");

			// Step 5) Apply constraints in batches to avoid blocking UI
			let successfulConstraints = 0;
			if (constraintEdges.length > 0) {
				console.log("üîß Applying " + constraintEdges.length + " constraints...");

				// Step 5a) Track successfully constrained edges to avoid duplicates
				// Use normalized edge key (minIdx_maxIdx) to handle both directions
				const constrainedEdges = new Set();
				const constrainedEdgeList = []; // Also keep list for intersection checking
				const getEdgeKey = (startIdx, endIdx) => {
					return Math.min(startIdx, endIdx) + "_" + Math.max(startIdx, endIdx);
				};
				const isEdgeConstrained = (startIdx, endIdx) => {
					return constrainedEdges.has(getEdgeKey(startIdx, endIdx));
				};
				const markEdgeConstrained = (startIdx, endIdx) => {
					constrainedEdges.add(getEdgeKey(startIdx, endIdx));
					constrainedEdgeList.push([startIdx, endIdx]);
				};

				// Step 5a.1) Function to check if two line segments intersect (excluding endpoints)
				const segmentsIntersect = (p1, p2, p3, p4) => {
					// Check if segments [p1-p2] and [p3-p4] intersect
					// Using cross product method
					const d1 = (p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x);
					const d2 = (p4.x - p3.x) * (p2.y - p3.y) - (p4.y - p3.y) * (p2.x - p3.x);
					const d3 = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
					const d4 = (p2.x - p1.x) * (p4.y - p1.y) - (p2.y - p1.y) * (p4.x - p1.x);

					// Check if segments intersect (not including endpoints)
					if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
						return true;
					}
					return false;
				};

				// Step 5a.2) Find all points that lie on the constraint edge (collinear points)
				// Returns array of point indices sorted by position along the edge
				const findPointsOnEdge = (startIdx, endIdx) => {
					const p1 = points[startIdx];
					const p2 = points[endIdx];

					if (!p1 || !p2) return [];

					const dx = p2.x - p1.x;
					const dy = p2.y - p1.y;
					const lengthSq = dx * dx + dy * dy;

					if (lengthSq < 0.00000001) return [];

					const tolerance = 0.01; // Tolerance for point-on-line detection (increased from 0.001 to catch more marginal cases)
					const toleranceSq = tolerance * tolerance;
					const pointsOnEdge = [];

					// Step 1) Calculate bounding box for quick rejection
					const minX = Math.min(p1.x, p2.x) - tolerance;
					const maxX = Math.max(p1.x, p2.x) + tolerance;
					const minY = Math.min(p1.y, p2.y) - tolerance;
					const maxY = Math.max(p1.y, p2.y) + tolerance;

					// Step 2) Check all points to find those on the edge
					for (let i = 0; i < points.length; i++) {
						// Step 3) Skip the endpoints
						if (i === startIdx || i === endIdx) continue;

						const p = points[i];
						if (!p) continue;

						// Step 4) Quick bounding box check
						if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;

						// Step 5) Calculate distance from point to line segment
						const px = p.x - p1.x;
						const py = p.y - p1.y;

						// Step 6) Project point onto line segment
						const t = (px * dx + py * dy) / lengthSq;

						// Step 7) Only consider points between endpoints (not at ends)
						if (t <= 0.001 || t >= 0.999) continue;

						// Step 8) Calculate closest point on segment
						const closestX = p1.x + t * dx;
						const closestY = p1.y + t * dy;

						// Step 9) Distance from point to segment (squared for efficiency)
						const distX = p.x - closestX;
						const distY = p.y - closestY;
						const distSq = distX * distX + distY * distY;

						// Step 10) If point is on the line (within tolerance)
						if (distSq < toleranceSq) {
							pointsOnEdge.push({ index: i, t: t });
						}
					}

					// Step 11) Sort by position along edge (t value)
					pointsOnEdge.sort((a, b) => a.t - b.t);

					// Step 12) Return just the indices
					return pointsOnEdge.map((item) => item.index);
				};

				// Step 5a.2a) Split constraint edge into segments through collinear points
				const splitConstraintThroughPoints = (startIdx, endIdx) => {
					const pointsOnEdge = findPointsOnEdge(startIdx, endIdx);

					if (pointsOnEdge.length === 0) {
						// No points on edge - return original constraint
						return [[startIdx, endIdx]];
					}

					// Step 1) Create segments: start -> point1, point1 -> point2, ..., pointN -> end
					const segments = [];
					let currentStart = startIdx;

					for (const pointIdx of pointsOnEdge) {
						segments.push([currentStart, pointIdx]);
						currentStart = pointIdx;
					}

					// Step 2) Add final segment to end
					segments.push([currentStart, endIdx]);

					return segments;
				};

				// Step 5a.3) Check if a constraint edge would intersect existing constrained edges
				const wouldIntersectConstrainedEdges = (startIdx, endIdx) => {
					const p1 = points[startIdx];
					const p2 = points[endIdx];

					if (!p1 || !p2) return false;

					// Check against all existing constrained edges
					for (const [existingStartIdx, existingEndIdx] of constrainedEdgeList) {
						// Skip if edges share an endpoint (they're allowed to meet at vertices)
						if (startIdx === existingStartIdx || startIdx === existingEndIdx || endIdx === existingStartIdx || endIdx === existingEndIdx) {
							continue;
						}

						const p3 = points[existingStartIdx];
						const p4 = points[existingEndIdx];

						if (!p3 || !p4) continue;

						// Check if segments intersect
						if (segmentsIntersect(p1, p2, p3, p4)) {
							return true;
						}
					}
					return false;
				};

				// Step 5b) Process constraints in batches with yields between batches
				// This prevents blocking the UI while processing multiple constraints per frame
				let currentIndex = 0;
				const startTime = Date.now();
				const MAX_CONSTRAINT_TIME = 30000; // Maximum 30 seconds for constraint application
				let lastProgressIndex = 0;
				let lastProgressTime = Date.now();
				const STUCK_THRESHOLD = 5000; // If no progress for 5 seconds, skip remaining
				const CONSTRAINTS_PER_BATCH = 10; // Process multiple constraints per frame for speed
				const PROGRESS_UPDATE_INTERVAL = 100; // Update progress at most every 100ms
				let lastProgressUpdateTime = Date.now();
				let batchStartIndex = 0; // Track start of current batch

				// Step 5a.1) Process constraints one at a time with yields between each
				const processNextConstraint = () => {
					try {
						// Check if we've exceeded maximum time
						const totalElapsed = Date.now() - startTime;
						if (totalElapsed > MAX_CONSTRAINT_TIME) {
							console.warn("?? Maximum constraint application time (" + MAX_CONSTRAINT_TIME / 1000 + "s) exceeded. Skipping remaining " + (constraintEdges.length - currentIndex) + " constraints.");
							// Force completion with what we have
							currentIndex = constraintEdges.length;
						}

						// Check if we're stuck (no progress for too long)
						if (currentIndex === lastProgressIndex) {
							const stuckTime = Date.now() - lastProgressTime;
							if (stuckTime > STUCK_THRESHOLD) {
								console.warn("?? Detected stuck constraint at index " + currentIndex + ". Skipping remaining " + (constraintEdges.length - currentIndex) + " constraints.");
								// Skip to end
								currentIndex = constraintEdges.length;
							}
						} else {
							// Progress detected - update tracking
							lastProgressIndex = currentIndex;
							lastProgressTime = Date.now();
						}

						if (currentIndex >= constraintEdges.length) {
							// All constraints processed
							const failedConstraints = constraintEdges.length - successfulConstraints;
							console.log("‚úÖ Processed " + constraintEdges.length + " constraints: " + successfulConstraints + " applied, " + failedConstraints + " skipped");

							if (failedConstraints > 0) {
								console.warn("üö® " + failedConstraints + " constraints were skipped due to conflicts or errors");
							}

							if (updateProgress) updateProgress(95, "Finalizing triangulation...");

							// Step 6) Convert result triangles
							const resultTriangles = [];
							const triangles = delaunay.triangles;

							for (let i = 0; i < triangles.length; i += 3) {
								const idx1 = triangles[i];
								const idx2 = triangles[i + 1];
								const idx3 = triangles[i + 2];

								const v1 = points[idx1];
								const v2 = points[idx2];
								const v3 = points[idx3];

								if (v1 && v2 && v3) {
									resultTriangles.push({
										vertices: [v1, v2, v3],
										indices: [idx1, idx2, idx3],
										minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
										maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
									});
								}
							}

							console.log("üéâ Constrainautor complete: " + resultTriangles.length + " triangles");

							if (updateProgress) updateProgress(100, "Complete!");

							resolve({
								resultTriangles,
								points: points,
								stats: {
									algorithm: "constrainautor",
									originalPoints: points.length,
									triangles: resultTriangles.length,
									constraints: successfulConstraints,
									constraintAttempts: constraintEdges.length,
									failedConstraints: failedConstraints,
								},
							});
							return;
						}

						// Process single constraint
						const [startIdx, endIdx] = constraintEdges[currentIndex];
						const constraint = validConstraints[currentIndex];
						const constraintStartTime = Date.now();
						const constraintIndex = currentIndex; // Store for logging

						try {
							// Check time before processing - if we're close to limit, skip this one
							const elapsedBefore = Date.now() - startTime;
							if (elapsedBefore > MAX_CONSTRAINT_TIME - 1000) {
								console.warn("üö® Skipping constraint " + constraintIndex + " - approaching time limit");
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.1) Check if edge is already constrained - skip if so
							if (isEdgeConstrained(startIdx, endIdx)) {
								// Edge already constrained - skip silently (this is expected for duplicate constraints)
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.1a) REMOVED - No longer needed since problematic constraints are processed first
							// Constraints from entities with unmapped segments are now handled early in the process
							// when the triangulation is simpler and there are fewer existing constraints to conflict with

							// Step 5c.2) Pre-validate constraint indices before applying
							if (startIdx < 0 || endIdx < 0 || startIdx >= points.length || endIdx >= points.length || startIdx === endIdx) {
								console.warn("üö® Skipping invalid constraint " + constraintIndex + ": invalid indices [" + startIdx + ", " + endIdx + "]");
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
								if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									batchStartIndex = currentIndex;
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.3) Check if constraint edge length is reasonable (very short edges can cause issues)
							const p1 = points[startIdx];
							const p2 = points[endIdx];
							if (p1 && p2) {
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								const edgeLength = Math.sqrt(dx * dx + dy * dy);

								// Skip extremely short edges (< 0.0001) as they can cause numerical issues
								if (edgeLength < 0.0001) {
									console.warn("üö® Skipping constraint " + constraintIndex + " - edge too short: " + edgeLength.toFixed(6));
									currentIndex++;
									// Continue processing batch
									const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
									if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
										batchStartIndex = currentIndex;
										requestAnimationFrame(processNextConstraint);
									} else {
										processNextConstraint();
									}
									return;
								}
							}

							// Step 5c.3a) Check if constraint edge passes through other points (collinear issue)
							// Instead of skipping, split the constraint into smaller segments through the points
							let pointsOnEdge = findPointsOnEdge(startIdx, endIdx);

							// Step 5c.3a.1) If we're in the problematic range (700-720) and no points found, try with looser tolerance
							if (pointsOnEdge.length === 0 && constraintIndex >= 700 && constraintIndex <= 720) {
								// Re-check with 10x looser tolerance
								const findPointsOnEdgeLoose = (startIdx, endIdx) => {
									const p1 = points[startIdx];
									const p2 = points[endIdx];
									if (!p1 || !p2) return [];

									const dx = p2.x - p1.x;
									const dy = p2.y - p1.y;
									const lengthSq = dx * dx + dy * dy;
									if (lengthSq < 0.00000001) return [];

									const looseTolerance = 0.1; // 100x looser than original
									const looseToleranceSq = looseTolerance * looseTolerance;
									const pointsOnEdge = [];

									const minX = Math.min(p1.x, p2.x) - looseTolerance;
									const maxX = Math.max(p1.x, p2.x) + looseTolerance;
									const minY = Math.min(p1.y, p2.y) - looseTolerance;
									const maxY = Math.max(p1.y, p2.y) + looseTolerance;

									for (let i = 0; i < points.length; i++) {
										if (i === startIdx || i === endIdx) continue;
										const p = points[i];
										if (!p) continue;
										if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;

										const px = p.x - p1.x;
										const py = p.y - p1.y;
										const t = (px * dx + py * dy) / lengthSq;
										if (t <= 0.001 || t >= 0.999) continue;

										const closestX = p1.x + t * dx;
										const closestY = p1.y + t * dy;
										const distSq = (p.x - closestX) ** 2 + (p.y - closestY) ** 2;

										if (distSq < looseToleranceSq) {
											pointsOnEdge.push({ index: i, t: t });
										}
									}

									pointsOnEdge.sort((a, b) => a.t - b.t);
									return pointsOnEdge.map((item) => item.index);
								};

								pointsOnEdge = findPointsOnEdgeLoose(startIdx, endIdx);
								if (pointsOnEdge.length > 0) {
									console.log("üîò Loose tolerance detected " + pointsOnEdge.length + " collinear points for constraint " + constraintIndex);
								}
							}

							if (pointsOnEdge.length > 0) {
								// Step 1) Split constraint into segments through collinear points
								const splitSegments = splitConstraintThroughPoints(startIdx, endIdx);

								console.log("‚úÇÔ∏è Splitting constraint " + constraintIndex + " from entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.log("   Found " + pointsOnEdge.length + " collinear points: " + pointsOnEdge.join(", "));
								console.log("   Creating " + splitSegments.length + " sub-constraints");

								// Step 2) Apply each split segment as a separate constraint
								let splitSuccessCount = 0;
								for (let segIdx = 0; segIdx < splitSegments.length; segIdx++) {
									const [segStartIdx, segEndIdx] = splitSegments[segIdx];

									// Step 3) Skip if segment is already constrained
									if (isEdgeConstrained(segStartIdx, segEndIdx)) {
										continue;
									}

									try {
										// Step 4) Apply the split constraint
										constrainautor.constrainOne(segStartIdx, segEndIdx);
										markEdgeConstrained(segStartIdx, segEndIdx);
										splitSuccessCount++;
									} catch (splitError) {
										const splitErrorMsg = splitError.message || "";
										if (splitErrorMsg.includes("already constrained") || splitErrorMsg.includes("intersects already constrained")) {
											markEdgeConstrained(segStartIdx, segEndIdx);
										} else {
											console.warn("   ?? Failed to apply split segment " + segIdx + ": [" + segStartIdx + ", " + segEndIdx + "] - " + splitErrorMsg);
										}
									}
								}

								// Step 5) Mark original edge as constrained and continue
								markEdgeConstrained(startIdx, endIdx);
								successfulConstraints += splitSuccessCount;
								console.log("   ? Successfully applied " + splitSuccessCount + "/" + splitSegments.length + " split segments");

								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
								if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.3b) Check if this constraint would intersect existing constrained edges
							// This prevents hangs from intersecting constraints (especially from entities with unmapped segments)
							if (wouldIntersectConstrainedEdges(startIdx, endIdx)) {
								console.warn("?? Skipping constraint " + constraintIndex + " from entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: Edge would intersect existing constrained edge - this can cause hangs");
								// Mark as constrained anyway to prevent trying it again
								markEdgeConstrained(startIdx, endIdx);
								currentIndex++;
								// Continue processing batch
								const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
								if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
									requestAnimationFrame(processNextConstraint);
								} else {
									processNextConstraint();
								}
								return;
							}

							// Step 5c.4) Apply constraint - ENHANCED LOGGING for problematic constraints
							if (constraintIndex >= 705 && constraintIndex <= 710) {
								const p1 = points[startIdx];
								const p2 = points[endIdx];
								const dx = p2.x - p1.x;
								const dy = p2.y - p1.y;
								const edgeLength = Math.sqrt(dx * dx + dy * dy);

								console.log("‚ÑπÔ∏è Detailed info for constraint " + constraintIndex + ":");
								console.log("   Entity: " + (constraint?.entityName || "unknown"));
								console.log("   Indices: [" + startIdx + ", " + endIdx + "]");
								console.log("   Coordinates: [" + p1.x.toFixed(3) + ", " + p1.y.toFixed(3) + ", " + (p1.z || 0).toFixed(3) + "] -> [" + p2.x.toFixed(3) + ", " + p2.y.toFixed(3) + ", " + (p2.z || 0).toFixed(3) + "]");
								console.log("   Edge length: " + edgeLength.toFixed(6));
								console.log("   Already constrained edges: " + constrainedEdges.size);

								// Check for nearby points with tighter tolerance
								const tighterPoints = findPointsOnEdge(startIdx, endIdx);
								if (tighterPoints.length > 0) {
									console.log("   üîò Collinear points detected: " + tighterPoints.join(", "));
								}

								// Check for very close points (even tighter tolerance)
								const veryClosePoints = [];
								const lengthSq = dx * dx + dy * dy;

								for (let i = 0; i < points.length; i++) {
									if (i === startIdx || i === endIdx) continue;
									const p = points[i];
									if (!p) continue;

									const px = p.x - p1.x;
									const py = p.y - p1.y;
									const t = (px * dx + py * dy) / lengthSq;

									if (t > 0 && t < 1) {
										const closestX = p1.x + t * dx;
										const closestY = p1.y + t * dy;
										const distSq = (p.x - closestX) ** 2 + (p.y - closestY) ** 2;
										const dist = Math.sqrt(distSq);

										if (dist < 0.01) {
											// Much tighter tolerance
											veryClosePoints.push({ idx: i, dist: dist.toFixed(6), t: t.toFixed(4) });
										}
									}
								}

								if (veryClosePoints.length > 0) {
									console.log("   ?? Very close points (< 0.01):", veryClosePoints);
								}
							}

							constrainautor.constrainOne(startIdx, endIdx);
							const constraintTime = Date.now() - constraintStartTime;

							// Mark edge as constrained after successful application
							markEdgeConstrained(startIdx, endIdx);

							// Check if constraint took too long (>2000ms) - might indicate a problem
							if (constraintTime > 2000) {
								console.warn("?? Constraint " + constraintIndex + " took " + constraintTime + "ms (very slow but completed)");
							}

							successfulConstraints++;
						} catch (constraintError) {
							// Check if error is because edge is already constrained
							const errorMsg = constraintError.message || "";
							if (errorMsg.includes("already constrained") || errorMsg.includes("intersects already constrained")) {
								// Edge is already constrained - mark it and continue silently
								markEdgeConstrained(startIdx, endIdx);
							} else if (errorMsg.includes("intersects point") || errorMsg.includes("Constraining edge intersects point")) {
								// Collinear point issue - this is expected and should be skipped
								console.warn("?? Skipping constraint " + constraintIndex + " for entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: " + constraintError.message + " (collinear point not detected in pre-check)");
								markEdgeConstrained(startIdx, endIdx);
							} else {
								// Other error - log but continue
								console.warn("?? Skipping constraint " + constraintIndex + " for entity " + constraint?.entityName + ": [" + startIdx + ", " + endIdx + "]");
								console.warn("   Reason: " + constraintError.message);
							}
						}

						currentIndex++;

						// Update progress throttled (every 100ms or at end of batch)
						const now = Date.now();
						const shouldUpdateProgress = now - lastProgressUpdateTime >= PROGRESS_UPDATE_INTERVAL || currentIndex >= constraintEdges.length;
						if (updateProgress && shouldUpdateProgress) {
							const constraintProgress = 45 + Math.round((currentIndex / constraintEdges.length) * 45);
							const progressPercent = Math.min(constraintProgress, 90);
							const elapsed = ((now - startTime) / 1000).toFixed(1);
							updateProgress(progressPercent, "Applying constraints: " + Math.round((currentIndex / constraintEdges.length) * 100) + "% (" + currentIndex + "/" + constraintEdges.length + ") - " + elapsed + "s elapsed");
							lastProgressUpdateTime = now;
						}

						// Process multiple constraints per frame, then yield to browser
						// This speeds up processing while still keeping UI responsive
						const constraintsProcessedThisBatch = currentIndex - batchStartIndex;
						if (constraintsProcessedThisBatch >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
							// Yield to browser after processing a batch
							batchStartIndex = currentIndex; // Reset batch counter for next batch
							requestAnimationFrame(processNextConstraint);
						} else {
							// Continue processing more constraints in this frame
							processNextConstraint();
						}
					} catch (batchError) {
						// Catch any errors in constraint processing
						console.error("? Error processing constraint " + currentIndex + ":", batchError);
						currentIndex++; // Skip this constraint and continue
						// Continue processing batch
						const constraintsProcessedThisFrame = currentIndex - lastProgressIndex;
						if (constraintsProcessedThisFrame >= CONSTRAINTS_PER_BATCH || currentIndex >= constraintEdges.length) {
							requestAnimationFrame(processNextConstraint);
						} else {
							processNextConstraint();
						}
					}
				};

				// Step 5e) Start processing constraints one at a time
				processNextConstraint();
			} else {
				// No constraints - just convert triangles
				if (updateProgress) updateProgress(50, "No constraints to apply, finalizing...");

				const resultTriangles = [];
				const triangles = delaunay.triangles;

				for (let i = 0; i < triangles.length; i += 3) {
					const idx1 = triangles[i];
					const idx2 = triangles[i + 1];
					const idx3 = triangles[i + 2];

					const v1 = points[idx1];
					const v2 = points[idx2];
					const v3 = points[idx3];

					if (v1 && v2 && v3) {
						resultTriangles.push({
							vertices: [v1, v2, v3],
							indices: [idx1, idx2, idx3],
							minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
							maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
						});
					}
				}

				if (updateProgress) updateProgress(100, "Complete!");

				resolve({
					resultTriangles,
					points: points,
					stats: {
						algorithm: "constrainautor",
						originalPoints: points.length,
						triangles: resultTriangles.length,
						constraints: 0,
						constraintAttempts: 0,
					},
				});
			}
		} catch (error) {
			console.error("? Constrainautor error:", error);
			reject(error);
		}
	});
}

// =============================================================================
// STEP 5: KEEP - Fallback triangulation function (unchanged)
// =============================================================================

function createFallbackTriangulation(points) {
	if (points.length < 3) {
		return { resultTriangles: [], points: [], stats: {} };
	}

	try {
		const getX = (p) => p.x;
		const getY = (p) => p.y;

		const delaunay = Delaunator.from(points, getX, getY);
		const resultTriangles = [];

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const v1 = points[delaunay.triangles[i]];
			const v2 = points[delaunay.triangles[i + 1]];
			const v3 = points[delaunay.triangles[i + 2]];

			resultTriangles.push({
				vertices: [v1, v2, v3],
				indices: [delaunay.triangles[i], delaunay.triangles[i + 1], delaunay.triangles[i + 2]],
				minZ: Math.min(v1.z || 0, v2.z || 0, v3.z || 0),
				maxZ: Math.max(v1.z || 0, v2.z || 0, v3.z || 0),
			});
		}

		return {
			resultTriangles,
			points,
			stats: {
				algorithm: "delaunator_fallback",
				triangles: resultTriangles.length,
				points: points.length,
			},
		};
	} catch (error) {
		console.error("? Fallback triangulation failed:", error);
		return { resultTriangles: [], points: [], stats: {} };
	}
}

// Helper function to determine blast hole point type from params
function getBlastHolePointType(params) {
	if (params.useCollars) return "collar";
	if (params.useGrade) return "grade";
	if (params.useToe) return "toe";
	if (params.useMLength) return "measuredLength";
	return "collar"; // default
}

//======================================================

// ? VERBOSE REMOVAL COMMENT - showTriangulationPopup() and processTriangulationFormData() removed
// Step 1) These functions (~422 lines total, lines 13292-13713) were extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Functions extracted:
//        - showTriangulationPopup() - 401 lines - Dialog for Delaunay 2.5D triangulation
//        - processTriangulationFormData() - 18 lines - Helper to process triangulation form data
// Step 5) Both functions are exposed globally via window.functionName in KADDialogs.js


//===========================
//#endregion DELAUNAY TRIANGULATION  - SURFACE TOOL - END
//===========================

//===========================
//#region DELAUNAY TRIANGLES START
//===========================
/**
 * Function to generate a Delaunay triangulation from a set of 2D points, and
 * filter out triangles with edges that are longer than a specified maximum edge length.
 * @param {Array} points the set of 2D points to triangulate
 * @param {number} maxEdgeLength the maximum edge length to allow
 * @returns {Array} an array of triangles, where each triangle is an array of 3 points,
 * each point being an array of 3 numbers (x, y, z)
 */
function delaunayTriangles(points, maxEdgeLength) {
	// Only do the expensive calculation if slope or relief triangles are being displayed
	if (!displaySlope.checked && !displayRelief.checked) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}

	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}

	const factor = 1.6;
	const minAngleThreshold = 5;
	if (!points || !Array.isArray(points) || points.length < 3) {
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}
	let resultTriangles = [];
	let reliefTriangles = [];
	try {
		const getX = (point) => parseFloat(point.startXLocation);
		const getY = (point) => parseFloat(point.startYLocation);

		// Helper function to get average distance to N nearest neighbors for a specific point
		function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
			const distances = [];

			for (let i = 0; i < allPoints.length; i++) {
				if (allPoints[i] === targetPoint) continue; // Skip self

				const dx = getX(targetPoint) - getX(allPoints[i]);
				const dy = getY(targetPoint) - getY(allPoints[i]);
				const distance = Math.sqrt(dx * dx + dy * dy);
				distances.push(distance);
			}

			// Sort distances and take the closest N neighbors
			distances.sort((a, b) => a - b);
			const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

			// Return average of nearest neighbors
			return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
		}

		// Cache for local averages to improve performance
		const localAverageCache = new Map();

		function getCachedLocalAverage(point) {
			if (!localAverageCache.has(point)) {
				localAverageCache.set(point, getLocalAverageDistance(point, points, 6));
			}
			return localAverageCache.get(point);
		}

		// Construct the Delaunay triangulation object
		const delaunay = Delaunator.from(points, getX, getY);

		// Helper function to calculate the squared distance between two points
		function distanceSquared(p1, p2) {
			const dx = p1[0] - p2[0];
			const dy = p1[1] - p2[1];
			return dx * dx + dy * dy;
		}

		for (let i = 0; i < delaunay.triangles.length; i += 3) {
			const p1Index = delaunay.triangles[i];
			const p2Index = delaunay.triangles[i + 1];
			const p3Index = delaunay.triangles[i + 2];

			const p1 = points[p1Index];
			const p2 = points[p2Index];
			const p3 = points[p3Index];

			// Get cached local average distances for each vertex of the triangle
			const p1LocalAvg = getCachedLocalAverage(p1);
			const p2LocalAvg = getCachedLocalAverage(p2);
			const p3LocalAvg = getCachedLocalAverage(p3);

			// Use the average of the three vertices' local averages
			const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;

			// Create adaptive max edge length for this specific triangle
			// You can adjust the 1.8 multiplier to be more or less restrictive
			const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

			// Calculate squared edge lengths
			const edge1Squared = distanceSquared([getX(p1), getY(p1)], [getX(p2), getY(p2)]);
			const edge2Squared = distanceSquared([getX(p2), getY(p2)], [getX(p3), getY(p3)]);
			const edge3Squared = distanceSquared([getX(p3), getY(p3)], [getX(p1), getY(p1)]);

			// Use the adaptive max edge length for this triangle
			const maxEdgeLengthSquared = adaptiveMaxEdgeLength ** 2;

			// Check if all edge lengths are within the adaptive limit
			if (edge1Squared <= maxEdgeLengthSquared && edge2Squared <= maxEdgeLengthSquared && edge3Squared <= maxEdgeLengthSquared) {
				// Optional: Add angle check to reject very acute triangles (bridging triangles)
				const edge1 = Math.sqrt(edge1Squared);
				const edge2 = Math.sqrt(edge2Squared);
				const edge3 = Math.sqrt(edge3Squared);

				// Calculate angles using law of cosines
				const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2 * edge3)))) * (180 / Math.PI);
				const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1 * edge3)))) * (180 / Math.PI);
				const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1 * edge2)))) * (180 / Math.PI);

				const minAngle = Math.min(angle1, angle2, angle3);

				// Only accept triangles with reasonable angles (reject very acute triangles)
				// You can adjust the 12 degree minimum angle threshold
				if (minAngle >= minAngleThreshold) {
					// Add the triangle to the result
					resultTriangles.push([
						[getX(p1), getY(p1), p1.startZLocation], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.startZLocation], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.startZLocation], // [x, y, z] of point 3
					]);

					reliefTriangles.push([
						[getX(p1), getY(p1), p1.holeTime], // [x, y, z] of point 1
						[getX(p2), getY(p2), p2.holeTime], // [x, y, z] of point 2
						[getX(p3), getY(p3), p3.holeTime], // [x, y, z] of point 3
					]);
				}
			}
		}

		// // Optional: Log some statistics for debugging
		// console.log("Triangulation completed:");
		// console.log("- Total triangles generated:", resultTriangles.length);
		// console.log("- Cache size:", localAverageCache.size);

		return {
			resultTriangles,
			reliefTriangles,
		};
	} catch (err) {
		console.log("Error in delaunayTriangles:", err);
		return {
			resultTriangles: [],
			reliefTriangles: [],
		};
	}
}

//Delaunay triangulation helper function
function getDelaunayFromPoints(points, useToeLocation) {
	try {
		return d3.Delaunay.from(
			points,
			function (p) {
				return useToeLocation ? parseFloat(p.endXLocation) : parseFloat(p.startXLocation);
			},
			function (p) {
				return useToeLocation ? parseFloat(p.endYLocation) : parseFloat(p.startYLocation);
			}
		);
	} catch (err) {
		console.log("Error in getDelaunayFromPoints:", err);
	}
}

//#endregion DELAUNAY TRIANGLES END

//===========================
//#region VORONOI DIAGRAM START
//===========================

//Voronoi Diagram
function getVoronoiMetrics(allBlastHoles, useToeLocation) {
	try {
		if (!allBlastHoles || allBlastHoles.length === 0) {
			console.warn("No Blast Holes to calculate Voronoi metrics");
			return [];
		}

		const delaunay = getDelaunayFromPoints(allBlastHoles, useToeLocation);

		const margin = 10; // optional
		const xExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endXLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startXLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startXLocation)))];
		const yExtent = useToeLocation ? [Math.min(...allBlastHoles.map((h) => parseFloat(h.endYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.endYLocation)))] : [Math.min(...allBlastHoles.map((h) => parseFloat(h.startYLocation))), Math.max(...allBlastHoles.map((h) => parseFloat(h.startYLocation)))];

		const voronoi = delaunay.voronoi([xExtent[0] - margin, yExtent[0] - margin, xExtent[1] + margin, yExtent[1] + margin]);

		const voronoiResults = [];

		for (let i = 0; i < allBlastHoles.length; i++) {
			const polygon = voronoi.cellPolygon(i);
			if (!polygon) continue;

			// Area using shoelace formula
			let area = 0;
			for (let j = 0; j < polygon.length; j++) {
				const [x1, y1] = polygon[j];
				const [x2, y2] = polygon[(j + 1) % polygon.length];
				area += x1 * y2 - x2 * y1;
			}
			area = Math.abs(area / 2); // in m? if coords are meters

			const h = allBlastHoles[i];
			const length = parseFloat(h.measuredLength || h.benchHeight || 1);
			const measuredLength = parseFloat(h.measuredLength || 0);
			const designedLength = parseFloat(h.holeLengthCalculated || 0);
			const holeFiringTime = parseFloat(h.holeTime || 0);
			const mass = parseFloat(h.measuredMass || 0);
			const volume = area * length;
			const powderFactor = volume > 0 ? mass / volume : null;
			//Add more metrics here

			voronoiResults.push({
				index: i,
				hole: h,
				polygon: polygon,
				area: area,
				length: length,
				measuredLength: measuredLength,
				designedLength: designedLength,
				holeFiringTime: holeFiringTime,
				volume: volume,
				mass: mass,
				powderFactor: powderFactor,
				//add a scaled heelan vibration calculation here
			});
		}

		//console.log("Returning Voronoi Metrics", voronoiResults);
		return voronoiResults;
	} catch (err) {
		console.log("Error in getVoronoiMetrics:", err);
		return [];
	}
}

// All legends now use a cool-to-hot gradient: blue (cool, small) -> cyan -> green -> yellow -> red (hot, large)

function getPFColor(pf, min, max) {
	// Map PF to a visible spectrum (violet -> blue -> green -> yellow -> orange -> red)
	//console.log("Getting PF Color", pf, min, max);
	let ratio;
	let r, g, b;
	if (!isVoronoiLegendFixed) {
		const minPF = min;
		const maxPF = max;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		// Interpolate from violet (148,0,211) -> blue (0,0,255) -> cyan (0,255,255) -> green (0,255,0) -> yellow (255,255,0) -> red (255,0,0)
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	} else {
		// Fixed spectrum: min=0, max=3, 0=violet, 0.2=blue, 0.4=cyan, 0.6=green, 0.8=yellow, 1=red
		const minPF = 0.0;
		const maxPF = 3.0;
		ratio = Math.min(Math.max((pf - minPF) / (maxPF - minPF), 0), 1);
		if (ratio < 0.2) {
			// Violet (148,0,211) to Blue (0,0,255)
			const t = ratio / 0.2;
			r = Math.round(148 * (1 - t));
			g = 0;
			b = Math.round(211 * (1 - t) + 255 * t);
		} else if (ratio < 0.4) {
			// Blue (0,0,255) to Cyan (0,255,255)
			const t = (ratio - 0.2) / 0.2;
			r = 0;
			g = Math.round(255 * t);
			b = 255;
		} else if (ratio < 0.6) {
			// Cyan (0,255,255) to Green (0,255,0)
			const t = (ratio - 0.4) / 0.2;
			r = 0;
			g = 255;
			b = Math.round(255 * (1 - t));
		} else if (ratio < 0.8) {
			// Green (0,255,0) to Yellow (255,255,0)
			const t = (ratio - 0.6) / 0.2;
			r = Math.round(255 * t);
			g = 255;
			b = 0;
		} else {
			// Yellow (255,255,0) to Red (255,0,0)
			const t = (ratio - 0.8) / 0.2;
			r = 255;
			g = Math.round(255 * (1 - t));
			b = 0;
		}
	}

	return `rgb(${r},${g},${b})`;
}

function getAreaColor(area, min, max) {
	// Map area to a cool-to-hot gradient (blue-cyan-green-yellow-red)

	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((area - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getLengthColor(length, min, max) {
	// Map length to a cool-to-hot gradient (blue-cyan-green-yellow-red)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((length - minColor) / (maxColor - minColor), 0), 1);

	let r, g, b;
	if (ratio < 0.25) {
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getHoleFiringTimeColor(holeFiringTime, min, max) {
	// Color scale: lime green (min) to red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((holeFiringTime - minColor) / (maxColor - minColor), 0), 1);

	// Lime green: rgb(0, 150, 0), Red: rgb(200, 0, 0)
	const r = Math.round(50 + (255 - 50) * ratio);
	const g = Math.round(255 - 255 * ratio);
	const b = Math.round(50 - 50 * ratio);

	return `rgb(${r},${g},${b})`;
}

function getMassColor(mass, min, max) {
	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((mass - minColor) / (maxColor - minColor), 0), 1);

	// Interpolate through blue -> cyan -> green -> yellow -> red
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

function getVolumeColor(volume, min, max) {
	const minColor = min;
	const maxColor = max;
	const ratio = Math.min(Math.max((volume - minColor) / (maxColor - minColor), 0), 1);

	// Cool to hot: blue (min) -> cyan -> green -> yellow -> red (max)
	let r, g, b;
	if (ratio < 0.25) {
		// Blue (0,0,255) to Cyan (0,255,255)
		const t = ratio / 0.25;
		r = 0;
		g = Math.round(255 * t);
		b = 255;
	} else if (ratio < 0.5) {
		// Cyan (0,255,255) to Green (0,255,0)
		const t = (ratio - 0.25) / 0.25;
		r = 0;
		g = 255;
		b = Math.round(255 * (1 - t));
	} else if (ratio < 0.75) {
		// Green (0,255,0) to Yellow (255,255,0)
		const t = (ratio - 0.5) / 0.25;
		r = Math.round(255 * t);
		g = 255;
		b = 0;
	} else {
		// Yellow (255,255,0) to Red (255,0,0)
		const t = (ratio - 0.75) / 0.25;
		r = 255;
		g = Math.round(255 * (1 - t));
		b = 0;
	}
	return `rgb(${r},${g},${b})`;
}

//Draw function for Powderfactor
function drawVoronoiMetric(metrics, metricName, getColorForMetric) {
	const ctx = canvas.getContext("2d");

	for (let cell of metrics) {
		// Skip if the cell doesn't have a polygon or the metric is null/undefined
		if (!cell.polygon || cell[metricName] == null) continue;

		const color = getColorForMetric(cell[metricName]);

		ctx.beginPath();
		ctx.moveTo(cell.polygon[0][0], cell.polygon[0][1]);
		for (let j = 1; j < cell.polygon.length; j++) {
			ctx.lineTo(cell.polygon[j][0], cell.polygon[j][1]);
		}
		ctx.closePath();
		ctx.fillStyle = color;
		ctx.fill();
	}
}

//using resultTriangles from delaunayTriangles function create a bounding polygon
function createBlastBoundaryPolygon(triangles) {
	let blastBoundaryPolygon = [];

	if (triangles && triangles.length > 0) {
		// Extract all vertices from triangles
		let vertices = triangles.flat().map((point) => ({
			x: point[0],
			y: point[1],
		}));

		// Compute convex hull
		if (vertices.length > 0) {
			try {
				const hull = d3.polygonHull(vertices.map((v) => [v.x, v.y]));

				if (hull && hull.length > 0) {
					blastBoundaryPolygon = hull.map((point) => ({
						x: point[0],
						y: point[1],
					}));
				}
			} catch (error) {
				console.error("Error computing convex hull:", error);
				// Optionally, fall back to a simpler method or return an empty polygon
				blastBoundaryPolygon = [];
			}
		}
	}

	return blastBoundaryPolygon;
}
//#endregion DELAUNAY TRIANGLES END

//===========================
//#region RADII POLYGONS START
//===========================

/**
 * Generates polygons representing circles around given points, optionally performing a union of these circles.
 *
 * @param {Array<Object>} points - An array of objects, each with `startXLocation`, `startYLocation`, and `startZLocation` properties, representing the center of a circle.
 * @param {number} steps - The number of steps to use when generating the circle polygon. Higher values result in smoother circles.
 * @param {number} radius - The radius of the circles.
 * @param {boolean} union - If true, performs a union of all the circle polygons using the ClipperLib library.
 * @param {boolean} addToMaps - If true, adds the generated polygons to the `allKADDrawingsMap`.
 * @returns {Array<Array<Object>>} An array of polygons. Each polygon is an array of points, where each point is an object with `x`, `y`, and `z` properties.  Returns an empty array if the Clipper union fails.
 */
function getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation) {
	// Step 0) Early return if no points provided
	if (!points || points.length === 0) {
		return [];
	}

	const scale = 100000;
	const rawPolygons = [];

	// Generate circle polygons
	points.forEach((pt) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		const poly = [];
		for (let i = 0; i < steps; i++) {
			const angle = (i / steps) * Math.PI * 2;
			const x = cx + radius * Math.cos(angle);
			const y = cy + radius * Math.sin(angle);
			poly.push({
				x: x,
				y: y,
				z: z,
			});
		}

		rawPolygons.push(poly);
	});

	if (!union) {
		if (addToMaps) {
			// Step 30b) Get active layer for radii polygons
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			rawPolygons.forEach((polygon) => {
				entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					layerId: activeLayerId,
					data: polygon.map((pt) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: "",
						lineWidth: 5,
						color: 1,
						closed: true,
						entityType: "poly",
					})),
				});
				if (activeLayer) activeLayer.entities.add(entityName);
			});
		}
		return rawPolygons; // each point includes x, y, z
	}

	// Convert for ClipperLib union
	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale),
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("Clipper union failed.");
			clipperUnionWarned = true;
		}
		return [];
	}
	// Interpolate Z using nearest original point
	const unionedPolygons = solution.map((path) =>
		path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ,
			};
		})
	);

	if (addToMaps) {
		// Step 30c) Get active layer for unioned radii polygons
		var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
		if (!window.allDrawingLayers.has(activeLayerId)) {
			window.allDrawingLayers.set(activeLayerId, {
				layerId: activeLayerId,
				name: "Default Layer",
				type: "drawing",
				visible: true,
				entities: new Set()
			});
		}
		var activeLayer = window.allDrawingLayers.get(activeLayerId);

		unionedPolygons.forEach((polygon) => {
			entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + Math.random().toString(36).substring(2, 6);
			//add pointID to each point starting from 1 to nth
			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});
			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				layerId: activeLayerId,
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 5,
					color: color || 1,
					closed: true,
					entityType: "poly",
				})),
			});
			if (activeLayer) activeLayer.entities.add(entityName);
		});
	}

	return unionedPolygons; // includes x, y, z
}

/**
 * Enhanced Radii Polygons Generator
 *
 * Creates circular or starburst polygons around blast hole points with advanced features:
 * - Rotation offset for orienting polygons
 * - Starburst effect for creating star-shaped patterns
 * - Union capability for combining overlapping circles
 * - Automatic Z-elevation inheritance from nearest points
 *
 * @param {Array} points - Array of blast hole objects with location properties
 * @param {number} steps - Number of polygon vertices (3-100, higher = smoother circles)
 * @param {number} radius - Base radius in meters for polygon generation
 * @param {boolean} union - Whether to union overlapping polygons using Clipper
 * @param {boolean} addToMaps - Whether to add results to KAD drawings map
 * @param {string} color - Hex color code for polygon display
 * @param {number} lineWidth - Line width for polygon rendering
 * @param {boolean} useToeLocation - Use end/toe location (true) or start/collar (false)
 * @param {number} rotationOffset - Rotation angle in degrees (-360 to +360)
 * @param {number} starburstOffset - Starburst ratio 0-1 (1.0=circle, 0.5=half radius on even points, 0=star)
 *
 * @returns {Array} Array of polygon objects with {x, y, z} coordinates
 *
 * Features:
 * - Rotation: 0? = no rotation, +45? = clockwise, -45? = counter-clockwise
 * - Starburst: Even-numbered vertices get reduced radius, odd vertices keep full radius
 * - Example: 5m radius + 0.5 starburst = odd points at 5m, even points at 2.5m
 * - Union: Combines overlapping circles into single complex polygons
 * - Z-elevation: Automatically finds nearest point elevation for each vertex
 *
 * Entity Naming Convention:
 * - RAD-SRT: Start/collar location polygons
 * - RAD-END: End/toe location polygons
 * - -R45: Rotation offset suffix (e.g., 45 degrees)
 * - -S50: Starburst suffix (e.g., 50% ratio)
 * - -UNION: Indicates unioned polygons
 */

// Enhanced version with rotation and starburst capabilities
// Enhanced version with rotation and starburst capabilities (with 8-step minimum)
function getRadiiPolygonsEnhanced(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation, rotationOffset, starburstOffset) {
	// Step 0) Early return if no points provided
	if (!points || points.length === 0) {
		return [];
	}

	// Step 1: Initialize variables and convert rotation to radians
	const scale = 100000;
	const rawPolygons = [];
	const rotationRadians = (rotationOffset || 0) * (Math.PI / 180); // Convert degrees to radians

	// Step 2: Apply starburst constraint - only allow if steps >= 8
	let effectiveStarburstRatio;
	if (steps >= 8 && starburstOffset !== undefined) {
		effectiveStarburstRatio = starburstOffset;
	} else {
		effectiveStarburstRatio = 1.0; // Force normal circle for < 8 steps
	}

	console.log("üåü Creating enhanced radii polygons:");
	console.log("   Steps: " + steps + " (starburst " + (steps >= 8 ? "enabled" : "disabled") + ")");
	console.log("   Rotation: " + (rotationOffset || 0) + "¬∞ (" + rotationRadians.toFixed(4) + " rad)");
	console.log("   Starburst ratio: " + effectiveStarburstRatio + " (" + effectiveStarburstRatio * 100 + "%)");

	// Step 3: Generate enhanced circle polygons with rotation and starburst
	points.forEach((pt, pointIndex) => {
		const cx = useToeLocation ? pt.endXLocation : pt.startXLocation;
		const cy = useToeLocation ? pt.endYLocation : pt.startYLocation;
		const z = useToeLocation ? pt.endZLocation : pt.startZLocation;

		console.log("   Processing point " + (pointIndex + 1) + " at (" + cx + ", " + cy + ", " + z + ")");

		const poly = [];

		// Step 4: Create polygon points with enhanced features
		for (let i = 0; i < steps; i++) {
			// Step 5: Calculate base angle with rotation offset
			const baseAngle = (i / steps) * Math.PI * 2;
			const angle = baseAngle + rotationRadians;

			// Step 6: Apply starburst effect only if enabled (steps >= 8)
			let currentRadius = radius;
			if (steps >= 8 && i % 2 === 0) {
				// Even-numbered points (0, 2, 4, ...) get starburst reduction
				currentRadius = radius * effectiveStarburstRatio;
			}
			// Odd-numbered points (1, 3, 5, ...) always keep full radius

			// Step 7: Calculate point coordinates
			const x = cx + currentRadius * Math.cos(angle);
			const y = cy + currentRadius * Math.sin(angle);

			poly.push({
				x: x,
				y: y,
				z: z,
			});

			// Debug logging for first few points
			if (pointIndex === 0 && i < 4) {
				console.log("     Point " + i + ": angle=" + ((angle * 180) / Math.PI).toFixed(1) + "¬∞, radius=" + currentRadius.toFixed(2) + "m, coords=(" + x.toFixed(2) + "," + y.toFixed(2) + ")");
			}
		}

		rawPolygons.push(poly);
	});

	// Step 8: Handle non-union case (multiple separate polygons)
	if (!union) {
		if (addToMaps) {
			// Step 30d) Get active layer for enhanced radii polygons
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			rawPolygons.forEach((polygon, index) => {
				// Step 9: Create unique entity name with enhanced indicators
				let entityName = useToeLocation ? "RAD-END" : "RAD-SRT";
				if (rotationOffset !== 0) {
					entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
				}
				if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
					entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
				}
				entityName += "-" + Math.random().toString(36).substring(2, 6);

				// Step 10: Add polygon to KAD drawings map with active layer
				allKADDrawingsMap.set(entityName, {
					entityType: "poly",
					layerId: activeLayerId,
					data: polygon.map((pt, pointIndex) => ({
						entityName: entityName,
						pointXLocation: pt.x,
						pointYLocation: pt.y,
						pointZLocation: pt.z,
						pointID: pointIndex + 1,
						lineWidth: lineWidth || 2,
						color: color || "#00FF00",
						closed: true,
						entityType: "poly",
					})),
				});
				if (activeLayer) activeLayer.entities.add(entityName);

				console.log("‚úÖ Created enhanced polygon: " + entityName + " in layer:", activeLayerId);
			});
		}
		return rawPolygons;
	}

	// Continue with union logic (same as before)...
	console.log("üîó Performing union operation on " + rawPolygons.length + " polygons...");

	const clipperPolys = rawPolygons.map((poly) =>
		poly.map((pt) => ({
			X: Math.round(pt.x * scale),
			Y: Math.round(pt.y * scale),
		}))
	);

	const cpr = new ClipperLib.Clipper();
	cpr.AddPaths(clipperPolys, ClipperLib.PolyType.ptSubject, true);

	const solution = new ClipperLib.Paths();
	const succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

	if (!succeeded || solution.length === 0) {
		if (!clipperUnionWarned) {
			console.warn("?? Clipper union failed for enhanced radii polygons.");
			clipperUnionWarned = true;
		}
		return [];
	}

	console.log("‚úÖ Union successful, created " + solution.length + " combined polygon(s)");

	const unionedPolygons = solution.map((path, pathIndex) => {
		console.log("   Processing union polygon " + (pathIndex + 1) + " with " + path.length + " points");

		return path.map((pt) => {
			const realX = pt.X / scale;
			const realY = pt.Y / scale;

			let nearestZ = 0;
			let minDist = Infinity;

			points.forEach((p) => {
				const dx = useToeLocation ? p.endXLocation - realX : p.startXLocation - realX;
				const dy = useToeLocation ? p.endYLocation - realY : p.startYLocation - realY;
				const dist = dx * dx + dy * dy;
				if (dist < minDist) {
					minDist = dist;
					nearestZ = useToeLocation ? p.endZLocation : p.startZLocation;
				}
			});

			return {
				x: realX,
				y: realY,
				z: nearestZ,
			};
		});
	});

	if (addToMaps) {
		// Step 30e) Get active layer for enhanced unioned radii polygons
		var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
		if (!window.allDrawingLayers.has(activeLayerId)) {
			window.allDrawingLayers.set(activeLayerId, {
				layerId: activeLayerId,
				name: "Default Layer",
				type: "drawing",
				visible: true,
				entities: new Set()
			});
		}
		var activeLayer = window.allDrawingLayers.get(activeLayerId);

		unionedPolygons.forEach((polygon, index) => {
			let entityName = (useToeLocation ? "RAD-END" : "RAD-SRT") + "-UNION";
			if (rotationOffset !== 0) {
				entityName += "-R" + Math.abs(rotationOffset).toFixed(0);
			}
			if (steps >= 8 && effectiveStarburstRatio !== 1.0) {
				entityName += "-S" + Math.round(effectiveStarburstRatio * 100);
			}
			entityName += "-" + Math.random().toString(36).substring(2, 6);

			let pointID = 1;
			polygon.forEach((pt) => {
				pt.pointID = pointID;
				pointID++;
			});

			allKADDrawingsMap.set(entityName, {
				entityType: "poly",
				layerId: activeLayerId,
				data: polygon.map((pt) => ({
					entityName: entityName,
					pointXLocation: pt.x,
					pointYLocation: pt.y,
					pointZLocation: pt.z,
					pointID: pt.pointID,
					lineWidth: lineWidth || 2,
					color: color || "#00FF00",
					closed: true,
					entityType: "poly",
				})),
			});
			if (activeLayer) activeLayer.entities.add(entityName);

			console.log("‚úÖ Created enhanced union polygon: " + entityName + " with " + polygon.length + " points");
		});
	}

	return unionedPolygons;
}

function clipVoronoiCells(voronoiMetrics) {
	// Step 0) Early return if no blast holes or voronoi metrics
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return [];
	}
	if (!voronoiMetrics || voronoiMetrics.length === 0) {
		return [];
	}

	const scale = 100000;
	const allClippedCells = []; // Changed variable name for clarity

	// --- Your existing logic to calculate contractedPolygons ---
	const nearest = getNearestNeighborDistancesByAggregation(allBlastHoles, "mode", useToeLocation);
	const expand = nearest * 1.5;
	const contract = expand * 0.65;
	//----------------------getRadiiPolygons(points, steps, radius, union, addToMaps, color, lineWidth, useToeLocation)
	const unionedPolygons = getRadiiPolygons(allBlastHoles, 36, expand, true, false, "red", 1, useToeLocation);
	//----------------------
	const simplifiedPolygons = unionedPolygons.map((polygon) => simplifyPolygon(polygon, 0.1, true));
	const contractedPolygons = simplifiedPolygons.map((polygon) => offsetPolygonClipper(polygon, -contract));
	// --- End of your existing logic ---

	const clipPathPolygons = contractedPolygons; // These are the actual geometric polygons
	/*
	console.log("nearest:", nearest);
	console.log("expand:", expand);
	console.log("unionedPolygons:", unionedPolygons);
	console.log("simplifiedPolygons:", simplifiedPolygons);
	console.log("contract:", contract);
	console.log("contractedPolygons:", contractedPolygons);
	console.log("clipPathPolygons for iteration:", clipPathPolygons);
	*/

	for (let cell of voronoiMetrics) {
		if (!cell.polygon || cell.polygon.length < 3) continue;

		const subjPath = cell.polygon.map((p) => ({
			X: Math.round((p.x || p[0]) * scale),
			Y: Math.round((p.y || p[1]) * scale),
		}));

		let cellSuccessfullyClippedAndAdded = false;
		// Iterate through each of your boundary polygons
		for (const currentBoundaryPolygon of clipPathPolygons) {
			if (!currentBoundaryPolygon || currentBoundaryPolygon.length < 3) continue;

			// Convert the current boundary polygon to Clipper format
			const clipperSingleClipPath = currentBoundaryPolygon.map((p) => ({
				X: Math.round(p.x * scale),
				Y: Math.round(p.y * scale),
			}));

			const clipper = new ClipperLib.Clipper();
			clipper.AddPath(subjPath, ClipperLib.PolyType.ptSubject, true);
			clipper.AddPath(clipperSingleClipPath, ClipperLib.PolyType.ptClip, true); // Use only ONE clip path here

			const solution = new ClipperLib.Paths();
			const success = clipper.Execute(ClipperLib.ClipType.ctIntersection, solution, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);

			if (success && solution.length > 0 && solution[0].length > 0) {
				// Check solution[0] for valid polygon
				const clippedResultPolygon = solution[0].map((pt) => ({
					x: pt.X / scale,
					y: pt.Y / scale,
				}));

				const area = Math.abs(
					clippedResultPolygon.reduce((acc, curr, i, arr) => {
						const next = arr[(i + 1) % arr.length];
						return acc + curr.x * next.y - next.x * curr.y;
					}, 0) / 2
				);
				const volume = area * cell.length;
				const powderFactor = volume > 0 ? cell.mass / volume : null;

				allClippedCells.push({
					...cell,
					polygon: clippedResultPolygon,
					area,
					volume,
					powderFactor,
				});
				cellSuccessfullyClippedAndAdded = true;
				break; // Important: Cell is clipped by this boundary, no need to check others
			}
		}
		// If cellSuccessfullyClippedAndAdded is false here, the cell was not inside any of the boundaries.
	}
	return allClippedCells;
}

function simplifyPolygon(polygon, tolerance, forceClose) {
	if (!polygon || polygon.length < 3) return polygon;

	const scale = 100000;
	const scaledPath = polygon.map((p) => ({
		X: Math.round((p.x || p[0]) * scale),
		Y: Math.round((p.y || p[1]) * scale),
	}));

	const c = new ClipperLib.Clipper();
	const cleaned = ClipperLib.Clipper.CleanPolygon(scaledPath, tolerance * scale);

	if (!cleaned || cleaned.length < 3) return polygon;

	const simplified = cleaned.map((p) => ({
		x: p.X / scale,
		y: p.Y / scale,
	}));

	if (forceClose && simplified.length > 0) {
		simplified.push({
			...simplified[0],
		});
	}

	return simplified;
}

function offsetPolygonClipper(polygon, offsetMeters) {
	if (!polygon || polygon.length < 3) return [];

	const scale = 100000; // ClipperLib works in integers, scale up for precision

	// Convert to Clipper path format
	const path = polygon.map((p) => ({
		X: Math.round(p.x * scale),
		Y: Math.round(p.y * scale),
	}));

	// Initialize and execute offset
	const co = new ClipperLib.ClipperOffset();
	co.AddPath(path, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

	const offsetPaths = [];
	co.Execute(offsetPaths, offsetMeters * scale);

	// Convert back to float points
	if (offsetPaths.length === 0) return [];
	return offsetPaths[0].map((p) => ({
		x: p.X / scale,
		y: p.Y / scale,
	}));
}

// function to offset a selected KAD object. Uses clipper library to offset.
// All KAD are allowed Points, lines, Poly, circle and text.
// Projection at 0? inherits the existing KAD object elevation
// first select the kad object to offset.
// then click the offsetKADButton.  The button cannot be on it can only be click.  There must be a selection from the selectPointer.
// then show a popup with the amount to offset Positive or Negative. will define the direction.
// the popup will allow for projection up at and angle or down at and angle.
// 0? is horizontal, -ve? is down, +ve? is Up.  The distance is the amount from the orignal line.
// the popup will allow for multiple offset. 1 - 100
// the kad object will be offset by the amount positive expands and negative compresses.
// ================================
// OFFSET KAD FUNCTIONALITY
// ================================

// Update the offset button event listener with full functionality
offsetKADButton.addEventListener("change", function () {
	if (this.checked) {
		// Reset other tools and activate offset mode
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		resetAllSelectedStores();
		resetSwitchesTogglesOptionalDisplay(false);
		setMultipleSelectionModeToFalse();
		resetFloatingToolbarButtons("offsetKADTool");

		isOffsetKAD = true;
		offsetKADButton.checked = true;

		// Check if there's already a selected KAD object
		if (selectedKADObject && (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly")) {
			// Show offset popup immediately for the selected object
			showOffsetKADPopup(selectedKADObject);
		} else {
			// Add click listener for offset operations
			canvas.addEventListener("click", handleOffsetKADClick);
			canvas.addEventListener("touchstart", handleOffsetKADClick);
			updateStatusMessage("Offset Tool Activated\nClick on a KAD object (line/polygon) to offset\nThen configure offset parameters");
		}
	} else {
		isOffsetKAD = false;
		canvas.removeEventListener("click", handleOffsetKADClick);
		canvas.removeEventListener("touchstart", handleOffsetKADClick);
		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Handle clicks when offset tool is active
function handleOffsetKADClick(event) {
	if (!isOffsetKAD) return;

	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;

	if (isNaN(clickX) || isNaN(clickY)) {
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	}

	// Find clicked KAD object
	const clickedKADObject = getClickedKADObject(clickX, clickY);

	if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
		// Show offset configuration popup
		showOffsetKADPopup(clickedKADObject);
	} else {
		updateStatusMessage("Please click on a line or polygon to offset");
		setTimeout(() => updateStatusMessage("Offset Tool Active - Click on a line or polygon"), 2000);
	}
}
// Show the offset configuration popup
//! Useing the FloatingDialog class to show the popup
// ? VERBOSE REMOVAL COMMENT - showOffsetKADPopup() removed
// Step 1) This function (148 lines, lines 14443-14590) was extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Function extracted: showOffsetKADPopup() - Dialog for offsetting KAD entities
// Step 5) Function is exposed globally via window.showOffsetKADPopup in KADDialogs.js

function createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null, keepElevations = true, limitElevation = false, elevationLimit = 0.0) {
	try {
		const originalPoints = originalEntity.data;

		// Fix Issue #2: Handle undefined entityName
		const baseEntityName = originalEntityName || originalEntity.entityName || "unnamed_entity";

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance from the line at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// Horizontal component of the offset (2D plane)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical component calculation
			// For distance priority, the vertical offset is based on the sine of the angle
			// and the ABSOLUTE value of the offset amount (distance is always positive)
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta Calculation:
			// - projectionAngle > 0: Going UP, so ADD to Z
			// - projectionAngle < 0: Going DOWN, so SUBTRACT from Z
			// - projectionAngle = 0: No vertical change
			// Note: We use the signed value of verticalOffset (which includes angle sign)
			zDelta = verticalOffset; // This already has the correct sign from sin(angle)
		} else {
			// Vertical Priority: The offset amount IS the vertical distance
			// The sign of the projection angle determines up/down direction
			// The sign of the offset amount affects horizontal direction:
			//   - Lines: +ve = left (facing forward), -ve = right
			//   - Polygons: +ve = expand outward, -ve = contract inward

			if (projectionAngle > 0) {
				// Positive angle = going UP
				// Z increases by the absolute offset amount
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				// Z decreases by the absolute offset amount
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = pure horizontal, no Z change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset needed to achieve the vertical distance at the angle
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// Horizontal offset maintains direction from offsetAmount sign:
					//   - Lines: +ve = left, -ve = right (when facing forward)
					//   - Polygons: +ve = expand, -ve = contract
					// Magnitude is adjusted based on the projection angle
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount; // Fallback for very small angles
				}
			} else {
				// Pure horizontal offset when angle is 0
				horizontalOffset = offsetAmount;
			}
		}

		// Determine if this is a closed polygon
		const isClosedPolygon = originalEntity.entityType === "poly" || originalPoints[0].closed === true;

		// Note: Polygon offset direction is now handled correctly by the perpendicular vector calculation
		// No negation needed since we fixed the perpendicular direction (dy, -dx) vs old (-dy, dx)

		// Step 1) Create descriptive direction string based on entity type
		const directionDescription = isClosedPolygon
			? (offsetAmount > 0 ? "expand (outward)" : "contract (inward)")
			: (offsetAmount > 0 ? "left (facing forward)" : "right (facing forward)");

		console.log("üîß Offset calculation:");
		console.log("  entityType:", originalEntity.entityType, "| isClosedPolygon:", isClosedPolygon);
		console.log("  offsetAmount:", offsetAmount + "m | direction:", directionDescription);
		console.log("  projectionAngle:", projectionAngle + "¬∞ (0¬∞=horizontal, +ve=up, -ve=down)");
		console.log("  priorityMode:", priorityMode);
		console.log("  horizontalOffset:", horizontalOffset.toFixed(3) + "m");
		console.log("  verticalOffset:", verticalOffset.toFixed(3) + "m");
		console.log("  zDelta:", zDelta.toFixed(3) + "m (" + (zDelta > 0 ? "up" : zDelta < 0 ? "down" : "no change") + ")");
		console.log("  baseEntityName:", baseEntityName);
		console.log("  handleCrossovers:", handleCrossovers);

		if (!handleCrossovers) {
			// Use the simple method without crossover handling
			return createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName);
		}

		// Create offset segments with crossover handling
		const offsetSegments = [];

		// Generate offset segments for each original segment
		// For polygons, include the closing segment from last point to first
		const numSegments = isClosedPolygon ? originalPoints.length : originalPoints.length - 1;
		for (let i = 0; i < numSegments; i++) {
			const p1 = originalPoints[i];
			const p2 = originalPoints[(i + 1) % originalPoints.length]; // Wrap around for closed polygons

			// Calculate segment direction vector
			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length === 0) continue; // Skip zero-length segments

			// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
			// Positive dy and negative dx gives us the left-hand perpendicular (positive = outward)
			let perpX1 = (-dy / length) * horizontalOffset;
			let perpY1 = (dx / length) * horizontalOffset;
			let perpX2 = perpX1;
			let perpY2 = perpY1;

			// Apply elevation limit (project to level) if enabled
			let p1ZDelta = parseFloat(zDelta);
			let p2ZDelta = parseFloat(zDelta);

			if (limitElevation && projectionAngle !== 0) {
				const angleRad = Math.abs(projectionAngle * Math.PI / 180);
				const tanAngle = Math.tan(angleRad);

				// Check p1 (start point) - limit projection to elevation limit
				const p1OrigZ = parseFloat(p1.pointZLocation);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p1OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						const verticalDrop = p1OrigZ - elevationLimit;
						const horizontalDistance = verticalDrop / tanAngle;
						// FIX: Use same perpendicular direction (-dy, dx) as normal offset
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p1OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						const verticalRise = elevationLimit - p1OrigZ;
						const horizontalDistance = verticalRise / tanAngle;
						// FIX: Use same perpendicular direction (-dy, dx) as normal offset
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				}

				// Check p2 (end point) - limit projection to elevation limit
				const p2OrigZ = parseFloat(p2.pointZLocation);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p2OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						const verticalDrop = p2OrigZ - elevationLimit;
						const horizontalDistance = verticalDrop / tanAngle;
						// FIX: Use same perpendicular direction (-dy, dx) as normal offset
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p2OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						const verticalRise = elevationLimit - p2OrigZ;
						const horizontalDistance = verticalRise / tanAngle;
						// FIX: Use same perpendicular direction (-dy, dx) as normal offset
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				}
			}

			// Create offset segment with proper Z calculation
			// IMPORTANT: Ensure all values are numbers, not strings
			const offsetSeg = {
				start: {
					x: p1.pointXLocation + perpX1,
					y: p1.pointYLocation + perpY1,
					z: parseFloat(p1.pointZLocation) + p1ZDelta,
				},
				end: {
					x: p2.pointXLocation + perpX2,
					y: p2.pointYLocation + perpY2,
					z: parseFloat(p2.pointZLocation) + p2ZDelta,
				},
				index: i,
			};

			offsetSegments.push(offsetSeg);
		}

		// Handle single segment lines
		if (originalPoints.length === 2 && offsetSegments.length === 0) {
			const p1 = originalPoints[0];
			const p2 = originalPoints[1];

			const dx = p2.pointXLocation - p1.pointXLocation;
			const dy = p2.pointYLocation - p1.pointYLocation;
			const length = Math.sqrt(dx * dx + dy * dy);

			if (length > 0) {
				//const perpX = (dy / length) * horizontalOffset;
				//const perpY = (-dx / length) * horizontalOffset;
				//
				//offsetSegments.push({
				//	start: {
				//		x: p1.pointXLocation + perpX,
				//		y: p1.pointYLocation + perpY,
				//		z: parseFloat(p1.pointZLocation) + parseFloat(zDelta), // Fix string concatenation
				//	},
				//	end: {
				//		x: p2.pointXLocation + perpX,
				//		y: p2.pointYLocation + perpY,
				//		z: parseFloat(p2.pointZLocation) + parseFloat(zDelta), // Fix string concatenation
				//	},
				//	index: 0,
				//});
				let perpX1 = (dy / length) * horizontalOffset;
				let perpY1 = (-dx / length) * horizontalOffset;
				let perpX2 = perpX1;
				let perpY2 = perpY1;

				// Apply elevation limit (project to level) if enabled
				let p1ZDelta = parseFloat(zDelta);
				let p2ZDelta = parseFloat(zDelta);

				if (limitElevation && projectionAngle !== 0) {
					const angleRad = Math.abs(projectionAngle * Math.PI / 180);
					const tanAngle = Math.tan(angleRad);

					// Check p1 (start point) - limit projection to elevation limit
					const p1OrigZ = parseFloat(p1.pointZLocation);

					if (projectionAngle < 0) {
						// Projecting downward
						if (p1OrigZ > elevationLimit) {
							// Point is above limit - project down to limit
							p1ZDelta = elevationLimit - p1OrigZ;
							const verticalDrop = p1OrigZ - elevationLimit;
							const horizontalDistance = verticalDrop / tanAngle;
							perpX1 = (dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
							perpY1 = (-dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
						} else {
							// Point is at or below limit - no offset
							p1ZDelta = 0;
							perpX1 = 0;
							perpY1 = 0;
						}
					} else if (projectionAngle > 0) {
						// Projecting upward
						if (p1OrigZ < elevationLimit) {
							// Point is below limit - project up to limit
							p1ZDelta = elevationLimit - p1OrigZ;
							const verticalRise = elevationLimit - p1OrigZ;
							const horizontalDistance = verticalRise / tanAngle;
							perpX1 = (dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
							perpY1 = (-dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
						} else {
							// Point is at or above limit - no offset
							p1ZDelta = 0;
							perpX1 = 0;
							perpY1 = 0;
						}
					}

					// Check p2 (end point) - limit projection to elevation limit
					const p2OrigZ = parseFloat(p2.pointZLocation);

					if (projectionAngle < 0) {
						// Projecting downward
						if (p2OrigZ > elevationLimit) {
							// Point is above limit - project down to limit
							p2ZDelta = elevationLimit - p2OrigZ;
							const verticalDrop = p2OrigZ - elevationLimit;
							const horizontalDistance = verticalDrop / tanAngle;
							perpX2 = (dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
							perpY2 = (-dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
						} else {
							// Point is at or below limit - no offset
							p2ZDelta = 0;
							perpX2 = 0;
							perpY2 = 0;
						}
					} else if (projectionAngle > 0) {
						// Projecting upward
						if (p2OrigZ < elevationLimit) {
							// Point is below limit - project up to limit
							p2ZDelta = elevationLimit - p2OrigZ;
							const verticalRise = elevationLimit - p2OrigZ;
							const horizontalDistance = verticalRise / tanAngle;
							perpX2 = (dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
							perpY2 = (-dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
						} else {
							// Point is at or above limit - no offset
							p2ZDelta = 0;
							perpX2 = 0;
							perpY2 = 0;
						}
					}
				}

				offsetSegments.push({
					start: {
						x: p1.pointXLocation + perpX1,
						y: p1.pointYLocation + perpY1,
						z: parseFloat(p1.pointZLocation) + p1ZDelta,
					},
					end: {
						x: p2.pointXLocation + perpX2,
						y: p2.pointYLocation + perpY2,
						z: parseFloat(p2.pointZLocation) + p2ZDelta,
					},
					index: 0,
				});
			}
		}

		// Handle crossovers by finding intersections and trimming/extending segments
		const cleanedSegments = handleCrossovers ? handleSegmentCrossovers(offsetSegments, isClosedPolygon) : offsetSegments;

		// Convert cleaned segments to point array
		const offsetPoints = [];
		cleanedSegments.forEach((seg) => {
			offsetPoints.push(
				{
					pointXLocation: seg.start.x,
					pointYLocation: seg.start.y,
					pointZLocation: seg.start.z,
				},
				{
					pointXLocation: seg.end.x,
					pointYLocation: seg.end.y,
					pointZLocation: seg.end.z,
				}
			);
		});

		if (offsetPoints.length === 0) {
			throw new Error("No valid segments after crossover handling");
		}

		// Create unique name with short ID to avoid overwrites
		const shortId = Math.random().toString(36).substring(2, 6);
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + shortId;

		const newEntityData = offsetPoints.map((pt, index) => ({
			entityName: newEntityName,
			entityType: originalEntity.entityType || "line",
			pointID: index + 1,
			pointXLocation: pt.pointXLocation,
			pointYLocation: pt.pointYLocation,
			pointZLocation: pt.pointZLocation,
			lineWidth: originalPoints[0].lineWidth || 1,
			color: color,
			closed: isClosedPolygon,
			visible: true,
		}));

		// Step 30) Add to active layer (or default if none)
		var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
		if (!window.allDrawingLayers.has(activeLayerId)) {
			window.allDrawingLayers.set(activeLayerId, {
				layerId: activeLayerId,
				name: "Default Layer",
				type: "drawing",
				visible: true,
				entities: new Set()
			});
		}
		var activeLayer = window.allDrawingLayers.get(activeLayerId);

		// Add to the map with active layer assignment
		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: originalEntity.entityType || "line",
			layerId: activeLayerId,
			data: newEntityData,
			visible: true,
		});

		// Add to layer's entities set
		if (activeLayer) {
			activeLayer.entities.add(newEntityName);
		}

		console.log("‚úÖ Created crossover-handled line offset:", newEntityName, "in layer:", activeLayerId);
		return newEntityName;
	} catch (error) {
		console.error("Error in createLineOffsetCustom:", error);
		throw error;
	}
}

// Simple line offset without crossover handling (updated with fixes)
function createSimpleLineOffset(originalEntity, horizontalOffset, zDelta, color, offsetIndex, baseEntityName) {
	const originalPoints = originalEntity.data;
	const offsetPoints = [];

	// Handle single segment and multi-segment lines
	for (let i = 0; i < originalPoints.length - 1; i++) {
		const p1 = originalPoints[i];
		const p2 = originalPoints[i + 1];

		const dx = p2.pointXLocation - p1.pointXLocation;
		const dy = p2.pointYLocation - p1.pointYLocation;
		const length = Math.sqrt(dx * dx + dy * dy);

		if (length === 0) continue;

		// Calculate perpendicular vector (rotated 90 degrees) for horizontal offset
		const perpX = (dy / length) * horizontalOffset;
		const perpY = (-dx / length) * horizontalOffset;

		// Apply the correct Z delta
		// IMPORTANT: Parse float to avoid string concatenation
		const offsetP1 = {
			pointXLocation: p1.pointXLocation + perpX,
			pointYLocation: p1.pointYLocation + perpY,
			pointZLocation: parseFloat(p1.pointZLocation) + parseFloat(zDelta), // Fix concatenation
		};

		const offsetP2 = {
			pointXLocation: p2.pointXLocation + perpX,
			pointYLocation: p2.pointYLocation + perpY,
			pointZLocation: parseFloat(p2.pointZLocation) + parseFloat(zDelta), // Fix concatenation
		};

		offsetPoints.push(offsetP1, offsetP2);
	}

	const timestamp = Date.now();
	const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + timestamp;

	const newEntityData = offsetPoints.map((pt, index) => ({
		entityName: newEntityName,
		entityType: "line",
		pointID: index + 1,
		pointXLocation: pt.pointXLocation,
		pointYLocation: pt.pointYLocation,
		pointZLocation: pt.pointZLocation,
		lineWidth: originalPoints[0].lineWidth || 1,
		color: color,
		closed: false,
		visible: true,
	}));

	// Step 30a) Add to active layer (or default if none)
	var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
	if (!window.allDrawingLayers.has(activeLayerId)) {
		window.allDrawingLayers.set(activeLayerId, {
			layerId: activeLayerId,
			name: "Default Layer",
			type: "drawing",
			visible: true,
			entities: new Set()
		});
	}
	var activeLayer = window.allDrawingLayers.get(activeLayerId);

	allKADDrawingsMap.set(newEntityName, {
		entityName: newEntityName,
		entityType: "line",
		layerId: activeLayerId,
		data: newEntityData,
		visible: true,
	});

	// Add to layer's entities set
	if (activeLayer) {
		activeLayer.entities.add(newEntityName);
	}

	console.log("‚úÖ Created simple line offset:", newEntityName, "in layer:", activeLayerId);
	return newEntityName;
}

// Handle crossovers between offset segments
function handleSegmentCrossovers(segments, isClosedPolygon = false) {
	if (segments.length < 2) return segments;

	const cleanedSegments = [...segments];

	// Find intersections between consecutive segments and extend/trim accordingly
	for (let i = 0; i < cleanedSegments.length - 1; i++) {
		const seg1 = cleanedSegments[i];
		const seg2 = cleanedSegments[i + 1];

		// Find intersection between the two line segments
		const intersection = findLineIntersection(seg1.start.x, seg1.start.y, seg1.end.x, seg1.end.y, seg2.start.x, seg2.start.y, seg2.end.x, seg2.end.y);

		if (intersection) {
			// Extend/trim segments to meet at intersection
			seg1.end.x = intersection.x;
			seg1.end.y = intersection.y;
			seg2.start.x = intersection.x;
			seg2.start.y = intersection.y;
		}
	}

	// For closed polygons, also handle the intersection between last and first segment
	if (isClosedPolygon && cleanedSegments.length > 2) {
		const lastSeg = cleanedSegments[cleanedSegments.length - 1];
		const firstSeg = cleanedSegments[0];

		const intersection = findLineIntersection(lastSeg.start.x, lastSeg.start.y, lastSeg.end.x, lastSeg.end.y, firstSeg.start.x, firstSeg.start.y, firstSeg.end.x, firstSeg.end.y);

		if (intersection) {
			// Extend/trim segments to meet at intersection
			lastSeg.end.x = intersection.x;
			lastSeg.end.y = intersection.y;
			firstSeg.start.x = intersection.x;
			firstSeg.start.y = intersection.y;
		}
	}

	// Remove segments that became too short (less than 0.1m)
	return cleanedSegments.filter((seg) => {
		const length = Math.sqrt(Math.pow(seg.end.x - seg.start.x, 2) + Math.pow(seg.end.y - seg.start.y, 2));
		return length > 0.1;
	});
}

// Find intersection point between two line segments
function findLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

	if (Math.abs(denom) < 1e-10) {
		return null; // Lines are parallel
	}

	const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	// Check if intersection is within reasonable extension range
	if (t >= -0.5 && t <= 1.5 && u >= -0.5 && u <= 1.5) {
		return {
			x: x1 + t * (x2 - x1),
			y: y1 + t * (y2 - y1),
		};
	}

	return null; // No valid intersection
}

// Update the createOffsetEntity function for polygons
function createOffsetEntity(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers = true, priorityMode = "distance", originalEntityName = null, keepElevations = true, limitElevation = false, elevationLimit = 0.0) {
	try {
		const scale = 100000;
		const originalPoints = originalEntity.data;

		if (originalPoints.length < 2) {
			throw new Error("Need at least 2 points for offset");
		}

		/// Fix Issue #2: Handle undefined entityName - use passed name or fallback
		const baseEntityName = originalEntityName || originalEntity.entityName || "undef";

		// For lines AND polygons with projection angle or elevation limiting, use custom offset method
		if (originalEntity.entityType === "line" || (projectionAngle !== 0 || limitElevation)) {
			return createLineOffsetCustom(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers, priorityMode, baseEntityName, keepElevations, limitElevation, elevationLimit);
		}

		// For polygons, use ClipperLib
		const clipperPath = originalPoints.map((pt) => ({
			X: Math.round(pt.pointXLocation * scale),
			Y: Math.round(pt.pointYLocation * scale),
		}));

		const clipperOffset = new ClipperLib.ClipperOffset();
		clipperOffset.AddPath(clipperPath, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

		// Calculate offset components based on priority mode
		let horizontalOffset, verticalOffset, zDelta;

		if (priorityMode === "distance") {
			// Distance Priority: Preserve the actual distance at the projected angle
			const angleRad = (projectionAngle * Math.PI) / 180;

			// For polygons: offsetAmount controls expand(+) / contract(-)
			horizontalOffset = offsetAmount * Math.cos(angleRad);

			// Vertical offset uses sine of angle and absolute offset
			verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);

			// Z Delta: Use the signed verticalOffset (sin includes angle sign)
			zDelta = verticalOffset;
		} else {
			// Vertical Priority: Distance becomes the vertical amount
			if (projectionAngle > 0) {
				// Positive angle = going UP
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				// Negative angle = going DOWN
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				// Zero angle = no vertical change
				zDelta = 0;
				verticalOffset = 0;
			}

			// Calculate horizontal offset for vertical priority
			if (projectionAngle !== 0) {
				const angleRad = (projectionAngle * Math.PI) / 180;
				const tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					// For polygons, maintain expand/contract behavior
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount;
				}
			} else {
				horizontalOffset = offsetAmount;
			}
		}

		const offsetPaths = [];
		clipperOffset.Execute(offsetPaths, horizontalOffset * scale);

		if (offsetPaths.length === 0) {
			throw new Error("Clipper offset returned no results - try a smaller offset amount");
		}

		const offsetPath = offsetPaths[0];
		// Create unique name with short ID to avoid overwrites
		const shortId = Math.random().toString(36).substring(2, 6);
		const newEntityName = baseEntityName + "_offset_" + offsetIndex + "_" + shortId;

		const newEntityData = offsetPath.map((pt, index) => {
			const worldX = pt.X / scale;
			const worldY = pt.Y / scale;

			// Determine elevation based on keepElevations setting
			let worldZ;
			if (keepElevations) {
				// Find closest original point to interpolate/maintain elevation
				let closestPoint = originalPoints[0];
				let minDist = Infinity;
				for (let i = 0; i < originalPoints.length; i++) {
					const dx = worldX - originalPoints[i].pointXLocation;
					const dy = worldY - originalPoints[i].pointYLocation;
					const dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < minDist) {
						minDist = dist;
						closestPoint = originalPoints[i];
					}
				}

				// Calculate target Z with delta
				let targetZ = parseFloat(closestPoint.pointZLocation) + parseFloat(zDelta);

				// Apply elevation limit if enabled
				if (limitElevation && projectionAngle !== 0) {
					if ((projectionAngle > 0 && targetZ > elevationLimit) || (projectionAngle < 0 && targetZ < elevationLimit)) {
						// Cap at elevation limit
						targetZ = elevationLimit;
					}
				}

				worldZ = targetZ;
			} else {
				// Use max elevation (first point's Z as reference)
				let targetZ = parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta);

				// Apply elevation limit if enabled
				if (limitElevation && projectionAngle !== 0) {
					if ((projectionAngle > 0 && targetZ > elevationLimit) || (projectionAngle < 0 && targetZ < elevationLimit)) {
						targetZ = elevationLimit;
					}
				}

				worldZ = targetZ;
			}

			return {
				entityName: newEntityName,
				entityType: originalEntity.entityType,
				pointID: index + 1,
				pointXLocation: worldX,
				pointYLocation: worldY,
				pointZLocation: worldZ,
				lineWidth: originalPoints[0].lineWidth || 1,
				color: color,
				closed: originalEntity.entityType === "poly",
				visible: true,
			};
		});

		allKADDrawingsMap.set(newEntityName, {
			entityName: newEntityName,
			entityType: originalEntity.entityType,
			data: newEntityData,
			visible: true,
		});

		console.log("Created offset entity:", newEntityName, "with", newEntityData.length, "points");
		console.log("  baseEntityName:", baseEntityName); // Debug log
		console.log("  Original Z:", originalPoints[0].pointZLocation);
		console.log("  Z Delta:", zDelta);
		console.log("  New Z:", parseFloat(originalPoints[0].pointZLocation) + parseFloat(zDelta));

		return newEntityName;
	} catch (error) {
		console.error("Error in createOffsetEntity:", error);
		throw error;
	}
}

// Update performKADOffset to pass the priority mode
function performKADOffset(entity, params) {
	try {
		const results = [];

		for (let i = 1; i <= params.numberOfOffsets; i++) {
			const offsetAmount = params.baseAmount * i;

			const offsetEntity = createOffsetEntity(entity, offsetAmount, params.projectionAngle, params.color, i, params.handleCrossovers, params.priorityMode, params.originalEntityName, params.keepElevations, params.limitElevation, params.elevationLimit);

			if (offsetEntity) {
				results.push(offsetEntity);
			}
		}

		if (results.length > 0) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			// Step #) Trigger 3D rebuild to show offset results immediately
			window.threeDataNeedsRebuild = true;
			drawData(allBlastHoles, selectedHole);

			updateStatusMessage("Created " + results.length + " offset(s) successfully");
			setTimeout(() => updateStatusMessage(""), 3000);
		} else {
			updateStatusMessage("Failed to create offsets - check parameters");
		}
	} catch (error) {
		console.error("Error in performKADOffset:", error);
		updateStatusMessage("Error creating offsets: " + error.message);
	}
}

// ================================
// OFFSET PREVIEW FUNCTIONALITY - START
// ================================
// Step #) Calculate offset preview WITHOUT saving to allKADDrawingsMap
// This function mirrors createOffsetEntity but returns data arrays instead of persisting
function calculateOffsetPreview(originalEntity, params) {
	try {
		var previewResults = [];

		for (var i = 1; i <= params.numberOfOffsets; i++) {
			var offsetAmount = params.baseAmount * i;
			var previewEntity = calculateSingleOffsetPreview(
				originalEntity,
				offsetAmount,
				params.projectionAngle,
				params.color,
				i,
				params.handleCrossovers,
				params.priorityMode,
				params.keepElevations,
				params.limitElevation,
				params.elevationLimit
			);

			if (previewEntity && previewEntity.data && previewEntity.data.length > 0) {
				previewResults.push(previewEntity);
			}
		}

		return previewResults;
	} catch (error) {
		console.error("Error in calculateOffsetPreview:", error);
		return [];
	}
}

// Step #) Calculate a single offset preview (mirrors createLineOffsetCustom logic)
// This properly creates offset segments and finds intersections for crossover handling
function calculateSingleOffsetPreview(originalEntity, offsetAmount, projectionAngle, color, offsetIndex, handleCrossovers, priorityMode, keepElevations, limitElevation, elevationLimit) {
	try {
		var originalPoints = originalEntity.data;
		if (!originalPoints || originalPoints.length < 2) {
			return null;
		}

		// Step 1) Calculate offset components based on priority mode
		var horizontalOffset, zDelta;

		if (priorityMode === "distance") {
			var angleRad = (projectionAngle * Math.PI) / 180;
			horizontalOffset = offsetAmount * Math.cos(angleRad);
			var verticalOffset = Math.abs(offsetAmount) * Math.sin(angleRad);
			zDelta = verticalOffset;
		} else {
			// Vertical Priority
			var verticalOffset = 0;
			if (projectionAngle > 0) {
				zDelta = Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else if (projectionAngle < 0) {
				zDelta = -Math.abs(offsetAmount);
				verticalOffset = Math.abs(offsetAmount);
			} else {
				zDelta = 0;
			}

			if (projectionAngle !== 0) {
				var angleRad = (projectionAngle * Math.PI) / 180;
				var tanAngle = Math.tan(angleRad);
				if (Math.abs(tanAngle) > 0.001) {
					horizontalOffset = Math.sign(offsetAmount) * (Math.abs(verticalOffset) / Math.abs(tanAngle));
				} else {
					horizontalOffset = offsetAmount;
				}
			} else {
				horizontalOffset = offsetAmount;
			}
		}

		// Step 2) Determine entity type
		var isClosedPolygon = originalEntity.entityType === "poly" || (originalPoints[0] && originalPoints[0].closed === true);

		// Step 3) For polygons with 0 angle, use ClipperLib (handles complex polygons well)
		if (isClosedPolygon && projectionAngle === 0 && !limitElevation) {
			return calculatePolygonOffsetPreview(originalEntity, horizontalOffset, zDelta, color, offsetIndex, keepElevations);
		}

		// Step 4) Create offset SEGMENTS (not points) - each segment has start and end
		var offsetSegments = [];
		var numSegments = isClosedPolygon ? originalPoints.length : originalPoints.length - 1;

		for (var i = 0; i < numSegments; i++) {
			var p1 = originalPoints[i];
			var p2 = originalPoints[(i + 1) % originalPoints.length];

			var dx = p2.pointXLocation - p1.pointXLocation;
			var dy = p2.pointYLocation - p1.pointYLocation;
			var length = Math.sqrt(dx * dx + dy * dy);

			if (length === 0) continue;

			// Step 5) Calculate perpendicular vectors for each point
			// Using (-dy, dx) for left-hand perpendicular when going from p1 to p2
			var perpX1 = (-dy / length) * horizontalOffset;
			var perpY1 = (dx / length) * horizontalOffset;
			var perpX2 = perpX1;
			var perpY2 = perpY1;

			// Step 6) Calculate Z deltas for each point
			var p1ZDelta = parseFloat(zDelta);
			var p2ZDelta = parseFloat(zDelta);

			// Step 6a) Apply elevation limit if enabled
			if (limitElevation && projectionAngle !== 0) {
				var angleRadAbs = Math.abs(projectionAngle * Math.PI / 180);
				var tanAngle = Math.tan(angleRadAbs);

				// Handle p1 (start point)
				var p1OrigZ = parseFloat(p1.pointZLocation || 0);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p1OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						var verticalDrop = p1OrigZ - elevationLimit;
						var horizontalDistance = verticalDrop / tanAngle;
						// Use same perpendicular direction (-dy, dx) as normal offset
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p1OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p1ZDelta = elevationLimit - p1OrigZ;
						var verticalRise = elevationLimit - p1OrigZ;
						var horizontalDistance = verticalRise / tanAngle;
						// Use same perpendicular direction (-dy, dx) as normal offset
						perpX1 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY1 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p1ZDelta = 0;
						perpX1 = 0;
						perpY1 = 0;
					}
				}

				// Handle p2 (end point)
				var p2OrigZ = parseFloat(p2.pointZLocation || 0);

				if (projectionAngle < 0) {
					// Projecting downward
					if (p2OrigZ > elevationLimit) {
						// Point is above limit - project down to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						var verticalDrop = p2OrigZ - elevationLimit;
						var horizontalDistance = verticalDrop / tanAngle;
						// Use same perpendicular direction (-dy, dx) as normal offset
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or below limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				} else if (projectionAngle > 0) {
					// Projecting upward
					if (p2OrigZ < elevationLimit) {
						// Point is below limit - project up to limit
						p2ZDelta = elevationLimit - p2OrigZ;
						var verticalRise = elevationLimit - p2OrigZ;
						var horizontalDistance = verticalRise / tanAngle;
						// Use same perpendicular direction (-dy, dx) as normal offset
						perpX2 = (-dy / length) * Math.sign(horizontalOffset) * horizontalDistance;
						perpY2 = (dx / length) * Math.sign(horizontalOffset) * horizontalDistance;
					} else {
						// Point is at or above limit - no offset
						p2ZDelta = 0;
						perpX2 = 0;
						perpY2 = 0;
					}
				}
			}

			// Step 7) Calculate final Z values
			var p1Z = parseFloat(p1.pointZLocation || 0) + p1ZDelta;
			var p2Z = parseFloat(p2.pointZLocation || 0) + p2ZDelta;

			// Step 8) Create the offset segment
			offsetSegments.push({
				start: {
					x: p1.pointXLocation + perpX1,
					y: p1.pointYLocation + perpY1,
					z: p1Z
				},
				end: {
					x: p2.pointXLocation + perpX2,
					y: p2.pointYLocation + perpY2,
					z: p2Z
				}
			});
		}

		if (offsetSegments.length === 0) {
			return null;
		}

		// Step 8) Handle crossovers - find intersections between consecutive segments
		if (handleCrossovers && offsetSegments.length > 1) {
			offsetSegments = handlePreviewSegmentCrossovers(offsetSegments, isClosedPolygon);
		}

		// Step 9) Convert segments to points array
		var offsetPoints = [];
		for (var i = 0; i < offsetSegments.length; i++) {
			var seg = offsetSegments[i];

			// Add start point of first segment
			if (i === 0) {
				offsetPoints.push({
					pointXLocation: seg.start.x,
					pointYLocation: seg.start.y,
					pointZLocation: seg.start.z
				});
			}

			// Add end point of each segment
			offsetPoints.push({
				pointXLocation: seg.end.x,
				pointYLocation: seg.end.y,
				pointZLocation: seg.end.z
			});
		}

		// Step 10) Build preview entity data
		var previewData = offsetPoints.map(function (pt, index) {
			return {
				pointXLocation: pt.pointXLocation,
				pointYLocation: pt.pointYLocation,
				pointZLocation: pt.pointZLocation,
				lineWidth: originalPoints[0].lineWidth || 1,
				color: color,
				closed: isClosedPolygon
			};
		});

		return {
			entityType: originalEntity.entityType,
			data: previewData,
			color: color,
			isPreview: true,
			offsetIndex: offsetIndex
		};
	} catch (error) {
		console.error("Error in calculateSingleOffsetPreview:", error);
		return null;
	}
}

// Step #) Calculate polygon offset preview using ClipperLib
function calculatePolygonOffsetPreview(originalEntity, horizontalOffset, zDelta, color, offsetIndex, keepElevations) {
	try {
		var scale = 100000;
		var originalPoints = originalEntity.data;

		var clipperPath = originalPoints.map(function (pt) {
			return {
				X: Math.round(pt.pointXLocation * scale),
				Y: Math.round(pt.pointYLocation * scale)
			};
		});

		var clipperOffset = new ClipperLib.ClipperOffset();
		clipperOffset.AddPath(clipperPath, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);

		var offsetPaths = [];
		clipperOffset.Execute(offsetPaths, horizontalOffset * scale);

		if (offsetPaths.length === 0) {
			return null;
		}

		var offsetPath = offsetPaths[0];
		var previewData = offsetPath.map(function (pt, index) {
			var worldX = pt.X / scale;
			var worldY = pt.Y / scale;

			// Determine Z based on keepElevations
			var worldZ;
			if (keepElevations) {
				// Find closest original point for Z interpolation
				var closestPoint = originalPoints[0];
				var minDist = Infinity;
				for (var i = 0; i < originalPoints.length; i++) {
					var dx = worldX - originalPoints[i].pointXLocation;
					var dy = worldY - originalPoints[i].pointYLocation;
					var dist = Math.sqrt(dx * dx + dy * dy);
					if (dist < minDist) {
						minDist = dist;
						closestPoint = originalPoints[i];
					}
				}
				worldZ = parseFloat(closestPoint.pointZLocation || 0) + parseFloat(zDelta);
			} else {
				worldZ = parseFloat(originalPoints[0].pointZLocation || 0) + parseFloat(zDelta);
			}

			return {
				pointXLocation: worldX,
				pointYLocation: worldY,
				pointZLocation: worldZ,
				lineWidth: originalPoints[0].lineWidth || 1,
				color: color,
				closed: true
			};
		});

		return {
			entityType: "poly",
			data: previewData,
			color: color,
			isPreview: true,
			offsetIndex: offsetIndex
		};
	} catch (error) {
		console.error("Error in calculatePolygonOffsetPreview:", error);
		return null;
	}
}

// Step #) Handle crossovers between offset segments for preview
// Finds intersections between consecutive segments and extends/trims them to meet
function handlePreviewSegmentCrossovers(segments, isClosedPolygon) {
	if (segments.length < 2) return segments;

	var cleanedSegments = [];
	for (var i = 0; i < segments.length; i++) {
		cleanedSegments.push({
			start: { x: segments[i].start.x, y: segments[i].start.y, z: segments[i].start.z },
			end: { x: segments[i].end.x, y: segments[i].end.y, z: segments[i].end.z }
		});
	}

	// Step 1) Find intersections between consecutive segments and extend/trim
	for (var i = 0; i < cleanedSegments.length - 1; i++) {
		var seg1 = cleanedSegments[i];
		var seg2 = cleanedSegments[i + 1];

		// Find intersection between the two line segments (extended as rays)
		var intersection = findPreviewLineIntersection(
			seg1.start.x, seg1.start.y, seg1.end.x, seg1.end.y,
			seg2.start.x, seg2.start.y, seg2.end.x, seg2.end.y
		);

		if (intersection) {
			// Interpolate Z at intersection point
			var t1 = 0;
			var dx1 = seg1.end.x - seg1.start.x;
			var dy1 = seg1.end.y - seg1.start.y;
			var len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
			if (len1 > 0.001) {
				var dxI1 = intersection.x - seg1.start.x;
				var dyI1 = intersection.y - seg1.start.y;
				t1 = Math.sqrt(dxI1 * dxI1 + dyI1 * dyI1) / len1;
				if ((dx1 !== 0 && Math.sign(dxI1) !== Math.sign(dx1)) ||
					(dy1 !== 0 && Math.sign(dyI1) !== Math.sign(dy1))) {
					t1 = -t1;
				}
			}
			var intersectionZ = seg1.start.z + t1 * (seg1.end.z - seg1.start.z);

			// Extend/trim segments to meet at intersection
			seg1.end.x = intersection.x;
			seg1.end.y = intersection.y;
			seg1.end.z = intersectionZ;
			seg2.start.x = intersection.x;
			seg2.start.y = intersection.y;
			seg2.start.z = intersectionZ;
		}
	}

	// Step 2) For closed polygons, handle intersection between last and first segment
	if (isClosedPolygon && cleanedSegments.length > 2) {
		var lastSeg = cleanedSegments[cleanedSegments.length - 1];
		var firstSeg = cleanedSegments[0];

		var intersection = findPreviewLineIntersection(
			lastSeg.start.x, lastSeg.start.y, lastSeg.end.x, lastSeg.end.y,
			firstSeg.start.x, firstSeg.start.y, firstSeg.end.x, firstSeg.end.y
		);

		if (intersection) {
			// Interpolate Z
			var t1 = 0;
			var dx1 = lastSeg.end.x - lastSeg.start.x;
			var dy1 = lastSeg.end.y - lastSeg.start.y;
			var len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
			if (len1 > 0.001) {
				var dxI1 = intersection.x - lastSeg.start.x;
				var dyI1 = intersection.y - lastSeg.start.y;
				t1 = Math.sqrt(dxI1 * dxI1 + dyI1 * dyI1) / len1;
			}
			var intersectionZ = lastSeg.start.z + t1 * (lastSeg.end.z - lastSeg.start.z);

			lastSeg.end.x = intersection.x;
			lastSeg.end.y = intersection.y;
			lastSeg.end.z = intersectionZ;
			firstSeg.start.x = intersection.x;
			firstSeg.start.y = intersection.y;
			firstSeg.start.z = intersectionZ;
		}
	}

	// Step 3) Filter out segments that became too short (less than 0.1m)
	return cleanedSegments.filter(function (seg) {
		var dx = seg.end.x - seg.start.x;
		var dy = seg.end.y - seg.start.y;
		var length = Math.sqrt(dx * dx + dy * dy);
		return length > 0.1;
	});
}

// Step #) Find intersection point between two lines (extended as infinite lines)
function findPreviewLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
	var denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

	if (Math.abs(denom) < 1e-10) {
		return null; // Lines are parallel
	}

	var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
	var u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

	// Check if intersection is within reasonable extension range
	// Allow more extension than the actual function for preview visualization
	if (t >= -2.0 && t <= 3.0 && u >= -2.0 && u <= 3.0) {
		return {
			x: x1 + t * (x2 - x1),
			y: y1 + t * (y2 - y1)
		};
	}

	return null; // No valid intersection within range
}

// Step #) Update the offset preview with current form parameters
function updateOffsetPreview(entity, params) {
	if (!entity || !params) {
		clearOffsetPreview();
		return;
	}

	// Step 1) Enable preview mode
	offsetPreviewEnabled = true;
	offsetPreviewOriginalEntity = entity;
	offsetPreviewParams = params;

	// Step 2) Calculate preview entities
	offsetPreviewEntities = calculateOffsetPreview(entity, params);

	// Step 3) Trigger redraw to show preview
	// Use requestAnimationFrame for smooth updates
	requestAnimationFrame(function () {
		if (onlyShowThreeJS) {
			// In 3D mode, redraw the 3D scene
			draw3DOffsetPreview();
			if (threeRenderer) {
				threeRenderer.render();
			}
		} else {
			// In 2D mode, redraw the canvas
			drawData(allBlastHoles, selectedHole);
		}
	});
}

// Step #) Clear the offset preview
function clearOffsetPreview() {
	// Step 1) Clear all preview state
	offsetPreviewEnabled = false;
	offsetPreviewOriginalEntity = null;
	offsetPreviewEntities = [];
	offsetPreviewParams = {};

	// Step 2) Clear 3D preview meshes if they exist
	clear3DOffsetPreview();

	// Step 3) Force a full redraw to clear both 2D and 3D
	// Use redraw3D which sets threeDataNeedsRebuild and calls drawData
	if (typeof window.redraw3D === "function") {
		window.redraw3D();
	} else {
		drawData(allBlastHoles, selectedHole);
	}
}

// Step #) Draw 2D offset preview on canvas
function draw2DOffsetPreview() {
	if (!offsetPreviewEnabled || !ctx || offsetPreviewEntities.length === 0) {
		return;
	}

	ctx.save();

	// Step 1) Draw each preview entity with dashed lines and semi-transparency
	for (var e = 0; e < offsetPreviewEntities.length; e++) {
		var previewEntity = offsetPreviewEntities[e];
		if (!previewEntity || !previewEntity.data || previewEntity.data.length < 2) continue;

		var points = previewEntity.data;
		var color = previewEntity.color || "#FF0000";
		var lineWidth = points[0].lineWidth || 2;
		var isClosed = previewEntity.entityType === "poly";

		// Step 2) Set preview styling
		ctx.strokeStyle = color;
		ctx.globalAlpha = 0.7;
		ctx.setLineDash([8, 4]); // Dashed line for preview
		ctx.lineWidth = Math.max(lineWidth, 2);
		ctx.lineCap = "round";
		ctx.lineJoin = "round";

		// Step 3) Draw the preview line/polygon
		ctx.beginPath();
		for (var i = 0; i < points.length; i++) {
			var screenCoords = worldToCanvas(points[i].pointXLocation, points[i].pointYLocation);
			if (i === 0) {
				ctx.moveTo(screenCoords[0], screenCoords[1]);
			} else {
				ctx.lineTo(screenCoords[0], screenCoords[1]);
			}
		}

		// Close polygon if needed
		if (isClosed && points.length > 2) {
			ctx.closePath();
		}

		ctx.stroke();

		// Step 4) Draw start point indicator (green dot) for direction reference
		if (points.length > 0) {
			var startScreen = worldToCanvas(points[0].pointXLocation, points[0].pointYLocation);
			ctx.globalAlpha = 1.0;
			ctx.setLineDash([]);
			ctx.fillStyle = "#00FF00";
			ctx.beginPath();
			ctx.arc(startScreen[0], startScreen[1], 6, 0, Math.PI * 2);
			ctx.fill();
			ctx.strokeStyle = "#006600";
			ctx.lineWidth = 2;
			ctx.stroke();
		}

		// Step 5) Draw direction arrows along the preview line
		if (points.length >= 2) {
			drawPreviewDirectionArrows(points, color);
		}
	}

	// Step 6) Draw original entity start point indicator
	if (offsetPreviewOriginalEntity && offsetPreviewOriginalEntity.data && offsetPreviewOriginalEntity.data.length > 0) {
		var origStart = offsetPreviewOriginalEntity.data[0];
		var origScreen = worldToCanvas(origStart.pointXLocation, origStart.pointYLocation);
		ctx.globalAlpha = 1.0;
		ctx.setLineDash([]);
		ctx.fillStyle = "#00FFFF"; // Cyan for original start
		ctx.beginPath();
		ctx.arc(origScreen[0], origScreen[1], 8, 0, Math.PI * 2);
		ctx.fill();
		ctx.strokeStyle = "#006666";
		ctx.lineWidth = 2;
		ctx.stroke();

		// Draw "START" label
		ctx.fillStyle = darkModeEnabled ? "#FFFFFF" : "#000000";
		ctx.font = "bold 10px Arial";
		ctx.textAlign = "center";
		ctx.fillText("START", origScreen[0], origScreen[1] - 12);
	}

	ctx.restore();
}

// Step #) Draw direction arrows on preview lines
function drawPreviewDirectionArrows(points, color) {
	if (points.length < 2) return;

	ctx.save();
	ctx.fillStyle = color;
	ctx.globalAlpha = 0.9;
	ctx.setLineDash([]);

	// Draw arrows at 25%, 50%, 75% along the line
	var arrowPositions = [0.25, 0.5, 0.75];

	for (var a = 0; a < arrowPositions.length; a++) {
		var t = arrowPositions[a];
		var totalLength = 0;
		var segmentLengths = [];

		// Calculate total length and segment lengths
		for (var i = 0; i < points.length - 1; i++) {
			var dx = points[i + 1].pointXLocation - points[i].pointXLocation;
			var dy = points[i + 1].pointYLocation - points[i].pointYLocation;
			var segLen = Math.sqrt(dx * dx + dy * dy);
			segmentLengths.push(segLen);
			totalLength += segLen;
		}

		// Find position at t along the line
		var targetDist = t * totalLength;
		var accDist = 0;

		for (var i = 0; i < segmentLengths.length; i++) {
			if (accDist + segmentLengths[i] >= targetDist) {
				var segT = (targetDist - accDist) / segmentLengths[i];
				var p1 = points[i];
				var p2 = points[i + 1];

				// Interpolate position
				var x = p1.pointXLocation + segT * (p2.pointXLocation - p1.pointXLocation);
				var y = p1.pointYLocation + segT * (p2.pointYLocation - p1.pointYLocation);

				// Calculate direction angle
				var dx = p2.pointXLocation - p1.pointXLocation;
				var dy = p2.pointYLocation - p1.pointYLocation;
				var angle = Math.atan2(-dy, dx); // Negative dy for canvas Y inversion

				// Convert to screen coordinates
				var screenCoords = worldToCanvas(x, y);

				// Draw arrow
				var arrowSize = 8;
				ctx.save();
				ctx.translate(screenCoords[0], screenCoords[1]);
				ctx.rotate(-angle);

				ctx.beginPath();
				ctx.moveTo(arrowSize, 0);
				ctx.lineTo(-arrowSize / 2, -arrowSize / 2);
				ctx.lineTo(-arrowSize / 2, arrowSize / 2);
				ctx.closePath();
				ctx.fill();

				ctx.restore();
				break;
			}
			accDist += segmentLengths[i];
		}
	}

	ctx.restore();
}

// Step #) Track 3D preview meshes for cleanup
var offsetPreview3DMeshes = [];

// Step #) Draw 3D offset preview
function draw3DOffsetPreview() {
	// Step 0) Always clear existing preview meshes first
	// This ensures meshes are removed when preview is disabled
	clear3DOffsetPreview();

	// Step 1) Return early if preview is not enabled or no entities
	if (!threeRenderer || !offsetPreviewEnabled || offsetPreviewEntities.length === 0) {
		return;
	}

	// Step 2) Create preview meshes for each offset entity
	for (var e = 0; e < offsetPreviewEntities.length; e++) {
		var previewEntity = offsetPreviewEntities[e];
		if (!previewEntity || !previewEntity.data || previewEntity.data.length < 2) continue;

		var points = previewEntity.data;
		var color = previewEntity.color || "#FF0000";
		var lineWidth = points[0].lineWidth || 2;
		var isClosed = previewEntity.entityType === "poly";

		// Step 3) Create line geometry
		var positions = [];

		for (var i = 0; i < points.length; i++) {
			var local = worldToThreeLocal(points[i].pointXLocation, points[i].pointYLocation);
			var z = points[i].pointZLocation || 0;
			positions.push(local.x, local.y, z);
		}

		// Close polygon if needed
		if (isClosed && points.length > 2) {
			var firstLocal = worldToThreeLocal(points[0].pointXLocation, points[0].pointYLocation);
			positions.push(firstLocal.x, firstLocal.y, points[0].pointZLocation || 0);
		}

		// Step 4) Create THREE.js line with dashed material
		var geometry = new THREE.BufferGeometry();
		geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));

		var material = new THREE.LineDashedMaterial({
			color: new THREE.Color(color),
			transparent: true,
			opacity: 0.7,
			dashSize: 2,
			gapSize: 1,
			linewidth: lineWidth
		});

		var line = new THREE.Line(geometry, material);
		line.computeLineDistances(); // Required for dashed lines
		line.name = "offsetPreview_" + e;
		line.userData = { isPreview: true };

		// Add to scene
		if (threeRenderer.scene) {
			threeRenderer.scene.add(line);
			offsetPreview3DMeshes.push(line);
		}
	}

	// Step 5) Add start point indicator in 3D
	if (offsetPreviewOriginalEntity && offsetPreviewOriginalEntity.data && offsetPreviewOriginalEntity.data.length > 0) {
		var origStart = offsetPreviewOriginalEntity.data[0];
		var startLocal = worldToThreeLocal(origStart.pointXLocation, origStart.pointYLocation);
		var startZ = origStart.pointZLocation || 0;

		// Create cyan sphere for original start point
		var sphereGeom = new THREE.SphereGeometry(1.5, 16, 16);
		var sphereMat = new THREE.MeshBasicMaterial({
			color: 0x00FFFF,
			transparent: true,
			opacity: 0.9
		});
		var startSphere = new THREE.Mesh(sphereGeom, sphereMat);
		startSphere.position.set(startLocal.x, startLocal.y, startZ);
		startSphere.name = "offsetPreviewStart";
		startSphere.userData = { isPreview: true };

		if (threeRenderer.scene) {
			threeRenderer.scene.add(startSphere);
			offsetPreview3DMeshes.push(startSphere);
		}
	}
}

// Step #) Clear 3D offset preview meshes
function clear3DOffsetPreview() {
	if (!threeRenderer || !threeRenderer.scene) return;

	for (var i = 0; i < offsetPreview3DMeshes.length; i++) {
		var mesh = offsetPreview3DMeshes[i];
		if (mesh) {
			threeRenderer.scene.remove(mesh);
			if (mesh.geometry) mesh.geometry.dispose();
			if (mesh.material) mesh.material.dispose();
		}
	}
	offsetPreview3DMeshes = [];
}

// ================================
// OFFSET PREVIEW FUNCTIONALITY - END
// ================================

// ================================
// OFFSET KAD FUNCTIONALITY - ENDED
// ================================

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - STARTED
// ================================

radiiHolesOrKADsTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("radiiHolesOrKADsTool");

		// Get all selected entities (holes + KAD objects)
		const selectedEntities = getSelectedEntitiesForRadii();

		if (selectedEntities.length === 0) {
			// No entities selected, show message and deactivate tool
			showModalMessage("No Selection", "Please select holes or KAD entities first, then activate the Radii tool.", "info");
			this.checked = false;
			resetFloatingToolbarButtons("none");
			return;
		}

		// Show radii configuration popup
		showRadiiConfigPopup(selectedEntities);
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("");
	}
});

// Show radii configuration popup using FloatingDialog
// Show radii configuration popup using FloatingDialog
// ? VERBOSE REMOVAL COMMENT - showRadiiConfigPopup() removed
// Step 1) This function (291 lines, lines 15102-15392) was extracted to src/dialog/popups/generic/KADDialogs.js
// Step 2) Reason: Part of Phase 2.6 dialog extraction to modularize kirra.js
// Step 3) Date: 2025-12-20
// Step 4) Function extracted: showRadiiConfigPopup() - Dialog for creating radii/circles around entities
// Step 5) Function is exposed globally via window.showRadiiConfigPopup in KADDialogs.js

function createRadiiFromSelectedEntitiesFixed(selectedEntities, params) {
	try {
		// Step 1: Update status message
		updateStatusMessage("Creating radii polygons for " + selectedEntities.length + " selected entities...");

		// Step 2: Convert selectedEntities to simple point coordinates
		const pointsForRadii = [];

		selectedEntities.forEach((entity) => {
			let pointCoords;

			if (entity.type === "hole") {
				// Step 3: For holes, use start or end location based on user choice
				if (params.useToeLocation) {
					pointCoords = {
						startXLocation: entity.endXLocation,
						startYLocation: entity.endYLocation,
						startZLocation: entity.endZLocation,
						endXLocation: entity.endXLocation,
						endYLocation: entity.endYLocation,
						endZLocation: entity.endZLocation,
					};
				} else {
					pointCoords = {
						startXLocation: entity.startXLocation,
						startYLocation: entity.startYLocation,
						startZLocation: entity.startZLocation,
						endXLocation: entity.startXLocation,
						endYLocation: entity.startYLocation,
						endZLocation: entity.startZLocation,
					};
				}
			} else {
				// Step 4: For KAD objects, use the single point coordinate (no start/end distinction)
				pointCoords = {
					startXLocation: entity.startXLocation,
					startYLocation: entity.startYLocation,
					startZLocation: entity.startZLocation,
					endXLocation: entity.startXLocation, // Same as start for KAD objects
					endYLocation: entity.startYLocation, // Same as start for KAD objects
					endZLocation: entity.startZLocation, // Same as start for KAD objects
				};
			}

			pointsForRadii.push(pointCoords);
		});

		console.log("üî• Calling getRadiiPolygons with " + pointsForRadii.length + " points:");
		console.log("   Rotation: " + params.rotationOffset + "¬∞, Starburst: " + params.starburstOffset * 100 + "%");
		pointsForRadii.forEach((point, index) => {
			console.log("  Point " + (index + 1) + ": (" + point.startXLocation + ", " + point.startYLocation + ", " + point.startZLocation + ")");
		});

		// Step 5: Use existing getRadiiPolygons function with new rotation and starburst parameters
		const polygons = getRadiiPolygonsEnhanced(
			pointsForRadii,
			params.steps,
			params.radius,
			params.unionCircles,
			true, // addToMaps = true
			params.color,
			params.lineWidth,
			params.useToeLocation,
			params.rotationOffset,
			params.starburstOffset
		);

		console.log("‚úÖ getRadiiPolygonsEnhanced returned " + polygons.length + " polygon(s)");

		// Step 6: Update display and save
		// Step #) Trigger 3D rebuild to show radii results immediately
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedUpdateTreeView();

		// Step 7: Create success message
		const resultMessage = params.unionCircles ? "Unioned radii polygon created successfully." : polygons.length + " radii polygon(s) created successfully.";

		updateStatusMessage(resultMessage);

		// Step 8: Show success dialog using FloatingDialog
		showSuccessDialog(
			"Radii Creation Successful",
			`
            <div style="text-align: center;">
                <p><strong>` +
			resultMessage +
			`</strong></p>
                <p><strong>Input:</strong> ` +
			selectedEntities.length +
			` entities</p>
                <p><strong>Output:</strong> ` +
			polygons.length +
			` polygon(s)</p>
                <p><strong>Radius:</strong> ` +
			params.radius +
			`m</p>
                <p><strong>Rotation:</strong> ` +
			params.rotationOffset +
			`?</p>
                <p><strong>Starburst:</strong> ` +
			params.starburstOffset * 100 +
			`%</p>
                <p><strong>Line Width:</strong> ` +
			params.lineWidth +
			`</p>
                <p><strong>Location:</strong> ` +
			(params.useToeLocation ? "End/Toe" : "Start/Collar") +
			`</p>
                <p><strong>Zoom or scroll to see the results.</strong></p>
            </div>
        `
		);
	} catch (error) {
		// Step 9: Handle errors with FloatingDialog
		console.error("? Error creating radii polygons:", error);
		updateStatusMessage("Error creating radii polygons.");

		showErrorDialog(
			"Radii Creation Failed",
			`
            <div style="text-align: center;">
                <p><strong>Failed to create radii polygons.</strong></p>
                <hr style="border-color: #555; margin: 15px 0;">
                <p><strong>Error:</strong><br>` +
			(error.message || "Unknown error occurred") +
			`</p>
            </div>
        `
		);
	}
}

// Helper function to show success dialog using FloatingDialog
function showSuccessDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 300,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		},
	});

	dialog.show();
}

// Helper function to show error dialog using FloatingDialog
function showErrorDialog(title, content) {
	const contentDiv = document.createElement("div");
	contentDiv.innerHTML = content;
	contentDiv.style.color = "#ff6b6b";

	const dialog = new FloatingDialog({
		title: title,
		content: contentDiv,
		layoutType: "default",
		width: 350,
		height: 200,
		showConfirm: true,
		showCancel: false,
		confirmText: "OK",
		onConfirm: () => {
			// Dialog will close automatically
		},
	});

	dialog.show();
}
// Get all selected entities for radii creation
function getSelectedEntitiesForRadii() {
	const selectedEntities = [];

	// Add selected holes (handle both single and multiple selection)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach((hole) => {
			selectedEntities.push({
				type: "hole",
				data: hole,
				startXLocation: hole.startXLocation,
				startYLocation: hole.startYLocation,
				startZLocation: hole.startZLocation,
				endXLocation: hole.endXLocation,
				endYLocation: hole.endYLocation,
				endZLocation: hole.endZLocation,
			});
		});
	} else if (selectedHole) {
		// Handle single selected hole
		selectedEntities.push({
			type: "hole",
			data: selectedHole,
			startXLocation: selectedHole.startXLocation,
			startYLocation: selectedHole.startYLocation,
			startZLocation: selectedHole.startZLocation,
			endXLocation: selectedHole.endXLocation,
			endYLocation: selectedHole.endYLocation,
			endZLocation: selectedHole.endZLocation,
		});
	}

	// Add selected KAD object (singular) - with comprehensive debugging
	if (selectedKADObject) {
		console.log("üîç Processing selectedKADObject:", selectedKADObject);

		// Check if data exists and is an array
		if (selectedKADObject.data && Array.isArray(selectedKADObject.data)) {
			console.log("üìä KAD object has data array with " + selectedKADObject.data.length + " items");

			if (selectedKADObject.entityType === "point") {
				// For points, use the point location
				selectedKADObject.data.forEach((point, index) => {
					console.log("üîµ Processing point " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_point",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "line" || selectedKADObject.entityType === "poly") {
				// For lines and polygons, use each vertex
				selectedKADObject.data.forEach((point, index) => {
					console.log("üìç Processing vertex " + (index + 1) + ":", point);
					selectedEntities.push({
						type: "kad_vertex",
						data: selectedKADObject,
						startXLocation: point.pointXLocation,
						startYLocation: point.pointYLocation,
						startZLocation: point.pointZLocation || 0,
						endXLocation: point.pointXLocation,
						endYLocation: point.pointYLocation,
						endZLocation: point.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "text") {
				// For text, use the text position
				selectedKADObject.data.forEach((textPoint, index) => {
					console.log("üìù Processing text " + (index + 1) + ":", textPoint);
					selectedEntities.push({
						type: "kad_text",
						data: selectedKADObject,
						startXLocation: textPoint.pointXLocation,
						startYLocation: textPoint.pointYLocation,
						startZLocation: textPoint.pointZLocation || 0,
						endXLocation: textPoint.pointXLocation,
						endYLocation: textPoint.pointYLocation,
						endZLocation: textPoint.pointZLocation || 0,
					});
				});
			} else if (selectedKADObject.entityType === "circle") {
				// For circles, use the center point
				selectedKADObject.data.forEach((circlePoint, index) => {
					console.log("‚≠ï Processing circle " + (index + 1) + ":", circlePoint);
					selectedEntities.push({
						type: "kad_circle",
						data: selectedKADObject,
						startXLocation: circlePoint.pointXLocation,
						startYLocation: circlePoint.pointYLocation,
						startZLocation: circlePoint.pointZLocation || 0,
						endXLocation: circlePoint.pointXLocation,
						endYLocation: circlePoint.pointYLocation,
						endZLocation: circlePoint.pointZLocation || 0,
					});
				});
			}
		} else {
			// Alternative approach - try to extract from selectedKADObject itself
			console.warn("?? KAD object doesn't have proper data array, trying alternative extraction");
			console.log("KAD Object structure:", selectedKADObject);

			// Check if it's stored in allKADDrawingsMap
			if (selectedKADObject.entityName) {
				const entity = allKADDrawingsMap.get(selectedKADObject.entityName);
				if (entity && entity.data && Array.isArray(entity.data)) {
					console.log("‚úÖ Found entity in allKADDrawingsMap with " + entity.data.length + " points");

					entity.data.forEach((point, index) => {
						console.log("üîÑ Processing entity point " + (index + 1) + ":", point);
						selectedEntities.push({
							type: "kad_entity_point",
							data: entity,
							startXLocation: point.pointXLocation,
							startYLocation: point.pointYLocation,
							startZLocation: point.pointZLocation || 0,
							endXLocation: point.pointXLocation,
							endYLocation: point.pointYLocation,
							endZLocation: point.pointZLocation || 0,
						});
					});
				}
			}

			// Last resort - use selectedKADObject directly if it has coordinates
			if (selectedEntities.length === 0 && selectedKADObject.pointXLocation !== undefined && selectedKADObject.pointYLocation !== undefined) {
				console.log("üÜò Using fallback direct coordinates");
				selectedEntities.push({
					type: "kad_fallback",
					data: selectedKADObject,
					startXLocation: selectedKADObject.pointXLocation,
					startYLocation: selectedKADObject.pointYLocation,
					startZLocation: selectedKADObject.pointZLocation || 0,
					endXLocation: selectedKADObject.pointXLocation,
					endYLocation: selectedKADObject.pointYLocation,
					endZLocation: selectedKADObject.pointZLocation || 0,
				});
			}
		}
	}

	console.log("üéØ Final selectedEntities array has " + selectedEntities.length + " entities:");
	selectedEntities.forEach((entity, index) => {
		console.log("  " + (index + 1) + ". " + entity.type + " at (" + entity.startXLocation + ", " + entity.startYLocation + ", " + entity.startZLocation + ")");
	});

	return selectedEntities;
}

// ================================
// RADII HOLES OR KADs FUNCTIONALITY - ENDED
// ================================

// ================================
// DRAW BLAST BOUNDARY FUNCTIONALITY - STARTED
// ================================

function drawBlastBoundary(polygon, strokeColor) {
	//convert wold coords to screen cords
	const screenCoords = polygon.map((point) => {
		const x = (point.x - centroidX) * currentScale + canvas.width / 2;
		const y = (-point.y + centroidY) * currentScale + canvas.height / 2;
		return {
			x,
			y,
		};
	});

	ctx.beginPath();
	ctx.moveTo(screenCoords[0].x, screenCoords[0].y);
	for (let i = 1; i < screenCoords.length; i++) {
		ctx.lineTo(screenCoords[i].x, screenCoords[i].y);
	}
	ctx.closePath();
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 2;
	ctx.stroke();
}

function offsetPolygonMathematical(polygon, offset) {
	const result = [];
	const n = polygon.length;
	const quadrantRads = [];

	for (let i = 0; i < n; i++) {
		const dx = polygon[(i + 1) % n].x - polygon[i].x;
		const dy = polygon[(i + 1) % n].y - polygon[i].y;
		const dist = Math.sqrt(dx * dx + dy * dy);

		let angle = 0;
		if (dist > 0) {
			if (dy >= 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.asin(dx / dist);
			} else if (dy < 0 && dx >= 0) {
				angle = Math.PI / 2 - Math.acos(dy / dist);
			} else if (dy < 0 && dx < 0) {
				angle = (3 * Math.PI) / 2 - Math.asin(-dx / dist);
			} else {
				angle = (3 * Math.PI) / 2 - Math.acos(-dy / dist);
			}
		}
		quadrantRads.push(angle);
	}

	const offsetSegments = [];
	for (let i = 0; i < n; i++) {
		const theta = quadrantRads[i];
		const dx = offset * -Math.sin(theta);
		const dy = offset * Math.cos(theta);

		const p1 = {
			x: polygon[i].x + dx,
			y: polygon[i].y + dy,
		};
		const p2 = {
			x: polygon[(i + 1) % n].x + dx,
			y: polygon[(i + 1) % n].y + dy,
		};
		offsetSegments.push([p1, p2]);
	}

	for (let i = 0; i < n; i++) {
		const [p1a, p1b] = offsetSegments[i];
		const [p2a, p2b] = offsetSegments[(i + 1) % n];

		const denom = -(p2b.x - p2a.x) * -Math.sin(quadrantRads[i]) - Math.cos(quadrantRads[i]) * (p2b.y - p2a.y);

		if (denom === 0) {
			result.push(p1b); // fallback
			continue;
		}

		const s = Math.cos(quadrantRads[(i + 1) % n]) * (p2b.y - p2a.y) - (p2b.x - p2a.x) * Math.sin(quadrantRads[(i + 1) % n]);
		const t = s / denom;

		const x = p1b.x + Math.cos(quadrantRads[i]) * t;
		const y = p1b.y + Math.sin(quadrantRads[i]) * t;
		result.push({
			x: x,
			y: y,
		});
	}

	return result;
}

// FIXED: Much faster getAverageDistance function
function getAverageDistance(points) {
	if (!points || !Array.isArray(points) || points.length < 2) return 1;

	// For large datasets, use sampling to avoid O(n?) performance
	if (points.length > 1000) {
		// Sample every Nth point to keep it manageable
		const sampleSize = Math.min(500, Math.floor(points.length / 10));
		const step = Math.floor(points.length / sampleSize);
		const sampledPoints = [];

		for (let i = 0; i < points.length; i += step) {
			sampledPoints.push(points[i]);
		}

		// Use the sampled points for calculation
		return getAverageDistanceSmall(sampledPoints);
	}

	// For small datasets, use the original algorithm
	return getAverageDistanceSmall(points);
}

// Helper function for small datasets
function getAverageDistanceSmall(points) {
	let total = 0;
	let count = 0;

	for (let i = 0; i < points.length; i++) {
		let minDist = Infinity;

		for (let j = 0; j < points.length; j++) {
			if (i === j) continue;

			const dx = points[i].startXLocation - points[j].startXLocation;
			const dy = points[i].startYLocation - points[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);

			if (dist < minDist) {
				minDist = dist;
			}
		}

		if (minDist < Infinity) {
			total += minDist;
			count++;
		}
	}

	return count > 0 ? total / count : 1;
}

//=================================================
// Three.js Drawing Helper Functions
//=================================================

// Step 1) Helper - Convert RGB string to Three.js Color object
function rgbStringToThreeColor(rgbString) {
	// Parse "rgb(r, g, b)" string
	const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
	if (match) {
		const r = parseInt(match[1]) / 255;
		const g = parseInt(match[2]) / 255;
		const b = parseInt(match[3]) / 255;
		return { r: r, g: g, b: b };
	}
	return { r: 1, g: 1, b: 1 }; // Default white
}

// Note: Three.js drawing functions moved to src/draw/canvas3DDrawing.js

//=================================================
// End Three.js Drawing Helper Functions
//=================================================

/*** CODE TO DRAW POINTS FROM KAD DATA ***/
//Draws an open poly line from the kadLinesArray

function drawAllKADSelectionVisuals() {
	console.log("Drawing selections - single:", selectedKADObject ? 1 : 0, "multiple:", selectedMultipleKADObjects.length); // DEBUG - ADD THIS LINE
	// Handle single selection
	if (isSelectionPointerActive && selectedKADObject) {
		if (selectedKADObject.entityType === "circle") {
			// Highlight circles with a ring
			drawCircleSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "text") {
			// Highlight text with a box
			drawTextSelection(selectedKADObject);
		} else if (selectedKADObject.entityType === "point") {
			// Highlight points with a larger circle
			drawPointSelection(selectedKADObject);
		} else {
			// Use existing polygon selection for lines/polygons
			drawKADPolyUnified(selectedKADObject);
		}
	}

	// Handle multiple selections - use the same style as single selection
	if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		selectedMultipleKADObjects.forEach((kadObj) => {
			const entity = allKADDrawingsMap.get(kadObj.entityName);
			if (entity) {
				// Use the same selection functions for each selected object
				if (entity.entityType === "circle") {
					drawCircleSelection(entity);
				} else if (entity.entityType === "text") {
					drawTextSelection(entity);
				} else if (entity.entityType === "point") {
					drawPointSelection(entity);
				} else if (entity.entityType === "poly" || entity.entityType === "line") {
					// Use the same polygon/line selection drawing
					drawKADPolyUnified(entity.data);
				}
			}
		});
	}
}
// Unified drawing function for both lines and polygons
function drawKADPolyUnified(points) {
	if (points.length < 1) return;

	let currentPath = [];

	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		currentPath.push(point);

		// Check if this is the end of a path (closed or last point)
		const isLastPoint = i === points.length - 1;
		const isClosedPolygon = point.closed === true;

		if (isLastPoint || isClosedPolygon) {
			// Draw the accumulated path
			if (currentPath.length === 1) {
				// Single point - draw as dot
				const [x, y] = worldToCanvas(currentPath[0].pointXLocation, currentPath[0].pointYLocation);
				drawKADPoints(x, y, currentPath[0].pointZLocation, currentPath[0].color);
			} else if (currentPath.length >= 2) {
				// Multiple points - draw as polyline/polygon
				drawPolyPath(currentPath, isClosedPolygon);
			}

			// Reset for next path
			currentPath = [];
		}
	}
}

// Helper function to draw a path of connected points
function drawPolyPath(pathPoints, closed) {
	if (pathPoints.length < 2) return;

	const lineWidth = pathPoints[0].lineWidth || 1;
	const strokeColor = pathPoints[0].color || "#FF0000";

	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = lineWidth;
	ctx.beginPath();

	// Start at first point
	const [startX, startY] = worldToCanvas(pathPoints[0].pointXLocation, pathPoints[0].pointYLocation);
	ctx.moveTo(startX, startY);

	// Draw to subsequent points
	for (let i = 1; i < pathPoints.length; i++) {
		const [x, y] = worldToCanvas(pathPoints[i].pointXLocation, pathPoints[i].pointYLocation);
		ctx.lineTo(x, y);
	}

	// Close if it's a polygon
	if (closed) {
		ctx.closePath();
	}

	ctx.stroke();
}

// Add this to your drawData function
function drawPolygonSelection(ctx) {
	if (!isPolygonSelectionActive || polyPointsX.length < 2) return;

	ctx.beginPath();
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		if (i === 0) {
			ctx.moveTo(x, y);
		} else {
			ctx.lineTo(x, y);
		}
	}

	// Close the polygon by connecting back to first point
	if (polyPointsX.length >= 2) {
		const [firstX, firstY] = worldToCanvas(polyPointsX[0], polyPointsY[0]);
		ctx.lineTo(firstX, firstY);
	}

	ctx.strokeStyle = "rgba(200, 0, 200, 0.5)";
	ctx.lineWidth = 1;
	ctx.stroke();

	// Draw vertices
	for (let i = 0; i < polyPointsX.length; i++) {
		const [x, y] = worldToCanvas(polyPointsX[i], polyPointsY[i]);
		ctx.beginPath();
		ctx.arc(x, y, 4, 0, Math.PI * 2);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.fill();
	}
}

// Enhanced KAD preview function - FIXED VERSION
function drawKADPreviewLine(ctx) {
	// Check which tools are active
	const isPointActive = addPointDraw.checked;
	const isLineActive = addLineDraw.checked;
	const isCircleActive = addCircleDraw.checked;
	const isPolyActive = addPolyDraw.checked;
	const isTextActive = addTextDraw.checked;
	// const isPolygonSelectionActive_local = isPolyActive;

	const anyToolActive = isPointActive || isLineActive || isCircleActive || isPolyActive || isTextActive; // || isPolygonSelectionActive_local;

	if (!anyToolActive) return;

	// Skip if mouse is at origin (not moved yet)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	let previewStartX = null;
	let previewStartY = null;
	let previewColor = "rgba(255, 255, 255, 0.7)"; // Default white
	let previewStyle = [5, 5]; // Default dash pattern
	let shouldDraw = false;

	// Handle polygon selection first (it has its own tracking)
	if (isPolyActive && polyPointsX.length > 0) {
		previewStartX = polyPointsX[polyPointsX.length - 1];
		previewStartY = polyPointsY[polyPointsY.length - 1];
		previewColor = "rgba(255, 0, 255, 0.7)"; // Magenta for polygon selection
		previewStyle = [5, 5];
		shouldDraw = true;
	}
	// For other tools, use lastKADDrawPoint if available and actively drawing
	else if (lastKADDrawPoint && createNewEntity === false) {
		previewStartX = lastKADDrawPoint.x;
		previewStartY = lastKADDrawPoint.y;
		shouldDraw = true;

		// Set colors and styles for different tools
		if (isLineActive) {
			previewColor = "rgba(0, 255, 255, 0.7)"; // Cyan for lines
			previewStyle = [8, 4];
		} else if (isCircleActive) {
			previewColor = "rgba(255, 165, 0, 0.7)"; // Orange for circles
			previewStyle = [6, 3];
		} else if (isPointActive) {
			previewColor = "rgba(209, 0, 0, 0.8)"; // Red for points
			previewStyle = [4, 2];
		} else if (isTextActive) {
			previewColor = "rgba(0, 255, 0, 0.7)"; // Green for text
			previewStyle = [10, 5];
		} else if (isPolyActive) {
			previewColor = "rgba(215, 0, 215, 0.7)"; // Purple for polygons
			previewStyle = [7, 3];
		}
	}

	// Show tool indicators for ALL active tools (even if no previous point)
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	if (isPointActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(209, 0, 0, 0.8)"; // Purple for points
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var pointDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var pointBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(pointDist, pointBearing, "point", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isCircleActive) {
		ctx.beginPath();
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var circleDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var circleBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(circleDist, circleBearing, "circle", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, parseFloat(circleRadius.value) * currentScale, 0, Math.PI * 2);
		// // Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		//color of the circle to be drawn
		ctx.fillStyle = getJSColorHexDrawing() + "4D"; // Drawing color at 30% opacity
		ctx.fill();
	} else if (isTextActive) {
		// Show crosshair for Text tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 255, 0, 0.6)"; // Green for Text
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var textDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var textBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(textDist, textBearing, "text", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
	} else if (isLineActive) {
		// Show crosshair for line tool
		ctx.beginPath();
		//ctx.setLineDash([2, 2]);
		ctx.strokeStyle = "rgba(0, 207, 207, 0.8)"; // Cyan for lines
		ctx.lineWidth = 2;
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var lineDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var lineBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(lineDist, lineBearing, "line", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);
		ctx.stroke();
		//ctx.setLineDash([]);
	} else if (isPolyActive) {
		ctx.beginPath();
		ctx.strokeStyle = "rgba(215, 0, 215, 0.6)"; // Purple for polygons
		ctx.lineWidth = 2;
		// Show for polygon tool
		// Step #) Distance text removed - now using CSS DrawingDistancePanel
		if (shouldDraw) {
			var polyDist = Math.sqrt(Math.pow(currentMouseWorldX - previewStartX, 2) + Math.pow(currentMouseWorldY - previewStartY, 2));
			var polyBearing = (90 - (Math.atan2(currentMouseWorldY - previewStartY, currentMouseWorldX - previewStartX) * 180) / Math.PI + 360) % 360;
			showDrawingDistance(polyDist, polyBearing, "poly", mouseCanvasX + canvas.getBoundingClientRect().left, mouseCanvasY + canvas.getBoundingClientRect().top);
		}
		ctx.arc(mouseCanvasX, mouseCanvasY, snapRadiusPixels, 0, Math.PI * 2);
		// Draw crosshair
		ctx.moveTo(mouseCanvasX - snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.lineTo(mouseCanvasX + snapRadiusPixels * 1.5, mouseCanvasY);
		ctx.moveTo(mouseCanvasX, mouseCanvasY - snapRadiusPixels * 1.5);
		ctx.lineTo(mouseCanvasX, mouseCanvasY + snapRadiusPixels * 1.5);

		ctx.stroke();
	}

	// Draw preview line if we have a start point
	if (shouldDraw) {
		const [startCanvasX, startCanvasY] = worldToCanvas(previewStartX, previewStartY);

		// Draw the preview line
		ctx.beginPath();
		ctx.setLineDash(previewStyle);
		ctx.strokeStyle = previewColor;
		ctx.lineWidth = 2;
		ctx.moveTo(startCanvasX, startCanvasY);
		ctx.lineTo(mouseCanvasX, mouseCanvasY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Draw a small indicator at the start point
		ctx.beginPath();
		ctx.arc(startCanvasX, startCanvasY, 3, 0, Math.PI * 2);
		ctx.fillStyle = previewColor;
		ctx.fill();
	}
}
// Function to update the last KAD draw point when user draws something
function updateLastKADDrawPoint(x, y, z) {
	lastKADDrawPoint = {
		x: x,
		y: y,
		z: z,
	};
}
// Simplified test version of the KAD preview function
function drawKADTESTPreviewLine(ctx) {
	// Simple test: just check if any tool is active and draw a line
	const anyToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked || isPolygonSelectionActive;

	if (!anyToolActive) return;

	// Use mouse coordinates (they're 0 by default, not null)
	if (currentMouseWorldX === 0 && currentMouseWorldY === 0) return;

	// For testing, let's always use the center of the canvas as start point
	const testStartX = centroidX;
	const testStartY = centroidY;

	// Convert to canvas coordinates
	const [startCanvasX, startCanvasY] = worldToCanvas(testStartX, testStartY);
	const [mouseCanvasX, mouseCanvasY] = worldToCanvas(currentMouseWorldX, currentMouseWorldY);

	// Draw a bright red test line
	ctx.beginPath();
	ctx.setLineDash([10, 10]);
	ctx.strokeStyle = "rgba(255, 0, 0, 1.0)"; // Bright red
	ctx.lineWidth = 3;
	ctx.moveTo(startCanvasX, startCanvasY);
	ctx.lineTo(mouseCanvasX, mouseCanvasY);
	ctx.stroke();
	ctx.setLineDash([]);

	// Draw a circle at mouse position for debugging
	ctx.beginPath();
	ctx.arc(mouseCanvasX, mouseCanvasY, 5, 0, Math.PI * 2);
	ctx.fillStyle = "rgba(255, 0, 0, 1.0)";
	ctx.fill();
}

// Fix the drawKADCircles function around line 6450:
// Also update the drawKADTexts function to handle multiline calculations
/*** CODE TO DRAW POINTS FROM CSV DATA ***/

// Note: drawHexagon moved to src/draw/canvas2DDrawing.js

// Note: drawMultilineText moved to src/draw/canvas2DDrawing.js

// Note: drawDirectionArrow moved to src/draw/canvas2DDrawing.js

// Note: drawArrow moved to src/draw/canvas2DDrawing.js

// Note: drawArrowDelayText moved to src/draw/canvas2DDrawing.js
function drawDelauanySlopeMap(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.fillStyle = fillColor;
	ctx.lineWidth = 1;
	console.log("drawDelauanySlopeMap: " + triangles.length);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		const edge1 = {
			x: tBX - tAX,
			y: tBY - tAY,
			z: tBZ - tAZ,
		};
		const edge2 = {
			x: tCX - tAX,
			y: tCY - tAY,
			z: tCZ - tAZ,
		};
		const edge3 = {
			x: tCX - tBX,
			y: tCY - tBY,
			z: tCZ - tBZ,
		};

		// Calculate the maximum absolute slope angle for this triangle
		//const slopeAngles = [Math.abs(getEdgeSlopeAngle(triangle[0], triangle[1])), Math.abs(getEdgeSlopeAngle(triangle[1], triangle[2])), Math.abs(getEdgeSlopeAngle(triangle[2], triangle[0]))];
		//let maxSlopeAngle = Math.max(...slopeAngles);

		let maxSlopeAngle = getDipAngle(triangle);

		// Create a triangle array
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aAZ = tAZ;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aBZ = tBZ;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;
		const aCZ = tCZ;

		// Define the minimum and maximum RGB values (rgb(50, 50, 50) and rgb(200, 200, 200))
		const minRGB = [225, 225, 225];
		const maxRGB = [100, 100, 100];

		// Calculate the RGB values based on maxSlopeAngle using linear interpolation
		const r = Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const g = Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const b = Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		const ir = 255 - Math.round(minRGB[0] + (maxRGB[0] - minRGB[0]) * (maxSlopeAngle / 50));
		const ig = 255 - Math.round(minRGB[1] + (maxRGB[1] - minRGB[1]) * (maxSlopeAngle / 50));
		const ib = 255 - Math.round(minRGB[2] + (maxRGB[2] - minRGB[2]) * (maxSlopeAngle / 50));

		// Define the color ranges and corresponding RGB values
		let triangleFillColor;
		if (maxSlopeAngle >= 0 && maxSlopeAngle < 5) {
			// Cornflower blue for angles in the range [0, 4)
			triangleFillColor = "rgb(51, 139, 255)";
		} else if (maxSlopeAngle >= 5 && maxSlopeAngle < 7) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 102, 204)";
		} else if (maxSlopeAngle >= 7 && maxSlopeAngle < 9) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(0, 204, 204)";
		} else if (maxSlopeAngle >= 9 && maxSlopeAngle < 12) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(102, 204, 0)";
		} else if (maxSlopeAngle >= 12 && maxSlopeAngle < 15) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(204, 204, 0)";
		} else if (maxSlopeAngle >= 15 && maxSlopeAngle < 17) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 128, 0)";
		} else if (maxSlopeAngle >= 17 && maxSlopeAngle < 20) {
			// Green for angles in the range [7, 10]
			triangleFillColor = "rgb(255, 0, 0)";
		} else {
			// Default to grey for all other angles
			triangleFillColor = "rgb(153, 0, 76)";
		}

		// Combine the calculated RGB values into the final fill color
		// triangleFillColor = `rgb(${r}, ${g}, ${b})`;
		const triangleStrokeColor = `rgb(${r}, ${g}, ${b})`;
		// Invert the color by subtracting each channel value from 255
		const invertedColor = `rgb(${ir}, ${ig}, ${ib})`;

		ctx.strokeStyle = triangleStrokeColor;
		ctx.fillStyle = triangleFillColor;
		ctx.lineWidth = 1;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();

		ctx.lineWidth = 1;
	}
}

function drawDelauanyBurdenRelief(triangles, centroid, strokeColor) {
	if (!triangles || !Array.isArray(triangles) || triangles.length === 0) return;
	ctx.strokeStyle = strokeColor;
	ctx.lineWidth = 1;
	//console.log("drawDelauanyBurdenRelief: " + triangles.length);
	// const reliefResults = delaunayContourBurdenRelief(triangles, 20, 0);
	// console.log("Relief Results:", reliefResults);
	for (let i = 0; i < triangles.length; i++) {
		const triangle = triangles[i];
		const tAX = triangle[0][0];
		const tAY = triangle[0][1];
		const tAZ = triangle[0][2];
		const tBX = triangle[1][0];
		const tBY = triangle[1][1];
		const tBZ = triangle[1][2];
		const tCX = triangle[2][0];
		const tCY = triangle[2][1];
		const tCZ = triangle[2][2];

		// Find the earliest and latest times
		const earliestTime = Math.min(tAZ, tBZ, tCZ);
		const latestTime = Math.max(tAZ, tBZ, tCZ);

		// Calculate the time difference
		const timeDifference = latestTime - earliestTime; // ms

		// Determine which points correspond to the earliest and latest times
		let p1, p2;
		if (earliestTime === tAZ) {
			p1 = {
				x: tAX,
				y: tAY,
			};
		} else if (earliestTime === tBZ) {
			p1 = {
				x: tBX,
				y: tBY,
			};
		} else {
			p1 = {
				x: tCX,
				y: tCY,
			};
		}

		if (latestTime === tAZ) {
			p2 = {
				x: tAX,
				y: tAY,
			};
		} else if (latestTime === tBZ) {
			p2 = {
				x: tBX,
				y: tBY,
			};
		} else {
			p2 = {
				x: tCX,
				y: tCY,
			};
		}

		// Calculate the distance between the two points (earliest and latest)
		const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

		// Calculate burden relief in ms/m
		const burdenRelief = timeDifference / distance;

		//console.log("Time Difference (ms):", timeDifference);
		//console.log("Distance (m):", distance);
		//console.log("Burden Relief (ms/m):", burdenRelief);

		// Color mapping based on timing relief (adjust values as needed)
		let triangleFillColor;
		if (burdenRelief < 4) {
			triangleFillColor = "rgb(75, 20, 20)"; // fast
		} else if (burdenRelief < 7) {
			triangleFillColor = "rgb(255, 40, 40)";
		} else if (burdenRelief < 10) {
			triangleFillColor = "rgb(255, 120, 50)"; //
		} else if (burdenRelief < 13) {
			triangleFillColor = "rgb(255, 255, 50)"; //
		} else if (burdenRelief < 16) {
			triangleFillColor = "rgb(50, 255, 70)"; //
		} else if (burdenRelief < 19) {
			triangleFillColor = "rgb(50, 255, 200)"; //
		} else if (burdenRelief < 22) {
			triangleFillColor = "rgb(50, 230, 255)"; //
		} else if (burdenRelief < 25) {
			triangleFillColor = "rgb(50, 180, 255)"; //
		} else if (burdenRelief < 30) {
			triangleFillColor = "rgb(50, 100, 255)"; // Blue
		} else if (burdenRelief < 40) {
			triangleFillColor = "rgb(0, 0, 180)"; // Navy (actual dark blue)
		} else {
			triangleFillColor = "rgb(75, 0, 150)"; // Purple - slow
		}

		ctx.fillStyle = triangleFillColor;

		// Draw triangle
		const aAX = (tAX - centroid.x) * currentScale + canvas.width / 2;
		const aAY = (-tAY + centroid.y) * currentScale + canvas.height / 2;
		const aBX = (tBX - centroid.x) * currentScale + canvas.width / 2;
		const aBY = (-tBY + centroid.y) * currentScale + canvas.height / 2;
		const aCX = (tCX - centroid.x) * currentScale + canvas.width / 2;
		const aCY = (-tCY + centroid.y) * currentScale + canvas.height / 2;

		ctx.beginPath();
		ctx.moveTo(aAX, aAY);
		ctx.lineTo(aBX, aBY);
		ctx.lineTo(aCX, aCY);
		ctx.closePath();
		ctx.stroke();
		ctx.fill();
	}
}

function drawReliefLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function

	const legend0to4 = "rgb(75, 20, 20)"; // fast
	const legend4to7 = "rgb(255, 40, 40)";
	const legend7to10 = "rgb(255, 120, 50)"; //
	const legend10to13 = "rgb(255, 255, 50)"; //
	const legend13to16 = "rgb(50, 255, 70)"; //
	const legend16to19 = "rgb(50, 255, 200)"; //
	const legend19to22 = "rgb(50, 230, 255)"; //
	const legend22to25 = "rgb(50, 180, 255)"; //
	const legend25to30 = "rgb(50, 100, 255)"; //
	const legend30to40 = "rgb(50, 0, 255)"; //
	const legend40above = "rgb(75, 0, 150)"; // slow

	//draw the legend
	ctx.beginPath();
	ctx.fill();

	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Relief", 10, canvas.height / 2 - 70);
	ctx.fillText("0ms/m - 4ms/m", 10, canvas.height / 2 - 40);
	ctx.fillText("4ms/m - 7ms/m", 10, canvas.height / 2 - 10);
	ctx.fillText("7ms/m - 10ms/m", 10, canvas.height / 2 + 20);
	ctx.fillText("10ms/m - 13ms/m", 10, canvas.height / 2 + 50);
	ctx.fillText("13ms/m - 16ms/m", 10, canvas.height / 2 + 80);
	ctx.fillText("16ms/m - 19ms/m", 10, canvas.height / 2 + 110);
	ctx.fillText("19ms/m - 22ms/m", 10, canvas.height / 2 + 140);
	ctx.fillText("22ms/m - 25ms/m", 10, canvas.height / 2 + 170);
	ctx.fillText("25ms/m - 30ms/m", 10, canvas.height / 2 + 200);
	ctx.fillText("30ms/m - 40ms/m", 10, canvas.height / 2 + 230);
	ctx.fillText("40ms/m above", 10, canvas.height / 2 + 260);
	ctx.fillStyle = legend0to4;
	ctx.fillRect(130, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend4to7;
	ctx.fillRect(130, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to10;
	ctx.fillRect(130, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend10to13;
	ctx.fillRect(130, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend13to16;
	ctx.fillRect(130, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend16to19;
	ctx.fillRect(130, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend19to22;
	ctx.fillRect(130, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend22to25;
	ctx.fillRect(130, canvas.height / 2 + 155, 20, 20);
	ctx.fillStyle = legend25to30;
	ctx.fillRect(130, canvas.height / 2 + 185, 20, 20);
	ctx.fillStyle = legend30to40;
	ctx.fillRect(130, canvas.height / 2 + 215, 20, 20);
	ctx.fillStyle = legend40above;
	ctx.fillRect(130, canvas.height / 2 + 245, 20, 20);
	ctx.stroke();
}

function drawTriangleAngleText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let maxSlopeAngle = getDipAngle(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(maxSlopeAngle).toFixed(1), strokeColor);
}

function drawTriangleBurdenReliefText(triangle, centroid, strokeColor) {
	if (!triangle || !Array.isArray(triangle) || triangle.length !== 3) return;
	const triangleCentroid = calculateTriangleCentroid(triangle);
	let burdenRelief = getBurdenRelief(triangle);
	drawText((triangleCentroid.x - centroid.x) * currentScale + canvas.width / 2, (-triangleCentroid.y + centroid.y) * currentScale + canvas.height / 2, parseFloat(burdenRelief).toFixed(1), strokeColor);
}

function getAngleBetweenEdges(edge1, edge2) {
	const dotProduct = edge1.x * edge2.x + edge1.y * edge2.y + edge1.z * edge2.z;
	const magEdge1 = Math.sqrt(edge1.x * edge1.x + edge1.y * edge1.y + edge1.z * edge1.z);
	const magEdge2 = Math.sqrt(edge2.x * edge2.x + edge2.y * edge2.y + edge2.z * edge2.z);
	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero

	if (Math.abs(magEdge1) < epsilon || Math.abs(magEdge2) < epsilon) {
		// Handle the case where either edge is degenerate (magnitude close to zero)
		return 0;
	}

	let angle = Math.acos(dotProduct / (magEdge1 * magEdge2));
	return (angle * 180) / Math.PI;
}

function calculateTriangleCentroid(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];

	const triangleCentroid = {
		x: (tAX + tBX + tCX) / 3,
		y: (tAY + tBY + tCY) / 3,
		z: (tAZ + tBZ + tCZ) / 3,
	};
	return triangleCentroid;
}

function getDipAngle(triangle) {
	const edge1 = [triangle[1][0] - triangle[0][0], triangle[1][1] - triangle[0][1], triangle[1][2] - triangle[0][2]];
	const edge2 = [triangle[2][0] - triangle[0][0], triangle[2][1] - triangle[0][1], triangle[2][2] - triangle[0][2]];

	// Calculate the normal vector of the triangle's plane
	const normalVector = [edge1[1] * edge2[2] - edge1[2] * edge2[1], edge1[2] * edge2[0] - edge1[0] * edge2[2], edge1[0] * edge2[1] - edge1[1] * edge2[0]];

	// Calculate the dot product with the vertical direction (0, 0, 1)
	const dotProduct = normalVector[0] * 0 + normalVector[1] * 0 + normalVector[2] * 1;
	const magNormal = Math.sqrt(normalVector[0] ** 2 + normalVector[1] ** 2 + normalVector[2] ** 2);

	const epsilon = 1e-6; // Tolerance for checking if magnitude is close to zero
	if (Math.abs(magNormal) < epsilon) {
		// Handle degenerate case
		return 0;
	}

	const angleRadians = Math.acos(dotProduct / magNormal);
	const angleDegrees = (angleRadians * 180) / Math.PI;

	// Calculate the dip angle between the dot product and the horizontal plane (0 degrees)
	const dipAngle = 180 - angleDegrees;

	return dipAngle;
}

function getEdgeSlopeAngle(p1, p2) {
	const dx = p2[0] - p1[0];
	const dy = p2[1] - p1[1];
	const dz = p2[2] - p1[2]; // Consider the z-axis difference for vertical deviation
	const slopeAngleRadians = Math.atan2(dz, Math.sqrt(dx * dx + dy * dy));
	const slopeAngleDegrees = (slopeAngleRadians * 180) / Math.PI;
	return slopeAngleDegrees;
}

function getAngleBetweenPoints(p1, p2) {
	// Calculate the inferred point p3
	const p3 = [p1[0], p1[1], p2[2]];

	// Calculate the edges
	const edge1 = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
	const edge2 = [p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2]];

	// Calculate the angle between the edges
	const angleRadians = Math.acos((edge1[0] * edge2[0] + edge1[1] * edge2[1] + edge1[2] * edge2[2]) / (vectorMagnitude(edge1) * vectorMagnitude(edge2)));

	// Convert the angle to degrees
	const angleDegrees = (angleRadians * 180) / Math.PI;

	return angleDegrees;
}

function vectorMagnitude(vector) {
	return Math.sqrt(vector[0] ** 2 + vector[1] ** 2 + vector[2] ** 2);
}

function getBurdenRelief(triangle) {
	const tAX = triangle[0][0];
	const tAY = triangle[0][1];
	const tAZ = triangle[0][2];
	const tBX = triangle[1][0];
	const tBY = triangle[1][1];
	const tBZ = triangle[1][2];
	const tCX = triangle[2][0];
	const tCY = triangle[2][1];
	const tCZ = triangle[2][2];
	// Find the earliest and latest times
	const earliestTime = Math.min(tAZ, tBZ, tCZ);
	const latestTime = Math.max(tAZ, tBZ, tCZ);

	// Calculate the time difference
	const timeDifference = latestTime - earliestTime; // ms

	// Determine which points correspond to the earliest and latest times
	let p1, p2;
	if (earliestTime === tAZ) {
		p1 = {
			x: tAX,
			y: tAY,
		};
	} else if (earliestTime === tBZ) {
		p1 = {
			x: tBX,
			y: tBY,
		};
	} else {
		p1 = {
			x: tCX,
			y: tCY,
		};
	}

	if (latestTime === tAZ) {
		p2 = {
			x: tAX,
			y: tAY,
		};
	} else if (latestTime === tBZ) {
		p2 = {
			x: tBX,
			y: tBY,
		};
	} else {
		p2 = {
			x: tCX,
			y: tCY,
		};
	}

	// Calculate the distance between the two points (earliest and latest)
	const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

	// Calculate burden relief in ms/m
	const burdenRelief = timeDifference / distance;

	//console.log("Time Difference (ms):", timeDifference);
	//console.log("Distance (m):", distance);
	//console.log("Burden Relief (ms/m):", burdenRelief);
	return burdenRelief;
}

function drawMousePosition(x, y) {
	ctx.strokeStyle = strokeColor;
	ctx.beginPath();
	ctx.rect(x - 7, y - 7, 14, 14);
	ctx.lineWidth = 1;
	ctx.stroke();
}
//-------------------------SELECTION OF BLAST HOLES----------------------//
function getClickedHole(clickX, clickY) {
	// Step 2a) Only process 2D selection when 2D canvas is active
	if (onlyShowThreeJS) {
		// 3D mode is active, don't process 2D selection
		return null;
	}

	// Add null check at the very beginning
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null; // No holes to check
	}

	// Adjust the click coordinates based on the current scale and centroid
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY; // Invert the Y-coordinate
	// Calculate the distance threshold based on the scale factor

	//Create a constant called thresold set it to  (10/(currentScale/2).  If the value of thresold is less than 0.1 then set it to 0.1 else if it is greater than 2 set it to 2 else set it to 10/currentScale/2
	let threshold = 10 / (currentScale / 2);
	if (threshold > 0.2 && threshold <= 1.5) {
		10 / (currentScale / 2);
	} else if (threshold > 1.5) {
		threshold = 1.5;
	} else if (threshold < 0.2) {
		threshold = 0.2;
	}

	//keep an existing selection while the Move tool is active
	if (!isMultiHoleSelectionEnabled && !isMoveToolActive) {
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}

	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ? CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;
		let holeX = hole.startXLocation;
		let holeY = hole.startYLocation;
		let currentEntity = hole.entity;

		let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));
		if (distance > threshold) {
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Reset the selected hole ID
		}
	}
	if (isAddingConnector || isAddingMultiConnector) {
		// Loop through the points array to find the clicked hole
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			// Calculate the distance between the clicked point and the hole
			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			// Check if the distance is within the threshold
			if (distance <= threshold) {
				//Remove this if statement if the if & if else doesn't work
				if (firstSelectedHole == null) {
					firstSelectedHole = hole;
					secondSelectedHole = null;
				} else if (secondSelectedHole == null && firstSelectedHole != hole && hole != null) {
					secondSelectedHole = hole;
					firstSelectedHole = null;
				} else {
					firstSelectedHole = null;
					secondSelectedHole = hole;
				}
				return hole; // Return the clicked hole
			}
		}
		//calculateTimes(points);
	} else if (!isMultiHoleSelectionEnabled && isMeasureRecording) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID

				//

				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
	}
	//! IMPORTANT alway check if the bool needs to be put here for drawing to work.
	else if (!isMultiHoleSelectionEnabled && (isSelectionPointerActive || isPolygonSelectionActive || isHoleEditing || isLengthPopupEditing || isDeletingHole || isTypeEditing || isBlastNameEditing || isBearingToolActive || isMoveToolActive)) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			let hole = allBlastHoles[i];
			let holeX = hole.startXLocation;
			let holeY = hole.startYLocation;
			let holeXEnd = hole.endXLocation;
			let holeYEnd = hole.endYLocation;

			let distance = Math.sqrt(Math.pow(holeX - adjustedX, 2) + Math.pow(holeY - adjustedY, 2));

			if (distance <= threshold) {
				selectedHole = hole; // Update the selected hole ID
				// Update slider attributes here
				let holeNorthingSlider = document.getElementById("holeNorthingSlider");
				let holeEastingSlider = document.getElementById("holeEastingSlider");
				let holeElevationSlider = document.getElementById("holeElevationSlider");
				let holeLengthSlider = document.getElementById("holeLengthSlider");
				let holeDiameterSlider = document.getElementById("holeDiameterSlider");
				let holeAngleSlider = document.getElementById("holeAngleSlider");
				let holeBearingSlider = document.getElementById("holeBearingSlider");
				let holeSubdrillSlider = document.getElementById("holeSubdrillSlider");

				// Update slider attributes here

				holeEastingSlider.min = hole.startXLocation - 20;
				holeEastingSlider.max = hole.startXLocation + 20;
				holeEastingSlider.step = 0.1;

				holeNorthingSlider.min = hole.startYLocation - 20;
				holeNorthingSlider.max = hole.startYLocation + 20;
				holeNorthingSlider.step = 0.1;
				// Update slider attributes here

				holeElevationSlider.min = hole.startZLocation - 20;
				holeElevationSlider.max = hole.startZLocation + 20;
				holeElevationSlider.step = 0.1;

				//Length
				holeLengthSlider.step = 0.1;

				// Update slider attributes here
				holeAngleSlider.step = 1;

				// Update slider attributes here
				holeDiameterSlider.step = 1;

				// Update slider attributes here
				holeBearingSlider.step = 0.5;
				holeSubdrillSlider.step = 0.1;

				holeEastingSlider.value = hole.startXLocation;
				holeNorthingSlider.value = hole.startYLocation;
				holeElevationSlider.value = hole.startZLocation;
				holeLengthSlider.value = hole.holeLengthCalculated;
				holeDiameterSlider.value = hole.holeDiameter;
				holeAngleSlider.value = hole.holeAngle;
				holeBearingSlider.value = hole.holeBearing;
				holeSubdrillSlider.value = hole.subdrillAmount;

				holeEastingLabel.textContent = "Hole Easting (X) : " + parseFloat(hole.startXLocation).toFixed(2) + "mE";
				holeNorthingLabel.textContent = "Hole Northing (Y): " + parseFloat(hole.startYLocation).toFixed(2) + "mN";
				holeElevationLabel.textContent = "Hole Elevation (Z) : " + parseFloat(hole.startZLocation).toFixed(2) + "m";
				holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(hole.holeDiameter).toFixed(0) + "mm";
				holeLengthLabel.textContent = "Hole Length: " + parseFloat(hole.holeLengthCalculated).toFixed(1) + "m";
				holeAngleLabel.textContent = "Hole Angle: " + parseFloat(hole.holeAngle).toFixed(0) + "\u00B0";
				holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(hole.holeBearing).toFixed(1) + "\u00B0";
				holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(hole.subdrillAmount).toFixed(1) + "m";
				drawData(allBlastHoles, selectedHole);
				return hole; // Return the clicked hole
			}
		}
		if (isDisplayingContours) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}

			// directionArrows now contains the arrow data for later drawing
		}
		if (isDisplayingSlopeTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingReliefTriangles) {
			try {
				[resultTriangles, reliefTriangles] = delaunayTriangles(allBlastHoles, maxEdgeLength);
			} catch (error) {
				console.warn("Error calculating Delaunay triangles:", error);
			}
		}
		if (isDisplayingDirectionArrows) {
			try {
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
			} catch (error) {
				console.warn("Error calculating contour lines:", error);
			}
		}
		// If no hole is clicked or found within the threshold
		// Reset only the firstSelectedHole
		firstSelectedHole = null;
	}
	return null; // Return null if no hole is clicked
}

//-------------------------SELECTION OF BLAST HOLES IN 3D (with tolerance)----------------------//
// Step #) This function uses screen-space distance (like the snap torus) to find holes within tolerance
function getClickedHole3DWithTolerance(event) {
	console.log("‚¨áÔ∏è [3D HOLE TOLERANCE] getClickedHole3DWithTolerance called, onlyShowThreeJS=" + onlyShowThreeJS);

	// Step 1) Check if we're in 3D mode with required components
	if (!onlyShowThreeJS || !threeRenderer || !threeRenderer.camera) {
		console.log("‚¨áÔ∏è [3D HOLE TOLERANCE] Early exit: onlyShowThreeJS=" + onlyShowThreeJS + ", threeRenderer=" + !!threeRenderer);
		return null;
	}

	// Step 2) Get canvas and mouse position
	const canvas3D = threeRenderer.getCanvas();
	if (!canvas3D) return null;

	const rect = canvas3D.getBoundingClientRect();
	const mouseScreenX = event.clientX - rect.left;
	const mouseScreenY = event.clientY - rect.top;
	const canvasWidth = rect.width;
	const canvasHeight = rect.height;

	// Step 3) Get snap tolerance in pixels
	const tolerancePixels = snapRadiusPixels || 20;

	// Step 4) Get camera for projection
	const camera = threeRenderer.camera;

	// Step 5) Helper function to project world position to screen pixels
	var worldToScreen = function (worldX, worldY, worldZ) {
		// Convert world to Three.js local coordinates
		var localX = worldX - (window.threeLocalOriginX || window.dataCentroidX || 0);
		var localY = worldY - (window.threeLocalOriginY || window.dataCentroidY || 0);

		// Create vector and project to normalized device coordinates
		var vector = new THREE.Vector3(localX, localY, worldZ);
		vector.project(camera);

		// Convert NDC (-1 to +1) to screen pixels (0 to width/height)
		var screenX = ((vector.x + 1) * canvasWidth) / 2;
		var screenY = ((-vector.y + 1) * canvasHeight) / 2; // Invert Y for screen coords

		return { x: screenX, y: screenY };
	};

	// Step 6) Search all holes for closest one within tolerance
	var closestHole = null;
	var closestDistance = Infinity;

	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach(function (hole) {
			// Skip hidden holes
			if (!isHoleVisible(hole)) return;

			// Step 6a) Project hole collar to screen space
			var collarScreen = worldToScreen(
				hole.startXLocation,
				hole.startYLocation,
				hole.startZLocation || 0
			);

			// Step 6b) Calculate screen distance to mouse
			var dx = collarScreen.x - mouseScreenX;
			var dy = collarScreen.y - mouseScreenY;
			var screenDistance = Math.sqrt(dx * dx + dy * dy);

			// Step 6c) Check if within tolerance and closer than previous best
			if (screenDistance <= tolerancePixels && screenDistance < closestDistance) {
				closestDistance = screenDistance;
				closestHole = hole;
			}
		});
	}

	// Step 7) Return closest hole if found within tolerance
	if (closestHole) {
		if (developerModeEnabled) {
			console.log("‚¨áÔ∏è [3D HOLE] Found hole " + closestHole.holeID + " at screen distance " + closestDistance.toFixed(1) + "px (tolerance: " + tolerancePixels + "px)");
		}
		return closestHole;
	}

	return null;
}

//------------------MULTIPLE SELECTION OF BLAST HOLES----------------------//
function getMultipleClickedHoles(clickX, clickY) {
	if (!isMultiHoleSelectionEnabled) {
		return selectedMultipleHoles || [];
	}

	// Prevent selection modification if called during a mouse move that's not intended to change selection
	if (isUpdatingSelectionFromMove) {
		return selectedMultipleHoles || [];
	}

	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = Math.max(Math.min(10 / (currentScale / 2), 1.5), 0.2);

	let holesWithinThreshold = [];
	for (let i = 0; i < allBlastHoles.length; i++) {
		let hole = allBlastHoles[i];
		// ? CHECK VISIBILITY FIRST - Skip hidden holes
		if (!isHoleVisible(hole)) continue;

		let distance = Math.sqrt((hole.startXLocation - adjustedX) ** 2 + (hole.startYLocation - adjustedY) ** 2);
		if (distance < threshold) {
			holesWithinThreshold.push(hole);
		}
	}
	// Fix null reference issue - initialize selectedMultipleHoles if null
	if (!selectedMultipleHoles) {
		selectedMultipleHoles = [];
	}

	holesWithinThreshold.forEach((hole) => {
		if (!selectedMultipleHoles.includes(hole)) {
			selectedMultipleHoles.push(hole);
		} else {
			selectedMultipleHoles = selectedMultipleHoles.filter((h) => h !== hole);
			// Add UI feedback for deselection here
		}
		drawData(allBlastHoles, selectedHole);
	});

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let eastingAverage = 0;
	let northingAverage = 0;
	let elevationAverage = 0;
	let lengthAverage = 0;
	let diameterAverage = 0;
	let angleAverage = 0;
	let bearingAverage = 0;
	let subdrillSum = 0;
	let subdrillAverage = 0;

	if (isMultiHoleSelectionEnabled && (isHoleEditing || isPolygonSelectionActive || isSelectionPointerActive || isDeletingHole || isBlastNameEditing || isTypeEditing || isLengthPopupEditing)) {
		console.log("Selected Multiple Holes: ", selectedMultipleHoles);
		selectedMultipleHoles.forEach((hole) => {
			// Average the values of the selected holes in the selectedMultipleHoles array
			// Update slider attributes with the averaged values for each attribute
			// Update the UI labels with the averaged values for each attribute
			//console.log(selectedMultipleHoles);
			eastingSum += parseFloat(hole.startXLocation);
			northingSum += parseFloat(hole.startYLocation);
			elevationSum += parseFloat(hole.startZLocation);
			lengthSum += parseFloat(hole.holeLengthCalculated);
			diameterSum += parseFloat(hole.holeDiameter);
			angleSum += parseFloat(hole.holeAngle);
			bearingSum += parseFloat(hole.holeBearing);
			subdrillSum += parseFloat(hole.subdrillAmount);
			//console.log("Sums: \n   ", eastingSum, "\n   y", northingSum, "\n   z", elevationSum, "\n   l", lengthSum, "\n   d", diameterSum, "\n   a", angleSum, "\n   b", bearingSum);
			//console.log("Length: " + selectedMultipleHoles.length);

			eastingAverage = selectedMultipleHoles.length > 1 ? parseFloat(eastingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(eastingSum);
			northingAverage = selectedMultipleHoles.length > 1 ? parseFloat(northingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(northingSum);
			elevationAverage = selectedMultipleHoles.length > 1 ? parseFloat(elevationSum) / parseInt(selectedMultipleHoles.length) : parseFloat(elevationSum);
			lengthAverage = selectedMultipleHoles.length > 1 ? parseFloat(lengthSum) / parseInt(selectedMultipleHoles.length) : parseFloat(lengthSum);
			diameterAverage = selectedMultipleHoles.length > 1 ? parseFloat(diameterSum) / parseInt(selectedMultipleHoles.length) : parseFloat(diameterSum);
			angleAverage = selectedMultipleHoles.length > 1 ? parseFloat(angleSum) / parseInt(selectedMultipleHoles.length) : parseFloat(angleSum);
			bearingAverage = selectedMultipleHoles.length > 1 ? parseFloat(bearingSum) / parseInt(selectedMultipleHoles.length) : parseFloat(bearingSum);
			subdrillAverage = selectedMultipleHoles.length > 1 ? parseFloat(subdrillSum) / parseInt(selectedMultipleHoles.length) : parseFloat(subdrillSum);

			//console.log("Averages: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);

			holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
			holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
			holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
			holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
			holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
			holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
			holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
			holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";
			//set the min max range to a value either side the average value
			holeEastingSlider.min = eastingAverage - 20;
			holeEastingSlider.max = eastingAverage + 20;
			holeNorthingSlider.min = northingAverage - 20;
			holeNorthingSlider.max = northingAverage + 20;
			holeElevationSlider.min = elevationAverage - 20;
			holeElevationSlider.max = elevationAverage + 20;
			//set the value of the slider
			holeEastingSlider.value = eastingAverage;
			holeNorthingSlider.value = northingAverage;
			holeElevationSlider.value = elevationAverage;
			holeLengthSlider.value = lengthAverage;
			holeDiameterSlider.value = diameterAverage;
			holeAngleSlider.value = angleAverage;
			holeBearingSlider.value = bearingAverage;
			holeSubdrillSlider.value = subdrillAverage;
			//console.log("Averages 2: \n   x", eastingAverage, "\n   y", northingAverage, "\n   z", elevationAverage, "\n   l", lengthAverage, "\n   d", diameterAverage, "\n   a", angleAverage, "\n   b", bearingAverage);
		});
	}

	return selectedMultipleHoles || [];
}

// New function to handle averaging and slider updates
function updateSelectionAveragesAndSliders(selectedHoles) {
	if (!selectedHoles || selectedHoles.length === 0) return;

	let eastingSum = 0;
	let northingSum = 0;
	let elevationSum = 0;
	let lengthSum = 0;
	let diameterSum = 0;
	let angleSum = 0;
	let bearingSum = 0;
	let subdrillSum = 0;

	// Calculate sums
	selectedHoles.forEach((hole) => {
		eastingSum += parseFloat(hole.startXLocation);
		northingSum += parseFloat(hole.startYLocation);
		elevationSum += parseFloat(hole.startZLocation);
		lengthSum += parseFloat(hole.holeLengthCalculated);
		diameterSum += parseFloat(hole.holeDiameter);
		angleSum += parseFloat(hole.holeAngle);
		bearingSum += parseFloat(hole.holeBearing);
		subdrillSum += parseFloat(hole.subdrillAmount);
	});

	// Calculate averages
	const count = selectedHoles.length;
	const eastingAverage = count > 1 ? eastingSum / count : eastingSum;
	const northingAverage = count > 1 ? northingSum / count : northingSum;
	const elevationAverage = count > 1 ? elevationSum / count : elevationSum;
	const lengthAverage = count > 1 ? lengthSum / count : lengthSum;
	const diameterAverage = count > 1 ? diameterSum / count : diameterSum;
	const angleAverage = count > 1 ? angleSum / count : angleSum;
	const bearingAverage = count > 1 ? bearingSum / count : bearingSum;
	const subdrillAverage = count > 1 ? subdrillSum / count : subdrillSum;

	// Update labels
	holeEastingLabel.textContent = "Hole Easting av(X) : " + parseFloat(eastingAverage).toFixed(2) + "mE";
	holeNorthingLabel.textContent = "Hole Northing av(Y): " + parseFloat(northingAverage).toFixed(2) + "mN";
	holeElevationLabel.textContent = "Hole Elevation av(Z) : " + parseFloat(elevationAverage).toFixed(2) + "m";
	holeDiameterLabel.textContent = "Hole Diameter: " + parseFloat(diameterAverage).toFixed(0) + "mm";
	holeLengthLabel.textContent = "Hole Length: " + parseFloat(lengthAverage).toFixed(1) + "m";
	holeAngleLabel.textContent = "Hole Angle: " + parseFloat(angleAverage).toFixed(0) + "\u00B0";
	holeBearingLabel.textContent = "Hole Bearing: " + parseFloat(bearingAverage).toFixed(1) + "\u00B0";
	holeSubdrillLabel.textContent = "Hole Subdrill: " + parseFloat(subdrillAverage).toFixed(1) + "m";

	// Update slider ranges
	holeEastingSlider.min = eastingAverage - 20;
	holeEastingSlider.max = eastingAverage + 20;
	holeNorthingSlider.min = northingAverage - 20;
	holeNorthingSlider.max = northingAverage + 20;
	holeElevationSlider.min = elevationAverage - 20;
	holeElevationSlider.max = elevationAverage + 20;

	// Update slider values
	holeEastingSlider.value = eastingAverage;
	holeNorthingSlider.value = northingAverage;
	holeElevationSlider.value = elevationAverage;
	holeLengthSlider.value = lengthAverage;
	holeDiameterSlider.value = diameterAverage;
	holeAngleSlider.value = angleAverage;
	holeBearingSlider.value = bearingAverage;
	holeSubdrillSlider.value = subdrillAverage;
}

const colorConnectorElement = document.getElementById("connectorColor");
const floatingConnectorColorElement = document.getElementById("floatingConnectorColor");
const colorDrawingElement = document.getElementById("drawingColor");

function getJSColorHexDrawing() {
	// Get the JSColor instance from the element
	const jsColorInstance = colorDrawingElement.jscolor;
	// Get the color value
	const colorHex = jsColorInstance.toHEXString(); // This will get the color in HEX format, e.g., "#FF0000"
	return colorHex;
}

// Wait for DOM, then set up color picker syncing
document.addEventListener("DOMContentLoaded", function () {
	// Step #) Sync Connector Color pickers (existing)
	if (colorConnectorElement && colorConnectorElement.jscolor && floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		// Sync from the main color picker to the floating one
		colorConnectorElement.jscolor.option("onInput", function () {
			// 'this' refers to the jscolor instance that triggered the event
			floatingConnectorColorElement.jscolor.fromString(this.toHEXString());
		});

		// Sync from the floating color picker to the main one
		floatingConnectorColorElement.jscolor.option("onInput", function () {
			colorConnectorElement.jscolor.fromString(this.toHEXString());
		});
	}

	// Step #) Sync KAD Drawing Color pickers (floatingKADColor <-> drawingColor)
	var floatingKADColorElement = document.getElementById("floatingKADColor");
	if (colorDrawingElement && colorDrawingElement.jscolor && floatingKADColorElement && floatingKADColorElement.jscolor) {
		// Sync from main drawingColor to floatingKADColor
		colorDrawingElement.jscolor.option("onInput", function () {
			floatingKADColorElement.jscolor.fromString(this.toHEXString());
		});

		// Sync from floatingKADColor to main drawingColor
		floatingKADColorElement.jscolor.option("onInput", function () {
			colorDrawingElement.jscolor.fromString(this.toHEXString());
		});
	}

	// Step #) Sync Elevation inputs (drawingElevationToolbar <-> drawingElevation)
	var drawingElevationToolbarElement = document.getElementById("drawingElevationToolbar");
	var drawingElevationElement = document.getElementById("drawingElevation");
	if (drawingElevationToolbarElement && drawingElevationElement) {
		// Sync from main drawingElevation to toolbar
		drawingElevationElement.addEventListener("input", function () {
			drawingElevationToolbarElement.value = this.value;
		});
		drawingElevationElement.addEventListener("change", function () {
			drawingElevationToolbarElement.value = this.value;
		});

		// Sync from toolbar to main drawingElevation
		drawingElevationToolbarElement.addEventListener("input", function () {
			drawingElevationElement.value = this.value;
			drawingZValue = parseFloat(this.value) || 0.0;
		});
		drawingElevationToolbarElement.addEventListener("change", function () {
			drawingElevationElement.value = this.value;
			drawingZValue = parseFloat(this.value) || 0.0;
		});
	}

	// Step #) Sync Radius inputs (drawingKADRadiusToolbar <-> drawingRadius)
	var drawingKADRadiusToolbarElement = document.getElementById("drawingKADRadiusToolbar");
	var drawingRadiusElement = document.getElementById("drawingRadius");
	if (drawingKADRadiusToolbarElement && drawingRadiusElement) {
		// Sync from main drawingRadius to toolbar
		drawingRadiusElement.addEventListener("input", function () {
			drawingKADRadiusToolbarElement.value = this.value;
		});
		drawingRadiusElement.addEventListener("change", function () {
			drawingKADRadiusToolbarElement.value = this.value;
		});

		// Sync from toolbar to main drawingRadius
		drawingKADRadiusToolbarElement.addEventListener("input", function () {
			drawingRadiusElement.value = this.value;
		});
		drawingKADRadiusToolbarElement.addEventListener("change", function () {
			drawingRadiusElement.value = this.value;
		});
	}

	// Step #) Sync holesAddingTool with addHoleSwitch (two-way)
	var holesAddingToolElement = document.getElementById("holesAddingTool");
	var addHoleSwitchElement = document.getElementById("addHoleSwitch");
	if (holesAddingToolElement && addHoleSwitchElement) {
		// When sidenav addHoleSwitch changes, update floating toolbar
		addHoleSwitchElement.addEventListener("change", function () {
			holesAddingToolElement.checked = this.checked;
		});
	}
});

function getJSColorHex() {
	// Try floating first, then main
	if (floatingConnectorColorElement && floatingConnectorColorElement.jscolor) {
		return floatingConnectorColorElement.jscolor.toHEXString();
	}
	if (colorConnectorElement && colorConnectorElement.jscolor) {
		return colorConnectorElement.jscolor.toHEXString();
	}
	return "#FF0000"; // Default fallback
}

const delayElement = document.getElementById("delay");
const floatingDelayElement = document.getElementById("floatingDelay");

delayElement.addEventListener("input", function () {
	floatingDelayElement.value = this.value;
});

floatingDelayElement.addEventListener("input", function () {
	delayElement.value = this.value;
});

function getDelayValue() {
	// Return the floating delay if it exists and has a value, otherwise use main delay
	if (floatingDelayElement && floatingDelayElement.value) {
		return parseInt(floatingDelayElement.value);
	}
	if (delayElement && delayElement.value) {
		return parseInt(delayElement.value);
	}
	return 0; // Default fallback value
}

function handleConnectorClick(event) {
	console.log("‚¨áÔ∏è [CONNECTOR CLICK] handleConnectorClick called, onlyShowThreeJS=" + onlyShowThreeJS + ", isAddingMultiConnector=" + isAddingMultiConnector);

	// Step 1) Get the click/touch coordinates relative to the canvas
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// Step 2) Use 3D tolerance-based selection when in 3D mode, otherwise use 2D
	var clickedHole = null;
	if (onlyShowThreeJS) {
		// Step 2a) 3D mode: use screen-space tolerance selection (like snap torus)
		console.log("‚¨áÔ∏è [CONNECTOR CLICK] Using 3D tolerance selection...");
		clickedHole = getClickedHole3DWithTolerance(event);
		console.log("‚¨áÔ∏è [CONNECTOR CLICK] 3D result: " + (clickedHole ? clickedHole.holeID : "null"));
		if (developerModeEnabled && clickedHole) {
			console.log("‚¨áÔ∏è [CONNECTOR 3D] Selected hole: " + clickedHole.holeID + " in entity: " + clickedHole.entityName);
		}
	} else {
		// Step 2b) 2D mode: use standard 2D selection
		clickedHole = getClickedHole(clickX, clickY);
	}

	if (isAddingConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				selectedHole = clickedHole;
				const delay = getDelayValue();
				const clickedHoleIndex = allBlastHoles.findIndex((hole) => hole === clickedHole);

				if (clickedHoleIndex !== -1) {
					// Use the new combined format for fromHoleID
					allBlastHoles[clickedHoleIndex].fromHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;
					allBlastHoles[clickedHoleIndex].timingDelayMilliseconds = delay;
					allBlastHoles[clickedHoleIndex].colorHexDecimal = getJSColorHex();
				}
				fromHoleStore = null;
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step #) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Save connector changes to IndexedDB
				debouncedSaveHoles();

				// directionArrows now contains the arrow data for later drawing
				timeChart();

				// Step #) Trigger 3D rebuild to update connectors
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, selectedHole);
			}
		}
	} else if (isAddingMultiConnector) {
		if (clickedHole) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				// TODO: Update UI or provide feedback for selecting fromHole
			} else {
				const selectedHole = clickedHole;
				const pointsInLine = getPointsInLine(fromHoleStore, selectedHole);
				if (pointsInLine.length > 0) {
					connectHolesInLine(pointsInLine);
				}
				// Reset the fromHole and exit add connector mode
				fromHoleStore = null;
				// RECALCULATE TIMING, CONTOURS AND DIRECTION ARROWS
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, deltaX, deltaY);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;

				// Step #) Update contour overlay to reflect new timing
				updateOverlayColorsForTheme();

				// Save multi-connector changes to IndexedDB
				debouncedSaveHoles();

				// Update timing chart display
				timeChart();

				// Step #) Trigger 3D rebuild to update connectors
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
	}
}

function getPointsInLine(startPoint, endPoint, tolerance) {
	const pointsInLine = [];
	tolerance = connectAmount;
	const dx = endPoint.startXLocation - startPoint.startXLocation;
	const dy = endPoint.startYLocation - startPoint.startYLocation;
	const length = Math.sqrt(dx * dx + dy * dy);
	const dirX = dx / length;
	const dirY = dy / length;
	const points = allBlastHoles; //Assign the point as allBlastHoles

	for (const point of points) {
		if (point !== startPoint && point !== endPoint) {
			const vecX = point.startXLocation - startPoint.startXLocation;
			const vecY = point.startYLocation - startPoint.startYLocation;
			const dotProduct = vecX * dirX + vecY * dirY;
			if (dotProduct >= 0 && dotProduct <= length) {
				const distanceToLine = Math.abs(vecX * dirY - vecY * dirX);
				if (distanceToLine <= tolerance) {
					pointsInLine.push(point);
				}
			}
		}
	}

	// Add start and end points to the array
	pointsInLine.unshift(startPoint);
	pointsInLine.push(endPoint);

	return pointsInLine;
}

function connectHolesInLine(pointsInLine) {
	// Sort points based on distance from the fromHoleStore
	pointsInLine.sort((a, b) => {
		const distanceA = calculateDistance(fromHoleStore, a);
		const distanceB = calculateDistance(fromHoleStore, b);
		return distanceA - distanceB;
	});

	let previousHoleID = `${fromHoleStore.entityName}:::${fromHoleStore.holeID}`;

	// Connect each point to the previous point
	for (let i = 1; i < pointsInLine.length; i++) {
		const hole = pointsInLine[i];
		const holeIndex = allBlastHoles.findIndex((h) => h === hole);

		if (holeIndex !== -1) {
			allBlastHoles[holeIndex].fromHoleID = previousHoleID;
			allBlastHoles[holeIndex].timingDelayMilliseconds = getDelayValue();
			allBlastHoles[holeIndex].colorHexDecimal = getJSColorHex();
		}

		previousHoleID = `${hole.entityName}:::${hole.holeID}`;
	}
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, deltaX, deltaY);
	contourLinesArray = result.contourLinesArray;
	directionArrows = result.directionArrows;
	// Step #) Update contour overlay to reflect new timing
	updateOverlayColorsForTheme();
	timeChart();
	drawData(allBlastHoles, selectedHole);
}

// Function to calculate the distance between two points
function calculateDistance(point1, point2) {
	const dx = point2.startXLocation - point1.startXLocation;
	const dy = point2.startYLocation - point1.startYLocation;
	return Math.sqrt(dx * dx + dy * dy);
}

//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPointInMap(map, clickX, clickY) {
	const adjustedX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const adjustedY = -(clickY - canvas.height / 2) / currentScale + centroidY;
	let threshold = 10 / (currentScale / 2);
	let closestPoint = null;
	let minDistance = threshold;

	// Iterate over the keys of the map
	for (const entityName of map.keys()) {
		const entity = map.get(entityName);
		for (const point of entity.data) {
			const distance = Math.sqrt(Math.pow(point.pointXLocation - adjustedX, 2) + Math.pow(point.pointYLocation - adjustedY, 2));

			if (distance <= threshold && distance < minDistance) {
				closestPoint = point;
				minDistance = distance;
			}
		}
	}
	drawData(allBlastHoles, selectedHole);
	return closestPoint;
}
//-------------------------SELECTION OF POINTS IN MAP----------------------//
function getClickedPoint(event) {
	// get the values from clicking in the canvas
	const rect = canvas.getBoundingClientRect();
	let clickX = event.clientX - rect.left;
	let clickY = event.clientY - rect.top;
	if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
		// Handle the case when the values are NaN
		clickX = event.changedTouches[0].clientX - rect.left;
		clickY = event.changedTouches[0].clientY - rect.top;
	} else {
		// Proceed with the calculation using the valid values
		clickX = event.clientX - rect.left;
		clickY = event.clientY - rect.top;
	}
	// SNAPPIN SNAP CODE:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isDeletingKAD) {
		selectedPoint = getClickedPointInMap(allKADDrawingsMap, clickX, clickY);
		drawData(allBlastHoles, selectedHole);
		return selectedPoint;
	}

	drawData(allBlastHoles, selectedHole);
	// If none of the flags match, return null
	return null;
}

/**

 * Offsets a selected object (line or polyline) by a specified amount in a given direction
 * @param {Map} map - The map containing all KAD drawings
 * @param {Object} selectedPoint - The selected point object containing entity info
 * @param {string} direction - Direction to offset ("right", "left", "up", "down")
 * @param {number} offsetAmount - Distance to offset in map units
 * @param {boolean} [checkForCrossover=false] - Whether to check and prevent line segment crossovers
 * @param {boolean} [extendIfNecessary=false] - Whether to extend line segments that get too far apart
 * @returns {Object|undefined} The newly created offset entity, or undefined if no point selected
 */
function offsetObjectWithSelectedPoint(map, selectedPoint, direction, offsetAmount, checkForCrossover = false, extendIfNecessary = false) {
	if (selectedPoint) {
		const entityName = selectedPoint.entityName;
		const entityType = selectedPoint.entityType;

		// Create a new entity for the offset polyline
		const newEntity = {
			entityName: `${entityName}_offset`, // Modify this as needed
			entityType: entityType,
			data: [],
		};

		let prevPoint = null;

		// Offset and check for crossovers if needed
		for (const point of selectedPoint.data) {
			let offsetX = point.pointXLocation;
			let offsetY = point.pointYLocation;

			if (direction === "right") {
				offsetX += offsetAmount;
			} else if (direction === "left") {
				offsetX -= offsetAmount;
			} else if (direction === "up") {
				offsetY -= offsetAmount;
			} else if (direction === "down") {
				offsetY += offsetAmount;
			}

			if (checkForCrossover && prevPoint) {
				// Check for crossover and shorten the segment if needed
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					const ratio = offsetAmount / distance;
					offsetX = prevPoint.pointXLocation + (offsetX - prevPoint.pointXLocation) * ratio;
					offsetY = prevPoint.pointYLocation + (offsetY - prevPoint.pointYLocation) * ratio;
				}
			}

			// Add the offset point to the new entity
			newEntity.data.push({
				entityName: newEntity.entityName,
				entityType: newEntity.entityType,
				pointID: point.pointID, // Preserve point ID or modify as needed
				pointXLocation: offsetX,
				pointYLocation: offsetY,
				pointZLocation: point.pointZLocation,
				lineWidth: point.lineWidth,
				color: point.color,
			});

			if (extendIfNecessary && prevPoint) {
				const distance = Math.sqrt(Math.pow(offsetX - prevPoint.pointXLocation, 2) + Math.pow(offsetY - prevPoint.pointYLocation, 2));

				if (distance > offsetAmount) {
					// Extend the line segment if points get further away after offsetting
					newEntity.data.push({
						entityName: newEntity.entityName,
						entityType: newEntity.entityType,
						pointID: point.pointID, // Preserve point ID or modify as needed
						pointXLocation: offsetX,
						pointYLocation: offsetY,
						pointZLocation: point.pointZLocation,
						lineWidth: point.lineWidth,
						color: point.color,
					});
				}
			}

			prevPoint = point;
		}

		// Add the new entity to the appropriate map (line or poly)
		if (entityType === "poly") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		} else if (entityType === "line") {
			allKADDrawingsMap.set(newEntity.entityName, newEntity);
		}

		// Redraw the canvas or perform any other necessary updates
		drawData(allBlastHoles, selectedHole);

		// Return the newly created entity if needed
		return newEntity;
	}
}

function deleteSelectedPoint() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("‚ùå Cannot delete point from hidden entity: " + entityName);
			return;
		}
		deletePointInMap(allKADDrawingsMap, selectedPoint);
	}
}

// Helper function to get entity name from selected point
function getEntityNameFromSelectedPoint(selectedPoint) {
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entityName;
		}
	}
	return null;
}

// Helper function to determine entity type from selected point
function getEntityTypeFromSelectedPoint(selectedPoint) {
	// Find which entity this point belongs to
	for (const [entityName, entity] of allKADDrawingsMap.entries()) {
		const foundPoint = entity.data.find((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation);
		if (foundPoint) {
			return entity.entityType;
		}
	}
	return null;
}

function deleteSelectedObject() {
	if (selectedPoint && isDeletingKAD) {
		// Check if the entity containing this point is visible
		const entityName = getEntityNameFromSelectedPoint(selectedPoint);
		if (entityName && !isEntityVisible(entityName)) {
			console.log("‚ùå Cannot delete object from hidden entity: " + entityName);
			return;
		}
		deleteObjectInMap(allKADDrawingsMap, selectedPoint);
		// ADD THIS: Save after delete
		debouncedSaveKAD();
	}
}

function deleteSelectedAll() {
	if (selectedPoint && isDeletingKAD) {
		// Determine entity type from the selected point
		const entityType = getEntityTypeFromSelectedPoint(selectedPoint);
		if (entityType) {
			// Only delete visible entities of this type
			const visibleEntitiesToDelete = [];
			for (const [entityName, entity] of allKADDrawingsMap.entries()) {
				if (entity.entityType === entityType && isEntityVisible(entityName)) {
					visibleEntitiesToDelete.push(entityName);
				}
			}

			if (visibleEntitiesToDelete.length === 0) {
				console.log("‚ùå No visible entities of type " + entityType + " to delete");
				return;
			}

			// Delete only visible entities
			visibleEntitiesToDelete.forEach((entityName) => {
				allKADDrawingsMap.delete(entityName);
			});

			console.log("üóëÔ∏è Deleted " + visibleEntitiesToDelete.length + " visible " + entityType + " entities");
			// ADD THIS: Save after delete all of type
			debouncedSaveKAD();
		}
	}
}

// Enhanced function to delete only specific entity types and clear selection
function deleteAllOfType(map, entityType) {
	const entitiesToDelete = [];
	let shouldClearSelection = false;

	// Find all entities of the specified type
	for (const [entityName, entity] of map.entries()) {
		if (entity.entityType === entityType) {
			entitiesToDelete.push(entityName);

			// Check if the selected point belongs to this entity
			if (selectedPoint && entity.data.some((point) => point.pointID === selectedPoint.pointID && point.pointXLocation === selectedPoint.pointXLocation && point.pointYLocation === selectedPoint.pointYLocation)) {
				shouldClearSelection = true;
			}
		}
	}

	// Delete them
	entitiesToDelete.forEach((entityName) => {
		map.delete(entityName);
		console.log(`Deleted ${entityType} entity: ${entityName}`);
	});

	// Clear selection if the selected point was deleted
	if (shouldClearSelection) {
		selectedPoint = null;
		selectedKADObject = null; // Clear this too if it exists
		selectedKADPolygon = null; // And this one
	}

	updateStatusMessage(`Deleted ${entitiesToDelete.length} ${entityType} entities`);
	drawData(allBlastHoles, selectedHole);
	setTimeout(() => updateStatusMessage(""), 2000);
}

// Replace the deletePointInMap function around line 9227
function deletePointInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const dataIndex = entity.data.findIndex((point) => {
			return point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation;
		});

		if (dataIndex !== -1) {
			entity.data.splice(dataIndex, 1);
			updateStatusMessage("Deleted point " + pointToDelete.pointID + " from " + entity.entityType);

			// ? ADD: Renumber remaining points sequentially starting from 1
			renumberEntityPoints(entity);

			// If entity has no more points, delete the entire entity
			if (entity.data.length === 0) {
				map.delete(entityName);
				updateStatusMessage("Deleted empty " + entity.entityType + " entity: " + entityName);
			}

			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete point
			debouncedSaveKAD();
			break;
		}
	}
}

// ? ADD: New function to renumber points in an entity
function renumberEntityPoints(entity) {
	if (!entity || !entity.data || entity.data.length === 0) return;

	// Renumber all points sequentially starting from 1
	for (let i = 0; i < entity.data.length; i++) {
		entity.data[i].pointID = i + 1;
	}

	console.log("‚úÖ Renumbered " + entity.data.length + " points in " + entity.entityType + " entity");
}

function deleteObjectInMap(map, pointToDelete) {
	for (const [entityName, entity] of map) {
		const foundPoint = entity.data.find((point) => point.pointID === pointToDelete.pointID && point.pointXLocation === pointToDelete.pointXLocation && point.pointYLocation === pointToDelete.pointYLocation);

		if (foundPoint) {
			map.delete(entityName);
			updateStatusMessage(`Deleted ${entity.entityType} entity: ${entityName}`);
			selectedPoint = null;
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => updateStatusMessage(""), 2000);
			// ADD THIS: Save after delete object
			debouncedSaveKAD();
			break;
		}
	}
}

function deleteAllInMap(map) {
	map.clear();
	selectedPoint = null;
	drawData(allBlastHoles, selectedHole);
	// ADD THIS: Save after delete all in map
	debouncedSaveKAD();
}

function deleteSelectedHoles() {
	let holesWereActuallyDeleted = false; // To track if the allBlastHoles array was modified

	if (isDeletingHole) {
		const entitiesToRenumber = new Set(); // Store unique entity names that need renumbering
		const deletedCombinedIDs = new Set(); // Track deleted holes for fromHoleID cleanup

		if (selectedMultipleHoles.length > 0) {
			console.log("Processing deletion for " + selectedMultipleHoles.length + " selected holes.");
			const originalPointsLength = allBlastHoles.length;

			// Create a Set of hole references for efficient filtering
			const holesToDeleteReferences = new Set(selectedMultipleHoles);

			allBlastHoles = allBlastHoles.filter((hole) => {
				if (holesToDeleteReferences.has(hole)) {
					//console.log("Deleting Hole ID:", point.holeID, "in:", point.entityName);
					deletedCombinedIDs.add(hole.entityName + ":::" + hole.holeID);
					if (isRenumberingHoles) {
						entitiesToRenumber.add(hole.entityName);
					}
					return false; // Exclude this point (effectively deleting it)
				}
				return true; // Keep this point
			});

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
			}

			// Clear selections after processing
			selectedMultipleHoles = [];
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = [] // Ensure single selection is also cleared
		} else if (selectedHole !== null) {
			//console.log("Processing deletion for single Hole ID:", selectedHole.holeID, "in:", selectedHole.entityName);
			const holeToRemove = selectedHole; // Cache before selectedHole is nulled
			deletedCombinedIDs.add(holeToRemove.entityName + ":::" + holeToRemove.holeID);
			const originalPointsLength = allBlastHoles.length;

			allBlastHoles = allBlastHoles.filter((hole) => hole !== holeToRemove);

			if (allBlastHoles.length < originalPointsLength) {
				holesWereActuallyDeleted = true;
				if (isRenumberingHoles) {
					entitiesToRenumber.add(holeToRemove.entityName);
				}
			}
			// Clear selection after processing
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
		}

		if (holesWereActuallyDeleted) {
			// Clean up orphaned fromHoleID references before renumbering
			allBlastHoles.forEach((hole) => {
				if (deletedCombinedIDs.has(hole.fromHoleID)) {
					const selfReference = hole.entityName + ":::" + hole.holeID;
					console.log("üï≥Ô∏è Orphaned hole " + selfReference + " now references itself");
					hole.fromHoleID = selfReference;
				}
			});

			// Perform renumbering for all affected entities if enabled
			if (isRenumberingHoles) {
				entitiesToRenumber.forEach((entityName) => {
					// deleteRenumberStart is expected to be globally available and set appropriately
					//console.log("Renumbering for Entity:", entityName, "starting at:", deleteRenumberStart);
					renumberHolesFunction(deleteRenumberStart, entityName);
				});
			}

			// Save to IndexedDB after deletion
			debouncedSaveHoles();

			// Reset fromHoleStore as selections involving it are now gone
			fromHoleStore = null;

			// Note: Original intermediate recalculations and drawData(points, null) call
			// are omitted here because refreshPoints() handles these operations comprehensively.
		}
	}

	refreshPoints(); // This function will save changes, reload points, recalculate all necessary data, and redraw.
}

//function to delete holes that have the same entity name in both the allBlastHoles array and the map
function deleteSelectedPattern() {
	if (isDeletingHole) {
		if (selectedHole !== null) {
			// find the selected holeIDs entityName
			let entityNameToDelete = allBlastHoles.find((hole) => hole === selectedHole).entityName;

			// Remove holes with the same entityName from kadHolesMap
			// for (const [entityName, entity] of kadHolesMap) {
			// 	if (entityName === entityNameToDelete) {
			// 		kadHolesMap.delete(entityName);
			// 	}
			// }

			// Remove holes with the same entityName from the points array
			allBlastHoles = allBlastHoles.filter((hole) => hole.entityName !== entityNameToDelete);

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			window.threeDataNeedsRebuild = true; // Trigger 3D rebuild after pattern deletion
			drawData(allBlastHoles, selectedHole);
		} else {
			window.threeDataNeedsRebuild = true; // Trigger 3D rebuild
			drawData(allBlastHoles, selectedHole);
		}
	}
	refreshPoints();
}

//function to delete All Entities in the kadHolesMap and all the Entityies in the allBlastHoles array
function deleteSelectedAllPatterns() {
	console.log("üö® deleteSelectedAllPatterns called!");
	console.log("isDeletingHole:", isDeletingHole);
	console.log("selectedHole:", selectedHole);
	console.log("selectedMultipleHoles:", selectedMultipleHoles);
	console.log("Stack trace:", new Error().stack);
	if (isDeletingHole) {
		if (selectedHole !== null || selectedMultipleHoles.length > 0) {
			// Remove all holes from kadHolesMap
			//kadHolesMap.clear();

			// Remove all holes from the points array
			allBlastHoles = [];

			// Reset the selected holeID
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			// Reset the fromHoleStore
			fromHoleStore = null;
			// Recalculate contour lines
			const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
			holeTimes = calculateTimes(allBlastHoles);
			const result = recalculateContours(allBlastHoles, deltaX, deltaY);
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;

			// directionArrows now contains the arrow data for later drawing

			drawData(allBlastHoles, selectedHole);
		} else {
			drawData(allBlastHoles, selectedHole);
		}
	}
}

function handleHoleDeletingClick(event) {
	if (isDeletingHole) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
		}
	}
}

// Update renumberHolesFunction to preserve rowID/posID structure
function renumberHolesFunction(startNumber, selectedEntityName) {
	console.log("Renumbering holes for Entity:", selectedEntityName, "Starting at:", startNumber);

	const oldToNewHoleIDMap = new Map();

	// Get all holes for this entity
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === selectedEntityName);

	// Sort holes by rowID first, then by posID within each row
	entityHoles.sort((a, b) => {
		// First sort by rowID
		const rowDiff = (a.rowID || 0) - (b.rowID || 0);
		if (rowDiff !== 0) return rowDiff;

		// Then sort by posID within the same row
		return (a.posID || 0) - (b.posID || 0);
	});

	const startValue = startNumber.toString();
	const alphaMatch = startValue.match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;
	const canParseAsInt = !isNaN(parseInt(startValue)) && isFinite(startValue);

	if (isAlphaNumerical) {
		// ALPHA-NUMERICAL RENUMBERING BY ROW - Use rowID/posID structure
		console.log("Using alpha-numerical renumbering with rowID/posID structure starting at:", startValue);

		const startRowLetter = alphaMatch[1];
		const startHoleNumber = parseInt(alphaMatch[2]);

		// Group holes by rowID
		const rowGroups = new Map();
		entityHoles.forEach((hole) => {
			const rowID = hole.rowID || 1;
			if (!rowGroups.has(rowID)) {
				rowGroups.set(rowID, []);
			}
			rowGroups.get(rowID).push(hole);
		});

		// Sort each row by posID
		rowGroups.forEach((holes) => {
			holes.sort((a, b) => (a.posID || 0) - (b.posID || 0));
		});

		// Get sorted rowIDs
		const sortedRowIDs = Array.from(rowGroups.keys()).sort((a, b) => a - b);

		let currentRowLetter = startRowLetter;

		// Renumber each row
		sortedRowIDs.forEach((rowID) => {
			const rowHoles = rowGroups.get(rowID);
			rowHoles.forEach((hole, posIndex) => {
				const newHoleID = currentRowLetter + (startHoleNumber + posIndex);
				oldToNewHoleIDMap.set(hole.holeID, newHoleID);
				hole.holeID = newHoleID;
			});

			// Move to next row letter
			if (currentRowLetter === "Z") {
				currentRowLetter = "AA";
			} else if (currentRowLetter === "ZZ") {
				currentRowLetter = "AAA";
			} else {
				currentRowLetter = incrementLetter(currentRowLetter);
			}
		});
	} else {
		// NUMERICAL RENUMBERING - Respect rowID/posID order
		console.log("Using numerical renumbering with rowID/posID structure starting at:", startValue);

		const startNum = canParseAsInt ? parseInt(startValue) : 1;
		let currentNumber = startNum;

		entityHoles.forEach((hole) => {
			oldToNewHoleIDMap.set(hole.holeID, currentNumber.toString());
			hole.holeID = currentNumber.toString();
			currentNumber++;
		});
	}

	// Update fromHoleID references
	allBlastHoles.forEach((hole) => {
		if (hole.fromHoleID) {
			const [entity, oldHoleID] = hole.fromHoleID.split(":::");
			if (entity === selectedEntityName && oldToNewHoleIDMap.has(oldHoleID)) {
				hole.fromHoleID = entity + ":::" + oldToNewHoleIDMap.get(oldHoleID);
			}
		}
	});

	refreshPoints();
	drawData(allBlastHoles, selectedHole);
	console.log("Renumbered", entityHoles.length, "holes respecting rowID/posID structure");
}

function renumberPatternAfterClipping(entityName) {
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);

	if (entityHoles.length === 0) return;

	// For patterns generated in polygons, the offset-aware numbering is already applied during generation
	// This function now just ensures proper A1 start and maintains the existing numbering structure

	// Step 1: Automatically detect row orientation from the pattern
	let rowOrientation = 90; // Default to East (90?) if can't determine

	if (entityHoles.length >= 2) {
		// Sort holes by Y coordinate to find potential row mates
		const sortedByY = [...entityHoles].sort((a, b) => b.startYLocation - a.startYLocation);

		// Find the first two holes that are likely in the same row (similar Y coordinates)
		const tolerance = 2.0; // 2 meter tolerance for same row
		let firstRowHoles = [sortedByY[0]];

		for (let i = 1; i < sortedByY.length; i++) {
			if (Math.abs(sortedByY[i].startYLocation - sortedByY[0].startYLocation) <= tolerance) {
				firstRowHoles.push(sortedByY[i]);
			} else {
				break; // Found different row
			}
		}

		// If we have at least 2 holes in the same row, calculate row orientation
		if (firstRowHoles.length >= 2) {
			// Sort by X coordinate to get leftmost and rightmost holes in the row
			firstRowHoles.sort((a, b) => a.startXLocation - b.startXLocation);
			const leftHole = firstRowHoles[0];
			const rightHole = firstRowHoles[firstRowHoles.length - 1];

			// Calculate bearing from left to right hole using your protractor formula
			const deltaX = rightHole.startXLocation - leftHole.startXLocation;
			const deltaY = rightHole.startYLocation - leftHole.startYLocation;

			// Use the same bearing calculation as your protractor tool
			rowOrientation = (90 - (Math.atan2(deltaY, deltaX) * 180) / Math.PI + 360) % 360;
		}
	}

	console.log("Detected row orientation: " + rowOrientation + "¬∞ for entity: " + entityName);

	// Step 2: Convert compass bearing to math radians for projections
	const rowBearingRadians = (90 - rowOrientation) * (Math.PI / 180);
	const burdenBearingRadians = rowBearingRadians - Math.PI / 2; // Perpendicular to row direction

	// Step 3: Project each hole onto the burden axis (perpendicular to rows) and spacing axis (along rows)
	entityHoles.forEach((hole) => {
		// Project onto burden direction (perpendicular to rows) - this determines which row
		hole.burdenProjection = hole.startXLocation * Math.cos(burdenBearingRadians) + hole.startYLocation * Math.sin(burdenBearingRadians);
		// Project onto spacing direction (along rows) - this determines position within row
		hole.spacingProjection = hole.startXLocation * Math.cos(rowBearingRadians) + hole.startYLocation * Math.sin(rowBearingRadians);
	});

	// Step 4: Sort by burden projection (to group rows), then by spacing projection (within each row)
	entityHoles.sort((a, b) => {
		const burdenDiff = Math.abs(a.burdenProjection - b.burdenProjection);
		if (burdenDiff > 1.5) {
			// Tolerance for row grouping
			return b.burdenProjection - a.burdenProjection; // Sort rows (highest burden first)
		}
		return a.spacingProjection - b.spacingProjection; // Sort within row (left to right along row)
	});

	// Step 5: Group holes by rows using burden projection
	const tolerance = 2.0; // Tolerance in meters for row grouping
	const rows = [];

	if (entityHoles.length > 0) {
		let currentRow = [entityHoles[0]];
		let currentBurdenPos = entityHoles[0].burdenProjection;

		for (let i = 1; i < entityHoles.length; i++) {
			const hole = entityHoles[i];
			if (Math.abs(hole.burdenProjection - currentBurdenPos) <= tolerance) {
				currentRow.push(hole);
			} else {
				// Sort current row by spacing projection (along the row direction)
				currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
				rows.push(currentRow);
				currentRow = [hole];
				currentBurdenPos = hole.burdenProjection;
			}
		}

		// Don't forget the last row
		if (currentRow.length > 0) {
			currentRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
			rows.push(currentRow);
		}
	}

	// Step 6: Simple renumbering starting from A1 (offset logic already applied during generation)
	let rowLetter = "A";
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		const row = rows[rowIndex];

		// For clipped patterns, just renumber sequentially starting from 1 in each row
		for (let pos = 0; pos < row.length; pos++) {
			const hole = row[pos];
			const newHoleID = rowLetter + (pos + 1);

			// Update fromHoleID references
			allBlastHoles.forEach((hole) => {
				if (hole.fromHoleID === entityName + ":::" + hole.holeID) {
					hole.fromHoleID = entityName + ":::" + newHoleID;
				}
			});

			hole.holeID = newHoleID;
		}

		// Move to next row letter
		if (rowLetter === "Z") {
			rowLetter = "AA";
		} else if (rowLetter === "ZZ") {
			rowLetter = "AAA";
		} else {
			rowLetter = incrementLetter(rowLetter);
		}
	}

	// Step 7: Clean up temporary projection properties
	entityHoles.forEach((hole) => {
		delete hole.burdenProjection;
		delete hole.spacingProjection;
	});

	console.log("Renumbered " + entityHoles.length + " holes in " + rows.length + " rows for entity: " + entityName + " with detected row orientation: " + rowOrientation + "¬∞");
}

// Step #1: Unified deleteHoleAndRenumber for rowID/posID and alphanumeric holeID
function deleteHoleAndRenumber(holeToDelete) {
	const entityName = holeToDelete.entityName;
	const holeID = holeToDelete.holeID;
	const rowID = holeToDelete.rowID;
	const posID = holeToDelete.posID;
	const deletedCombinedID = entityName + ":::" + holeID;

	// Step #2: Find the hole in allBlastHoles and remove it
	const holeIndex = allBlastHoles.findIndex((hole) => hole.entityName === entityName && hole.holeID === holeID);
	if (holeIndex !== -1) {
		allBlastHoles.splice(holeIndex, 1);
		console.log("‚ùåüï≥Ô∏è Deleted hole:", entityName + ":" + holeID);

		// Step #2a: Clean up fromHoleID references - orphaned holes should reference themselves
		allBlastHoles.forEach((hole) => {
			if (hole.fromHoleID === deletedCombinedID) {
				const selfReference = hole.entityName + ":::" + hole.holeID;
				console.log("üï≥Ô∏è Orphaned hole " + selfReference + " now references itself");
				hole.fromHoleID = selfReference;
			}
		});

		// Step #2b: Save to IndexedDB after deletion
		debouncedSaveHoles();
	} else {
		console.warn("üö® Hole not found for deletion:", entityName + ":" + holeID);
		return;
	}

	// Step #3: If rowID/posID exist, use rowID/posID logic
	if (rowID && posID) {
		// Get all holes in the same row that come after the deleted hole
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID && hole.posID > posID);

		// Renumber positions in this row
		sameRowHoles.forEach((hole) => {
			const oldHoleID = hole.holeID;
			hole.posID = hole.posID - 1; // Shift position down by 1

			// Update fromHoleID references if needed
			allBlastHoles.forEach((h) => {
				if (h.fromHoleID === entityName + ":::" + oldHoleID) {
					h.fromHoleID = entityName + ":::" + hole.holeID;
				}
			});
		});

		console.log("Renumbered " + sameRowHoles.length + " holes in row " + rowID);
		return; // Step #4: Exit after rowID/posID logic
	}

	// Step #5: If not rowID/posID, check for alphanumeric holeID
	const alphaMatch = holeID && holeID.toString().match(/^([A-Z]+)(\d+)$/);
	const isAlphaNumerical = alphaMatch !== null;

	if (isAlphaNumerical) {
		const deletedRowLetter = alphaMatch[1];
		const deletedHoleNumber = parseInt(alphaMatch[2]);

		// Get all holes in the same row (same letter) and entity
		const sameRowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.holeID && hole.holeID.toString().startsWith(deletedRowLetter));

		// Sort by hole number within the row
		sameRowHoles.sort((a, b) => {
			const aMatch = a.holeID.toString().match(/^[A-Z]+(\d+)$/);
			const bMatch = b.holeID.toString().match(/^[A-Z]+(\d+)$/);
			if (aMatch && bMatch) {
				return parseInt(aMatch[1]) - parseInt(bMatch[1]);
			}
			return 0;
		});

		// Renumber holes in this row that come after the deleted hole
		sameRowHoles.forEach((hole) => {
			const currentMatch = hole.holeID.toString().match(/^([A-Z]+)(\d+)$/);
			if (currentMatch) {
				const currentHoleNumber = parseInt(currentMatch[2]);
				if (currentHoleNumber > deletedHoleNumber) {
					const oldHoleID = hole.holeID;
					const newHoleID = deletedRowLetter + (currentHoleNumber - 1);
					hole.holeID = newHoleID;

					// Update fromHoleID references
					allBlastHoles.forEach((h) => {
						if (h.fromHoleID === entityName + ":::" + oldHoleID) {
							h.fromHoleID = entityName + ":::" + newHoleID;
						}
					});
				}
			}
		});

		console.log("Renumbered " + sameRowHoles.length + " holes in row " + deletedRowLetter);
		return; // Step #6: Exit after alphanumeric logic
	}

	// Step #7: For numerical holes, no automatic renumbering on delete
	// (user can manually renumber if needed)
}

// Expose hole deletion and renumbering functions globally for HolesContextMenu.js
window.deleteHoleAndRenumber = deleteHoleAndRenumber;
window.renumberHolesFunction = renumberHolesFunction;
window.renumberPatternAfterClipping = renumberPatternAfterClipping;

// Expose setMeasuredDate for HolePropertyDialogs.js
window.setMeasuredDate = setMeasuredDate;

// Expose KAD functions for KADDialogs.js
window.performKADOffset = performKADOffset;
window.createRadiiFromSelectedEntitiesFixed = createRadiiFromSelectedEntitiesFixed;
window.resetFloatingToolbarButtons = resetFloatingToolbarButtons;
window.getEntityFromKADObject = getEntityFromKADObject;
window.handleOffsetKADClick = handleOffsetKADClick;

// Expose offset preview functions for KADDialogs.js live preview
window.updateOffsetPreview = updateOffsetPreview;
window.clearOffsetPreview = clearOffsetPreview;
window.calculateOffsetPreview = calculateOffsetPreview;
window.clear3DOffsetPreview = clear3DOffsetPreview;

// Expose offset preview state variables for direct manipulation in dialogs
// These need to be accessed directly for proper cleanup ordering
Object.defineProperty(window, "offsetPreviewEnabled", {
	get: function () { return offsetPreviewEnabled; },
	set: function (val) { offsetPreviewEnabled = val; }
});
Object.defineProperty(window, "offsetPreviewOriginalEntity", {
	get: function () { return offsetPreviewOriginalEntity; },
	set: function (val) { offsetPreviewOriginalEntity = val; }
});
Object.defineProperty(window, "offsetPreviewEntities", {
	get: function () { return offsetPreviewEntities; },
	set: function (val) { offsetPreviewEntities = val; }
});
Object.defineProperty(window, "offsetPreviewParams", {
	get: function () { return offsetPreviewParams; },
	set: function (val) { offsetPreviewParams = val; }
});

// Expose KAD tool variables for KADDialogs.js
window.offsetKADButton = offsetKADButton;
window.isOffsetKAD = isOffsetKAD;
window.radiiHolesOrKADsTool = radiiHolesOrKADsButton; // Alias for consistency

// Expose triangulation functions for KADDialogs.js
window.createConstrainedDelaunayTriangulation = createConstrainedDelaunayTriangulation;
window.createDelaunayTriangulation = createDelaunayTriangulation;
window.deleteTrianglesByClippingPolygon = deleteTrianglesByClippingPolygon;
window.deleteTrianglesByInternalAngle = deleteTrianglesByInternalAngle;
window.deleteTrianglesByEdgeLength = deleteTrianglesByEdgeLength;
window.updateCentroids = updateCentroids;

// Expose utility functions for dialogs
window.isIOS = isIOS;
window.showErrorDialog = showErrorDialog;

// Expose KAD renumbering function globally for KADContextMenu.js
window.renumberEntityPoints = renumberEntityPoints;

function handleHoleAddingClick(event) {
	if (isAddingHole) {
		console.log("‚ûïüï≥Ô∏è handleHoleAddingClick fired");
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = parseFloat(snapResult.worldX);
		worldY = parseFloat(snapResult.worldY);

		// Set worldZ if available from snap result, otherwise use current elevation
		if (snapResult.worldZ !== undefined && snapResult.worldZ !== null) {
			worldZ = parseFloat(snapResult.worldZ);
		} else {
			// Use drawing elevation or default
			worldZ = parseFloat(document.getElementById("drawingElevation")?.value || 0);
		}

		// Expose on window object for AddHoleDialog.js to access
		window.worldX = worldX;
		window.worldY = worldY;
		window.worldZ = worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		console.log("üìç worldX/worldY/worldZ set:", worldX, worldY, worldZ);
		console.log("üìç window.worldX/worldY/worldZ:", window.worldX, window.worldY, window.worldZ);

		// Step 1) Check if we're in multiple mode (have stored form data)
		if (window.isAddingSingleHole && window.multipleAddHoleFormData) {
			// Multiple mode: Reuse stored form data, don't show dialog
			console.log("üìçüìç Multiple mode: Reusing stored form data");
			if (typeof window.addHoleMultipleMode === "function") {
				window.addHoleMultipleMode(worldX, worldY);
			} else {
				console.error("? addHoleMultipleMode function not found");
				addHolePopup(); // Fallback to showing dialog
			}
		} else {
			// Single mode or first click: Show dialog
			console.log("üìç Single mode or first click: Showing dialog");
			addHolePopup();
		}
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		// Clear window properties too
		window.worldX = null;
		window.worldY = null;
		window.worldZ = null;
	}
}

//================================================
//DRAWING FUNCTIONS ADD KAD DRAWING POINT - LINE - POLY - CIRCLE - TEXT
//===============================================

// Add these variables to track the current drawing state
let currentDrawingEntityName = null;
let deleteKeyPressed = false;
let deleteKeyCount = 0;

// Enhanced key listener for delete/backspace functionality
function handleDrawingKeyEvents(event) {
	// Check for Delete or Backspace keys
	if (event.key === "Delete" || event.key === "Backspace") {
		event.preventDefault(); // Prevent default browser behavior

		// Only allow deletion if we have a current drawing entity
		if (currentDrawingEntityName && allKADDrawingsMap.has(currentDrawingEntityName)) {
			const entity = allKADDrawingsMap.get(currentDrawingEntityName);

			if (entity.data.length > 0) {
				// Remove the last point
				const removedPoint = entity.data.pop();
				deleteKeyCount++;

				// Update the last draw point to the previous point (if any)
				if (entity.data.length > 0) {
					const lastPoint = entity.data[entity.data.length - 1];
					updateLastKADDrawPoint(lastPoint.pointXLocation, lastPoint.pointYLocation);
				} else {
					// If no points left, reset the last draw point
					lastKADDrawPoint = null;
				}

				// Show user feedback
				const remainingPoints = entity.data.length;
				const entityType = entity.entityType;
				let message = "";

				if (remainingPoints === 0) {
					message = "Removed last point. Entity is now empty.";
				} else {
					message = "Removed last point. " + remainingPoints + " point" + (remainingPoints > 1 ? "s" : "") + " remaining in " + entityType + ".";
				}

				updateStatusMessage(message);
				setTimeout(() => updateStatusMessage(""), 2000);

				// Redraw the canvas (trigger 3D rebuild for deleted point)
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, selectedHole);
				debouncedSaveKAD();

				console.log("üóëÔ∏è Removed point from " + currentDrawingEntityName + ". Points remaining: " + remainingPoints);
			} else {
				updateStatusMessage("No points to remove from current " + entity.entityType + ".");
				setTimeout(() => updateStatusMessage(""), 1500);
			}
		} else {
			updateStatusMessage("No active drawing to remove points from.");
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		return true; // Signal that we handled the key
	}
	return false; // Signal that we didn't handle the key
}
// Enhanced function to update the current drawing entity name
function setCurrentDrawingEntity(entityName) {
	currentDrawingEntityName = entityName;
	deleteKeyCount = 0; // Reset delete count when starting new entity
	console.log("üé® Set current drawing entity: " + entityName);
}
// Function to clear current drawing entity when switching tools
function clearCurrentDrawingEntity() {
	currentDrawingEntityName = null;
	deleteKeyCount = 0;
	console.log("üßπ Cleared current drawing entity");
}

function handleKADPointClick(event) {
	if (isDrawingPoint) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADPoint();
		debouncedUpdateTreeView();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedUpdateTreeView(); // Use debounced version
		debouncedSaveKAD();
	}
}

// Step #) Helper function to generate unique KAD entity names
// This prevents duplicate names when entities are deleted and new ones created
function getUniqueKADEntityName(prefix) {
	// Step 1) Find all existing entity names with this prefix
	var existingNumbers = [];
	allKADDrawingsMap.forEach(function (entity, name) {
		if (name.startsWith(prefix)) {
			// Extract the number from the name (e.g., "polyObject5_a3k7" -> 5)
			var numStr = name.substring(prefix.length);
			// Handle both old format (no underscore) and new format (with _uid)
			var underscoreIndex = numStr.indexOf("_");
			if (underscoreIndex !== -1) {
				numStr = numStr.substring(0, underscoreIndex);
			}
			var num = parseInt(numStr, 10);
			if (!isNaN(num)) {
				existingNumbers.push(num);
			}
		}
	});

	// Step 2) Find the next available number (starting from 1)
	var nextNum = 1;
	if (existingNumbers.length > 0) {
		// Sort and find the first gap, or use max + 1
		existingNumbers.sort(function (a, b) { return a - b; });
		for (var i = 0; i < existingNumbers.length; i++) {
			if (existingNumbers[i] !== nextNum) {
				break; // Found a gap
			}
			nextNum++;
		}
	}

	// Step 3) Add short unique ID suffix to guarantee uniqueness
	var shortId = Math.random().toString(36).substring(2, 6);
	return prefix + nextNum + "_" + shortId;
}

function addKADPoint() {
	if (isDrawingPoint) {
		const color = getJSColorHexDrawing();
		const entityType = "point";

		// Use the same entity management as lines/polygons
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = getUniqueKADEntityName("pointObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		// In addKADPoint() function around line 9720
		const pointObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth, // This is added for inter-changable types. points > lines > polys
			color: color,
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			// Step 26) Get active layer for new drawing entity
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			// Ensure default layer exists
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				layerId: activeLayerId, // Step 26a) Assign to active layer
				data: [],
				visible: true,
			});
			// Step 26b) Add to layer's entities set
			if (activeLayer) {
				activeLayer.entities.add(entityName);
			}
			console.log("üìù Created KAD point entity in layer:", activeLayerId);
		}

		allKADDrawingsMap.get(entityName).data.push(pointObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new KAD point
		drawData(allBlastHoles, selectedHole);
		debouncedSaveKAD();
		debouncedSaveLayers();
		debouncedUpdateTreeView();
		console.log("Added point", pointID, "to", entityName);
	}
}

function handleKADLineClick(event) {
	if (isDrawingLine) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addKADLine();
		debouncedUpdateTreeView(); // Use debounced version
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADLine() {
	if (isDrawingLine) {
		const entityType = "line";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1; // Changed map
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();

		if (createNewEntity) {
			entityName = getUniqueKADEntityName("lineObject");
			createNewEntity = false;
			setCurrentDrawingEntity(entityName);
		}

		const lineObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: false, // Added: lines are open
			visible: true,
		};

		// Add to allKADDrawingsMap instead
		if (!allKADDrawingsMap.has(entityName)) {
			// Step 26c) Get active layer for new line entity
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			// Ensure default layer exists
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				layerId: activeLayerId, // Step 26d) Assign to active layer
				data: [],
				visible: true,
			});
			// Step 26e) Add to layer's entities set
			if (activeLayer) {
				activeLayer.entities.add(entityName);
			}
			console.log("üìù Created KAD line entity in layer:", activeLayerId);
		}
		allKADDrawingsMap.get(entityName).data.push(lineObject); // Changed map
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new KAD line
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedSaveLayers();
	debouncedUpdateTreeView();
}

function handleKADPolyClick(event) {
	if (isDrawingPoly) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADPoly();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
		debouncedUpdateTreeView();
	}
}
// Function to add a point to the allKADDrawingsMap
function addKADPoly() {
	if (isDrawingPoly) {
		// Create a new point object or use the existing one
		const entityType = "poly";
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;
		const color = getJSColorHexDrawing();
		const closed = true; // Default to closed polygon

		if (createNewEntity) {
			entityName = getUniqueKADEntityName("polyObject");
			createNewEntity = false; // Set the flag to false after creating a new entity
			setCurrentDrawingEntity(entityName);
		}

		const polyObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			lineWidth: lineWidth,
			color: color,
			closed: closed, // Set to true if the polygon is closed
			visible: true,
		};

		// Add the point to allKADDrawingsMap
		if (!allKADDrawingsMap.has(entityName)) {
			// Step 26f) Get active layer for new polygon entity
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			// Ensure default layer exists
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			allKADDrawingsMap.set(entityName, {
				name: entityName,
				entityType: entityType,
				layerId: activeLayerId, // Step 26g) Assign to active layer
				data: [],
				visible: true,
			});
			// Step 26h) Add to layer's entities set
			if (activeLayer) {
				activeLayer.entities.add(entityName);
			}
			console.log("üìù Created KAD polygon entity in layer:", activeLayerId);
		}
		allKADDrawingsMap.get(entityName).data.push(polyObject);
		// Add this line to update the last draw point
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
	}
	window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new KAD polygon
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedSaveLayers();
	debouncedUpdateTreeView();
	console.log("allKADDrawingsMap: ", allKADDrawingsMap);
}

function handleKADCircleClick(event) {
	if (isDrawingCircle) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADCircle();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

function addKADCircle() {
	if (isDrawingCircle) {
		const color = getJSColorHexDrawing();
		const radius = circleRadius.value;
		const entityType = "circle";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;
		const lineWidth = document.getElementById("drawingLineWidth").value || 1;

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			entityName = getUniqueKADEntityName("circleObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
		}

		const circleObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			radius: radius,
			lineWidth: lineWidth,
			color: color,
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			// Step 26i) Get active layer for new circle entity
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			// Ensure default layer exists
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				layerId: activeLayerId, // Step 26j) Assign to active layer
				data: [],
				visible: true,
			});
			// Step 26k) Add to layer's entities set
			if (activeLayer) {
				activeLayer.entities.add(entityName);
			}
			console.log("üìù Created KAD circle entity in layer:", activeLayerId);
		}
		allKADDrawingsMap.get(entityName).data.push(circleObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		console.log("Added circle", pointID, "to", entityName);
	}
	window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new KAD circle
	drawData(allBlastHoles, selectedHole);
	debouncedSaveKAD();
	debouncedSaveLayers();
	debouncedUpdateTreeView();
}

function handleKADTextClick(event) {
	if (isDrawingText) {
		// get the values from clicking in the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;
		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;
		worldZ = snapResult.worldZ;
		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}

		addKADText();
	} else {
		worldX = null;
		worldY = null;
		worldZ = null;
		lastKADDrawPoint = null; // Reset when switching tools
		//save the drawing using douncedSave
		debouncedSaveKAD();
	}
}

// Enhanced function to evaluate calculations with user-friendly error handling
async function processTextCalculationWithValidation(text) {
	if (text.startsWith("=")) {
		try {
			const expression = text.substring(1); // Remove '='
			const calculatedValue = evaluate(expression);

			// Check if result is valid
			if (isNaN(calculatedValue) || !isFinite(calculatedValue)) {
				throw new Error("Result is not a valid number");
			}

			return calculatedValue.toString(); // Return the result as a string
		} catch (error) {
			// Show user-friendly error popup
			const result = await showCalculationErrorPopup(text, error.message);
			return result; // Will be either corrected text or original
		}
	}
	return text; // Return original text if not a calculation
}
//TODO use the FloatingDialog class to create this popup
// Show calculation error popup with helpful feedback
function showCalculationErrorPopup(originalText, errorMessage) {
	return new Promise((resolve) => {
		// Generate helpful error message
		let helpfulMessage = "Unknown calculation error";
		let suggestions = "";

		if (errorMessage.includes("Unexpected token") || errorMessage.includes("Unexpected")) {
			helpfulMessage = "Invalid mathematical expression";
			suggestions = "? Check for typos in operators (+, -, *, /)<br>? Make sure parentheses are balanced<br>? Use numbers, operators, and math functions";
		} else if (errorMessage.includes("Undefined symbol") || errorMessage.includes("not defined")) {
			helpfulMessage = "Unknown variable or function";
			suggestions = "? Supported functions: sqrt, sin, cos, tan, abs, round, etc.<br>? Variables are not supported<br>? Check function spelling";
		} else if (errorMessage.includes("not a valid number")) {
			helpfulMessage = "Calculation result is invalid";
			suggestions = "? Check for division by zero<br>? Ensure the result is a finite number";
		} else {
			suggestions = "? Use format: =5+3 or =sqrt(16)<br>? Supported: +, -, *, /, (), sqrt, sin, cos, etc.<br>? Check for syntax errors";
		}

		// Step 1) Create content with error details using inline styles for dark mode
		const textColor = darkModeEnabled ? "#ffffff" : "#000000";
		const content = `
			<div style="text-align: center;">
				<label style="color: ${textColor}; font-size: 16px; font-weight: bold;"><strong>Formula:</strong> ${originalText}</label><br><br>
				<label style="color: ${textColor}; font-size: 14px; font-weight: bold;"><strong>Error:</strong> ${helpfulMessage}</label><br><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Suggestions:</strong></label><br>
				<div style="text-align: center; margin: 10px 20px;">
					<label style="color: ${textColor}; font-size: 10px;">${suggestions}</label>
				</div><br>
				<label style="color: ${textColor}; font-size: 12px; font-weight: bold;"><strong>Examples:</strong></label><br>
				<label style="color: ${textColor}; font-size: 10px;">=5+3 ? 8</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=10*2.5 ? 25</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=(100+50)/2 ? 75</label><br>
				<label style="color: ${textColor}; font-size: 10px;">=sqrt(16) ? 4</label>
			</div>
		`;

		// Step 2) Create FloatingDialog with three buttons
		const dialog = new FloatingDialog({
			title: "Calculation Error",
			content: content,
			width: 400,
			height: 300,
			showConfirm: true,
			showCancel: true,
			showDeny: false,
			showOption1: true, // Enable the third button
			showOption2: false,
			confirmText: "Fix It",
			cancelText: "Cancel",
			option1Text: "As Text", // Third button
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior
			layoutType: "default",
			onConfirm: () => {
				// Step 3) User wants to fix it - keep the text field focused for editing
				console.log("Calculation error dialog - Fix It selected");
				dialog.close();
				resolve(null); // Signal to not save and let user edit
			},
			onCancel: () => {
				// Step 4) User cancelled - don't save anything
				console.log("Calculation error dialog - Cancel selected");
				dialog.close();
				resolve(null);
			},
			onOption1: () => {
				// Step 5) User wants to use as regular text (remove the = sign)
				console.log("Calculation error dialog - As Text selected");
				dialog.close();
				resolve(originalText.substring(1)); // Remove = and store as plain text
			},
		});

		// Step 6) Show the dialog
		dialog.show();
	});
}

async function addKADText() {
	console.log("=== addKADText() called ===");
	console.log("createNewEntity:", createNewEntity);
	console.log("current entityName:", entityName);
	console.log("isDrawingText:", isDrawingText);

	if (isDrawingText) {
		// Get the text value from the input field
		let text = document.getElementById("drawingText").value.trim();

		// Check if text is blank and warn user
		if (text === "") {
			showModalMessage("No Text Entered", "Please enter text in the drawing tools text area.", "warning");
			return;
		}

		// ? ADD THIS: Process calculations if text starts with "="
		const processedText = await processTextCalculationWithValidation(text);

		// If processedText is null, user cancelled or wants to edit - return without saving
		if (processedText === null) {
			return;
		}

		// Use the processed text (either calculated result or original text)
		text = processedText;

		const color = getJSColorHexDrawing();
		const entityType = "text";

		// Use the same entity management as other tools
		const pointID = allKADDrawingsMap.has(entityName) ? allKADDrawingsMap.get(entityName).data.length + 1 : 1;
		const pointXLocation = worldX;
		const pointYLocation = worldY;
		// Step 17.6a) Use worldZ for snapping like other KAD tools
		const pointZLocation = worldZ || drawingZValue || document.getElementById("drawingElevation").value || 0;

		console.log("Before entity creation check:");
		console.log("  createNewEntity:", createNewEntity);
		console.log("  entityName:", entityName);
		console.log("  allKADDrawingsMap.has(entityName):", allKADDrawingsMap.has(entityName));

		// Create new entity name if needed (like other tools)
		if (createNewEntity) {
			console.log("Creating new entity...");
			entityName = getUniqueKADEntityName("textObject");
			createNewEntity = false; // Set to false after creating new entity
			setCurrentDrawingEntity(entityName);
			console.log("New entityName:", entityName);
		} else {
			console.log("Using existing entityName:", entityName);
		}

		const textObject = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointID,
			pointXLocation: pointXLocation,
			pointYLocation: pointYLocation,
			pointZLocation: pointZLocation,
			text: text, // ? Now using the processed text
			color: color,
			fontHeight: 12, // Step B1) Default fontHeight for new text entities
			connected: false,
			closed: false,
			visible: true,
		};

		// Create the entity if it doesn't exist
		if (!allKADDrawingsMap.has(entityName)) {
			console.log("Creating new map entry for:", entityName);
			// Step 26l) Get active layer for new text entity
			var activeLayerId = window.activeDrawingLayerId || window.DEFAULT_DRAWING_LAYER_ID;
			// Ensure default layer exists
			if (!window.allDrawingLayers.has(activeLayerId)) {
				window.allDrawingLayers.set(activeLayerId, {
					layerId: activeLayerId,
					name: "Default Layer",
					type: "drawing",
					visible: true,
					entities: new Set()
				});
			}
			var activeLayer = window.allDrawingLayers.get(activeLayerId);

			allKADDrawingsMap.set(entityName, {
				entityName: entityName,
				entityType: entityType,
				layerId: activeLayerId, // Step 26m) Assign to active layer
				data: [],
				visible: true,
			});
			// Step 26n) Add to layer's entities set
			if (activeLayer) {
				activeLayer.entities.add(entityName);
			}
			console.log("üìù Created KAD text entity in layer:", activeLayerId);
		} else {
			console.log("Using existing map entry for:", entityName);
			console.log("Existing entity type:", allKADDrawingsMap.get(entityName).entityType);
		}

		allKADDrawingsMap.get(entityName).data.push(textObject);
		updateLastKADDrawPoint(pointXLocation, pointYLocation);
		window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new KAD text
		drawData(allBlastHoles, selectedHole);
		debouncedUpdateTreeView();
		console.log("Added text", pointID, "to", entityName);
		console.log("Final entity type:", allKADDrawingsMap.get(entityName).entityType);
		debouncedSaveKAD();
		debouncedSaveLayers();
	}
}
/**
 * Modern AQM Export Dialog - Select columns and configure export options
 * Uses FloatingDialog with drag-and-drop column ordering
 */
function saveAQMPopup() {
	try {
		// Step 1) Filter visible blast holes
		const visibleBlastHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

		if (visibleBlastHoles.length === 0) {
			showModalMessage("No Visible Holes", "There are no visible holes to export.", "warning");
			return;
		}

		// Step 2) Load saved preferences or use defaults
		var savedPrefs = localStorage.getItem("kirra_aqm_export_prefs");
		var blastName, patternName, materialType, instruction, useHoleTypeAsInstruction, writeIgnoreColumn, columnOrder, columnEnabled;

		var entityName = visibleBlastHoles[0].entityName || "Blast";

		if (savedPrefs) {
			try {
				var prefs = JSON.parse(savedPrefs);
				blastName = prefs.blastName || entityName;
				patternName = prefs.patternName || entityName;
				materialType = prefs.materialType || "Material";
				instruction = prefs.instruction || "Instruction";
				useHoleTypeAsInstruction = prefs.useHoleTypeAsInstruction || false;
				writeIgnoreColumn = prefs.writeIgnoreColumn !== false; // Default true
				columnOrder = prefs.columnOrder || ["Pattern", "Blast", "Name", "Easting", "Northing", "Elevation", "Angle", "Azimuth", "Diameter", "Instruction", "Material Type"];
				columnEnabled = prefs.columnEnabled || {}; // Map of column name to enabled state
			} catch (e) {
				console.warn("Failed to parse AQM export preferences:", e);
				blastName = entityName;
				patternName = entityName;
				materialType = "Material";
				instruction = "Instruction";
				useHoleTypeAsInstruction = false;
				writeIgnoreColumn = true;
				columnOrder = ["Pattern", "Blast", "Name", "Easting", "Northing", "Elevation", "Angle", "Azimuth", "Diameter", "Instruction", "Material Type"];
				columnEnabled = {}; // All enabled by default
			}
		} else {
			blastName = entityName;
			patternName = entityName;
			materialType = "Material";
			instruction = "Instruction";
			useHoleTypeAsInstruction = false;
			writeIgnoreColumn = true;
			columnOrder = ["Pattern", "Blast", "Name", "Easting", "Northing", "Elevation", "Angle", "Azimuth", "Diameter", "Instruction", "Material Type"];
			columnEnabled = {}; // All enabled by default
		}

		// Step 3) Generate default filename with fresh timestamp
		var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
		var defaultFilename = "AQM_" + entityName + "_" + timestamp;

		// Step 4) Create dialog content
		var contentHTML = '<div style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">';

		// Header section - Filename
		contentHTML += '<div style="padding: 10px; border-bottom: 1px solid var(--light-mode-border);" class="button-container-2col">';
		contentHTML += '<label class="labelWhite15">Filename (without .aqm):</label>';
		contentHTML += '<input type="text" id="export-aqm-filename" value="' + defaultFilename + '" style="width: 100%; padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
		contentHTML += '<label class="labelWhite15"><strong>Holes to Export:</strong> ' + visibleBlastHoles.length + '</label>';
		contentHTML += '<div></div>';
		contentHTML += '</div>';

		// AQM-specific fields section
		contentHTML += '<div style="padding: 10px; border-bottom: 1px solid var(--light-mode-border);" class="button-container-2col">';
		contentHTML += '<label class="labelWhite12">Blast Name:</label>';
		contentHTML += '<input type="text" id="export-aqm-blast-name" value="' + blastName + '" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '<label class="labelWhite12">Pattern Name:</label>';
		contentHTML += '<input type="text" id="export-aqm-pattern-name" value="' + patternName + '" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '<label class="labelWhite12">Material Type:</label>';
		contentHTML += '<input type="text" id="export-aqm-material-type" value="' + materialType + '" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '<label class="labelWhite12">Instruction:</label>';
		contentHTML += '<input type="text" id="export-aqm-instruction" value="' + instruction + '" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '<label class="labelWhite12">Use hole type as instruction:</label>';
		contentHTML += '<input type="checkbox" id="export-aqm-use-hole-type"' + (useHoleTypeAsInstruction ? ' checked' : '') + '>';
		contentHTML += '<label class="labelWhite12">Write Ignore Columns:</label>';
		contentHTML += '<input type="checkbox" id="export-aqm-write-ignore"' + (writeIgnoreColumn ? ' checked' : '') + '>';
		contentHTML += '</div>';

		// Column ordering section
		contentHTML += '<div style="flex: 1; display: flex; flex-direction: column; padding: 10px; overflow: hidden;">';
		contentHTML += '<label class="labelWhite15" style="margin-bottom: 10px;"><strong>Column Order (Drag to Reorder):</strong></label>';
		contentHTML += '<div id="aqm-column-order-list" style="flex: 1; overflow-y: auto; background: var(--dark-mode-bg); border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 5px;">';
		contentHTML += '</div>';
		contentHTML += '</div>';
		contentHTML += '</div>';

		// Step 5) Create dialog
		var dialog;
		try {
			dialog = new FloatingDialog({
				title: "Export AQM File - Column Order",
				content: contentHTML,
				layoutType: "default",
				width: 650,
				height: 750,
				showConfirm: true,
				showCancel: true,
				confirmText: "Export",
				cancelText: "Cancel",
				onConfirm: async function () {
					try {
						// Step 6) Get column order and enabled state from sortable list
						var orderList = document.getElementById("aqm-column-order-list");
						var columnOrder = [];
						var columnEnabled = {};
						var exportColumnOrder = []; // Column order for export (includes "Ignore")
						var items = orderList.querySelectorAll(".aqm-column-item");

						for (var i = 0; i < items.length; i++) {
							var item = items[i];
							var checkbox = item.querySelector(".aqm-column-checkbox");
							var colName = item.getAttribute("data-col-name");

							// Save actual column name (not "Ignore")
							columnOrder.push(colName);
							// Save enabled state
							columnEnabled[colName] = checkbox && checkbox.checked;
							// Build export order (use "Ignore" for unchecked columns)
							if (checkbox && !checkbox.checked) {
								exportColumnOrder.push("Ignore");
							} else {
								exportColumnOrder.push(colName);
							}
						}

						if (columnOrder.length !== 11) {
							showModalMessage("Invalid Column Order", "AQM files must have exactly 11 columns", "error");
							return;
						}

						// Step 7) Get form values
						var filename = document.getElementById("export-aqm-filename").value.trim();
						var blastName = document.getElementById("export-aqm-blast-name").value.trim();
						var patternName = document.getElementById("export-aqm-pattern-name").value.trim();
						var materialType = document.getElementById("export-aqm-material-type").value.trim();
						var instruction = document.getElementById("export-aqm-instruction").value.trim();
						var useHoleTypeAsInstruction = document.getElementById("export-aqm-use-hole-type").checked;
						var writeIgnoreColumn = document.getElementById("export-aqm-write-ignore").checked;

						if (!filename) {
							showModalMessage("No Filename", "Please enter a filename", "warning");
							return;
						}

						// Ensure .aqm extension
						if (!filename.toLowerCase().endsWith(".aqm")) {
							filename += ".aqm";
						}

						// Step 8) Save preferences (with actual column names and enabled state)
						localStorage.setItem("kirra_aqm_export_prefs", JSON.stringify({
							blastName: blastName,
							patternName: patternName,
							materialType: materialType,
							instruction: instruction,
							useHoleTypeAsInstruction: useHoleTypeAsInstruction,
							writeIgnoreColumn: writeIgnoreColumn,
							columnOrder: columnOrder,
							columnEnabled: columnEnabled
						}));

						// Step 9) Generate AQM content using existing converter function (use exportColumnOrder with "Ignore")
						var aqmContent = convertPointsToAQMCSV(
							visibleBlastHoles,
							filename.replace(".aqm", ""), // Remove extension for converter
							blastName,
							patternName,
							materialType,
							instruction,
							useHoleTypeAsInstruction,
							writeIgnoreColumn,
							exportColumnOrder
						);

						// Step 10) Export using File System Access API if available
						if (window.showSaveFilePicker) {
							try {
								var fileHandle = await window.showSaveFilePicker({
									suggestedName: filename,
									types: [{
										description: 'AQM Files',
										accept: { 'text/csv': ['.aqm'] }
									}]
								});

								var writable = await fileHandle.createWritable();
								await writable.write(aqmContent);
								await writable.close();

								showModalMessage("Export Success", "Exported AQM to " + fileHandle.name, "success");
								dialog.close();
							} catch (error) {
								if (error.name === 'AbortError') {
									console.log("User cancelled file picker");
								} else {
									console.error("File System Access API error:", error);
									// Fallback to standard download
									downloadAQMStandard(aqmContent, filename);
									dialog.close();
								}
							}
						} else {
							// Fallback to standard download for unsupported browsers
							downloadAQMStandard(aqmContent, filename);
							dialog.close();
						}
					} catch (error) {
						console.error("AQM export error:", error);
						showModalMessage("Export Error", "Error: " + error.message, "error");
					}
				},
				onCancel: function () {
					// Dialog cancelled
				}
			});
		} catch (dialogError) {
			console.error("Error creating FloatingDialog:", dialogError);
			showModalMessage("Dialog Error", "Failed to create export dialog: " + dialogError.message, "error");
			return;
		}

		// Show the dialog
		dialog.show();

		// Step 6) Initialize column order list with drag-and-drop
		setTimeout(function () {
			var orderList = document.getElementById("aqm-column-order-list");
			if (!orderList) return;

			// Define available AQM columns (all 11 are always present)
			var aqmColumns = [
				{ name: "Pattern", label: "Pattern" },
				{ name: "Blast", label: "Blast" },
				{ name: "Name", label: "Name" },
				{ name: "Easting", label: "Easting" },
				{ name: "Northing", label: "Northing" },
				{ name: "Elevation", label: "Elevation" },
				{ name: "Angle", label: "Angle" },
				{ name: "Azimuth", label: "Azimuth" },
				{ name: "Diameter", label: "Diameter" },
				{ name: "Instruction", label: "Instruction" },
				{ name: "Material Type", label: "Material Type" }
			];

			// Populate order list from saved preferences or defaults (all 11 columns always shown)
			for (var i = 0; i < columnOrder.length; i++) {
				var colName = columnOrder[i];
				var colData = aqmColumns.find(function (col) { return col.name === colName; });
				if (!colData) continue;

				var item = document.createElement("div");
				item.className = "aqm-column-item";
				item.setAttribute("data-col-name", colName);
				item.setAttribute("draggable", "true");
				item.style.cssText = "display: flex; align-items: center; gap: 8px; padding: 8px; margin-bottom: 3px; background: var(--button-bg); border: 1px solid var(--light-mode-border); border-radius: 3px; cursor: move; user-select: none;";

				// Create checkbox (unchecked = Ignore)
				var checkbox = document.createElement("input");
				checkbox.type = "checkbox";
				checkbox.className = "aqm-column-checkbox";
				// Check if this column is enabled (default true if not specified)
				checkbox.checked = columnEnabled[colName] !== false;
				checkbox.style.cssText = "cursor: pointer;";
				checkbox.onclick = function (e) {
					e.stopPropagation(); // Prevent drag when clicking checkbox
				};

				// Create drag handle
				var handle = document.createElement("span");
				handle.textContent = "::";
				handle.style.cssText = "color: var(--accent-color); font-weight: bold; min-width: 30px;";

				// Create column number
				var number = document.createElement("span");
				number.className = "aqm-column-number";
				number.textContent = (i + 1) + ".";
				number.style.cssText = "color: var(--text-color); font-weight: bold; min-width: 25px;";

				// Create column label
				var label = document.createElement("span");
				label.textContent = colData.label;
				label.style.cssText = "color: var(--text-color); flex: 1;";

				item.appendChild(checkbox);
				item.appendChild(handle);
				item.appendChild(number);
				item.appendChild(label);
				orderList.appendChild(item);
			}

			// Set up drag-and-drop
			var draggedItem = null;

			orderList.addEventListener("dragstart", function (e) {
				if (e.target.className === "aqm-column-item") {
					draggedItem = e.target;
					e.target.style.opacity = "0.5";
				}
			});

			orderList.addEventListener("dragend", function (e) {
				if (e.target.className === "aqm-column-item") {
					e.target.style.opacity = "1";
					updateColumnNumbers();
				}
			});

			orderList.addEventListener("dragover", function (e) {
				e.preventDefault();
				var target = e.target;
				while (target && target.className !== "aqm-column-item") {
					target = target.parentElement;
				}

				if (target && target !== draggedItem && target.className === "aqm-column-item") {
					var rect = target.getBoundingClientRect();
					var midpoint = rect.top + rect.height / 2;
					if (e.clientY < midpoint) {
						target.parentNode.insertBefore(draggedItem, target);
					} else {
						target.parentNode.insertBefore(draggedItem, target.nextSibling);
					}
				}
			});

			// Update column numbers after reordering
			function updateColumnNumbers() {
				var items = orderList.querySelectorAll(".aqm-column-item");
				for (var i = 0; i < items.length; i++) {
					var numberSpan = items[i].querySelector(".aqm-column-number");
					if (numberSpan) {
						numberSpan.textContent = (i + 1) + ".";
					}
				}
			}
		}, 100);
	} catch (error) {
		console.error("Error in saveAQMPopup:", error);
		showModalMessage("Export Error", "Failed to open AQM export dialog: " + error.message, "error");
	}
}

// Helper function: Standard download for AQM files
function downloadAQMStandard(content, filename) {
	var blob = new Blob([content], { type: "text/csv;charset=utf-8" });
	var url = URL.createObjectURL(blob);
	var link = document.createElement("a");
	link.href = url;
	link.download = filename;
	link.style.display = "none";
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
	URL.revokeObjectURL(url);
	showModalMessage("Export Complete", "Downloaded AQM file: " + filename, "success");
}

/**
 * Modern Measured Data Export Dialog - Export measured values (Mass, Length, Comment)
 * Uses FloatingDialog with File System Access API
 */
function saveMeasuredDataPopup() {
	try {
		// Step 1) Filter visible blast holes
		const visibleBlastHoles = allBlastHoles.filter((hole) => isHoleVisible(hole));

		if (visibleBlastHoles.length === 0) {
			showModalMessage("No Visible Holes", "There are no visible holes to export.", "warning");
			return;
		}

		// Step 2) Generate default filename with fresh timestamp
		var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
		var defaultFilename = "MLC-EXPORT-" + timestamp;

		// Step 3) Create dialog content
		var contentHTML = '<div style="padding: 20px;">';
		contentHTML += '<div style="margin-bottom: 15px;">';
		contentHTML += '<label class="labelWhite15" style="display: block; margin-bottom: 5px;"><strong>Filename (without .csv):</strong></label>';
		contentHTML += '<input type="text" id="export-measured-filename" value="' + defaultFilename + '" style="width: 100%; padding: 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 14px;">';
		contentHTML += '</div>';
		contentHTML += '<div style="margin-bottom: 10px;">';
		contentHTML += '<label class="labelWhite15"><strong>Holes to Export:</strong> ' + visibleBlastHoles.length + '</label>';
		contentHTML += '</div>';
		contentHTML += '<div style="margin-top: 15px; padding: 10px; background: var(--dark-mode-bg); border: 1px solid var(--light-mode-border); border-radius: 4px;">';
		contentHTML += '<p class="labelWhite12" style="margin: 5px 0;"><strong>Export Format:</strong> Measured Data CSV</p>';
		contentHTML += '<p class="labelWhite12" style="margin: 5px 0;">Contains: Entity Name, Hole ID, Measured Length, Measured Mass, Measured Comment</p>';
		contentHTML += '<p class="labelWhite12" style="margin: 5px 0; color: var(--accent-color);">Timestamps included for all measurements</p>';
		contentHTML += '</div>';
		contentHTML += '</div>';

		// Step 4) Create dialog
		var dialog = new FloatingDialog({
			title: "Export Measured Data",
			content: contentHTML,
			layoutType: "default",
			width: 500,
			height: 300,
			showConfirm: true,
			showCancel: true,
			confirmText: "Export",
			cancelText: "Cancel",
			onConfirm: async function () {
				try {
					// Step 5) Get filename
					var filename = document.getElementById("export-measured-filename").value.trim();
					if (!filename) {
						showModalMessage("No Filename", "Please enter a filename", "warning");
						return;
					}

					// Ensure .csv extension
					if (!filename.toLowerCase().endsWith(".csv")) {
						filename += ".csv";
					}

					// Step 6) Get measured data writer from FileManager
					var Writer = window.fileManager.writers.get("blasthole-csv-actual");
					if (!Writer) {
						throw new Error("Measured data writer not found in FileManager");
					}

					var writer = new Writer({ format: "actual" });

					// Step 7) Generate measured data CSV
					var blob = await writer.write({ holes: visibleBlastHoles });

					// Step 8) Export using File System Access API if available
					if (window.showSaveFilePicker) {
						try {
							var fileHandle = await window.showSaveFilePicker({
								suggestedName: filename,
								types: [{
									description: 'CSV Files',
									accept: { 'text/csv': ['.csv'] }
								}]
							});

							var writable = await fileHandle.createWritable();
							await writable.write(blob);
							await writable.close();

							showModalMessage("Export Complete", "Measured data saved to: " + filename, "success");
						} catch (err) {
							if (err.name !== "AbortError") {
								console.error("File System Access API error:", err);
								writer.downloadFile(blob, filename);
							}
						}
					} else {
						// Fallback download
						writer.downloadFile(blob, filename);
					}

					console.log("Exported " + visibleBlastHoles.length + " holes with measured data");
				} catch (error) {
					console.error("Measured data export error:", error);
					showModalMessage("Export Error", "Error: " + error.message, "error");
				}
			},
			onCancel: function () {
				// Dialog cancelled
			}
		});

		// Step 5) Show the dialog
		dialog.show();

		// Step 6) Focus filename field
		setTimeout(function () {
			var filenameInput = document.getElementById("export-measured-filename");
			if (filenameInput) {
				filenameInput.focus();
				filenameInput.select();
			}
		}, 100);
	} catch (error) {
		console.error("Error in saveMeasuredDataPopup:", error);
		showModalMessage("Export Error", "Failed to open export dialog: " + error.message, "error");
	}
}

//TODO use the FloatingDialog class to create this popup
// Using SweetAlert Library Create a popup that gets input from the user.
// Updated addHolePopup function with proper field handling
function addHolePopup() {
	// Moved to src/dialog/popups/generic/AddHoleDialog.js
	window.showAddHoleDialog();
}

function handlePatternAddingClick(event) {
	if (isAddingPattern) {
		// Get the click/touch coordinates relative to the canvas
		//const rect = canvas.getBoundingClientRect();
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		let clickX = event.clientX - rect.left;
		let clickY = event.clientY - rect.top;

		if (isNaN(event.clientX - rect.left) || isNaN(event.clientY - rect.top)) {
			// Handle the case when the values are NaN
			clickX = event.changedTouches[0].clientX - rect.left;
			clickY = event.changedTouches[0].clientY - rect.top;
		} else {
			// Proceed with the calculation using the valid values
			clickX = event.clientX - rect.left;
			clickY = event.clientY - rect.top;
		}
		// SNAPPIN SNAP:
		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
		addPatternPopup(parseFloat(worldX.toFixed(3)), parseFloat(worldY.toFixed(3)));
		//console.log("worldX: " + worldX + " worldY: " + worldY);
	} else {
		worldX = null;
		worldY = null;
	}
}
//TODO use the FloatingDialog class to create this popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
function addPatternPopup(worldX, worldY) {
	window.showPatternDialog("add_pattern", worldX, worldY);
}

// Same Space Checker
function checkHoleProximity(newX, newY, newDiameter, existingHoles) {
	// Use 0.1m for dummy holes or holes with no diameter
	const checkDiameter = newDiameter || 0.1;
	const minDistance = checkDiameter / 1000; // Convert mm to meters, 1 diameter minimum

	const proximityHoles = [];

	for (let i = 0; i < existingHoles.length; i++) {
		const existingHole = existingHoles[i];
		const existingDiameter = existingHole.holeDiameter || 0.1;
		const existingMinDistance = existingDiameter / 1000;

		// Calculate distance between hole centers
		const distance = Math.sqrt(Math.pow(newX - existingHole.startXLocation, 2) + Math.pow(newY - existingHole.startYLocation, 2));

		// Check if holes are too close (less than 1 diameter apart)
		const combinedMinDistance = Math.max(minDistance, existingMinDistance);
		if (distance < combinedMinDistance) {
			proximityHoles.push({
				hole: existingHole,
				distance: distance,
				requiredDistance: combinedMinDistance,
			});
		}
	}

	return proximityHoles;
}

// Step 1) Function to show proximity warning and get user decision
// Converted to FloatingDialog class - returns Promise matching Swal result format
function showProximityWarning(proximityHoles, newHoleInfo) {
	// Step 1a) Build hole list for display
	const holeList = proximityHoles.map((ph) => "‚Ä¢ " + ph.hole.entityName + ":" + ph.hole.holeID + " (" + ph.distance.toFixed(3) + "m apart, need " + ph.requiredDistance.toFixed(3) + "m)").join("\n");

	// Step 1b) Create content div with proper styling
	const contentDiv = document.createElement("div");
	contentDiv.style.textAlign = "left";
	contentDiv.style.maxHeight = "300px";
	contentDiv.style.overflowY = "auto";
	contentDiv.style.padding = "10px";

	// Step 1c) Detect dark mode for text color
	const darkModeEnabled = typeof window.darkModeEnabled !== "undefined" ? window.darkModeEnabled : false;
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	// Step 1d) Create warning header
	const warningHeader = document.createElement("p");
	warningHeader.style.fontWeight = "bold";
	warningHeader.style.marginBottom = "10px";
	warningHeader.style.color = textColor;
	warningHeader.textContent = "New hole would be too close to existing holes:";
	contentDiv.appendChild(warningHeader);

	// Step 1e) Create new hole info paragraph
	const newHolePara = document.createElement("p");
	newHolePara.style.marginBottom = "10px";
	newHolePara.style.color = textColor;
	newHolePara.textContent = "New hole: " + newHoleInfo.entityName + ":" + newHoleInfo.holeID + " at (" + newHoleInfo.x.toFixed(3) + ", " + newHoleInfo.y.toFixed(3) + ")";
	contentDiv.appendChild(newHolePara);

	// Step 1f) Create conflicting holes header
	const conflictingHeader = document.createElement("p");
	conflictingHeader.style.fontWeight = "bold";
	conflictingHeader.style.marginTop = "15px";
	conflictingHeader.style.marginBottom = "10px";
	conflictingHeader.style.color = textColor;
	conflictingHeader.textContent = "Conflicting holes:";
	contentDiv.appendChild(conflictingHeader);

	// Step 1g) Create pre element for hole list with red color
	const holeListPre = document.createElement("pre");
	holeListPre.style.fontSize = "12px";
	holeListPre.style.color = "#ff6b6b";
	holeListPre.style.marginBottom = "15px";
	holeListPre.style.whiteSpace = "pre-wrap";
	holeListPre.textContent = holeList;
	contentDiv.appendChild(holeListPre);

	// Step 1h) Create options header
	const optionsHeader = document.createElement("p");
	optionsHeader.style.fontWeight = "bold";
	optionsHeader.style.marginTop = "15px";
	optionsHeader.style.marginBottom = "10px";
	optionsHeader.style.color = textColor;
	optionsHeader.textContent = "Options:";
	contentDiv.appendChild(optionsHeader);

	// Step 1i) Create options list
	const optionsList = document.createElement("ul");
	optionsList.style.textAlign = "left";
	optionsList.style.paddingLeft = "20px";
	optionsList.style.marginBottom = "10px";
	optionsList.style.color = textColor;

	const skipLi = document.createElement("li");
	skipLi.innerHTML = "<strong>Skip:</strong> Skip this hole and ask again for next conflict";
	optionsList.appendChild(skipLi);

	const skipAllLi = document.createElement("li");
	skipAllLi.innerHTML = "<strong>Skip All:</strong> Skip all conflicting holes and import only valid holes";
	optionsList.appendChild(skipAllLi);

	const ignoreLi = document.createElement("li");
	ignoreLi.innerHTML = "<strong>Ignore:</strong> Add this hole despite warning and continue";
	optionsList.appendChild(ignoreLi);

	const cancelLi = document.createElement("li");
	cancelLi.innerHTML = "<strong>Cancel:</strong> Stop the entire operation without importing";
	optionsList.appendChild(cancelLi);

	contentDiv.appendChild(optionsList);

	// Step 1j) Return Promise matching Swal result format
	// Also set up theme change listener for font responsiveness
	return new Promise((resolve) => {
		const dialog = new window.FloatingDialog({
			title: "Hole Proximity Warning",
			content: contentDiv,
			width: 450,
			height: 380,
			layoutType: "default",
			draggable: true,
			resizable: true,
			closeOnOutsideClick: false, // Modal behavior - prevent clicks outside
			showConfirm: true, // Skip button (green)
			showCancel: false, // Remove Cancel button
			showDeny: true, // Ignore button (orange)
			showOption1: true, // Cancel button (red)
			showOption2: true, // Skip All button (green)
			confirmText: "Skip", // Skip this hole, ask again for next (green - safe default)
			denyText: "Ignore", // Add this hole despite warning (orange - dangerous)
			option1Text: "Cancel", // Stop entire operation (red - most severe)
			option2Text: "Skip All", // Skip all conflicts automatically (green - safe)
			onConfirm: () => {
				// Step 1k) User chose Skip - skip this hole and ask again for next conflict
				console.log("Proximity warning: User chose Skip");
				cleanupThemeListener();
				dialog.close();
				resolve({
					isConfirmed: false,
					isDenied: true, // Skip this hole
					isDismissed: false,
					skipAll: false,
					cancelled: false
				});
			},
			onDeny: () => {
				// Step 1l) User chose Ignore - add this hole despite warning and continue
				console.log("Proximity warning: User chose Ignore");
				cleanupThemeListener();
				dialog.close();
				resolve({
					isConfirmed: true, // Add the hole
					isDenied: false,
					isDismissed: false,
					skipAll: false,
					cancelled: false
				});
			},
			onOption1: () => {
				// Step 1m) User chose Cancel - stop entire operation without importing
				// CRITICAL: Set flag IMMEDIATELY (synchronously) before Promise resolves
				console.log("Proximity warning: User chose Cancel");
				cleanupThemeListener();

				// Set cancellation flag immediately so pattern generation loops can check it
				window.holeGenerationCancelled = true;

				dialog.close();
				resolve({
					isConfirmed: false,
					isDenied: false,
					isDismissed: true,
					cancelled: true, // Stop entire operation
					skipAll: false
				});
			},
			onOption2: () => {
				// Step 1n) User chose Skip All - skip all conflicting holes and import only valid ones
				console.log("Proximity warning: User chose Skip All");
				cleanupThemeListener();
				dialog.close();
				resolve({
					isConfirmed: false,
					isDenied: false,
					isDismissed: false,
					cancelled: false,
					skipAll: true // Auto-skip all future proximity warnings
				});
			}
		});

		// Step 1n) Function to update text colors based on theme
		const updateTextColors = () => {
			const darkModeEnabled = typeof window.darkModeEnabled !== "undefined" ? window.darkModeEnabled : false;
			const textColor = darkModeEnabled ? "#ffffff" : "#000000";

			// Update all text elements
			const textElements = contentDiv.querySelectorAll("p, li");
			textElements.forEach((el) => {
				// Don't override red color for conflicting holes list
				if (!el.textContent.includes("m apart")) {
					el.style.color = textColor;
				}
			});
		};

		// Step 1o) Set up theme change listener
		let themeListener = null;
		if (typeof window.addEventListener !== "undefined") {
			// Listen for custom theme change events or check periodically
			themeListener = () => {
				updateTextColors();
			};

			// Check if there's a theme change event we can listen to
			// Otherwise, we'll check on a timer
			const checkTheme = setInterval(() => {
				updateTextColors();
			}, 500);

			// Store interval ID for cleanup
			dialog._themeCheckInterval = checkTheme;
		}

		// Step 1p) Cleanup function
		const cleanupThemeListener = () => {
			if (dialog._themeCheckInterval) {
				clearInterval(dialog._themeCheckInterval);
				dialog._themeCheckInterval = null;
			}
		};

		// Step 1q) Set higher z-index to ensure proximity warning appears on top of success dialogs
		// FloatingDialog defaults to 10000, we need higher priority for warnings
		if (dialog.element) {
			dialog.element.style.zIndex = "15000";
		}

		// Step 1r) Show the dialog
		dialog.show();

		// Step 1s) Ensure z-index is set after show() in case element wasn't created yet
		setTimeout(() => {
			if (dialog.element) {
				dialog.element.style.zIndex = "15000";
			}
			// Initial color update
			updateTextColors();
		}, 0);
	});
}

// Function to generate the pattern of holes
// added rowid and posid 14 july 2025
function addPattern(offset, entityName, nameTypeIsNumerical, useGradeZ, rowOrientation, x, y, z, gradeZ, diameter, type, angle, bearing, length, subdrill, burden, spacing, rows, holesPerRow) {
	let entityType = "hole";
	let useGradeToCalcLength = useGradeZ;
	let startXLocation = parseFloat(x);
	let startYLocation = parseFloat(y);
	let startZLocation = parseFloat(z);
	// Step 1) Calculate gradeZLocation based on mode
	// If useGradeZ: use the user-provided gradeZ directly
	// Otherwise: calculate from length and subdrill
	let gradeZLocation = useGradeToCalcLength ? parseFloat(gradeZ) : parseFloat(startZLocation - (length - subdrill) * Math.cos(angle * (Math.PI / 180)));
	// Step 2) Calculate hole length (bench height - collar to grade)
	// BUG FIX 2025-12-28: When using gradeZ, calculate bench height as (CollarZ - GradeZ) / cos(angle)
	// Previously was calculating total length which caused subdrill to be counted twice
	let angleRad = parseFloat(angle) * (Math.PI / 180);
	let cosAngle = Math.cos(angleRad);
	// Protect against division by zero for horizontal holes
	if (Math.abs(cosAngle) < 0.001) cosAngle = 0.001;
	let holeLength = useGradeToCalcLength ? parseFloat((startZLocation - gradeZLocation) / cosAngle) : parseFloat(length);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let subdrillAmount = parseFloat(subdrill);
	let patternburden = parseFloat(burden);
	let patternspacing = parseFloat(spacing);
	let patternrows = parseInt(rows);
	let patternholesPerRow = parseInt(holesPerRow);
	let patternoffset = parseFloat(offset);
	let patternnameTypeIsNumerical = nameTypeIsNumerical;
	let patternrowOrientation = parseFloat((90 - rowOrientation) * (Math.PI / 180));

	let referenceX = startXLocation;
	let referenceY = startYLocation;

	let currentLetter = "A";
	let globalHoleCounter = allBlastHoles.length > 0 ? Math.max(...allBlastHoles.map((h) => parseInt(h.holeID) || 0)) + 1 : 1;

	// Get the starting rowID for this pattern
	const startingRowID = getNextRowID(entityName);
	console.log("Starting rowID for addPattern:", startingRowID);

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	for (let i = 0; i < patternrows; i++) {
		// Check for cancellation before each row
		if (window.holeGenerationCancelled) {
			console.log("Pattern generation cancelled by user");
			break;
		}

		// Each pattern row gets its own rowID
		const currentRowID = startingRowID + i;

		for (let j = 0; j < patternholesPerRow; j++) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user");
				break;
			}
			const relativeX = j * patternspacing;
			const relativeY = i * patternburden;

			let offsetX = 0;
			if (i % 2 === 1) {
				offsetX = patternoffset * patternspacing;
			}

			const rotatedX = (relativeX + offsetX) * Math.cos(patternrowOrientation) - relativeY * Math.sin(patternrowOrientation);
			const rotatedY = (relativeX + offsetX) * Math.sin(patternrowOrientation) + relativeY * Math.cos(patternrowOrientation);

			const finalX = referenceX + rotatedX;
			const finalY = referenceY + rotatedY;

			let holeID;
			const useCustomHoleID = true;

			if (!patternnameTypeIsNumerical) {
				holeID = currentLetter + (j + 1);
			} else {
				holeID = globalHoleCounter.toString();
				globalHoleCounter++;
			}

			// Position ID is sequential for each hole in this row (j + 1)
			const posID = j + 1;

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user - stopping hole addition");
				break;
			}

			addHole(useCustomHoleID, useGradeZ, entityName, holeID, parseFloat(finalX), parseFloat(finalY), parseFloat(startZLocation), parseFloat(gradeZLocation), parseFloat(holeDiameter), holeType, parseFloat(holeLength), parseFloat(subdrillAmount), parseFloat(holeAngle), parseFloat(holeBearing), currentRowID, posID, patternburden, patternspacing);
		}

		// Increment the current letter for the next row ONLY IF alphanumeric naming is used
		if (!patternnameTypeIsNumerical) {
			if (currentLetter === "Z") {
				currentLetter = "AA";
			} else if (currentLetter === "ZZ") {
				currentLetter = "AAA";
			} else {
				currentLetter = incrementLetter(currentLetter);
			}
		}
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Reset the pattern adding state
	isAddingPattern = false;
	addPatternSwitch.checked = false;
	resetZoom();
	// Step #) Trigger 3D rebuild to show newly generated pattern
	window.threeDataNeedsRebuild = true;
	drawData(allBlastHoles, selectedHole);

	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	} else if (typeof updateTreeView === "function") {
		updateTreeView();
	}

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated pattern with " + patternrows + " rows (rowIDs " + startingRowID + "-" + (startingRowID + patternrows - 1) + ")");
	}
}

// Expose addPattern globally for PatternGenerationDialogs.js
window.addPattern = addPattern;
// Expose functions globally for AddHoleDialog.js
window.addHole = addHole;
window.checkHoleProximity = checkHoleProximity;
window.showProximityWarning = showProximityWarning;
// Expose world coordinate variables globally for AddHoleDialog.js
window.worldX = worldX;
window.worldY = worldY;
window.worldZ = worldZ;

function incrementLetter(str) {
	// Helper function to increment letters
	const lastIndex = str.length - 1;
	let carry = false;
	const newStr = str
		.split("")
		.reverse()
		.map((char, index) => {
			if (index === 0 || carry) {
				if (char === "Z") {
					carry = true;
					return "A";
				} else {
					carry = false;
					return String.fromCharCode(char.charCodeAt(0) + 1);
				}
			} else {
				return char;
			}
		})
		.reverse()
		.join("");
	if (carry) {
		return "A" + newStr;
	}
	return newStr;
}

function setMeasuredDate() {
	const date = new Date();
	const day = date.getDate();
	const month = date.getMonth() + 1;
	const year = date.getFullYear();
	const hours = date.getHours();
	const minutes = date.getMinutes();
	const seconds = date.getSeconds();
	return `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
}

function handleBlastNameClick(event) {
	if (isBlastNameEditing) {
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && editBlastNameSwitch.checked == false) {
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			} else {
				drawData(allBlastHoles, selectedHole);
			}
		}
		if (clickedHole && editBlastNameSwitch.checked == true) {
			editBlastNamePopup(selectedHole);
		}
	}

	clickedHole = null;
	fromHoleStore = null;
	selectedHole = null;
	selectedPoint = null;
	//selectedMultiplePoints = []
	isBlastNameEditing = false;
	editBlastNameSwitch.checked = false;
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView(); // Use debounced version
}

// IMPORTANT IMPLEMENTING A ROW ID AND POS ID FOR BLASTHOLES THIS WILL HELP WITH ORDERING
// Helper function to get the next rowID for a given entityName
function getNextRowID(entityName) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest rowID for this entityName
	const entityHoles = allBlastHoles.filter((hole) => hole.entityName === entityName);
	if (entityHoles.length === 0) {
		return 1;
	}

	let maxRowID = 0;
	entityHoles.forEach((hole) => {
		if (hole.rowID && !isNaN(hole.rowID)) {
			maxRowID = Math.max(maxRowID, parseInt(hole.rowID));
		}
	});

	return maxRowID + 1;
}

// Helper function to get the next posID for a given entityName and rowID
function getNextPosID(entityName, rowID) {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return 1;
	}

	// Find the highest posID for this entityName and rowID
	const rowHoles = allBlastHoles.filter((hole) => hole.entityName === entityName && hole.rowID === rowID);

	if (rowHoles.length === 0) {
		return 1;
	}

	let maxPosID = 0;
	rowHoles.forEach((hole) => {
		if (hole.posID && !isNaN(hole.posID)) {
			maxPosID = Math.max(maxPosID, parseInt(hole.posID));
		}
	});

	return maxPosID + 1;
}

/**
 * Add hole to the allBlastHoles array popup using sweetalert and then draw the allBlastHoles
 * @param {boolean} useCustomHoleID - If true, use the custom hole ID
 * @param {boolean} useGradeZ - If true, use grade Z instead of length
 * @param {string} entityName - The name of the entity
 * @param {number} holeID - The ID of the hole
 * @param {number} startXLocation - The X location of the start of the hole
 * @param {number} startYLocation - The Y location of the start of the hole
 * @param {number} startZLocation - The Z location of the start of the hole
 * @param {number} gradeZLocation - The Z location of the grade of the hole
 * @param {number} diameter - The diameter of the hole
 * @param {string} type - The type of the hole
 * @param {number} length - The length of the hole
 * @param {number} subdrill - The subdrill of the hole
 * @param {number} angle - The angle of the hole
 * @param {number} bearing - The bearing of the hole
 * @param {number} rowID - The row ID (Vulcan-style organization)
 * @param {number} posID - The position ID within the row (Vulcan-style organization)
 * @param {number} burden - The burden of the hole
 * @param {number} spacing - The spacing of the hole
 *
 */
async function addHole(useCustomHoleID, useGradeZ, entityName, holeID, startXLocation, startYLocation, startZLocation, gradeZLocation, diameter, type, length, subdrill, angle, bearing, rowID = null, posID = null, burden, spacing) {
	if (typeof entityName === "string" && entityName.trim() !== "") {
		entityName = entityName.trim();
	} else {
		entityName = "undefined";
	}
	const entityType = "hole";

	// Initialize allBlastHoles as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	// Auto-assign rowID and posID if not provided (for individual hole creation)
	if (rowID === null) {
		rowID = getNextRowID(entityName);
	}
	if (posID === null) {
		posID = getNextPosID(entityName, rowID);
	}

	let newHoleID = null;
	if (useCustomHoleID === true) {
		// CRITICAL: Check for duplicate hole ID before using the custom ID
		const originalHoleID = holeID.toString();
		newHoleID = validateUniqueHoleID(entityName, originalHoleID);

		if (newHoleID !== originalHoleID) {
			console.warn("‚ö†Ô∏è Duplicate hole ID detected during addHole:", entityName + ":" + originalHoleID, "? Auto-assigned:", newHoleID);
		}
	} else if (useCustomHoleID === false) {
		if (allBlastHoles !== null) {
			newHoleID = allBlastHoles.length + 1;
		} else {
			newHoleID = 1;
		}
	} else {
		newHoleID = 9999;
	}

	// Parse values first
	startXLocation = parseFloat(startXLocation);
	startYLocation = parseFloat(startYLocation);
	startZLocation = parseFloat(startZLocation);
	let holeDiameter = parseFloat(diameter);
	let holeType = type;
	let holeLengthCalculated = parseFloat(length);
	let subdrillAmount = parseFloat(subdrill);
	let holeAngle = parseFloat(angle);
	let holeBearing = parseFloat(bearing);
	let connectorCurve = 0;

	// Handle NaN values
	if (isNaN(holeAngle)) {
		holeAngle = 0;
	}
	if (isNaN(holeBearing)) {
		holeBearing = 0;
	}

	// Calculate length from gradeZ if length is null and useGradeZ is true
	if (useGradeZ && isNaN(holeLengthCalculated) && !isNaN(parseFloat(gradeZLocation))) {
		let deltaZ = startZLocation - parseFloat(gradeZLocation);
		holeLengthCalculated = Math.abs(deltaZ / Math.cos(holeAngle * (Math.PI / 180)));
	}

	// Calculate gradeZLocation from length - subdrill if gradeZLocation is null
	if (useGradeZ && isNaN(parseFloat(gradeZLocation)) && !isNaN(holeLengthCalculated)) {
		gradeZLocation = startZLocation - (holeLengthCalculated - subdrillAmount) * Math.cos(holeAngle * (Math.PI / 180));
	}

	// Set default length to 0 if both length and gradeZ are null
	if (isNaN(holeLengthCalculated)) {
		holeLengthCalculated = 0;
	}

	// Step 2.5) Calculate angle components for geometry
	let angleRad = angle * (Math.PI / 180);
	let bearingRad = ((450 - bearing) % 360) * (Math.PI / 180);
	let cosAngle = Math.cos(angleRad);
	let sinAngle = Math.sin(angleRad);

	// Step 2.6) Calculate benchHeight from gradeZ or holeLengthCalculated
	// benchHeight is the VERTICAL distance from collar to grade
	let benchHeight;
	if (useGradeZ && !isNaN(parseFloat(gradeZLocation))) {
		benchHeight = startZLocation - parseFloat(gradeZLocation);
	} else {
		benchHeight = holeLengthCalculated * cosAngle;
	}

	// Step 2.7) Calculate total hole length along axis (collar to toe)
	// This already includes subdrill when calculated from gradeZ
	let totalLength = holeLengthCalculated;

	// Step 2.8) Calculate horizontal projection for toe
	let horizontalProjection = totalLength * sinAngle;

	// Step 3) Calculate end locations (toe) using the total length
	let endXLocation = parseFloat(startXLocation + horizontalProjection * Math.cos(bearingRad));
	let endYLocation = parseFloat(startYLocation + horizontalProjection * Math.sin(bearingRad));
	let endZLocation = parseFloat(startZLocation - totalLength * cosAngle);

	// Step 3.5) Calculate grade locations using bench length only (without subdrill)
	// benchLength is the distance along the hole axis from collar to grade
	let benchLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
	let horizontalProjectionToGrade = benchLength * sinAngle;
	let gradeXLocation = parseFloat(startXLocation + horizontalProjectionToGrade * Math.cos(bearingRad));
	let gradeYLocation = parseFloat(startYLocation + horizontalProjectionToGrade * Math.sin(bearingRad));

	// Only overwrite gradeZLocation if useGradeZ is false (using length-based calculation)
	if (!useGradeZ) {
		gradeZLocation = parseFloat(startZLocation - benchHeight);
	}

	// Step 3.6) Calculate subdrillLength (distance along hole axis from grade to toe)
	// This is the measured length of the subdrill section
	let subdrillLength = Math.abs(cosAngle) > 1e-9 ? subdrillAmount / cosAngle : subdrillAmount;

	// Check if endXLocation, endYLocation, or endZLocation is NaN
	if (isNaN(endXLocation)) {
		endXLocation = startXLocation;
	}
	if (isNaN(endYLocation)) {
		endYLocation = startYLocation;
	}
	if (isNaN(endZLocation)) {
		endZLocation = startZLocation;
	}

	// Check if gradeXLocation, gradeYLocation, or gradeZLocation is NaN
	if (isNaN(gradeXLocation)) {
		gradeXLocation = startXLocation;
	}
	if (isNaN(gradeYLocation)) {
		gradeYLocation = startYLocation;
	}
	if (isNaN(gradeZLocation)) {
		gradeZLocation = startZLocation;
	}

	let toHoleCombinedID = entityName.toString() + ":::" + newHoleID.toString();
	let timingDelayMilliseconds = 0;
	let colorHexDecimal = "red";
	let measuredLength = 0;
	let measuredLengthTimeStamp = "09/05/1975 00:00:00";
	let measuredMass = 0;
	let measuredMassTimeStamp = "09/05/1975 00:00:00";
	let measuredComment = "None";
	let measuredCommentTimeStamp = "09/05/1975 00:00:00";

	// benchHeight already calculated above in Step 2.6
	// No need to recalculate here

	// PROXIMITY CHECK: Check for nearby holes before adding
	const proximityHoles = checkHoleProximity(startXLocation, startYLocation, holeDiameter, allBlastHoles);

	if (proximityHoles.length > 0) {
		// Check if Skip All flag is set
		if (window.proximitySkipAll === true) {
			// Auto-skip this hole without showing dialog
			console.log("Auto-skipped hole due to proximity (Skip All active): " + newHoleID);
			return; // Skip this hole
		}

		// Show warning and get user decision
		const newHoleInfo = {
			entityName: entityName,
			holeID: newHoleID.toString(),
			x: startXLocation,
			y: startYLocation,
			diameter: holeDiameter,
		};

		try {
			const result = await showProximityWarning(proximityHoles, newHoleInfo);

			// Check if Skip All was selected
			if (result.skipAll) {
				// Set global flag to auto-skip all future proximity warnings
				window.proximitySkipAll = true;
				console.log("Skip All activated - all future proximity conflicts will be auto-skipped");
				// Skip this hole
				console.log("Skipped hole due to proximity (Skip All): " + newHoleID);
				return;
			}

			if (result.isConfirmed) {
				// User chose Ignore - add the hole
				addHoleToAllBlastHoles(
					entityName,
					entityType,
					newHoleID,
					startXLocation,
					startYLocation,
					startZLocation,
					endXLocation,
					endYLocation,
					endZLocation,
					gradeXLocation,
					gradeYLocation,
					gradeZLocation,
					subdrillAmount,
					subdrillLength,
					benchHeight,
					holeDiameter,
					holeType,
					holeLengthCalculated,
					holeAngle,
					holeBearing,
					toHoleCombinedID,
					timingDelayMilliseconds,
					colorHexDecimal,
					measuredLength,
					measuredLengthTimeStamp,
					measuredMass,
					measuredMassTimeStamp,
					measuredComment,
					measuredCommentTimeStamp,
					rowID,
					posID,
					burden || 0,
					spacing || 0,
					connectorCurve || 0
				);
			} else if (result.isDenied) {
				// User chose Skip - don't add this hole but continue
				console.log("Skipped hole due to proximity: " + newHoleID);
			} else if (result.isDismissed || result.cancelled) {
				// User chose Cancel - flag already set synchronously in dialog onCancel handler
				// Just remove holes and save (flag was set immediately above)
				console.log("Cancelled hole generation due to proximity warning - removing holes");

				// Remove all holes added during this generation session
				if (typeof window.holeGenerationStartCount !== "undefined" && window.allBlastHoles) {
					const startCount = window.holeGenerationStartCount;
					const currentCount = window.allBlastHoles.length;
					if (currentCount > startCount) {
						console.log("Removing " + (currentCount - startCount) + " holes added during cancelled generation");
						window.allBlastHoles.splice(startCount, currentCount - startCount);
						// Save to IndexedDB to persist the removal
						if (typeof window.debouncedSaveHoles === "function") {
							window.debouncedSaveHoles();
						}
						// Redraw and update
						if (typeof window.drawData === "function") {
							window.drawData(window.allBlastHoles, window.selectedHole);
						}
						if (typeof window.debouncedUpdateTreeView === "function") {
							window.debouncedUpdateTreeView();
						}
					}
				}
			}

			return; // Exit early after handling proximity result
		} catch (error) {
			console.error("Error in proximity warning:", error);
			return;
		}
	}

	// No proximity issues - add the hole normally
	addHoleToAllBlastHoles(
		entityName,
		entityType,
		newHoleID,
		startXLocation,
		startYLocation,
		startZLocation,
		endXLocation,
		endYLocation,
		endZLocation,
		gradeXLocation,
		gradeYLocation,
		gradeZLocation,
		subdrillAmount,
		subdrillLength,
		benchHeight,
		holeDiameter,
		holeType,
		holeLengthCalculated,
		holeAngle,
		holeBearing,
		toHoleCombinedID,
		timingDelayMilliseconds,
		colorHexDecimal,
		measuredLength,
		measuredLengthTimeStamp,
		measuredMass,
		measuredMassTimeStamp,
		measuredComment,
		measuredCommentTimeStamp,
		rowID,
		posID,
		burden || 0,
		spacing || 0,
		connectorCurve || 0
	);

	if (isAddingHole && !isAddingPattern) {
		debouncedUpdateTreeView();
		window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for new hole
		drawData(allBlastHoles, selectedHole);
	}
}

// Helper function to actually add the hole to allBlastHoles array
function addHoleToAllBlastHoles(
	entityName,
	entityType,
	newHoleID,
	startXLocation,
	startYLocation,
	startZLocation,
	endXLocation,
	endYLocation,
	endZLocation,
	gradeXLocation,
	gradeYLocation,
	gradeZLocation,
	subdrillAmount,
	subdrillLength,
	benchHeight,
	holeDiameter,
	holeType,
	holeLengthCalculated,
	holeAngle,
	holeBearing,
	toHoleCombinedID,
	timingDelayMilliseconds,
	colorHexDecimal,
	measuredLength,
	measuredLengthTimeStamp,
	measuredMass,
	measuredMassTimeStamp,
	measuredComment,
	measuredCommentTimeStamp,
	rowID,
	posID,
	burden,
	spacing,
	connectorCurve
) {
	allBlastHoles.push({
		entityName: entityName,
		entityType: entityType,
		holeID: newHoleID.toString(),
		startXLocation: startXLocation,
		startYLocation: startYLocation,
		startZLocation: startZLocation,
		endXLocation: endXLocation,
		endYLocation: endYLocation,
		endZLocation: endZLocation,
		gradeXLocation: gradeXLocation,
		gradeYLocation: gradeYLocation,
		gradeZLocation: gradeZLocation,
		subdrillAmount: subdrillAmount,
		subdrillLength: subdrillLength,
		benchHeight: benchHeight,
		holeDiameter: holeDiameter,
		holeType: holeType,
		holeLengthCalculated: holeLengthCalculated,
		holeAngle: holeAngle,
		holeBearing: holeBearing,
		fromHoleID: toHoleCombinedID.toString(),
		timingDelayMilliseconds: timingDelayMilliseconds,
		colorHexDecimal: colorHexDecimal.toString(),
		measuredLength: measuredLength,
		measuredLengthTimeStamp: measuredLengthTimeStamp,
		measuredMass: measuredMass,
		measuredMassTimeStamp: measuredMassTimeStamp,
		measuredComment: measuredComment,
		measuredCommentTimeStamp: measuredCommentTimeStamp,
		visible: true,
		rowID: parseInt(rowID),
		posID: parseInt(posID),
		burden: burden,
		spacing: spacing,
		connectorCurve: connectorCurve,
	});

	//console.log("Added Hole: " + newHoleID + " (Row: " + rowID + ", Pos: " + posID + ")");
}

function handleMeasuredLengthClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredLengthTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole.holeID);
		if (clickedHole && measuredLengthSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
			}
		} else if (clickedHole && measuredLengthSwitch.checked == true) {
			measuredLengthPopup();
		}
	}
}

function handleMeasuredMassClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredMassTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredMassSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredMassSwitch.checked == true) {
			measuredMassPopup();
		}
	}
}

function handleMeasuredCommentClick(event) {
	if (isMeasureRecording) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;
		//const measuredCommentTimeStamp = formatDate(new Date().toLocaleString());

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		// console.log("ClickedX = " + clickX);
		// console.log("ClickedY = " + clickY);
		// console.log("ClickedHole = " + clickedHole);
		if (clickedHole && measuredCommentSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			}
		} else if (clickedHole && measuredCommentSwitch.checked == true) {
			measuredCommentPopup();
		}
	}
}

function handleHoleTypeEditClick(event) {
	if (isTypeEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editHoleTypePopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editHoleTypePopupSwitch.checked == true) {
			editHoleTypePopup();
		}
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editHoleTypePopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

function handleHoleLengthEditClick(event) {
	if (isLengthPopupEditing) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Get the clicked hole
		const clickedHole = getClickedHole(clickX, clickY);
		drawData(allBlastHoles, selectedHole);

		if (clickedHole && editLengthPopupSwitch.checked == false) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		} else if (clickedHole && editLengthPopupSwitch.checked == true) {
			editHoleLengthPopup();
		}
		// Replace the problematic lines with null-safe versions:
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled && editLengthPopupSwitch.checked == false) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole);
			debouncedUpdateTreeView();
		}
	}
}

// Modified handleSelection function to support multiple KAD object selection
function handleSelection(event) {
	if (developerModeEnabled) {
		console.log("=== HANDLE SELECTION DEBUG ===");
		console.log("isSelectionPointerActive:", isSelectionPointerActive);
		console.log("event.shiftKey:", event.shiftKey);
		console.log("Click coordinates:", event.clientX - canvas.getBoundingClientRect().left, event.clientY - canvas.getBoundingClientRect().top);
	}

	if (isSelectionPointerActive) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		// Step 5) Respect radio selection mode
		const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
		const selectingKAD = selectKADRadio && selectKADRadio.checked;

		// Check if Shift key is pressed for multiple selection
		const isShiftPressed = event.shiftKey;

		// Step 6) Try Holes (only if Holes radio is selected)
		let clickedHole = null;
		if (selectingHoles) {
			clickedHole = getClickedHole(clickX, clickY);
		}

		if (clickedHole && selectingHoles && !isMultiHoleSelectionEnabled) {
			// Single hole selection
			if (!fromHoleStore) {
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			} else {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = []; // Clear multiple KAD selection
			}
		}

		// Step 7) Multiple holes (only if Holes radio is selected)
		let multipleClickedHoles = selectingHoles ? getMultipleClickedHoles(clickX, clickY) : [];
		if (selectingHoles && multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles];
			selectedKADPolygon = null;
			selectedKADObject = null;
			selectedMultipleKADObjects = []; // Clear multiple KAD selection
		}

		// Step 8) Try KAD objects (only if KAD radio is selected)
		let clickedKADObject = null;
		if (selectingKAD) {
			clickedKADObject = getClickedKADObject(clickX, clickY);

			if (clickedKADObject) {
				// Allow multiple selection for ALL entity types, not just poly
				if (isShiftPressed) {
					if (developerModeEnabled) {
						console.log("Shift pressed - multiple selection mode for", clickedKADObject.entityType);
					}

					// Multiple selection mode with Shift key
					const existingIndex = selectedMultipleKADObjects.findIndex(function (obj) {
						return obj.entityName === clickedKADObject.entityName && obj.entityType === clickedKADObject.entityType;
					});

					if (existingIndex === -1) {
						// Add to multiple selection
						selectedMultipleKADObjects.push(clickedKADObject);
					} else {
						// Remove from multiple selection
						selectedMultipleKADObjects.splice(existingIndex, 1);
					}

					// Clear single selection when using multiple
					selectedKADObject = null;
					selectedKADPolygon = null;
				} else {
					// Single selection - clear multiple selection
					selectedKADObject = clickedKADObject;
					selectedKADPolygon = clickedKADObject; // Maintain backward compatibility
					selectedMultipleKADObjects = [];

					const entity = getEntityFromKADObject(selectedKADObject);
					const hasMultipleElements = entity && entity.data.length > 1;

					// Step 9c) Set selectedPoint - for segments, highlight the endpoint that will be deleted
					if (clickedKADObject.selectionType === "segment" && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
						const isPoly = clickedKADObject.entityType === "poly";
						const numPoints = entity.data.length;
						const endpointIndex = isPoly ? (clickedKADObject.elementIndex + 1) % numPoints : clickedKADObject.elementIndex + 1;
						selectedPoint = entity.data[endpointIndex];
					} else {
						selectedPoint = entity.data[clickedKADObject.elementIndex];
					}
				}

				// Clear hole selections when KAD object is selected
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// Step 9) Nothing was clicked - clear all selections if not shift clicking
		if (!isShiftPressed && !clickedHole && !multipleClickedHoles.length && !clickedKADObject) {
			if (selectingKAD) {
				selectedKADPolygon = null;
				selectedKADObject = null;
				selectedMultipleKADObjects = [];
				selectedPoint = null;
			}
			if (selectingHoles) {
				selectedHole = null;
				selectedMultipleHoles = [];
			}
		}

		// HUD: Show selection message (consistent format for 2D/3D)
		if (selectedMultipleHoles.length > 0) {
			var holeIDs = selectedMultipleHoles.map((h) => h.holeID);
			var displayIDs = holeIDs.length > 10 ? holeIDs.slice(0, 10).join(",") + "..." : holeIDs.join(",");
			showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs + "}\nEscape key to clear Selection");
			console.log("Selected Multiple Holes:", selectedMultipleHoles);
		} else if (selectedHole) {
			showSelectionMessage(buildHoleSelectionMessage(selectedHole));
		} else if (selectedMultipleKADObjects.length > 0) {
			showSelectionMessage("Editing " + selectedMultipleKADObjects.length + " KAD objects\nEscape key to clear Selection");
			console.log("Selected Multiple KAD Objects:", selectedMultipleKADObjects);
		} else if (selectedKADObject) {
			showSelectionMessage("Editing KAD: " + selectedKADObject.entityName + "\nEscape key to clear Selection");
		} else {
			clearStatus();
		}

		// Step 10) Sync selections to TreeView
		if (typeof syncCanvasToTreeView === "function") {
			syncCanvasToTreeView();
		}

		drawData(allBlastHoles, selectedHole);
	} else {
		console.log("Selection pointer NOT active - exiting");
	}
}

function completePolygonSelection() {
	if (!isPolygonSelectionActive || polyPointsX.length < 3) return;

	// Step 1) Remove the last moving point
	polyPointsX.pop();
	polyPointsY.pop();

	// Step 2) Clear previous selections
	selectedMultipleHoles = [];
	selectedMultipleKADObjects = [];
	selectedHole = null; // Clear single hole selection

	// Step 3) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	// Step 4) Mutually exclusive selection logic
	if (selectingHoles) {
		// Only select holes
		allBlastHoles.forEach((hole) => {
			if (isHoleVisible(hole) && isPointInPolygon(hole.startXLocation, hole.startYLocation, polyPointsX, polyPointsY)) {
				selectedMultipleHoles.push(hole);
			}
		});
	} else if (selectingKAD) {
		// Only select KAD objects
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			if (!isEntityVisible(entityName)) continue;

			let isInsideSelection = false;

			// For all entity types, check if any VISIBLE point is inside the selection polygon
			for (const point of entity.data) {
				// Step 4a) Skip hidden points - hidden items not selectable from canvas
				if (point.visible === false) continue;
				if (isPointInPolygon(point.pointXLocation, point.pointYLocation, polyPointsX, polyPointsY)) {
					isInsideSelection = true;
					break;
				}
			}

			// Additional check: if any VISIBLE segment intersects the selection polygon boundary
			if (!isInsideSelection && entity.data.length >= 2) {
				let numPoints = entity.data.length;
				let isClosed = entity.entityType === "poly";

				for (let i = 0; i < (isClosed ? numPoints : numPoints - 1); i++) {
					const point1 = entity.data[i];
					const point2 = entity.data[(i + 1) % numPoints];
					// Step 4b) Skip segments where either endpoint is hidden
					if (point1.visible === false || point2.visible === false) continue;

					const p1x = point1.pointXLocation;
					const p1y = point1.pointYLocation;
					const p2x = point2.pointXLocation;
					const p2y = point2.pointYLocation;

					for (let j = 0; j < polyPointsX.length; j++) {
						const q1x = polyPointsX[j];
						const q1y = polyPointsY[j];
						const q2x = polyPointsX[(j + 1) % polyPointsX.length];
						const q2y = polyPointsY[(j + 1) % polyPointsY.length];

						if (lineSegmentsIntersect(p1x, p1y, p2x, p2y, q1x, q1y, q2x, q2y)) {
							isInsideSelection = true;
							break;
						}
					}
					if (isInsideSelection) break;
				}
			}

			if (isInsideSelection) {
				// Create object in same format as shift-click selection
				const kadObject = {
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: 0, // Default to first element
					selectionType: "entity", // Mark as full entity selection
				};

				// Add specific properties based on entity type
				if (entity.entityType === "circle" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.radius = entity.data[0].radius;
				} else if (entity.entityType === "text" && entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
					kadObject.text = entity.data[0].text;
				} else if (entity.data[0]) {
					kadObject.pointXLocation = entity.data[0].pointXLocation;
					kadObject.pointYLocation = entity.data[0].pointYLocation;
				}

				selectedMultipleKADObjects.push(kadObject);
			}
		}
	}

	// Step 5) HUD: Show selection message (consistent format for 2D/3D)
	if (selectedMultipleHoles.length > 0) {
		var holeIDsPoly = selectedMultipleHoles.map((h) => h.holeID);
		var displayIDsPoly = holeIDsPoly.length > 10 ? holeIDsPoly.slice(0, 10).join(",") + "..." : holeIDsPoly.join(",");
		showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDsPoly + "}\nEscape key to clear Selection");
	} else if (selectedMultipleKADObjects.length > 0) {
		showSelectionMessage("Editing " + selectedMultipleKADObjects.length + " KAD objects\nEscape key to clear Selection");
	} else {
		showStatusMessage("No objects found in selection area", 3000);
	}

	// Step 6) Enable multi-selection mode if we have selections
	if (selectedMultipleHoles.length > 0) {
		isMultiHoleSelectionEnabled = true;
	}

	// Step 7) Clear polygon selection points
	polyPointsX = [];
	polyPointsY = [];

	// Step 8) Update visual display and tree view
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();

	// Step 9) Highlight selected nodes in tree view using existing system
	if (treeView) {
		const nodeIds = [];

		// Add selected holes to node IDs
		if (selectedMultipleHoles.length > 0) {
			selectedMultipleHoles.forEach((hole) => {
				nodeIds.push("hole‚£ø" + hole.holeID);
			});
		}

		// Add selected KAD objects to node IDs
		if (selectedMultipleKADObjects.length > 0) {
			selectedMultipleKADObjects.forEach((kad) => {
				nodeIds.push(kad.entityType + "‚£ø" + kad.entityName);
			});
		}

		// Highlight all selected nodes at once
		treeView.highlightNodes(nodeIds);
	}
}
function handleHoleEditingSelection(event) {
	if (isHoleEditing || selectPointerTool.checked) {
		// Get the click/touch coordinates relative to the canvas
		const rect = canvas.getBoundingClientRect();
		const clickX = event.clientX - rect.left;
		const clickY = event.clientY - rect.top;

		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole && !isMultiHoleSelectionEnabled) {
			if (!fromHoleStore) {
				// Set the selected fromHole
				fromHoleStore = clickedHole;
				selectedHole = clickedHole;
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
			} else {
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();
				//console.log("centroidX: " + centroidX + " centroidY: " + centroidY);
			}
		}
		// Get the clicked hole or holes
		const multipleClickedHoles = getMultipleClickedHoles(clickX, clickY);
		if (multipleClickedHoles.length > 0 && isMultiHoleSelectionEnabled) {
			selectedMultipleHoles = [...multipleClickedHoles]; // Update the selection
			drawData(allBlastHoles, selectedHole); // You might need to modify this function to handle multiple selected holes
			debouncedUpdateTreeView();
		}
	}
}

// Step 0) Invalidate contour cache - call this when holes are added/modified/deleted
function invalidateContourCache() {
	cachedContourHash = null;
	cachedContourLinesArray = [];
	cachedDirectionArrows = [];
}

// Step 0a) Force recalculate contours regardless of display options (for pre-caching)
function forceRecalculateContours(blastHoles) {
	if (!blastHoles || blastHoles.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	try {
		// Step 1) Calculate hole times
		var times = calculateTimes(blastHoles);

		// Step 2) Prepare contour data
		var contourData = [];
		for (var i = 0; i < times.length; i++) {
			var parts = times[i][0].split(":::");
			var entityName = parts[0];
			var holeID = parts[1];
			var time = times[i][1];

			var hole = null;
			for (var j = 0; j < blastHoles.length; j++) {
				if (blastHoles[j].entityName === entityName && blastHoles[j].holeID === holeID) {
					hole = blastHoles[j];
					break;
				}
			}

			if (hole) {
				contourData.push({
					x: hole.startXLocation,
					y: hole.startYLocation,
					z: time,
				});
			}
		}

		if (contourData.length === 0) {
			return { contourLinesArray: [], directionArrows: [] };
		}

		// Step 3) Call delaunayContours
		var result = delaunayContours(contourData, null, maxEdgeLength);

		if (!result || !result.contourLinesArray) {
			return { contourLinesArray: [], directionArrows: [] };
		}

		// Step 4) Cache the results
		cachedContourHash = computeContourHash(blastHoles);
		cachedContourLinesArray = result.contourLinesArray;
		cachedDirectionArrows = result.directionArrows || [];

		return {
			contourLinesArray: cachedContourLinesArray,
			directionArrows: cachedDirectionArrows,
		};
	} catch (err) {
		console.error("Error in forceRecalculateContours:", err);
		return { contourLinesArray: [], directionArrows: [] };
	}
}

// Step 1) Helper function to compute a hash of hole positions, times, AND display options for caching
function computeContourHash(holes) {
	if (!holes || holes.length === 0) return "";
	// Step 1a) Create a hash based on hole positions and times
	var hashStr = "";
	for (var i = 0; i < holes.length; i++) {
		var h = holes[i];
		hashStr += h.startXLocation.toFixed(2) + "," + h.startYLocation.toFixed(2) + "," + (h.holeTime || 0) + ";";
	}

	// Step 1b) Include display options that affect contour/arrow generation
	// This ensures cache is invalidated when user toggles checkboxes or adjusts sliders
	hashStr += "opts:" +
		(displayContours ? displayContours.checked : false) + "," +
		(displayFirstMovements ? displayFirstMovements.checked : false) + "," +
		(displayRelief ? displayRelief.checked : false) + "," +
		(typeof intervalAmount !== "undefined" ? intervalAmount : 25) + "," +
		(typeof firstMovementSize !== "undefined" ? firstMovementSize : 2);

	// Step 1c) Simple hash function
	var hash = 0;
	for (var j = 0; j < hashStr.length; j++) {
		var chr = hashStr.charCodeAt(j);
		hash = (hash << 5) - hash + chr;
		hash |= 0; // Convert to 32bit integer
	}
	return hash.toString();
}

function recalculateContours(allBlastHoles, deltaX, deltaY) {
	// Step 1) Check if we have holes
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	// Step 2) Calculate hole times (always needed)
	holeTimes = calculateTimes(allBlastHoles);
	timeChart();

	// Step 3) Only recalculate if contours or direction arrows are being displayed
	if (!displayContours.checked && !displayFirstMovements.checked && !displayRelief.checked) {
		// Return cached if available, otherwise empty
		if (cachedContourLinesArray && cachedContourLinesArray.length > 0) {
			return {
				contourLinesArray: cachedContourLinesArray,
				directionArrows: cachedDirectionArrows,
			};
		}
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	try {
		// Step 4) Compute hash to check if we can use cached contours
		var currentHash = computeContourHash(allBlastHoles);
		if (currentHash === cachedContourHash && cachedContourLinesArray && cachedContourLinesArray.length > 0) {
			// Cache hit - return cached results
			return {
				contourLinesArray: cachedContourLinesArray,
				directionArrows: cachedDirectionArrows,
			};
		}

		// Step 5) Prepare contour data
		var contourData = [];
		for (var i = 0; i < holeTimes.length; i++) {
			var parts = holeTimes[i][0].split(":::");
			var entityName = parts[0];
			var holeID = parts[1];
			var time = holeTimes[i][1];

			var hole = null;
			for (var j = 0; j < allBlastHoles.length; j++) {
				if (allBlastHoles[j].entityName === entityName && allBlastHoles[j].holeID === holeID) {
					hole = allBlastHoles[j];
					break;
				}
			}

			if (hole) {
				contourData.push({
					x: hole.startXLocation,
					y: hole.startYLocation,
					z: time,
				});
			}
		}

		if (contourData.length === 0) {
			throw new Error("No valid contour data holes found.");
		}

		// Step 6) Call delaunayContours ONCE - it calculates ALL contour levels
		var result = delaunayContours(contourData, null, maxEdgeLength);

		// Step 7) Check if result is valid
		if (!result || !result.contourLinesArray) {
			console.warn("delaunayContours returned invalid result");
			return {
				contourLinesArray: [],
				directionArrows: [],
			};
		}

		// Step 8) Cache the results
		cachedContourHash = currentHash;
		cachedContourLinesArray = result.contourLinesArray;
		cachedDirectionArrows = result.directionArrows || [];

		// Step 9) Return the complete result (already contains all contour levels)
		return {
			contourLinesArray: cachedContourLinesArray,
			directionArrows: cachedDirectionArrows,
		};
	} catch (err) {
		console.error("Error in recalculateContours:", err);
		// Return empty arrays instead of undefined
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}
}

function calculateHoleGeometry(clickedHole, newValue, modeLAB) {
	const index = allBlastHoles.findIndex((hole) => hole.holeID === clickedHole.holeID && hole.entityName === clickedHole.entityName);
	if (index === -1) {
		return; // Hole not found
	}

	// Work directly on the original hole object instead of creating a copy
	let hole = allBlastHoles[index];

	// Destructure for easier access
	let { startXLocation: startX, startYLocation: startY, startZLocation: startZ, holeAngle, holeBearing, benchHeight, subdrillAmount } = hole;

	const radBearing = ((450 - holeBearing) % 360) * (Math.PI / 180);

	if (modeLAB === 1) {
		// Length
		const newLength = parseFloat(newValue);
		hole.holeLengthCalculated = newLength;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			const subdrillLength = subdrillAmount / cosAngle;
			const newBenchDrillLength = newLength - subdrillLength;
			hole.benchHeight = newBenchDrillLength * cosAngle;
		}

		// Recalculate everything based on the new length
		const newTotalVerticalDrop = newLength * cosAngle;
		hole.endZLocation = startZ - newTotalVerticalDrop;
		const horizontalProjection = newLength * sinAngle;
		hole.endXLocation = startX + horizontalProjection * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjection * Math.sin(radBearing);

		hole.gradeZLocation = startZ - hole.benchHeight;
		const benchDrillLength = hole.benchHeight / (Math.abs(cosAngle) > 1e-9 ? cosAngle : 1);
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);
	} else if (modeLAB === 2) {
		// Angle
		const newAngle = parseFloat(newValue);
		hole.holeAngle = newAngle;
		const radAngle = newAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + subdrillAmount) / cosAngle;
		} // For horizontal holes, length is independent

		hole.gradeZLocation = startZ - benchHeight;
		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0; // No bench drop for horizontal
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 3) {
		// Bearing
		const newBearing = parseFloat(newValue);
		hole.holeBearing = newBearing;
		const newRadBearing = ((450 - newBearing) % 360) * (Math.PI / 180);
		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(newRadBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(newRadBearing);

		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(newRadBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(newRadBearing);

		// FIX: Add the missing endZLocation calculation
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 4) {
		// Easting (X) - Simple delta shift
		const deltaX = newValue - hole.startXLocation;
		hole.startXLocation = newValue;
		hole.gradeXLocation += deltaX;
		hole.endXLocation += deltaX;
	} else if (modeLAB === 5) {
		// Northing (Y) - Simple delta shift
		const deltaY = newValue - hole.startYLocation;
		hole.startYLocation = newValue;
		hole.gradeYLocation += deltaY;
		hole.endYLocation += deltaY;
	} else if (modeLAB === 6) {
		// Elevation (Z)
		const deltaZ = newValue - hole.startZLocation;
		hole.startZLocation = newValue;
		hole.gradeZLocation += deltaZ;
		hole.endZLocation += deltaZ;
	} else if (modeLAB === 7) {
		// Diameter
		hole.holeDiameter = newValue;
	} else if (modeLAB === 8) {
		// Subdrill Amount
		const newSubdrillAmount = parseFloat(newValue);

		if (isNaN(newSubdrillAmount)) {
			console.warn("Invalid subdrill amount:", newValue);
			return;
		}
		hole.subdrillAmount = newSubdrillAmount;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (benchHeight + newSubdrillAmount) / cosAngle;
		}

		// Step 1) Update grade point (grade is at bench level, before subdrill)
		hole.gradeZLocation = startZ - benchHeight;
		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? benchHeight / cosAngle : 0;
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);

		// Step 2) Update toe/end point
		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	} else if (modeLAB === 9) {
		// BenchHeight (new mode for when grade Z changes)
		const newBenchHeight = parseFloat(newValue);

		if (isNaN(newBenchHeight)) {
			console.warn("Invalid bench height:", newValue);
			return;
		}
		hole.benchHeight = newBenchHeight;

		const radAngle = holeAngle * (Math.PI / 180);
		const cosAngle = Math.cos(radAngle);
		const sinAngle = Math.sin(radAngle);

		// Step 1) Recalculate hole length based on new bench height
		if (Math.abs(cosAngle) > 1e-9) {
			hole.holeLengthCalculated = (newBenchHeight + subdrillAmount) / cosAngle;
		}

		// Step 2) Update grade point at new bench height along hole vector
		hole.gradeZLocation = startZ - newBenchHeight;
		const benchDrillLength = Math.abs(cosAngle) > 1e-9 ? newBenchHeight / cosAngle : 0;
		const horizontalProjectionToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = startX + horizontalProjectionToGrade * Math.cos(radBearing);
		hole.gradeYLocation = startY + horizontalProjectionToGrade * Math.sin(radBearing);

		// Step 3) Update toe/end point
		const horizontalProjectionOfHoleLength = hole.holeLengthCalculated * sinAngle;
		hole.endXLocation = startX + horizontalProjectionOfHoleLength * Math.cos(radBearing);
		hole.endYLocation = startY + horizontalProjectionOfHoleLength * Math.sin(radBearing);
		hole.endZLocation = startZ - hole.holeLengthCalculated * cosAngle;
	}
	debouncedUpdateTreeView(); // Use debounced version
	if (typeof debouncedSaveHoles === "function") {
		debouncedSaveHoles(); // Save changes to IndexedDB
	}
	if (typeof window.redraw3D === "function") {
		window.redraw3D();
	} else {
		window.drawData(window.allBlastHoles, window.selectedHole);
	}
}

let isUpdatingTimeChart = false;
let timeChartUpdateTimer = null;

function timeChart() {
	if (isUpdatingTimeChart) {
		if (developerModeEnabled) {
			console.log("‚ùå Preventing recursive timechart call");
		}
		return;
	}

	isUpdatingTimeChart = true;

	// Step 1) Clear any pending timer
	if (timeChartUpdateTimer) {
		clearTimeout(timeChartUpdateTimer);
	}

	const chart = document.getElementById("timeChart");
	// If no holeTimes data, create a blank chart instead of returning
	if (!Array.isArray(holeTimes) || holeTimes.length === 0) {
		const layout = {
			title: {
				text: "Time Window Chart - No Data",
				xanchor: "right",
				font: {
					size: 10,
				},
			},
			plot_bgcolor: noneColor,
			paper_bgcolor: noneColor,
			font: {
				color: textFillColor,
			},
			modebar: {
				orientation: "v",
				bgcolor: noneColor,
				color: "rgba(255, 0, 0, 0.4)",
				activecolor: "red",
				position: "left",
			},
			margin: {
				l: 5,
				r: 50,
				b: 25,
				t: 25,
				pad: 2,
			},
			xaxis: {
				title: {
					text: "milliseconds (ms)",
					font: {
						size: 10,
					},
				},
				showgrid: true,
				range: [0, 100],
			},
			yaxis: {
				title: {
					text: "Holes Firing",
					font: {
						size: 10,
					},
				},
				showgrid: true,
				range: [0, 10],
			},
			height: 380,
			width: chart.offsetWidth - 50,
			annotations: [
				{
					text: "Load holes and connect them to see timing data",
					xref: "paper",
					yref: "paper",
					x: 0.5,
					y: 0.5,
					xanchor: "center",
					yanchor: "middle",
					showarrow: false,
					font: {
						size: 12,
						color: textFillColor,
					},
				},
			],
		};

		Plotly.react("timeChart", [], layout, {
			responsive: true,
			displayModeBar: true,
			modeBarButtonsToRemove: ["lasso2d", "select2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
			modeBarButtons: [["zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]],
		});

		// Reset flag for blank chart
		timeChartUpdateTimer = setTimeout(() => {
			isUpdatingTimeChart = false;
		}, 300);

		return; // Exit early after creating blank chart
	}

	const times = holeTimes.map((time) => time[1]);
	const maxTime = Math.max(...times);
	const timeRange = parseInt(document.getElementById("timeRange").value);
	const timeOffset = parseInt(document.getElementById("timeOffset").value);
	const numBins = Math.ceil(maxTime / timeRange);
	const binStart = -timeOffset;

	const measuredMassRadio = document.getElementById("measuredMassRadio");
	const holeCountRadio = document.getElementById("holeCountRadio");
	let useMass;
	useMass = useMass ? holeCountRadio?.checked : measuredMassRadio?.checked || false;

	let counts = Array(numBins).fill(0);
	let massSum = Array(numBins).fill(0);
	let validMassCount = 0;

	for (let hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			counts[binIndex]++;
			const mass = Number(hole.measuredMass);
			if (useMass && !isNaN(mass) && isFinite(mass)) {
				massSum[binIndex] += mass;
				validMassCount++;
			}
		}
	}

	const fallbackToCount = useMass && validMassCount < 2;
	const yValues = useMass && !fallbackToCount ? massSum : counts;

	const binEdges = Array(numBins)
		.fill(0)
		.map((_, index) => index * timeRange + binStart);

	const binCenters = binEdges.map((edge) => edge + timeRange / 2);
	const xTickInterval = Math.ceil(numBins / 10); // label ~5 ticks
	const tickvals = binCenters.filter((_, i) => i % xTickInterval === 0);
	const ticktext = tickvals.map((center) => center - timeRange / 2 + "?" + (center + timeRange / 2));

	const holeIDs = Array(numBins).fill(null);

	for (const hole of allBlastHoles) {
		const binIndex = Math.floor((hole.holeTime - binStart) / timeRange);
		if (binIndex >= 0 && binIndex < numBins) {
			holeIDs[binIndex] = holeIDs[binIndex] || [];
			holeIDs[binIndex].push(hole.entityName + ":" + hole.holeID);
		}
	}

	const entityholeIDTexts = holeIDs.map((bin) => {
		if (!bin) return "";
		return bin
			.map((combinedID) => {
				const [entityName, holeID] = combinedID.split(":");
				const hole = allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
				return hole ? hole.entityName + ":" + hole.holeID : "";
			})
			.filter(Boolean)
			.join(", ");
	});

	const hoverText = entityholeIDTexts.map((text, index) => {
		const totalMass = useMass && !fallbackToCount && massSum[index] ? massSum[index].toFixed(1) + " kg" : "";
		return totalMass ? text + "<br>Mass: " + totalMass : text;
	});

	const currentLayout = chart?._fullLayout;
	const newYLabel = useMass && !fallbackToCount ? "Total Measured Mass (kg)" : "Holes Firing";
	const currentYLabel = currentLayout?.yaxis?.title?.text;
	const preserveYRange = currentYLabel === newYLabel;

	const maxYValue = Math.max(...yValues) + 1;

	// Step 1) Extract numeric range values to avoid circular references
	let yAxisRange = [0, maxYValue - 0.5];
	if (preserveYRange && currentLayout && currentLayout.yaxis && currentLayout.yaxis.range) {
		const r0 = Number(currentLayout.yaxis.range[0]);
		const r1 = Number(currentLayout.yaxis.range[1]);
		if (!isNaN(r0) && !isNaN(r1) && isFinite(r0) && isFinite(r1)) {
			yAxisRange = [r0, r1];
		}
	}

	const layout = {
		title: {
			text: "Time Window Chart",
			xanchor: "right",
			font: {
				size: 10,
			},
		},
		plot_bgcolor: noneColor,
		paper_bgcolor: noneColor,
		font: {
			color: textFillColor,
		},
		modebar: {
			orientation: "v",
			bgcolor: noneColor,
			color: "rgba(255, 0, 0, 0.4)",
			activecolor: "red",
			position: "left",
		},
		margin: {
			l: 5,
			r: 50,
			b: 25,
			t: 25,
			pad: 2,
		},
		xaxis: {
			title: {
				text: "milliseconds (ms)",
				font: {
					size: 10,
				},
			},
			showgrid: true,
			rangeslider: {
				visible: true,
				thickness: 0.1,
			},
			tickvals: "auto", //tickvals, // if you want bin ranges
			ticktext: "~s", //ticktext, //if you want bin ranges
		},
		yaxis: {
			title: {
				text: newYLabel,
				font: {
					size: 10,
				},
			},
			showgrid: true,
			automargin: true,
			range: yAxisRange,
		},
		height: 380,
		width: chart.offsetWidth - 50, // ? dynamic width based on container,
	};

	// Step 1) Create fresh color array for initial chart - NEVER pass defaultColor directly
	const initialColors = [];
	for (let i = 0; i < numBins; i++) {
		initialColors.push("red");
	}

	const data = [
		{
			x: binCenters,
			y: yValues,
			type: "bar",
			width: timeRange, // ?? match bin width
			marker: {
				color: initialColors, // Use fresh array, not defaultColor
			},
			// text: hoverText,
			// textposition: "none", // ? disables labels drawn on bars
			//hoverinfo: "text+y",
			hovertemplate: "Bin: %{x} ms<br>" + (useMass && !fallbackToCount ? "Mass" : "Value") + ": %{y}<extra></extra>",
		},
	];

	Plotly.react("timeChart", data, layout, {
		responsive: true,
		displayModeBar: true,
		modeBarButtonsToRemove: ["lasso2d", "select2d", "hoverClosestCartesian", "hoverCompareCartesian", "toggleSpikelines"],
		modeBarButtons: [["zoomIn2d", "zoomOut2d", "autoScale2d", "resetScale2d", "toImage", "pan2d"]],
	});

	// ? Clear previously registered listeners
	chart.removeAllListeners?.("plotly_click");
	chart.removeAllListeners?.("plotly_deselect");

	let lastClickedIndex = null;
	let eventThrottleTimer = null;

	// Step 1) Helper to create fresh color array (NEVER reuse arrays - Plotly contaminates them)
	function createFreshColorArray(binCount, selectedIndex = -1) {
		const colors = [];
		for (let i = 0; i < binCount; i++) {
			if (i === selectedIndex) {
				colors.push("lime");
			} else {
				colors.push("red");
			}
		}
		return colors;
	}

	// Step 2) Throttled handler for single bar selection
	function handleSelection(selectedIndex) {
		// Clear any pending throttle
		if (eventThrottleTimer) {
			clearTimeout(eventThrottleTimer);
		}

		// Throttle rapid events
		eventThrottleTimer = setTimeout(() => {
			// Update selected holes array for single bin
			timingWindowHolesSelected = holeIDs[selectedIndex]
				? holeIDs[selectedIndex]
					.map((combinedID) => {
						const [entityName, holeID] = combinedID.split(":");
						return allBlastHoles.find((h) => h.entityName === entityName && h.holeID === holeID);
					})
					.filter(Boolean)
				: [];

			// Redraw canvas WITHOUT calling timeChart
			const wasUpdating = isUpdatingTimeChart;
			isUpdatingTimeChart = true;
			drawData(allBlastHoles, selectedHole);
			isUpdatingTimeChart = wasUpdating;
		}, 100); // 100ms throttle to batch rapid events
	}

	chart.on("plotly_click", function (data) {
		if (isUpdatingTimeChart) return; // Skip if already updating

		const clickedIndex = data.points?.[0]?.pointIndex;
		if (clickedIndex == null) return;

		// Create FRESH color array - never reuse
		const currentColors = createFreshColorArray(numBins, clickedIndex);

		try {
			Plotly.restyle("timeChart", {
				"marker.color": [currentColors],
			});
		} catch (e) {
			console.warn("?? Plotly.restyle error:", e);
			return;
		}

		lastClickedIndex = clickedIndex;

		// Handle selection with throttling
		handleSelection(clickedIndex);
	});

	chart.on("plotly_deselect", function () {
		if (isUpdatingTimeChart) return; // Skip if already updating

		// Create FRESH color array - all red (no selection)
		const resetColors = createFreshColorArray(numBins, -1);

		try {
			Plotly.restyle("timeChart", {
				"marker.color": [resetColors],
			});
		} catch (e) {
			console.warn("?? Plotly.restyle error:", e);
			return;
		}

		timingWindowHolesSelected = [];
		lastClickedIndex = null;

		// Redraw immediately without throttle for deselect
		const wasUpdating = isUpdatingTimeChart;
		isUpdatingTimeChart = true;
		drawData(allBlastHoles, selectedHole);
		isUpdatingTimeChart = wasUpdating;
	});

	// Step 2) Reset flag after Plotly has finished processing
	timeChartUpdateTimer = setTimeout(() => {
		isUpdatingTimeChart = false;
	}, 300);
}

// Log Helper Functions for the play slider
function playSpeedLogScale(sliderValue) {
	if (sliderValue <= 50) {
		// First half: 0.01 to 1.0
		const normalizedValue = sliderValue / 50;
		const minLog = Math.log10(0.01);
		const maxLog = Math.log10(1.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	} else {
		// Second half: 1.0 to 10.0
		const normalizedValue = (sliderValue - 50) / 50;
		const minLog = Math.log10(1.0);
		const maxLog = Math.log10(10.0);
		const scale = (maxLog - minLog) * normalizedValue;
		return Math.pow(10, minLog + scale);
	}
}

function updatePlaySpeed() {
	const playSpeedInput = document.getElementById("playSpeed");
	const sliderValue = parseFloat(playSpeedInput.value);

	// Use logarithmic scaling instead of direct value
	playSpeed = playSpeedLogScale(sliderValue);

	// Update button text with actual speed
	const playButton = document.getElementById("play");
	playButton.textContent = "PLAY @ " + playSpeed.toFixed(3) + "x";
}

// Optional: Add visual markers to show the scale divisions
function addPlaySpeedMarkers() {
	const slider = document.getElementById("playSpeed");
	const container = slider.parentElement;

	// Create scale markers div
	const markers = document.createElement("div");
	markers.style.cssText = "display: flex; justify-content: space-between; font-size: 10px; color: #666; margin-top: 2px;";
	markers.innerHTML = "<span>0.01x</span><span>1x</span><span>10x</span>";

	// Insert after the slider
	container.insertBefore(markers, slider.nextSibling);
}

// Add click event listener to the "Play" button
const playButton = document.getElementById("play");

playButton.addEventListener("click", () => {
	// Step 1) Update play speed
	updatePlaySpeed();

	// Step 2) Ensure timing is calculated before animation
	holeTimes = calculateTimes(allBlastHoles);

	// Step 3) Calculate max time safely
	let maxTime = 0;
	if (holeTimes && holeTimes.length > 0) {
		const times = holeTimes.map((time) => time[1]).filter((t) => !isNaN(t) && isFinite(t));
		maxTime = times.length > 0 ? Math.max(...times) : 0;
	}
	console.log("Calculated maxTime:", maxTime, "from", holeTimes.length, "holes");

	// Step 4) Set animation state
	isPlaying = true;

	// Step 5) Clear any existing animation
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
	}

	// Step 6) Initialize animation variables
	let currentTime = 0;
	let lastFrameTime = performance.now();
	let lastRenderTime = 0;
	const targetFPS = 60; // Target 60fps for smooth animation
	const frameInterval = 1000 / targetFPS;

	// Step 7) Define the animation loop using requestAnimationFrame
	function animationLoop() {
		if (!isPlaying) return; // Exit if stopped

		const now = performance.now();
		const realTimeElapsed = now - lastFrameTime; // Real milliseconds elapsed
		const blastTimeToAdvance = realTimeElapsed * playSpeed; // Scale by playSpeed

		currentTime += blastTimeToAdvance;
		lastFrameTime = now;

		// Step 8) Update and render if within time bounds
		// Scale buffer with playSpeed - faster speeds need MORE buffer time
		// At 0.5x: 250ms, at 1x: 500ms, at 2x: 1000ms, at 10x: 5000ms
		const bufferTime = 500 * Math.max(playSpeed, 0.1);
		if (currentTime <= maxTime + bufferTime) {
			// PERFORMANCE: Only render if enough time has elapsed (target 60fps)
			const timeSinceRender = now - lastRenderTime;
			if (timeSinceRender >= frameInterval) {
				timingWindowHolesSelected = allBlastHoles.filter((hole) => hole.holeTime <= currentTime);
				drawData(allBlastHoles, timingWindowHolesSelected);
				lastRenderTime = now - (timeSinceRender % frameInterval); // Account for drift
			}

			// Step 9) Request next frame
			animationFrameId = requestAnimationFrame(animationLoop);
		} else {
			// Step 10) Animation complete - ensure final frame is rendered
			timingWindowHolesSelected = allBlastHoles.filter((hole) => hole.holeTime <= currentTime);
			drawData(allBlastHoles, timingWindowHolesSelected);
			stopButton.click();
		}
	}

	// Step 11) Start the animation loop
	animationFrameId = requestAnimationFrame(animationLoop);
});

// Add click event listener to the "Stop" button
const stopButton = document.getElementById("stop");
stopButton.addEventListener("click", () => {
	// Step 1) Stop animation state
	isPlaying = false;

	// Step 2) Clear interval-based animation if exists
	if (animationInterval) {
		clearInterval(animationInterval);
		animationInterval = null;
	}

	// Step 3) Cancel requestAnimationFrame-based animation if exists
	if (animationFrameId) {
		cancelAnimationFrame(animationFrameId);
		animationFrameId = null;
	}

	// Step 4) Reset the selected holes array
	timingWindowHolesSelected = [];
});

// Add input event listener to the playSpeed input range
const playSpeedInput = document.getElementById("playSpeed");
playSpeedInput.addEventListener("input", updatePlaySpeed);

function drawLegend(strokecolor) {
	//draw a legend at the bottom of the screen in the center
	//the legend should be for the drawDelauanyTriangles function
	//the legend should display the roundedAngleDip Ranges and there colors
	const legend0to5 = "rgb(51, 139, 255)";
	const legend5to7 = "rgb(0, 102, 204)";
	const legend7to9 = "rgb(0, 204, 204)";
	const legend9to12 = "rgb(102, 204, 0)";
	const legend12to15 = "rgb(204, 204, 0)";
	const legend15to17 = "rgb(255, 128, 0)";
	const legend17to20 = "rgb(255, 0, 0)";
	const legend20above = "rgb(153, 0, 76)";
	//draw the legend
	ctx.beginPath();
	ctx.fill();
	ctx.font = "14px Arial";
	ctx.fontWeight = "bold";
	ctx.fillStyle = strokecolor;
	ctx.fillText("Legend Slope", 10, canvas.height / 2 - 70);
	ctx.fillText("0\u00B0-5\u00B0", 10, canvas.height / 2 - 40);
	ctx.fillText("5\u00B0-7\u00B0", 10, canvas.height / 2 - 10);
	ctx.fillText("7\u00B0-9\u00B0", 10, canvas.height / 2 + 20);
	ctx.fillText("9\u00B0-12\u00B0", 10, canvas.height / 2 + 50);
	ctx.fillText("12\u00B0-15\u00B0", 10, canvas.height / 2 + 80);
	ctx.fillText("15\u00B0-17\u00B0", 10, canvas.height / 2 + 110);
	ctx.fillText("17\u00B0-20\u00B0", 10, canvas.height / 2 + 140);
	ctx.fillText("20\u00B0+", 10, canvas.height / 2 + 170);
	ctx.fillStyle = legend0to5;
	ctx.fillRect(60, canvas.height / 2 - 55, 20, 20);
	ctx.fillStyle = legend5to7;
	ctx.fillRect(60, canvas.height / 2 - 25, 20, 20);
	ctx.fillStyle = legend7to9;
	ctx.fillRect(60, canvas.height / 2 + 5, 20, 20);
	ctx.fillStyle = legend9to12;
	ctx.fillRect(60, canvas.height / 2 + 35, 20, 20);
	ctx.fillStyle = legend12to15;
	ctx.fillRect(60, canvas.height / 2 + 65, 20, 20);
	ctx.fillStyle = legend15to17;
	ctx.fillRect(60, canvas.height / 2 + 95, 20, 20);
	ctx.fillStyle = legend17to20;
	ctx.fillRect(60, canvas.height / 2 + 125, 20, 20);
	ctx.fillStyle = legend20above;
	ctx.fillRect(60, canvas.height / 2 + 155, 20, 20);
	ctx.stroke();
}

function worldToCanvas(x, y) {
	return [(x - centroidX) * currentScale + canvas.width / 2, (-y + centroidY) * currentScale + canvas.height / 2];
}

// Helper to fetch display options once
function getDisplayOptions() {
	return {
		holeID: document.getElementById("display1").checked,
		holeLen: document.getElementById("display2").checked,
		holeDia: document.getElementById("display2A").checked,
		holeAng: document.getElementById("display3").checked,
		holeDip: document.getElementById("display4").checked,
		holeBea: document.getElementById("display5").checked,
		holeSubdrill: document.getElementById("display5B").checked,
		connector: document.getElementById("display5A").checked,
		delayValue: document.getElementById("display6").checked,
		initiationTime: document.getElementById("display6A").checked,
		contour: document.getElementById("display8").checked,
		slopeMap: document.getElementById("display8A").checked,
		burdenRelief: document.getElementById("display8B").checked,
		firstMovement: document.getElementById("display8C").checked,
		xValue: document.getElementById("display9").checked,
		yValue: document.getElementById("display10").checked,
		zValue: document.getElementById("display11").checked,
		holeType: document.getElementById("display12").checked,
		measuredLength: document.getElementById("display13").checked,
		measuredMass: document.getElementById("display14").checked,
		measuredComment: document.getElementById("display15").checked,
		voronoiPF: document.getElementById("display16").checked,
		displayRowAndPosId: document.getElementById("rowAndPosDisplay").checked,
	};
}

// Build hole map for quick lookup by entityName and holeID
function buildHoleMap(allBlastHoles) {
	const map = new Map();
	if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
		for (const pt of allBlastHoles) {
			map.set(pt.entityName + ":::" + pt.holeID, pt);
		}
	}
	return map;
}

let drawMouseLines = true; //used to debug mouse location

function drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, showSnapRadius = true, showMouseLines = true) {
	//draw a vertical lin the height of the canvas at the mouse x location and draw a line the width of the canvas at the y location of the mouse. it should be color grey at 50% opacity
	if (showMouseLines) {
		ctx.lineWidth = 0.5;
		ctx.beginPath();
		ctx.moveTo(mouseX, 0);
		ctx.lineTo(mouseX, canvas.height);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
		ctx.beginPath();
		ctx.moveTo(0, mouseY);
		ctx.lineTo(canvas.width, mouseY);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
	if (showSnapRadius && snapRadiusPixels > 0) {
		// Draw the snapping radius circle
		ctx.beginPath();
		ctx.arc(mouseX, mouseY, snapRadiusPixels, 0, 2 * Math.PI);
		ctx.strokeStyle = darkModeEnabled ? "rgba(200, 200, 200, 0.6)" : "rgba(100, 100, 100, 0.6)";
		ctx.stroke();
		ctx.closePath();
	}
}

// Main draw function
function drawData(allBlastHoles, selectedHole) {

	// Expose globals to window for canvas3DDrawing.js module
	exposeGlobalsToWindow();

	// Step 0.5) Initialize mouse indicator on first draw in 3D mode
	// This ensures the grey torus appears immediately on startup
	if (onlyShowThreeJS && threeInitialized && interactionManager && threeRenderer && !mouseIndicatorInitialized && allBlastHoles && allBlastHoles.length > 0) {
		mouseIndicatorInitialized = true; // Set flag immediately to prevent multiple calls

		// Use requestAnimationFrame to ensure canvas is fully rendered
		requestAnimationFrame(() => {
			const threeCanvas = threeRenderer.getCanvas();
			if (threeCanvas) {
				// Get canvas center coordinates
				const rect = threeCanvas.getBoundingClientRect();
				const centerX = rect.left + rect.width / 2;
				const centerY = rect.top + rect.height / 2;

				// Create and dispatch a synthetic mousemove event at canvas center
				const syntheticEvent = new MouseEvent("mousemove", {
					bubbles: true,
					cancelable: true,
					clientX: centerX,
					clientY: centerY,
					button: 0,
					buttons: 0,
				});

				// Dispatch on document (same as the real mousemove handler)
				// Synthetic Events is killing the GPU and destroying performance.  
				// document.dispatchEvent(syntheticEvent);
			}
		});
	}

	if (canvas) {
		// For UI version 2, this is ESSENTIAL.
		// For UI version 1, it adds robustness if its display size could ever change.
		if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;
		}
	}

	// Step 0) Initialize Three.js on first draw
	if (!threeInitialized && !threeInitializationFailed) {
		initializeThreeJS();
	}

	// Step 0a) Ensure Three.js canvas size matches 2D canvas
	if (threeInitialized && threeRenderer && canvas) {
		const threeCanvas = threeRenderer.getCanvas();
		if (threeCanvas && (threeCanvas.width !== canvas.clientWidth || threeCanvas.height !== canvas.clientHeight)) {
			threeRenderer.resize(canvas.clientWidth, canvas.clientHeight);
		}
	}

	// Step 0b) Update local origin if any data is loaded (holes or surfaces)
	if (threeLocalOriginX === 0 && threeLocalOriginY === 0) {
		const hasHoles = allBlastHoles && allBlastHoles.length > 0;
		const hasSurfaces = loadedSurfaces && loadedSurfaces.size > 0;
		const hasKADDrawings = allKADDrawingsMap && allKADDrawingsMap.size > 0;

		if (hasHoles || hasSurfaces || hasKADDrawings) {
			updateThreeLocalOrigin();

			// Step 0b.0) CRITICAL: Re-sync globals to window AFTER origin update
			// This ensures window.threeLocalOriginX/Y match module-level values
			// Fixes stadium zone coordinate mismatch bug where InteractionManager
			// used stale window.threeLocalOriginX/Y values
			exposeGlobalsToWindow();

			// Step 0b.1a) If 2D centroid is still at origin, calculate from all data sources
			// This ensures camera positioning works with surfaces/images even without blast holes
			if (centroidX === 0 && centroidY === 0) {
				const fullCentroid = calculateDataCentroid();
				centroidX = fullCentroid.x;
				centroidY = fullCentroid.y;
				centroidZ = fullCentroid.z;
				console.log("üìç 2D/3D centroid calculated from data:", centroidX.toFixed(2), centroidY.toFixed(2), centroidZ.toFixed(2));
			}

			// Step 0b.1) Sync camera to view the data after setting origin
			syncCameraToThreeJS();
		}
	}

	// Step 0c) Calculate Z centroid for orbit center ONLY when data changes
	// CRITICAL FIX: Removed per-frame calculation that caused 1-5 FPS with large LAS files
	// Now only recalculates when centroidNeedsRecalculation flag is set (by imports/deletes)
	if (centroidNeedsRecalculation) {
		dataCentroidZ = calculateDataZCentroid();
		centroidNeedsRecalculation = false;
		if (window.developerModeEnabled) {
			console.log("üìç dataCentroidZ recalculated:", dataCentroidZ.toFixed(2));
		}
	}

	// Step 1) Clear Three.js geometry ONLY when rebuild is needed
	// CRITICAL: Don't clear every frame - this was causing 1-4 FPS!
	if (window.threeDataNeedsRebuild && onlyShowThreeJS) {
		clearThreeJS();
	}
	// Step 1a) Clear 2D canvas always (to remove old content)
	if (ctx) {
		clearCanvas();
	}

	// Step 1b) Only process 2D drawing if not in Three.js-only mode
	if (ctx && !onlyShowThreeJS) {
		// Step 1b.1) Set canvas smoothing for 2D drawing
		ctx.imageSmoothingEnabled = false;

		const displayOptions = getDisplayOptions();
		let holeMap = new Map();
		if (allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			holeMap = buildHoleMap(allBlastHoles);
		}

		// Draw background images FIRST (bottom layer) - 2D ONLY
		drawBackgroundImage();

		// Draw surfaces SECOND - 2D ONLY
		// Note: drawSurface() will handle both 2D canvas drawing AND 3D geometry addition
		// when in hybrid mode (both visible). In pure 2D mode, only 2D triangles are drawn.
		drawSurface();

		// Step 4e) Highlight single selected point if needed (2D only)
		if (selectedPoint !== null && !onlyShowThreeJS) {
			const [x, y] = worldToCanvas(selectedPoint.pointXLocation, selectedPoint.pointYLocation);
			drawHiHole(x, y, 10, "rgba(255, 102, 255, 0.3)", "rgba(255, 0, 255, 0.6)");
		}

		// In drawData function, replace the drawing logic with hierarchical visibility:
		if (drawingsGroupVisible) {
			// ? ADD: Check overall drawings group visibility
			for (const [name, entity] of allKADDrawingsMap.entries()) {
				// ? Check entity visibility
				if (entity.visible === false) continue;

				// ? ADD: Check sub-group visibility based on entity type
				let subGroupVisible = true;
				switch (entity.entityType) {
					case "point":
						subGroupVisible = pointsGroupVisible;
						break;
					case "line":
						subGroupVisible = linesGroupVisible;
						break;
					case "poly":
						subGroupVisible = polygonsGroupVisible;
						break;
					case "circle":
						subGroupVisible = circlesGroupVisible;
						break;
					case "text":
						subGroupVisible = textsGroupVisible;
						break;
				}

				if (!subGroupVisible) continue; // ? Skip if sub-group is hidden

				if (developerModeEnabled && entity.entityType === "point") {
					entity.data.forEach((point) => {
						// ? Check individual element visibility
						if (point.visible === false) return;
						const screenX = (point.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(point.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						let lineWidthForDisplay = point.lineWidth;
						if (point.lineWidth <= 1) {
							lineWidthForDisplay = 1;
						}
						drawKADPoints(screenX, screenY, point.pointZLocation, lineWidthForDisplay, point.color);
						drawKADCoordinates(point, screenX, screenY);
					});
				} else if (entity.entityType === "point") {
					// Apply pixel distance simplification to points for performance
					const originalPoints = entity.data.filter((point) => point.visible !== false);
					const simplifiedPoints = simplifyByPxDist(originalPoints, 3);

					for (const pointData of simplifiedPoints) {
						let lineWidthForDisplay = pointData.lineWidth;
						if (pointData.lineWidth <= 1) {
							lineWidthForDisplay = 1;
						}
						const [x, y] = worldToCanvas(pointData.pointXLocation, pointData.pointYLocation);
						drawKADPoints(x, y, pointData.pointZLocation, lineWidthForDisplay, pointData.color);
						drawKADCoordinates(pointData, x, y);
					}
				} else if (entity.entityType === "circle") {
					// ? FIXED: Move visibility check inside forEach loop
					entity.data.forEach((circle) => {
						if (circle.visible === false) return; // ? Check individual element visibility
						const screenX = (circle.pointXLocation - centroidX) * currentScale + canvas.width / 2;
						const screenY = -(circle.pointYLocation - centroidY) * currentScale + canvas.height / 2;
						drawKADCircles(screenX, screenY, circle.pointZLocation, circle.radius, circle.lineWidth, circle.color);
						drawKADCoordinates(circle, screenX, screenY);
					});
				} else if (entity.entityType === "text") {
					entity.data.forEach((textData) => {
						if (textData.visible === false) return; // ? Check individual element visibility
						if (textData && textData.text) {
							const screenX = (textData.pointXLocation - centroidX) * currentScale + canvas.width / 2;
							const screenY = -(textData.pointYLocation - centroidY) * currentScale + canvas.height / 2;
							// Step B2) Pass fontHeight to 2D text drawing
							var textFontHeight2D = textData.fontHeight || 12;
							drawKADTexts(screenX, screenY, textData.pointZLocation, textData.text, textData.color, textFontHeight2D);
							drawKADCoordinates(textData, screenX, screenY);
						}
					});
				} else if (developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// ? FIXED: Filter visible points first, then use filtered data
					var visiblePoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});
					if (visiblePoints.length < 2) continue;

					// Draw all segments without any simplification
					// NOTE: Use nextPoint's color - segment TO the point uses that point's color
					for (var i = 0; i < visiblePoints.length - 1; i++) {
						var currentPoint = visiblePoints[i];
						var nextPoint = visiblePoints[i + 1];

						var coords1 = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						var coords2 = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);
						var sx = coords1[0],
							sy = coords1[1],
							ex = coords2[0],
							ey = coords2[1];

						// Step #) Use nextPoint's color and lineWidth - segment TO the point uses that point's attributes
						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, nextPoint.lineWidth, nextPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === visiblePoints[visiblePoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					var isClosed = entity.entityType === "poly";
					if (isClosed && visiblePoints.length > 2) {
						var firstPoint = visiblePoints[0];
						var lastPoint = visiblePoints[visiblePoints.length - 1];
						var coordsLast = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						var coordsFirst = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);
						var sx = coordsLast[0],
							sy = coordsLast[1],
							ex = coordsFirst[0],
							ey = coordsFirst[1];

						// For closing segment, use firstPoint's color (the segment goes TO firstPoint)
						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, firstPoint.lineWidth, firstPoint.color, false);
					}
				} else if (!developerModeEnabled && (entity.entityType === "line" || entity.entityType === "poly")) {
					// --- Pixel-distance simplification for performance ---
					var originalPoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});
					if (originalPoints.length < 2) continue;

					// Simplify by pixel distance
					// Get the scale ratio like the overlay does
					var PIXELS_PER_METER_96DPI = 3779.52;
					var scaleRatio = PIXELS_PER_METER_96DPI / currentScale;
					// Use scale ratio to determine pixel threshold
					var pointThreshold;
					if (scaleRatio > 3000) {
						pointThreshold = 4; // Normal zoom
					}
					else if (scaleRatio > 600) {
						pointThreshold = 3; // Normal zoom
					} else if (scaleRatio > 400) {
						pointThreshold = 2; // Normal zoom
					} else {
						pointThreshold = 1; // Zoomed in
					}

					var simplifiedPoints = simplifyByPxDist(originalPoints, pointThreshold);

					// Draw the simplified line/polygon
					// NOTE: Use nextPoint's color - segment TO the point uses that point's color
					for (var i = 0; i < simplifiedPoints.length - 1; i++) {
						var currentPoint = simplifiedPoints[i];
						var nextPoint = simplifiedPoints[i + 1];

						var coords1 = worldToCanvas(currentPoint.pointXLocation, currentPoint.pointYLocation);
						var coords2 = worldToCanvas(nextPoint.pointXLocation, nextPoint.pointYLocation);
						var sx = coords1[0],
							sy = coords1[1],
							ex = coords2[0],
							ey = coords2[1];

						// Step #) Use nextPoint's color and lineWidth - segment TO the point uses that point's attributes
						drawKADPolys(sx, sy, ex, ey, currentPoint.pointZLocation, nextPoint.pointZLocation, nextPoint.lineWidth, nextPoint.color, false);
						drawKADCoordinates(currentPoint, sx, sy);
						if (nextPoint === simplifiedPoints[simplifiedPoints.length - 1]) {
							drawKADCoordinates(nextPoint, ex, ey);
						}
					}

					// Handle closing segment for polygons
					var isClosed = entity.entityType === "poly";
					if (isClosed && simplifiedPoints.length > 2) {
						var firstPoint = simplifiedPoints[0];
						var lastPoint = simplifiedPoints[simplifiedPoints.length - 1];
						var coordsLast = worldToCanvas(lastPoint.pointXLocation, lastPoint.pointYLocation);
						var coordsFirst = worldToCanvas(firstPoint.pointXLocation, firstPoint.pointYLocation);
						var sx = coordsLast[0],
							sy = coordsLast[1],
							ex = coordsFirst[0],
							ey = coordsFirst[1];

						// For closing segment, use firstPoint's color (the segment goes TO firstPoint)
						drawKADPolys(sx, sy, ex, ey, lastPoint.pointZLocation, firstPoint.pointZLocation, firstPoint.lineWidth, firstPoint.color, false);
					}
				}
			}
		}

		// Step #) Draw offset preview overlay if active (2D mode)
		// This draws the live preview of offset operations on top of KAD drawings
		draw2DOffsetPreview();

		// Voronoi Powder Factor
		if (displayOptions.voronoiPF) {
			// VORONOI PF & OVERLAYS
			const tri = delaunayTriangles(allBlastHoles, maxEdgeLength);
			const blastBoundaryPolygon = createBlastBoundaryPolygon(tri.resultTriangles);
			const offsetBoundaryPolygon = offsetPolygonClipper(blastBoundaryPolygon, getAverageDistance(allBlastHoles) / 2);
			// console.log("DEBUG: VORONOI PF");
			switch (selectedVoronoiMetric) {
				case "powderFactor":
					// console.log("Drawing Powder Factor");
					//get the min and max values for the PF if isVoronoiLegendFixed is false
					let minPF, maxPF, intervalPF, deltaPF;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI PF NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.powderFactor).filter((v) => v != null && !isNaN(v));
						minPF = 0; //values.length > 0 ? Math.min(...values) : 0;
						maxPF = values.length > 0 ? Math.max(...values) : 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF / 4;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI PF FIXED");
						minPF = 0;
						maxPF = 3;
						if (maxPF - minPF > 0) {
							deltaPF = maxPF - minPF;
							intervalPF = deltaPF > 0 ? Math.ceil(deltaPF / 10) : 0.5;
						} else {
							minPF = 0;
							maxPF = 1;
							intervalPF = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getPFColor(value, minPF, maxPF), "Legend Powder Factor", minPF, maxPF, intervalPF);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Powder Factor (kg/m\u00b3)", minPF, maxPF);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCells = clipVoronoiCells(voronoiMetrics);
						drawVoronoiCellsThreeJS(
							clippedCells,
							function (value) {
								return getPFColor(value, minPF, maxPF);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"powderFactor"
						);
					}
					break;
				case "mass":
					// console.log("Drawing Mass");
					let minMass, maxMass, intervalMass, deltaMass;

					if (!isVoronoiLegendFixed) {
						// console.log("DEBUG: VORONOI MASS NOT FIXED");
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.mass).filter((v) => v != null && !isNaN(v));
						minMass = values.length > 0 ? Math.min(...values) : 0;
						maxMass = values.length > 0 ? Math.max(...values) : 500;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass / 4;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					} else {
						// console.log("DEBUG: VORONOI MASS FIXED");
						minMass = 0;
						maxMass = 1000;
						if (maxMass - minMass > 0) {
							deltaMass = maxMass - minMass;
							intervalMass = deltaMass > 0 ? Math.ceil(deltaMass / 10) : 250;
						} else {
							minMass = 0;
							maxMass = 1;
							intervalMass = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getMassColor(value, minMass, maxMass), "Legend Mass", minMass, maxMass, intervalMass);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Mass (kg)", minMass, maxMass);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsMass = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsMass = clipVoronoiCells(voronoiMetricsMass);
						drawVoronoiCellsThreeJS(
							clippedCellsMass,
							function (value) {
								return getMassColor(value, minMass, maxMass);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"mass"
						);
					}
					break;
				case "volume": {
					// console.log("Drawing Volume");
					let minVol, maxVol, intervalVol, deltaVol;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.volume).filter((v) => v != null && !isNaN(v));
						minVol = values.length > 0 ? Math.min(...values) : 0;
						maxVol = values.length > 0 ? Math.max(...values) : 100;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = deltaVol / 10;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					} else {
						minVol = 0;
						maxVol = 5000;
						if (maxVol - minVol > 0) {
							deltaVol = maxVol - minVol;
							intervalVol = 500;
						} else {
							minVol = 0;
							maxVol = 1;
							intervalVol = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getVolumeColor(value, minVol, maxVol), "Legend Volume", minVol, maxVol, intervalVol);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Volume (m\u00b3)", minVol, maxVol);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsVol = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsVol = clipVoronoiCells(voronoiMetricsVol);
						drawVoronoiCellsThreeJS(
							clippedCellsVol,
							function (value) {
								return getVolumeColor(value, minVol, maxVol);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"volume"
						);
					}
					break;
				}
				case "area": {
					// console.log("Drawing Area");
					let minArea, maxArea, intervalArea, deltaArea;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.area).filter((v) => v != null && !isNaN(v));
						minArea = values.length > 0 ? Math.min(...values) : 0;
						maxArea = values.length > 0 ? Math.max(...values) : 100;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = deltaArea / 10;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					} else {
						minArea = 0;
						maxArea = 500;
						if (maxArea - minArea > 0) {
							deltaArea = maxArea - minArea;
							intervalArea = 50;
						} else {
							minArea = 0;
							maxArea = 1;
							intervalArea = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getAreaColor(value, minArea, maxArea), "Legend Area", minArea, maxArea, intervalArea);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Area (m\u00b2)", minArea, maxArea);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsArea = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsArea = clipVoronoiCells(voronoiMetricsArea);
						drawVoronoiCellsThreeJS(
							clippedCellsArea,
							function (value) {
								return getAreaColor(value, minArea, maxArea);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"area"
						);
					}
					break;
				}
				case "measuredLength": {
					// console.log("Drawing Measured Length");
					let minMLen, maxMLen, intervalMLen, deltaMLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.measuredLength).filter((v) => v != null && !isNaN(v));
						minMLen = values.length > 0 ? Math.min(...values) : 0;
						maxMLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = deltaMLen / 10;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					} else {
						minMLen = 0;
						maxMLen = 50;
						if (maxMLen - minMLen > 0) {
							deltaMLen = maxMLen - minMLen;
							intervalMLen = 5;
						} else if (maxMLen > 0) {
							minMLen = 0;
							maxMLen = maxMLen;
							intervalMLen = (maxMLen - minMLen) / 10;
						} else {
							minMLen = 0;
							maxMLen = 1;
							intervalMLen = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minMLen, maxMLen), "Legend Measured Length", minMLen, maxMLen, intervalMLen);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Measured Length (m)", minMLen, maxMLen);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsMLen = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsMLen = clipVoronoiCells(voronoiMetricsMLen);
						drawVoronoiCellsThreeJS(
							clippedCellsMLen,
							function (value) {
								return getLengthColor(value, minMLen, maxMLen);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"measuredLength"
						);
					}
					break;
				}
				case "designedLength": {
					// console.log("Drawing Designed Length");
					let minDLen, maxDLen, intervalDLen, deltaDLen;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const values = clippedCells.map((c) => c.designedLength).filter((v) => v != null && !isNaN(v));
						minDLen = values.length > 0 ? Math.min(...values) : 0;
						maxDLen = values.length > 0 ? Math.max(...values) : 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = deltaDLen / 10;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					} else {
						minDLen = 0;
						maxDLen = 50;
						if (maxDLen - minDLen > 0) {
							deltaDLen = maxDLen - minDLen;
							intervalDLen = 5;
						} else if (maxDLen > 0) {
							minDLen = 0;
							maxDLen = maxDLen;
							intervalDLen = (maxDLen - minDLen) / 10;
						} else {
							minDLen = 0;
							maxDLen = 1;
							intervalDLen = 0.2;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getLengthColor(value, minDLen, maxDLen), "Legend Designed Length", minDLen, maxDLen, intervalDLen);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Designed Length (m)", minDLen, maxDLen);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsDLen = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsDLen = clipVoronoiCells(voronoiMetricsDLen);
						drawVoronoiCellsThreeJS(
							clippedCellsDLen,
							function (value) {
								return getLengthColor(value, minDLen, maxDLen);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"designedLength"
						);
					}
					break;
				}
				case "holeFiringTime": {
					// console.log("Drawing Hole Firing Time");
					let minHTime, maxHTime, intervalHTime, deltaHTime;

					if (!isVoronoiLegendFixed) {
						const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
						const clippedCells = clipVoronoiCells(voronoiMetrics);
						const holeTimes = clippedCells.map((c) => c.holeFiringTime).filter((t) => t != null && !isNaN(t));
						minHTime = holeTimes.length > 0 ? Math.min(...holeTimes) : 0;
						maxHTime = holeTimes.length > 0 ? Math.max(...holeTimes) : 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime / 10;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					} else {
						minHTime = 0;
						maxHTime = 5000;
						if (maxHTime - minHTime > 0) {
							deltaHTime = maxHTime - minHTime;
							intervalHTime = deltaHTime > 0 ? Math.ceil(deltaHTime / 10) : 1000;
						} else {
							minHTime = 0;
							maxHTime = 1;
							intervalHTime = 0.5;
						}
					}
					// Step 8a) Draw 2D Voronoi only when NOT in 3D-only mode
					if (!onlyShowThreeJS) {
						drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, (value) => getHoleFiringTimeColor(value, minHTime, maxHTime), "Legend Hole Firing Time", minHTime, maxHTime, intervalHTime);
					}
					// HUD: Show Voronoi legend
					showVoronoiLegend("Hole Firing Time (ms)", minHTime, maxHTime);
					// Step 8b) Draw Voronoi cells in Three.js
					if (threeInitialized) {
						var voronoiMetricsHTime = getVoronoiMetrics(allBlastHoles, useToeLocation);
						var clippedCellsHTime = clipVoronoiCells(voronoiMetricsHTime);
						drawVoronoiCellsThreeJS(
							clippedCellsHTime,
							function (value) {
								return getHoleFiringTimeColor(value, minHTime, maxHTime);
							},
							allBlastHoles,
							0.2,
							useToeLocation,
							"holeFiringTime"
						);
					}
					break;
				}
			}
		} else {
			// Hide Voronoi legend when not displayed
			hideVoronoiLegend();
		}

		// Slope Map
		if (displayOptions.slopeMap) {
			const centroid = {
				x: centroidX,
				y: centroidY,
			};
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

			// Step 6a) Draw 2D slope map only when NOT in 3D-only mode
			if (!onlyShowThreeJS) {
				drawDelauanySlopeMap(resultTriangles, centroid, strokeColor);
				for (const triangle of resultTriangles) {
					drawTriangleAngleText(triangle, centroid, strokeColor);
				}
				// HUD: Show slope legend (replaces ctx drawLegend)
				showSlopeLegend();
			}

			// Step 6b) Draw slope map in Three.js ONLY when in 3D mode
			// This prevents duplicate rendering when in 2D-only mode
			if (threeInitialized && onlyShowThreeJS && resultTriangles && resultTriangles.length > 0) {
				drawSlopeMapThreeJS(resultTriangles, allBlastHoles);
			}
		} else {
			// Hide slope legend when not displayed
			hideSlopeLegend();
		}

		// Burden Relief
		if (displayOptions.burdenRelief) {
			const centroid = {
				x: centroidX,
				y: centroidY,
			};
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

			// Step 7a) Draw 2D relief map only when NOT in 3D-only mode
			if (!onlyShowThreeJS) {
				drawDelauanyBurdenRelief(reliefTriangles, centroid, strokeColor);
				for (const triangle of reliefTriangles) {
					drawTriangleBurdenReliefText(triangle, centroid, strokeColor);
				}
				// HUD: Show relief legend (replaces ctx drawReliefLegend)
				showReliefLegend();
			}

			// Step 7b) Draw burden relief map in Three.js ONLY when in 3D mode
			// This prevents duplicate rendering when in 2D-only mode
			if (threeInitialized && onlyShowThreeJS && reliefTriangles && reliefTriangles.length > 0) {
				drawBurdenReliefMapThreeJS(reliefTriangles, allBlastHoles);
			}
		} else {
			// Hide relief legend when not displayed
			hideReliefLegend();
		}

		// Step 8) Contour Lines - Draw on main canvas for responsive pan/zoom
		if (displayOptions.contour && contourLinesArray && contourLinesArray.length > 0) {
			// Step 8a) Draw 2D contours (we're in the 2D-only block)
			// Skip if overlay system is handling contours (useContourOverlay = true)
			if (!useContourOverlay) {
				// Step 8b) Calculate interval for time labels
				var maxHoleTimeForLabels = 0;
				for (var hi = 0; hi < allBlastHoles.length; hi++) {
					var ht = allBlastHoles[hi].holeTime || 0;
					if (ht > maxHoleTimeForLabels) maxHoleTimeForLabels = ht;
				}
				var contourInterval = maxHoleTimeForLabels < 350 ? 25 : maxHoleTimeForLabels < 700 ? 100 : 250;
				if (typeof intervalAmount !== "undefined") {
					contourInterval = parseInt(intervalAmount);
				}

				// Step 8c) Set up contour line style
				ctx.lineWidth = 2;
				ctx.setLineDash([8, 4]);

				// Step 8d) Draw each contour level
				for (var levelIdx = 0; levelIdx < contourLinesArray.length; levelIdx++) {
					var contourLevel = contourLinesArray[levelIdx];
					if (!contourLevel || contourLevel.length === 0) continue;

					// Step 8e) Alternate colors for visibility
					ctx.strokeStyle = levelIdx % 2 === 0 ? "#FFFF00" : "#FF00FF";

					// Step 8f) Draw each line segment in this level
					for (var li = 0; li < contourLevel.length; li++) {
						var line = contourLevel[li];
						if (!line || !line[0] || !line[1]) continue;

						var startCoords = worldToCanvas(line[0].x, line[0].y);
						var endCoords = worldToCanvas(line[1].x, line[1].y);

						ctx.beginPath();
						ctx.moveTo(startCoords[0], startCoords[1]);
						ctx.lineTo(endCoords[0], endCoords[1]);
						ctx.stroke();
					}
				}

				// Step 8g) Reset line dash and line width for other drawing
				ctx.setLineDash([]);
				ctx.lineWidth = 1;
			}
			// Note: 3D contour drawing moved to the Three.js-only block (Step 3.0)
		}

		// First Movement Direction Arrows
		if (displayOptions.firstMovement) {
			connScale = document.getElementById("connSlider").value;

			// Step 9a) Draw 2D direction arrows (we're in the 2D-only block, no need for onlyShowThreeJS check)
			for (const arrow of directionArrows) {
				const [startX, startY] = worldToCanvas(arrow[0], arrow[1]);
				const [endX, endY] = worldToCanvas(arrow[2], arrow[3]);
				drawDirectionArrow(startX, startY, endX, endY, arrow[4], strokeColor, arrow[5]);
			}
			// Note: 3D direction arrow drawing moved to the Three.js-only block (Step 3.0b)
		}

		// Main hole loop
		ctx.lineWidth = 1;
		ctx.strokeStyle = strokeColor;
		ctx.font = parseInt(currentFontSize) + "px Arial";
		if (blastGroupVisible && allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			// ? ADD: Check blast group visibility
			for (const hole of allBlastHoles) {
				if (hole.visible === false) continue;
				const [x, y] = worldToCanvas(hole.startXLocation, hole.startYLocation);
				const [gradeX, gradeY] = worldToCanvas(hole.gradeXLocation, hole.gradeYLocation);
				const [lineEndX, lineEndY] = worldToCanvas(hole.endXLocation, hole.endYLocation);

				toeSizeInMeters = document.getElementById("toeSlider").value;
				connScale = document.getElementById("connSlider").value;

				// Draw collar-to-toe track if angled
				if (hole.holeAngle > 0) {
					drawTrack(x, y, lineEndX, lineEndY, gradeX, gradeY, strokeColor, hole.subdrillAmount);
				}

				// Step 4a) Highlight selected holes for animation/time window selection (2D only)
				// Only draw 2D highlighting when in 2D mode
				if (!onlyShowThreeJS) {
					handleHoleHighlighting(hole, x, y);
				}

				// Draw toe if hole length is not zero
				if (parseFloat(hole.holeLengthCalculated).toFixed(1) != 0.0) {
					const radiusInPixels = toeSizeInMeters * currentScale;
					drawHoleToe(lineEndX, lineEndY, transparentFillColor, strokeColor, radiusInPixels);
				}

				// Calculate text offsets
				const textOffset = parseInt((hole.holeDiameter / 1000) * holeScale * currentScale);
				const leftSideToe = parseInt(lineEndX) - textOffset;
				const rightSideToe = parseInt(lineEndX) + textOffset;
				const leftSideCollar = parseInt(x) - textOffset;
				const rightSideCollar = parseInt(x) + textOffset;
				const topSideToe = parseInt(lineEndY - textOffset);
				const middleSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize / 4));
				const bottomSideToe = parseInt(lineEndY + textOffset + parseInt(currentFontSize));
				const topSideCollar = parseInt(y - textOffset);
				const middleSideCollar = parseInt(y + parseInt(currentFontSize / 2));
				const bottomSideCollar = parseInt(y + textOffset + parseInt(currentFontSize));

				// Draw text/labels based on displayOptions
				drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, {
					leftSideToe,
					rightSideToe,
					leftSideCollar,
					rightSideCollar,
					topSideToe,
					middleSideToe,
					bottomSideToe,
					topSideCollar,
					middleSideCollar,
					bottomSideCollar,
					holeMap,
					displayOptions,
				});

				// Draw main hole geometry, with selection highlight logic
				drawHoleMainShape(hole, x, y, selectedHole);

				// Step 3) DO NOT draw Three.js geometry in 2D block
				// 3D hole rendering happens in 3D-only block at line 22587
				// This prevents dual rendering when camera is orbited

				// Font slider/label only needs to be updated once, after loop
			}
		}

		// Step 4) DO NOT draw KAD 3D geometry in 2D block
		// KAD 3D rendering happens in 3D-only block
		// This prevents dual rendering when camera is orbited

		// Step 7) Highlight selected KAD objects in 2D mode
		// Draw 2D selection visuals only (3D highlights happen in 3D-only block below)
		// highlightSelectedKADThreeJS(); // ? REMOVED: This was causing 3D highlights in 2D mode

		// After all other drawing operations but before font updates
		if (isPolygonSelectionActive) {
			drawPolygonSelection(ctx);
		}
		// Add preview lines right after polygon selection
		drawKADPreviewLine(ctx);

		// Step HUD) Update HUD stats panel instead of ctx.fillText
		// Use lastMouseX and lastMouseY if available, otherwise default to 0
		const mouseX = typeof lastMouseX !== "undefined" ? lastMouseX : 0;
		const mouseY = typeof lastMouseY !== "undefined" ? lastMouseY : 0;
		// Convert canvas (mouse) coordinates to world coordinates
		const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
		const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

		// Count KAD entities by type from allKADDrawingsMap
		var kadPointCount = 0, kadLineCount = 0, kadPolyCount = 0, kadCircleCount = 0, kadTextCount = 0;
		if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
			allKADDrawingsMap.forEach(function (kadObj) {
				if (kadObj.entityType === "point") kadPointCount++;
				else if (kadObj.entityType === "line") kadLineCount++;
				else if (kadObj.entityType === "poly") kadPolyCount++;
				else if (kadObj.entityType === "circle") kadCircleCount++;
				else if (kadObj.entityType === "text") kadTextCount++;
			});
		}

		// Count unique blast names
		var blastNames = new Set();
		if (allBlastHoles && Array.isArray(allBlastHoles)) {
			for (var i = 0; i < allBlastHoles.length; i++) {
				if (allBlastHoles[i].entityName) {
					blastNames.add(allBlastHoles[i].entityName);
				}
			}
		}

		// Emit to HUD
		emitStats({
			blastsCount: blastNames.size,
			holesCount: allBlastHoles ? allBlastHoles.length : 0,
			pointsCount: kadPointCount,
			linesCount: kadLineCount,
			polysCount: kadPolyCount,
			circlesCount: kadCircleCount,
			textsCount: kadTextCount,
			version: buildVersion
		});

		// Get Z from snapped point or drawing elevation
		var worldZ = currentMouseWorldZ || drawingZValue || 0;
		// Check if currently snapped (snapHighlight is set when snapped)
		var isCurrentlySnapped = snapHighlight !== null && snapEnabled;
		emitCoords(
			{ x: mouseX, y: mouseY },
			{ x: worldX, y: worldY, z: parseFloat(worldZ) || 0 },
			currentScale,
			isCurrentlySnapped
		);

		if (drawMouseLines) {
			drawMouseCrossHairs(mouseX, mouseY, snapRadiusPixels, true, true);
		}

		// Draw crosshair indicator for Add Hole tool
		if (isAddingHole) {
			ctx.beginPath();
			ctx.strokeStyle = "rgba(209, 0, 0, 0.8)"; // Red crosshair
			ctx.lineWidth = 2;

			// Horizontal line
			ctx.moveTo(mouseX - snapRadiusPixels * 1.5, mouseY);
			ctx.lineTo(mouseX + snapRadiusPixels * 1.5, mouseY);
			// Vertical line
			ctx.moveTo(mouseX, mouseY - snapRadiusPixels * 1.5);
			ctx.lineTo(mouseX, mouseY + snapRadiusPixels * 1.5);
			ctx.stroke();

			// Optional: Draw small circle at center
			ctx.beginPath();
			ctx.arc(mouseX, mouseY, 3, 0, Math.PI * 2);
			ctx.fillStyle = "rgba(209, 0, 0, 0.6)";
			ctx.fill();
		}

		// Draw live ruler while measuring
		if (isRulerActive && rulerStartPoint && !rulerEndPoint) {
			// Get current snap result at mouse position
			const snapResult = canvasToWorldWithSnap(mouseX, mouseY);

			// // DEBUG: Log the actual values being used
			// console.log("Live Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, rulerStartPoint.z);
			// console.log("  Mouse Point:", snapResult.worldX, snapResult.worldY, snapResult.worldZ);
			// console.log("  Snap Result:", snapResult);

			// Use the snapped coordinates
			const worldMouseX = snapResult.worldX;
			const worldMouseY = snapResult.worldY;
			const worldMouseZ = snapResult.worldZ;

			// Ensure we have valid Z values
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = worldMouseZ !== undefined && worldMouseZ !== null ? worldMouseZ : startZ;

			// console.log("  Final Z values - startZ:", startZ, "endZ:", endZ);

			// Draw the full ruler from start point to mouse position
			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, worldMouseX, worldMouseY, endZ);
		}
		// Draw active rulers (completed measurements)
		if (isRulerActive && rulerStartPoint && rulerEndPoint) {
			// Ensure Z values exist and are valid numbers
			const startZ = rulerStartPoint.z !== undefined && rulerStartPoint.z !== null ? rulerStartPoint.z : 0;
			const endZ = rulerEndPoint.z !== undefined && rulerEndPoint.z !== null ? rulerEndPoint.z : 0;

			// console.log("Completed Ruler Debug:");
			// console.log("  Start Point:", rulerStartPoint.x, rulerStartPoint.y, startZ);
			// console.log("  End Point:", rulerEndPoint.x, rulerEndPoint.y, endZ);

			drawRuler(rulerStartPoint.x, rulerStartPoint.y, startZ, rulerEndPoint.x, rulerEndPoint.y, endZ);
		}
		// Draw completed bearing measurement
		if (isRulerProtractorActive && rulerProtractorPoints.length === 3) {
			drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, rulerProtractorPoints[2].x, rulerProtractorPoints[2].y);
		}

		// Draw live bearing measurement preview
		if (isRulerProtractorActive && rulerProtractorPoints.length > 0 && rulerProtractorPoints.length < 3) {
			const worldMouseX = (mouseX - canvas.width / 2) / currentScale + centroidX;
			const worldMouseY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

			if (rulerProtractorPoints.length === 1) {
				// After first click - show line from center to mouse
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, worldMouseX, worldMouseY, rulerProtractorPoints[0].x, rulerProtractorPoints[0].y); // Same point for p3
			} else if (rulerProtractorPoints.length === 2) {
				// After second click - show both legs with live second leg
				drawProtractor(rulerProtractorPoints[0].x, rulerProtractorPoints[0].y, rulerProtractorPoints[1].x, rulerProtractorPoints[1].y, worldMouseX, worldMouseY);
			}
		}
		// Step A) Draw pattern tool visuals (2D only - 3D handled in 3D block below)
		drawPatternInPolygonVisual();
		drawPatternOnPolylineVisual();
		drawKADPolygonHighlightSelectedVisuals();
		drawHolesAlongLineVisuals();
		drawKADHighlightSelectionVisuals(); // ADD THIS AS THE VERY LAST LINE:
		// drawAllKADSelectionVisuals(); // this function doesn't get used...
		drawSurfaceLegend();
		// HUD: Show status message (replaces ctx.fillText for status)
		if (statusMessage) {
			showStatusMessage(statusMessage);
		}
		// Update font slider and label after loop (once)
		fontSlider.value = currentFontSize;
		fontLabel.textContent = "Font Size: " + parseFloat(currentFontSize).toFixed(1) + "px";
		if (printMode) {
			drawPrintBoundary(ctx, canvas);
		}
	} else if (!ctx) {
		// Handle missing context
		console.warn("?? Canvas context not available");
	} else if (onlyShowThreeJS) {
		// Three.js-only mode: 2D canvas drawing intentionally skipped
		// This is normal, not an error
	}

	// ===================================================================================
	// CRITICAL AI AGENT NOTICE - DO NOT MODIFY THIS RENDERING LOGIC
	// ===================================================================================
	// When in a Dimension Mode (2D or 3D), the alternate mode must NOT render.
	//
	// REASONS:
	// 1. Performance/Overheads: Rendering both modes doubles the computational load
	// 2. Responsiveness: Dual rendering causes lag and poor user experience
	// 3. Confusion: Users expect only ONE rendering mode active at a time
	//
	// RULE: Use ONLY the onlyShowThreeJS flag to determine which mode renders.
	// DO NOT use isIn3DMode or camera orbit angles - they cause dual rendering!
	//
	// CORRECT LOGIC:
	// - if (onlyShowThreeJS) ? Render ONLY 3D, skip ALL 2D
	// - if (!onlyShowThreeJS) ? Render ONLY 2D, skip ALL 3D
	//
	// This has been broken and fixed multiple times. DO NOT BREAK IT AGAIN.
	// ===================================================================================

	// Step 1c) Create Three.js geometry ONLY when in Three.js-only mode
	// DO NOT check isIn3DMode or orbit angles - that causes dual rendering!
	if (onlyShowThreeJS && threeInitialized) {
		// Step 1d) Draw background images in Three.js
		if (imagesGroupVisible) {
			//console.log("üñºÔ∏è [3D IMAGE] Processing images for 3D display. Total images:", loadedImages.size);
			loadedImages.forEach((image, imageKey) => {
				// Step 2.3a) REMOVED skip logic - both flattened images AND textured meshes should display in 3D
				// This allows users to see both the 3D textured mesh and the flattened image plane simultaneously


				// DEBUG: Disabled excessive logging on render
				// console.log("üñºÔ∏è [3D IMAGE] Checking image:", imageKey, {
				// 	visible: image.visible,
				// 	hasCanvas: !!image.canvas,
				// 	hasBbox: !!image.bbox,
				// 	bbox: image.bbox,
				// 	zElevation: image.zElevation,
				// });

				if (image.visible && image.canvas && image.bbox) {
					const imageId = image.id || image.name || "image_" + Date.now();
					const imageTransparency = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;
					const imageZElevation = image.zElevation !== undefined ? image.zElevation : null;
					// console.log("üñºÔ∏è[3D IMAGE] Drawing image in 3D:", imageId, "transparency:", imageTransparency, "zElevation:", imageZElevation); // DISABLED - repeats on every render
					drawBackgroundImageThreeJS(imageId, image.canvas, image.bbox, imageTransparency, imageZElevation);
				}
			});
		}

		// Draw surfaces (includes Three.js rendering)
		drawSurface();

		// Step 2.4a) Update surface legend in 3D mode (must be called after drawSurface)
		drawSurfaceLegend();

		// Step 2.5) Get display options for 3D rendering
		const displayOptions3D = getDisplayOptions();

		// Step 3.0) Draw contours in Three.js (3D-only mode)
		// CRITICAL FIX: This was incorrectly placed inside the 2D-only block, so 3D contours never rendered
		// The 3D contour drawing must be here in the Three.js-only block
		if (displayOptions3D.contour && contourLinesArray && contourLinesArray.length > 0) {
			console.log("üî∂ 3D Contours: Drawing " + contourLinesArray.length + " contour levels in Three.js");
			drawContoursThreeJS(contourLinesArray, strokeColor, allBlastHoles);
		}

		// Step 3.0b) Draw direction arrows in Three.js (3D-only mode)
		// CRITICAL FIX: This was incorrectly placed inside the 2D-only block, so 3D arrows never rendered
		if (displayOptions3D.firstMovement && directionArrows && directionArrows.length > 0) {
			console.log("üî∂ 3D Direction Arrows: Drawing " + directionArrows.length + " arrows in Three.js");
			drawDirectionArrowsThreeJS(directionArrows, allBlastHoles);
		}

		// Step 3.1) Draw slope map in Three.js (3D-only mode)
		if (displayOptions3D.slopeMap && allBlastHoles && allBlastHoles.length > 0) {
			const { resultTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			if (resultTriangles && resultTriangles.length > 0) {
				drawSlopeMapThreeJS(resultTriangles, allBlastHoles);
				// HUD: Show slope legend in 3D mode
				showSlopeLegend();
			}
		} else {
			// HUD: Hide slope legend in 3D mode when not displayed
			hideSlopeLegend();
		}

		// Step 3.2) Draw burden relief map in Three.js (3D-only mode)
		if (displayOptions3D.burdenRelief && allBlastHoles && allBlastHoles.length > 0) {
			const { reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);
			if (reliefTriangles && reliefTriangles.length > 0) {
				drawBurdenReliefMapThreeJS(reliefTriangles, allBlastHoles);
				// HUD: Show relief legend in 3D mode
				showReliefLegend();
			}
		} else {
			// HUD: Hide relief legend in 3D mode when not displayed
			hideReliefLegend();
		}

		// Step 3.3) Draw Voronoi cells in Three.js (3D-only mode)
		if (displayOptions3D.voronoiPF && allBlastHoles && allBlastHoles.length > 0) {
			var voronoiMetrics3D = getVoronoiMetrics(allBlastHoles, useToeLocation);
			var clippedCells3D = clipVoronoiCells(voronoiMetrics3D);
			if (clippedCells3D && clippedCells3D.length > 0) {
				// Step 3.3a) Use the selected voronoi metric for coloring
				var selectedMetric3D = selectedVoronoiMetric || "powder_factor";
				var colorFunction3D;
				// Step 3.3b) Map metric name to cell property name
				var cellPropertyName = selectedMetric3D;
				if (selectedMetric3D === "powder_factor") {
					cellPropertyName = "powderFactor";
				}

				// Step 3.3c) Apply isVoronoiLegendFixed check to match 2D behavior
				switch (selectedMetric3D) {
					case "powderFactor":
						var minPF3D, maxPF3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.1) Min-Max mode: calculate from data (min always 0 for PF)
							var pfValues3D = clippedCells3D
								.map(function (c) {
									return c.powderFactor;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minPF3D = 0; // PF min is always 0 per 2D logic (line 21031)
							maxPF3D = pfValues3D.length > 0 ? Math.max.apply(null, pfValues3D) : 3;
						} else {
							// Step 3.3c.2) Fixed mode: use hardcoded values matching 2D (lines 21043-21044)
							minPF3D = 0;
							maxPF3D = 3;
						}
						colorFunction3D = function (value) {
							return getPFColor(value, minPF3D, maxPF3D);
						};
						break;
					case "mass":
						var minMass3D, maxMass3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.3) Min-Max mode: calculate from data (lines 21083-21084)
							var massValues3D = clippedCells3D
								.map(function (c) {
									return c.mass;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minMass3D = massValues3D.length > 0 ? Math.min.apply(null, massValues3D) : 0;
							maxMass3D = massValues3D.length > 0 ? Math.max.apply(null, massValues3D) : 500;
						} else {
							// Step 3.3c.4) Fixed mode: use hardcoded values matching 2D (lines 21095-21096)
							minMass3D = 0;
							maxMass3D = 1000;
						}
						colorFunction3D = function (value) {
							return getMassColor(value, minMass3D, maxMass3D);
						};
						break;
					case "volume":
						var minVol3D, maxVol3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.5) Min-Max mode: calculate from data (lines 21120-21121)
							var volValues3D = clippedCells3D
								.map(function (c) {
									return c.volume;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minVol3D = volValues3D.length > 0 ? Math.min.apply(null, volValues3D) : 0;
							maxVol3D = volValues3D.length > 0 ? Math.max.apply(null, volValues3D) : 100;
						} else {
							// Step 3.3c.6) Fixed mode: use hardcoded values matching 2D (lines 21131-21132)
							minVol3D = 0;
							maxVol3D = 5000;
						}
						colorFunction3D = function (value) {
							return getVolumeColor(value, minVol3D, maxVol3D);
						};
						break;
					case "area":
						var minArea3D, maxArea3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.7) Min-Max mode: calculate from data (lines 21161-21162)
							var areaValues3D = clippedCells3D
								.map(function (c) {
									return c.area;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minArea3D = areaValues3D.length > 0 ? Math.min.apply(null, areaValues3D) : 0;
							maxArea3D = areaValues3D.length > 0 ? Math.max.apply(null, areaValues3D) : 100;
						} else {
							// Step 3.3c.8) Fixed mode: use hardcoded values matching 2D (lines 21172-21173)
							minArea3D = 0;
							maxArea3D = 500;
						}
						colorFunction3D = function (value) {
							return getAreaColor(value, minArea3D, maxArea3D);
						};
						break;
					case "measuredLength":
						var minMLen3D, maxMLen3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.9) Min-Max mode: calculate from data (lines 21204-21205)
							var mLenValues3D = clippedCells3D
								.map(function (c) {
									return c.measuredLength;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minMLen3D = mLenValues3D.length > 0 ? Math.min.apply(null, mLenValues3D) : 0;
							maxMLen3D = mLenValues3D.length > 0 ? Math.max.apply(null, mLenValues3D) : 50;
						} else {
							// Step 3.3c.10) Fixed mode: use hardcoded values matching 2D (lines 21219-21220)
							minMLen3D = 0;
							maxMLen3D = 50;
						}
						colorFunction3D = function (value) {
							return getLengthColor(value, minMLen3D, maxMLen3D);
						};
						break;
					case "designedLength":
						var minDLen3D, maxDLen3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.11) Min-Max mode: calculate from data (lines 21254-21255)
							var dLenValues3D = clippedCells3D
								.map(function (c) {
									return c.designedLength;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minDLen3D = dLenValues3D.length > 0 ? Math.min.apply(null, dLenValues3D) : 0;
							maxDLen3D = dLenValues3D.length > 0 ? Math.max.apply(null, dLenValues3D) : 50;
						} else {
							// Step 3.3c.12) Fixed mode: use hardcoded values matching 2D (lines 21269-21270)
							minDLen3D = 0;
							maxDLen3D = 50;
						}
						colorFunction3D = function (value) {
							return getLengthColor(value, minDLen3D, maxDLen3D);
						};
						break;
					case "holeFiringTime":
						var minHTime3D, maxHTime3D;
						if (!isVoronoiLegendFixed) {
							// Step 3.3c.13) Min-Max mode: calculate from data (lines 21354-21355)
							var hTimeValues3D = clippedCells3D
								.map(function (c) {
									return c.holeFiringTime;
								})
								.filter(function (v) {
									return v != null && !isNaN(v);
								});
							minHTime3D = hTimeValues3D.length > 0 ? Math.min.apply(null, hTimeValues3D) : 0;
							maxHTime3D = hTimeValues3D.length > 0 ? Math.max.apply(null, hTimeValues3D) : 5000;
						} else {
							// Step 3.3c.14) Fixed mode: use hardcoded values matching 2D (lines 21365-21366)
							minHTime3D = 0;
							maxHTime3D = 5000;
						}
						colorFunction3D = function (value) {
							return getHoleFiringTimeColor(value, minHTime3D, maxHTime3D);
						};
						break;
					default:
						// Step 3.3c.15) Default to PF with fixed range
						colorFunction3D = function (value) {
							return getPFColor(value, 0, 3);
						};
						cellPropertyName = "powderFactor";
				}
				drawVoronoiCellsThreeJS(clippedCells3D, colorFunction3D, allBlastHoles, 0.2, useToeLocation, cellPropertyName);

				// HUD: Show appropriate Voronoi legend in 3D mode
				switch (selectedMetric3D) {
					case "powderFactor":
						showVoronoiLegend("Powder Factor (kg/m\u00b3)", minPF3D, maxPF3D);
						break;
					case "mass":
						showVoronoiLegend("Mass (kg)", minMass3D, maxMass3D);
						break;
					case "volume":
						showVoronoiLegend("Volume (m\u00b3)", minVol3D, maxVol3D);
						break;
					case "area":
						showVoronoiLegend("Area (m\u00b2)", minArea3D, maxArea3D);
						break;
					case "measuredLength":
						showVoronoiLegend("Measured Length (m)", minMLen3D, maxMLen3D);
						break;
					case "designedLength":
						showVoronoiLegend("Designed Length (m)", minDLen3D, maxDLen3D);
						break;
					case "holeFiringTime":
						showVoronoiLegend("Hole Firing Time (ms)", minHTime3D, maxHTime3D);
						break;
				}
			}
		} else {
			// HUD: Hide Voronoi legend in 3D mode when not displayed
			hideVoronoiLegend();
		}

		// Step 3.4) CLEAR old highlights and stadium zones EVERY frame (regardless of hole count)
		// This MUST run before any highlighting code to prevent accumulation
		if (threeRenderer) {
			var typesToClear = ["selectionHighlight", "stadiumZone", "kadHighlight", "kadSelectionHighlight", "vertexSelectionHighlight"];
			var groupsToClear = [threeRenderer.holesGroup, threeRenderer.connectorsGroup, threeRenderer.kadGroup];

			groupsToClear.forEach(function (group) {
				if (!group) return;
				var childrenToRemove = [];
				group.children.forEach(function (child) {
					if (child.userData && typesToClear.indexOf(child.userData.type) !== -1) {
						childrenToRemove.push(child);
					}
				});
				childrenToRemove.forEach(function (child) {
					// Step #) Dispose geometry, material, and TEXTURES to prevent memory leaks
					if (child.traverse) {
						child.traverse(function (obj) {
							if (obj.geometry) obj.geometry.dispose();
							if (obj.material) {
								if (Array.isArray(obj.material)) {
									obj.material.forEach(function (m) {
										// Step #) Dispose textures before disposing material
										if (m.map) m.map.dispose();
										if (m.lightMap) m.lightMap.dispose();
										if (m.bumpMap) m.bumpMap.dispose();
										if (m.normalMap) m.normalMap.dispose();
										if (m.specularMap) m.specularMap.dispose();
										if (m.envMap) m.envMap.dispose();
										m.dispose();
									});
								} else {
									// Step #) Dispose textures before disposing material
									if (obj.material.map) obj.material.map.dispose();
									if (obj.material.lightMap) obj.material.lightMap.dispose();
									if (obj.material.bumpMap) obj.material.bumpMap.dispose();
									if (obj.material.normalMap) obj.material.normalMap.dispose();
									if (obj.material.specularMap) obj.material.specularMap.dispose();
									if (obj.material.envMap) obj.material.envMap.dispose();
									obj.material.dispose();
								}
							}
						});
					}
					group.remove(child);
				});
			});
		}

		// Draw holes - ONLY rebuild geometry when data changes
		var toeSizeInMeters3D = document.getElementById("toeSlider") ? parseFloat(document.getElementById("toeSlider").value) : 1;
		if (blastGroupVisible && allBlastHoles && Array.isArray(allBlastHoles) && allBlastHoles.length > 0) {
			// Step 3.1) ONLY REBUILD GEOMETRY when threeDataNeedsRebuild is true
			// This prevents rebuilding geometry every frame (which was causing 1 FPS!)
			if (window.threeDataNeedsRebuild) {
				// NEW INSTANCED RENDERING: Use InstancedMeshManager for 10-50x performance improvement
				// Automatically groups holes by diameter/type and batches rendering
				for (var holeIdx = 0; holeIdx < allBlastHoles.length; holeIdx++) {
					var hole = allBlastHoles[holeIdx];
					if (hole.visible === false) continue;

					// Use instanced rendering (includes collar, grade, toe automatically)
					// Pass toe slider radius so all toes use the same size
					drawHoleThreeJS_Instanced(hole, toeSizeInMeters3D);

					// Draw hole text labels (labels are still individual sprites for flexibility)
					if (threeInitialized) {
						drawHoleTextsAndConnectorsThreeJS(hole, displayOptions3D);
					}
				}

				// Step 3.2) FLUSH BATCHED LINES - Creates single draw call for all hole body lines
				// This is the key performance optimization: 1644 lines -> ~5 draw calls
				if (threeRenderer && threeRenderer.instancedMeshManager) {
					threeRenderer.instancedMeshManager.flushLineBatches(threeRenderer.holesGroup);
				}

				if (developerModeEnabled) {
					console.log("üöÄ Instanced rendering complete: " + allBlastHoles.length + " holes");
					if (threeRenderer && threeRenderer.instancedMeshManager) {
						console.log("üìä Instance stats:", threeRenderer.instancedMeshManager.getStats());
					}
				}
				// NOTE: threeDataNeedsRebuild flag reset moved to AFTER KAD drawing (Step 3 below)
			}

			// Step 3.5) Clear and redraw connectors when data changes (rebuild is true)
			// NOTE: Highlight clearing moved to Step 3.4 (outside holes block) so it runs even with 0 holes

			// Step 3.5a) Clear connectors when rebuild is needed so they can be redrawn
			if (window.threeDataNeedsRebuild && threeRenderer && threeRenderer.connectorsGroup) {
				var connectorsToRemove = [];
				threeRenderer.connectorsGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "connector") {
						connectorsToRemove.push(child);
					}
				});
				connectorsToRemove.forEach(function (child) {
					threeRenderer.connectorsGroup.remove(child);
					if (child.geometry) child.geometry.dispose();
					if (child.material) {
						if (Array.isArray(child.material)) {
							child.material.forEach(function (m) { m.dispose(); });
						} else {
							child.material.dispose();
						}
					}
				});
			}

			// Step 4) Build hole map ONCE for connector lookup (moved outside loop for O(n) vs O(n¬≤))
			const holeMap3D = new Map();
			if (displayOptions3D.connector) {
				allBlastHoles.forEach(function (h) {
					holeMap3D.set(h.entityName + ":::" + h.holeID, h);
				});
			}

			for (var holeIdx = 0; holeIdx < allBlastHoles.length; holeIdx++) {
				var hole = allBlastHoles[holeIdx];
				if (hole.visible === false) continue;

				// Step 4a) Draw connectors in Three.js (only when rebuild needed or first time)
				if (threeInitialized && displayOptions3D.connector && hole.fromHoleID) {
					const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
					const fromHole = holeMap3D.get(splitEntityName + ":::" + splitFromHoleID);
					if (fromHole) {
						const connColor = hole.colorHexDecimal || hole.holeColor || "#FF0000";
						const delayText = displayOptions3D.delayValue ? hole.timingDelayMilliseconds : null;
						const connScale3D = document.getElementById("connSlider") ? document.getElementById("connSlider").value : 100;
						drawConnectorThreeJS(fromHole, hole, connColor, hole.connectorCurve || 0, delayText, connScale3D);
					}
				}

				// Step 5) Draw selection highlighting in Three.js (matching 2D style)
				if (threeInitialized) {
					// Connector mode highlighting
					if (isAddingConnector || isAddingMultiConnector) {
						// Step 5.1) Check if this is the fromHoleStore (compare by entityName and holeID)
						const isFromHole = fromHoleStore && fromHoleStore.entityName === hole.entityName && fromHoleStore.holeID === hole.holeID;
						if (isFromHole) {
							highlightSelectedHoleThreeJS(hole, "first");
							// Step 5.1a) Draw stadium zone using view-plane mouse position (follows cursor in 3D)
							if (isAddingMultiConnector && currentMouseIndicatorX !== 0 && currentMouseIndicatorY !== 0) {
								drawConnectStadiumZoneThreeJS(hole, { x: currentMouseIndicatorX, y: currentMouseIndicatorY, z: currentMouseIndicatorZ }, connectAmount);
							}
							// HUD: Show connector mode message (replaces 3D text)
							showStatusMessage("1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)", 0);
						} else if (firstSelectedHole && firstSelectedHole.entityName === hole.entityName && firstSelectedHole.holeID === hole.holeID) {
							highlightSelectedHoleThreeJS(hole, "first");
							// HUD: Show connector mode message (replaces 3D text)
							showStatusMessage("1st Selected Hole: " + hole.holeID + " in: " + hole.entityName, 0);
						} else if (secondSelectedHole && secondSelectedHole === hole) {
							highlightSelectedHoleThreeJS(hole, "second");
							// HUD: Show connector mode message (replaces 3D text)
							showStatusMessage("2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)", 0);
						}
					}
					// Regular selection highlighting
					else if (selectedHole && selectedHole === hole) {
						highlightSelectedHoleThreeJS(hole, "selected");
						// HUD: Show selection message with connection info (replaces drawToolPromptThreeJS)
						showSelectionMessage(buildHoleSelectionMessage(selectedHole));
					}
					// Multiple selection highlighting
					else if (selectedMultipleHoles && selectedMultipleHoles.find((h) => h.entityName === hole.entityName && h.holeID === hole.holeID)) {
						highlightSelectedHoleThreeJS(hole, "multi");
						if (hole === selectedMultipleHoles[0]) {
							// HUD: Show multi-selection message (cap at 10 holes)
							var holeIDs = selectedMultipleHoles.map((h) => h.holeID);
							var displayIDs = holeIDs.length > 10 ? holeIDs.slice(0, 10).join(",") + "..." : holeIDs.join(",");
							showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs + "}\nEscape key to clear Selection");
						}
					}
					// Animation/timing window highlighting
					if (timingWindowHolesSelected && timingWindowHolesSelected.find((h) => h.entityName === hole.entityName && h.holeID === hole.holeID)) {
						if (isPlaying) {
							highlightSelectedHoleThreeJS(hole, "animation-playing");
						} else {
							highlightSelectedHoleThreeJS(hole, "animation-paused");
						}
					}
				}
			}
		}

		// Step 3) Draw KAD entities in Three.js
		// CRITICAL: Only rebuild KAD geometry when threeDataNeedsRebuild is true
		// This was the cause of 17k+ scene objects - KAD was adding every frame without clearing!
		if (drawingsGroupVisible && window.threeDataNeedsRebuild) {

			// Step 3.1) SUPER-BATCH: For large DXF files, merge ALL lines/polys into ONE geometry
			// This reduces 3799 draw calls to just 1 - massive performance improvement!
			var linePolyEntities = [];
			var pointEntities = [];
			var circleEntities = [];
			var hasLinesOrPolys = (linesGroupVisible || polygonsGroupVisible);
			var usedSuperBatchLines = false;
			var usedSuperBatchPoints = false;
			var usedSuperBatchCircles = false;
			var superBatchedLineEntities = new Map(); //Track which line/poly entities were actually superbatched.

			if (use3DSimplification && allKADDrawingsMap.size > 50) {
				// Step 3.1a) Collect all visible entities by type for super-batch
				for (var [entityName, entity] of allKADDrawingsMap.entries()) {
					if (entity.visible === false) continue;
					// Add entityName to entity for reference in super-batch
					entity.entityName = entityName;

					if (entity.entityType === "line" && linesGroupVisible) {
						linePolyEntities.push(entity);
					} else if (entity.entityType === "poly" && polygonsGroupVisible) {
						linePolyEntities.push(entity);
					} else if (entity.entityType === "point" && pointsGroupVisible) {
						pointEntities.push(entity);
					} else if (entity.entityType === "circle" && circlesGroupVisible) {
						circleEntities.push(entity);
					}
				}

				// Step 3.1b) Create HYBRID super-batched geometry for LINES/POLYGONS
				// Uses fast LineBasicMaterial for thin lines (<=1), FatLines for thick (>1)
				if (linePolyEntities.length > 0) {
					// LineMaterial resolution uses window dimensions (CSS pixels)
					var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
					var hybridBatch = GeometryFactory.createHybridSuperBatchedLines(linePolyEntities, worldToThreeLocal, resolution);
					if (hybridBatch) {
						// Add thin lines batch (1 draw call for all standard lines)
						if (hybridBatch.thinLineSegments) {
							threeRenderer.kadGroup.add(hybridBatch.thinLineSegments);
						}
						// Add fat lines batches (1 draw call per unique thick lineWidth)
						hybridBatch.fatLinesByWidth.forEach(function (fatBatch) {
							threeRenderer.kadGroup.add(fatBatch);
						});
						usedSuperBatchLines = true;
						superBatchedLineEntities = hybridBatch.entityRanges;
						if (developerModeEnabled) {
							var fatCount = hybridBatch.fatLinesByWidth.size;
							var drawCalls = (hybridBatch.thinLineSegments ? 1 : 0) + fatCount;
							console.log("üöÄ HYBRID-BATCH LINES: " + linePolyEntities.length + " entities (" + hybridBatch.thinCount + " thin + " + hybridBatch.thickCount + " thick segments) in " + drawCalls + " draw calls");
						}
					}
				}

				// Step 3.1c) Create super-batched geometry for POINTS
				if (pointEntities.length > 0) {
					var superBatchPoints = drawKADSuperBatchedPointsThreeJS(pointEntities, worldToThreeLocal);
					if (superBatchPoints) {
						usedSuperBatchPoints = true;
						if (developerModeEnabled) {
							console.log("üöÄ SUPER-BATCH POINTS: " + pointEntities.length + " entities (" + superBatchPoints.totalPoints + " points) merged into 1 draw call");
						}
					}
				}

				// Step 3.1d) Create HYBRID super-batched geometry for CIRCLES
				// Uses fast LineBasicMaterial for thin circles (<=1), FatLines for thick (>1)
				if (circleEntities.length > 0) {
					// LineMaterial resolution uses window dimensions (CSS pixels)
					var circleResolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
					var hybridCircles = GeometryFactory.createHybridSuperBatchedCircles(circleEntities, worldToThreeLocal, circleResolution);
					if (hybridCircles) {
						// Add thin circles batch
						if (hybridCircles.thinLineSegments) {
							threeRenderer.kadGroup.add(hybridCircles.thinLineSegments);
						}
						// Add fat circles batches
						hybridCircles.fatLinesByWidth.forEach(function (fatBatch) {
							threeRenderer.kadGroup.add(fatBatch);
						});
						usedSuperBatchCircles = true;
						if (developerModeEnabled) {
							var fatCircleCount = hybridCircles.fatLinesByWidth.size;
							var circleDrawCalls = (hybridCircles.thinLineSegments ? 1 : 0) + fatCircleCount;
							console.log("üöÄ HYBRID-BATCH CIRCLES: " + circleEntities.length + " entities (" + hybridCircles.thinCount + " thin + " + hybridCircles.thickCount + " thick) in " + circleDrawCalls + " draw calls");
						}
					}
				}

				// Step 3.1e) CRITICAL: Update LineMaterial resolution after adding all fat lines
				// This ensures fat lines render with correct thickness on initial draw
				if (typeof updateAllLineMaterialResolution === "function") {
					updateAllLineMaterialResolution();
				}
			}

			// Step 3.2) Draw remaining entities (texts, and points/circles/lines/polys if not super-batched)

			for (const [name, entity] of allKADDrawingsMap.entries()) {
				if (entity.visible === false) continue;

				// Step 4) Check sub-group visibility and skip if super-batched
				let subGroupVisible = true;
				switch (entity.entityType) {
					case "point":
						subGroupVisible = pointsGroupVisible;
						// Skip if already super-batched
						if (usedSuperBatchPoints) continue;
						break;
					case "line":
						subGroupVisible = linesGroupVisible;
						// Skip if already super-batched
						if (superBatchedLineEntities.has(name)) continue;
						break;
					case "poly":
						subGroupVisible = polygonsGroupVisible;
						// Skip if already super-batched
						if (superBatchedLineEntities.has(name)) continue;
						break;
					case "circle":
						subGroupVisible = circlesGroupVisible;
						// Skip if already super-batched
						if (usedSuperBatchCircles) continue;
						break;
					case "text":
						subGroupVisible = textsGroupVisible;
						break;
				}

				if (!subGroupVisible) continue;

				// Step 5) Render each KAD entity type (with local coordinate conversion)
				if (entity.entityType === "point") {
					for (const pointData of entity.data) {
						if (pointData.visible === false) continue;
						const size = ((pointData.lineWidth || 2) / 2) * 0.25; // Convert diameter to radius (lineWidth 3 = radius 1.5, scaled by 0.1)
						const local = worldToThreeLocal(pointData.pointXLocation, pointData.pointYLocation);
						const vertexIndex = entity.data.indexOf(pointData);
						const kadId = name + ":::" + vertexIndex;
						drawKADPointThreeJS(local.x, local.y, pointData.pointZLocation || 0, size, pointData.color || "#FF0000", kadId); // kadId format: "entityName:::vertexIndex"
					}
				} else if (entity.entityType === "line" || entity.entityType === "poly") {
					// Step 6) Lines and Polygons: Draw segment-by-segment (matches 2D canvas behavior)
					// Each segment gets its own lineWidth and color from point data
					var visiblePoints = entity.data.filter(function (point) {
						return point.visible !== false;
					});

					if (visiblePoints.length >= 2) {
						// Step 6a) Skip frustum culling for now - just use all visible points
						// The batching alone gives 100x performance improvement
						var pointsToRender = visiblePoints;

						// Step 6b) Check if lineWidths vary across points
						var hasVaryingLineWidths = false;
						if (pointsToRender.length > 1) {
							var firstWidth = pointsToRender[0].lineWidth || 1;
							for (var i = 1; i < pointsToRender.length; i++) {
								if ((pointsToRender[i].lineWidth || 1) !== firstWidth) {
									hasVaryingLineWidths = true;
									break;
								}
							}
						}

						// Step 6c) Draw entity - BATCHED approach for performance when simplification enabled
						// CRITICAL OPTIMIZATION: Instead of creating one mesh per segment (thousands of draw calls),
						// create ONE mesh for the entire entity (one draw call per entity!)
						// NOTE: Batching requires uniform lineWidth - if widths vary, use segment-by-segment

						if (use3DSimplification && !hasVaryingLineWidths) {
							// Step 6c.1) FAST PATH: Use batched rendering (ONE draw call per entity!)
							// Convert points to local coordinates with COLORS for vertex coloring
							var batchedPoints = [];
							for (var i = 0; i < pointsToRender.length; i++) {
								var p = pointsToRender[i];
								var local = worldToThreeLocal(p.pointXLocation, p.pointYLocation);
								// Properly handle NaN values - NaN || 0 still gives NaN!
								var zVal = p.pointZLocation;
								if (isNaN(zVal) || zVal === null || zVal === undefined) {
									zVal = 0;
								}
								batchedPoints.push({
									x: local.x,
									y: local.y,
									z: zVal,
									color: p.color || "#777777" // Use actual color or DXF default gray
								});
							}

							// Use first point's lineWidth (lineWidth varies less than color typically)
							var entityLineWidth = pointsToRender[0].lineWidth || 1;
							var entityColor = pointsToRender[0].color || "#FFFFFF"; // Fallback color
							var isPolygon = entity.entityType === "poly";

							if (developerModeEnabled) {
								console.log("[3D Batched] entity:", name, "lineWidth:", entityLineWidth, "rawValue:", pointsToRender[0].lineWidth, "numPoints:", pointsToRender.length);
							}

							// ONE draw call for entire entity with per-vertex colors!
							drawKADBatchedPolylineThreeJS(batchedPoints, entityLineWidth, entityColor, name, isPolygon);

						} else {
							// Step 6c.2) SLOW PATH: Segment-by-segment for full color/width control
							// NOTE: Segment color uses nextPoint.color (the "to" point) because when user clicks
							// a point with a new color, that color should apply to the segment leading TO that point
							var segmentsForThisEntity = pointsToRender.length - 1;

							for (var i = 0; i < pointsToRender.length - 1; i++) {
								var currentPoint = pointsToRender[i];
								var nextPoint = pointsToRender[i + 1];

								var currentLocal = worldToThreeLocal(currentPoint.pointXLocation, currentPoint.pointYLocation);
								var nextLocal = worldToThreeLocal(nextPoint.pointXLocation, nextPoint.pointYLocation);

								// Use nextPoint's color and lineWidth - the segment TO the point uses that point's attributes
								var lineWidth = nextPoint.lineWidth || 1;
								var color = nextPoint.color || "#FF0000";

								if (i === 0) {
									//	console.log("[3D Segment] segment", i, "lineWidth:", lineWidth, "rawValue:", nextPoint.lineWidth, "color:", color);
								}

								if (entity.entityType === "line") {
									drawKADLineSegmentThreeJS(currentLocal.x, currentLocal.y, currentPoint.pointZLocation || 0, nextLocal.x, nextLocal.y, nextPoint.pointZLocation || 0, lineWidth, color, name);
								} else {
									drawKADPolygonSegmentThreeJS(currentLocal.x, currentLocal.y, currentPoint.pointZLocation || 0, nextLocal.x, nextLocal.y, nextPoint.pointZLocation || 0, lineWidth, color, name);
								}
							}

							// For polygons, close the loop with final segment
							// NOTE: Closing segment goes TO firstPoint, so use firstPoint's color
							if (entity.entityType === "poly" && pointsToRender.length > 2) {
								var firstPoint = pointsToRender[0];
								var lastPoint = pointsToRender[pointsToRender.length - 1];

								var firstLocal = worldToThreeLocal(firstPoint.pointXLocation, firstPoint.pointYLocation);
								var lastLocal = worldToThreeLocal(lastPoint.pointXLocation, lastPoint.pointYLocation);

								// Use firstPoint's color - the closing segment goes TO the first point
								var lineWidth = firstPoint.lineWidth || 1;
								var color = firstPoint.color || "#FF0000";

								drawKADPolygonSegmentThreeJS(lastLocal.x, lastLocal.y, lastPoint.pointZLocation || 0, firstLocal.x, firstLocal.y, firstPoint.pointZLocation || 0, lineWidth, color, name);
							}
						}

						// Step 6d) Draw invisible vertex markers for selection (raycasting only - no visual)
						// IMPORTANT: Use original visiblePoints, NOT simplified points, for vertex selection
						// Vertices are hidden but still selectable - pink highlight appears on selection via move tool
						for (var i = 0; i < visiblePoints.length; i++) {
							var point = visiblePoints[i];
							var local = worldToThreeLocal(point.pointXLocation, point.pointYLocation);
							var vertexIndex = entity.data.indexOf(point);
							var kadId = name + ":::" + vertexIndex;
							var vertexSize = 0.3; // Small marker for vertex selection (invisible)

							// Create invisible point for raycasting only
							var pointMesh = GeometryFactory.createKADPoint(local.x, local.y, point.pointZLocation || 0, vertexSize, point.color || "#FF0000");
							pointMesh.userData = { type: "kadPoint", kadId: kadId };
							pointMesh.visible = false; // Make invisible but keep in scene for raycasting
							window.threeRenderer.kadGroup.add(pointMesh);
						}
					}
				} else if (entity.entityType === "circle") {
					for (const circleData of entity.data) {
						if (circleData.visible === false) continue;
						const centerX = circleData.centerX || circleData.pointXLocation;
						const centerY = circleData.centerY || circleData.pointYLocation;
						const centerZ = circleData.centerZ || circleData.pointZLocation || 0;
						const radius = circleData.radius || 10; // Radius in world units
						const local = worldToThreeLocal(centerX, centerY);
						const vertexIndex = entity.data.indexOf(circleData);
						const kadId = name + ":::" + vertexIndex;
						drawKADCircleThreeJS(local.x, local.y, centerZ, radius, circleData.lineWidth || 1, circleData.color || "#FF0000", kadId); // kadId format: "entityName:::vertexIndex"
					}
				} else if (entity.entityType === "text") {
					for (const textData of entity.data) {
						if (textData.visible === false) continue;
						const local = worldToThreeLocal(textData.pointXLocation, textData.pointYLocation);
						const vertexIndex = entity.data.indexOf(textData);
						const kadId = name + ":::" + vertexIndex;
						// Step B2) Use fontHeight attribute for text size, default to 12
						var textFontSize = textData.fontHeight || 12;
						drawKADTextThreeJS(local.x, local.y, textData.pointZLocation || 0, textData.text || "", textFontSize, textData.color || "#000000", textData.backgroundColor || null, kadId); // kadId format: "entityName:::vertexIndex"
					}
				}
			}
		}

		// Step 6) Highlight selected KAD objects in Three.js (after KAD drawing)
		highlightSelectedKADThreeJS();

		// Step 6a) Draw offset preview in 3D if active
		// This draws the live preview of offset operations in 3D mode
		draw3DOffsetPreview();
	}

	// Step 7) RESET REBUILD FLAG - After all geometry (holes AND KAD) is drawn
	// This MUST be after both blocks to prevent partial rebuilds
	if (window.threeDataNeedsRebuild) {
		window.threeDataNeedsRebuild = false;
		if (developerModeEnabled) {
			console.log("‚úÖ 3D geometry rebuild complete - flag reset");
		}
	}

	// Step 7a) Draw leading line AFTER rebuild completes (so it doesn't get cleared)
	// Leading line is a temporary UI element, redrawn every frame like mouse indicator
	if (onlyShowThreeJS && threeInitialized) {
		const isAnyDrawingToolActive = isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText || isAddingHole;
		if (isAnyDrawingToolActive && lastKADDrawPoint && createNewEntity === false) {
			const drawZ = parseFloat(drawingZValue || document.getElementById("drawingElevation").value || 0);
			const leadingLineZ = lastKADDrawPoint.z || drawZ;

			var leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan default
			if (isDrawingPoint || isAddingHole) {
				leadingLineColor = "rgba(209, 0, 0, 0.8)"; // Red
			} else if (isDrawingLine) {
				leadingLineColor = "rgba(0, 255, 255, 0.8)"; // Cyan
			} else if (isDrawingPoly) {
				leadingLineColor = "rgba(255, 0, 255, 0.8)"; // Magenta
			} else if (isDrawingCircle) {
				leadingLineColor = "rgba(255, 165, 0, 0.8)"; // Orange
			} else if (isDrawingText) {
				leadingLineColor = "rgba(0, 255, 0, 0.8)"; // Green
			}

			// Step 7a.1) Use currentMouseIndicator (from indicatorPos) NOT currentMouseWorld
			// indicatorPos correctly tracks mouse via view plane and snap targets
			// currentMouseWorld comes from mouseWorldPos which doesn't handle camera rotation
			drawKADLeadingLineThreeJSV2(
				lastKADDrawPoint.x,
				lastKADDrawPoint.y,
				lastKADDrawPoint.z,
				currentMouseIndicatorX,
				currentMouseIndicatorY,
				currentMouseIndicatorZ,
				leadingLineColor
			);

		} else {
			clearKADLeadingLineThreeJS();
		}
	}

	// Step 2) Render Three.js scene ONLY when in Three.js-only mode
	// CRITICAL: DO NOT check isIn3DMode - use ONLY onlyShowThreeJS flag
	if (onlyShowThreeJS) {
		// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
		// ‚õî DO NOT USE THIS CODE - EVER!!! ‚õî
		// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
		// Step 2a) DISABLED - Cursor is now drawn in handle3DMouseMove() with proper view plane Z
		// This old code was using flat dataCentroidZ which caused cursor to be in wrong position
		// if (onlyShowThreeJS && threeInitialized && threeRenderer && interactionManager) {
		// 	// Use current mouse world position if available, otherwise use camera centroid
		// 	let indicatorPos = null;
		// 	if (currentMouseWorldX !== undefined && currentMouseWorldY !== undefined && isFinite(currentMouseWorldX) && isFinite(currentMouseWorldY)) {
		// 		indicatorPos = {
		// 			x: currentMouseWorldX,
		// 			y: currentMouseWorldY,
		// 			z: window.dataCentroidZ || 0, // WRONG! Should use view plane Z
		// 		};
		// 	} else {
		// 		// Fallback to camera centroid
		// 		const cameraState = window.cameraControls ? window.cameraControls.getCameraState() : null;
		// 		if (cameraState && isFinite(cameraState.centroidX) && isFinite(cameraState.centroidY)) {
		// 			const originX = window.threeLocalOriginX !== undefined && isFinite(window.threeLocalOriginX) ? window.threeLocalOriginX : 0;
		// 			const originY = window.threeLocalOriginY !== undefined && isFinite(window.threeLocalOriginY) ? window.threeLocalOriginY : 0;
		// 			indicatorPos = {
		// 				x: cameraState.centroidX + originX,
		// 				y: cameraState.centroidY + originY,
		// 				z: window.dataCentroidZ || 0,
		// 			};
		// 		} else if (typeof centroidX !== "undefined" && typeof centroidY !== "undefined" && isFinite(centroidX) && isFinite(centroidY)) {
		// 			indicatorPos = {
		// 				x: centroidX,
		// 				y: centroidY,
		// 				z: window.dataCentroidZ || 0,
		// 			};
		// 		}
		// 	}
		//
		// 	if (indicatorPos && isFinite(indicatorPos.x) && isFinite(indicatorPos.y)) {
		// 		drawMousePositionIndicatorThreeJS(indicatorPos.x, indicatorPos.y, indicatorPos.z);
		// 	}
		// }

		// Step B) Draw 3D visuals for pattern tools (MUST be in 3D block to actually render!)
		// These were incorrectly placed in the 2D block where onlyShowThreeJS is always false
		drawPatternInPolygon3DVisual();
		drawHolesAlongPolyline3DVisual();
		drawHolesAlongLine3DVisual();

		renderThreeJS();

		if (developerModeEnabled) {
			console.log("üßä Three.js scene rendered - drawData()");
		}
	}
}

function drawKADCoordinates(kadPoint, screenX, screenY) {
	const displayOptions = getDisplayOptions();

	// Calculate text offset based on current scale and font size
	const textOffset = Math.max(10, parseInt(currentFontSize * 0.5));
	const leftSide = parseInt(screenX) - textOffset;
	const rightSide = parseInt(screenX) + textOffset;
	const topSide = parseInt(screenY - textOffset);
	const middleSide = parseInt(screenY + parseInt(currentFontSize / 2));
	const bottomSide = parseInt(screenY + textOffset + parseInt(currentFontSize));

	// Set font for coordinate display
	ctx.font = parseInt(currentFontSize * 0.5) + "px Arial";

	// Display X coordinate (right side, top)
	if (displayOptions.xValue) {
		drawText(rightSide, topSide, parseFloat(kadPoint.pointXLocation).toFixed(2), textFillColor);
	}

	// Display Y coordinate (right side, middle)
	if (displayOptions.yValue) {
		drawText(rightSide, middleSide, parseFloat(kadPoint.pointYLocation).toFixed(2), textFillColor);
	}

	// Display Z coordinate (right side, bottom)
	if (displayOptions.zValue) {
		drawText(rightSide, bottomSide, parseFloat(kadPoint.pointZLocation).toFixed(2), textFillColor);
	}
}

// Draws Voronoi cells only - legend is now in HUD overlay
function drawVoronoiLegendAndCells(allBlastHoles, selectedVoronoiMetric, getColorForMetric, legendLabel, minValue, maxValue, step) {
	// Legend drawing removed - now using HUD overlay (showVoronoiLegend)

	const voronoiMetrics = getVoronoiMetrics(allBlastHoles, useToeLocation);
	const clippedCells = clipVoronoiCells(voronoiMetrics);

	for (const cell of clippedCells) {
		const value = cell[selectedVoronoiMetric];
		if (!cell.polygon || value == null) continue;
		ctx.beginPath();
		for (let j = 0; j < cell.polygon.length; j++) {
			const pt = cell.polygon[j];
			const [x, y] = worldToCanvas(pt.x !== undefined ? pt.x : pt[0], pt.y !== undefined ? pt.y : pt[1]);
			if (j === 0) ctx.moveTo(x, y);
			else ctx.lineTo(x, y);
		}
		ctx.closePath();
		ctx.fillStyle = getColorForMetric(value);
		ctx.fill();
		ctx.strokeStyle = "#222";
		ctx.lineWidth = 1;
		ctx.stroke();
	}
}

// === Helper: Draw hole labels, connectors, delay text, etc. ===
function drawHoleTextsAndConnectors(hole, x, y, lineEndX, lineEndY, ctxObj) {
	const { leftSideToe, rightSideToe, leftSideCollar, rightSideCollar, topSideToe, middleSideToe, bottomSideToe, topSideCollar, middleSideCollar, bottomSideCollar, holeMap, displayOptions } = ctxObj;

	if (displayOptions.holeID) {
		drawText(rightSideCollar, topSideCollar, hole.holeID, textFillColor);
	}
	if (displayOptions.holeDia) {
		drawText(rightSideCollar, middleSideCollar, parseFloat(hole.holeDiameter).toFixed(0), "green");
	}
	if (displayOptions.holeLen) {
		drawText(rightSideCollar, bottomSideCollar, parseFloat(hole.holeLengthCalculated).toFixed(1), depthColor);
	}
	if (displayOptions.holeAng) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeDip) {
		drawRightAlignedText(leftSideToe, topSideToe, 90 - parseFloat(hole.holeAngle).toFixed(0), angleDipColor);
	}
	if (displayOptions.holeBea) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.holeBearing).toFixed(1), "red");
	}
	if (displayOptions.holeSubdrill) {
		drawRightAlignedText(leftSideToe, bottomSideToe, parseFloat(hole.subdrillAmount).toFixed(1), "blue");
	}
	if (displayOptions.initiationTime) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, hole.holeTime, "red");
	}
	if (displayOptions.connector && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			try {
				drawArrow(startX, startY, x, y, connColor, connScale, hole.connectorCurve || 0);
			} catch (error) {
				console.error("Error drawing arrow:", error);
			}
		}
	}
	if (displayOptions.delayValue && hole.fromHoleID) {
		const [splitEntityName, splitFromHoleID] = hole.fromHoleID.split(":::");
		const fromHole = holeMap.get(splitEntityName + ":::" + splitFromHoleID);
		if (fromHole) {
			const [startX, startY] = worldToCanvas(fromHole.startXLocation, fromHole.startYLocation);
			const connColor = hole.colorHexDecimal;
			const pointDelay = hole.timingDelayMilliseconds;
			drawArrowDelayText(startX, startY, x, y, connColor, pointDelay, hole.connectorCurve || 0);
		}
	}
	if (displayOptions.xValue) {
		drawRightAlignedText(leftSideCollar, topSideCollar, parseFloat(hole.startXLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.yValue) {
		drawRightAlignedText(leftSideCollar, middleSideCollar, parseFloat(hole.startYLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.zValue) {
		drawRightAlignedText(leftSideCollar, bottomSideCollar, parseFloat(hole.startZLocation).toFixed(2), textFillColor);
	}
	if (displayOptions.holeType) {
		drawText(rightSideCollar, middleSideCollar, hole.holeType, "green");
	}
	if (displayOptions.measuredLength) {
		drawRightAlignedText(leftSideCollar, bottomSideToe, hole.measuredLength, "#FF4400");
	}
	if (displayOptions.measuredMass) {
		drawRightAlignedText(leftSideCollar, topSideToe, hole.measuredMass, "#FF6600");
	}
	if (displayOptions.measuredComment) {
		drawText(rightSideCollar, middleSideCollar, hole.measuredComment, "#FF8800");
	}
	if (displayOptions.displayRowAndPosId) {
		drawRightAlignedText(leftSideCollar, topSideCollar, "Row:" + hole.rowID, "#FF00FF");
		drawRightAlignedText(leftSideCollar, middleSideCollar, "Pos:" + hole.posID, "#FF00FF");
	}
}

// === Helper: Build selection message with connection info ===
function buildHoleSelectionMessage(hole) {
	let message = "Editing Selected Hole: " + hole.holeID + " in: " + hole.entityName;

	// Add connection information if hole has a fromHoleID
	if (hole.fromHoleID && hole.fromHoleID !== "") {
		const [fromEntity, fromHoleID] = hole.fromHoleID.split(":::");
		message += "\nConnected from: " + fromHoleID;
		if (fromEntity && fromEntity !== hole.entityName) {
			message += " (" + fromEntity + ")";
		}
		// Add delay value if available
		if (hole.timingDelayMilliseconds !== undefined && hole.timingDelayMilliseconds !== null) {
			message += " | Delay: " + hole.timingDelayMilliseconds + "ms";
		}
	}

	message += "\nEscape key to clear Selection";
	return message;
}

// === Helper: Draw hole labels in Three.js for 3D mode ===
// Note: drawHoleTextsAndConnectorsThreeJS moved to src/draw/canvas3DDrawing.js

function drawConnectStadiumZone(sx, sy, endX, endY, connectAmount) {
	// Only draw stadium zone if multi-connector tool is active
	if (isAddingMultiConnector) {
		// Convert world coordinates to canvas coordinates
		const [canvasStartX, canvasStartY] = worldToCanvas(sx, sy);
		const [canvasEndX, canvasEndY] = worldToCanvas(endX, endY);

		// connectAmount is already in meters, so just multiply by currentScale
		const radiusPx = connectAmount * currentScale;

		// Calculate the line vector and perpendicular vector
		const dx = canvasEndX - canvasStartX;
		const dy = canvasEndY - canvasStartY;
		const length = Math.sqrt(dx * dx + dy * dy);

		// Avoid division by zero
		if (length < 1) return;

		// Normalize the direction vector
		const dirX = dx / length;
		const dirY = dy / length;

		// Get perpendicular vector (for width)
		const perpX = -dirY;
		const perpY = dirX;

		// Calculate the four corners of the rectangle
		const corner1X = canvasStartX + perpX * radiusPx;
		const corner1Y = canvasStartY + perpY * radiusPx;
		const corner2X = canvasStartX - perpX * radiusPx;
		const corner2Y = canvasStartY - perpY * radiusPx;
		const corner3X = canvasEndX - perpX * radiusPx;
		const corner3Y = canvasEndY - perpY * radiusPx;
		const corner4X = canvasEndX + perpX * radiusPx;
		const corner4Y = canvasEndY + perpY * radiusPx;
		// Set stadium zone color with transparency
		ctx.strokeStyle = "rgba(0, 255, 0, 0.4)";
		ctx.fillStyle = "rgba(0, 255, 0, 0.15)";
		ctx.lineWidth = 2;
		ctx.setLineDash([5, 5]); // Set dashed line with 5px gap and 5px dash

		// Draw the stadium shape (rounded rectangle)
		ctx.beginPath();

		// Start at the center of the first semicircle
		ctx.arc(canvasStartX, canvasStartY, radiusPx, Math.atan2(perpY, perpX), Math.atan2(-perpY, -perpX), false);

		// Line to second corner
		ctx.lineTo(corner3X, corner3Y);

		// Second semicircle
		ctx.arc(canvasEndX, canvasEndY, radiusPx, Math.atan2(-perpY, -perpX), Math.atan2(perpY, perpX), false);

		// Line back to first corner
		ctx.lineTo(corner1X, corner1Y);

		ctx.closePath();
		ctx.fill();
		ctx.stroke();
		// CRITICAL: Reset line dash back to solid line
		ctx.setLineDash([]);
	}
}

// === Helper: Draw main hole, highlight if selected ===
function drawHoleMainShape(hole, x, y, selectedHole) {
	const diameterPx = parseInt((hole.holeDiameter / 1000) * currentScale * holeScale);

	let highlightType = null;
	let highlightColor1 = null,
		highlightColor2 = null,
		highlightText = null;

	// Check if we're in connector mode
	if (isAddingConnector || isAddingMultiConnector) {
		// First selected hole in connector mode (using fromHoleStore)
		if (fromHoleStore && fromHoleStore === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Select second hole)";
			// Step 4d) Draw 2D stadium zone only when in 2D mode
			if (!onlyShowThreeJS) {
				drawConnectStadiumZone(hole.startXLocation, hole.startYLocation, currentMouseWorldX, currentMouseWorldY, connectAmount);
			}
		}
		// Second selected hole in connector mode (using firstSelectedHole/secondSelectedHole)
		else if (firstSelectedHole && firstSelectedHole === hole) {
			highlightType = "first";
			highlightColor1 = "rgba(0, 255, 0, 0.2)";
			highlightColor2 = "rgba(0, 190, 0, .8)";
			highlightText = "1st Selected Hole: " + hole.holeID + " in: " + hole.entityName;
		} else if (secondSelectedHole && secondSelectedHole === hole) {
			highlightType = "second";
			highlightColor1 = "rgba(255, 255, 0, 0.2)";
			highlightColor2 = "rgba(255, 200, 0, .8)";
			highlightText = "2nd Selected Hole: " + hole.holeID + " in: " + hole.entityName + " (Click to connect)";
		}
	}
	// Regular selection highlighting (NOT in connector mode)
	else if (selectedHole != null && selectedHole === hole) {
		highlightType = "selected";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		highlightText = "";  // Don't draw ctx text anymore
		// HUD: Show selection message with connection info
		showSelectionMessage(buildHoleSelectionMessage(selectedHole));
	}
	// Multiple selection highlighting
	else if (selectedMultipleHoles != null && selectedMultipleHoles.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		highlightType = "multi";
		highlightColor1 = "rgba(255, 0, 150, 0.2)";
		highlightColor2 = "rgba(255, 0, 150, .8)";
		if (hole === selectedMultipleHoles[0]) {
			// HUD: Show multi-selection message (cap at 10 holes)
			var holeIDs2D = selectedMultipleHoles.map((h) => h.holeID);
			var displayIDs2D = holeIDs2D.length > 10 ? holeIDs2D.slice(0, 10).join(",") + "..." : holeIDs2D.join(",");
			highlightText = "";  // Don't draw ctx text anymore
			showSelectionMessage("Editing " + selectedMultipleHoles.length + " Holes: {" + displayIDs2D + "}\nEscape key to clear Selection");
		} else {
			highlightText = "";
		}
	}

	// Step 4c) Draw highlight, if any (2D only - only when in 2D mode)
	if (highlightType && !onlyShowThreeJS) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 900) * holeScale * currentScale), highlightColor1, highlightColor2);
		// Selection text now shown in HUD instead of ctx
	}

	// Draw main hole/track shape (dummy, missing, or real)
	ctx.lineWidth = 1;
	ctx.strokeStyle = strokeColor;
	if (parseFloat(hole.holeLengthCalculated).toFixed(1) == 0.0) {
		drawDummy(x, y, parseInt(0.2 * holeScale * currentScale), strokeColor);
	} else if (hole.holeDiameter == 0) {
		drawNoDiameterHole(x, y, 10, strokeColor);
	} else {
		drawHole(x, y, diameterPx, fillColor, strokeColor);
	}
}

// === Helper: Handle Highlighting for Animation/Time Window ===
function handleHoleHighlighting(hole, x, y) {
	if (isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 400) * holeScale * currentScale), "rgba(255, 150, 0, 0.7)", "rgba(200, 200, 0, 0.7)");
	}
	if (!isPlaying && timingWindowHolesSelected != null && timingWindowHolesSelected.find((p) => p.entityName === hole.entityName && p.holeID === hole.holeID)) {
		drawHiHole(x, y, 10 + parseInt((hole.holeDiameter / 500) * holeScale * currentScale), "rgba(0, 255, 0, 0.5)", "rgba(0, 255, 0, 0.7)");
	}
}

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	const canvasX = evt.clientX - rect.left;
	const canvasY = evt.clientY - rect.top;

	lastMouseX = canvasX;
	lastMouseY = canvasY;

	return {
		x: canvasX,
		y: canvasY,
	};
}

function openHelp() {
	window.open("kirrausermanual.html");
}

function zoomIn() {
	// Step 1) Check if 3D mode is active
	if (window.onlyShowThreeJS && window.cameraControls) {
		// Step 1a) Get current camera state
		const currentState = window.cameraControls.getCameraState();
		const zoomFactor = 1.1; // Zoom in by 10%
		const newScale = currentState.scale * zoomFactor;

		// Step 1b) Update camera state with new scale
		window.cameraControls.setCameraState(currentState.centroidX, currentState.centroidY, newScale, currentState.rotation, currentState.orbitX, currentState.orbitY);
		return;
	}

	// Step 2) 2D mode - use existing logic
	currentScale += 1; // increase the current scale by 1
	currentFontSize += 1;
	drawData(allBlastHoles, selectedHole);
}

function zoomOut() {
	// Step 1) Check if 3D mode is active
	if (window.onlyShowThreeJS && window.cameraControls) {
		// Step 1a) Get current camera state
		const currentState = window.cameraControls.getCameraState();
		const zoomFactor = 0.9; // Zoom out by 10%
		const newScale = Math.max(0.01, currentState.scale * zoomFactor);

		// Step 1b) Update camera state with new scale
		window.cameraControls.setCameraState(currentState.centroidX, currentState.centroidY, newScale, currentState.rotation, currentState.orbitX, currentState.orbitY);
		return;
	}

	// Step 2) 2D mode - use existing logic
	currentScale = Math.max(0.25, currentScale - 1); // decrease the current scale by 0.25, but not below 1
	currentFontSize -= 1;
	drawData(allBlastHoles, selectedHole);
}

function getHoleBoundaries() {
	if (!allBlastHoles || allBlastHoles.length === 0) {
		return null;
	}

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	for (const hole of allBlastHoles) {
		if (hole.startXLocation < minX) minX = hole.startXLocation;
		if (hole.startXLocation > maxX) maxX = hole.startXLocation;
		if (hole.startYLocation < minY) minY = hole.startYLocation;
		if (hole.startYLocation > maxY) maxY = hole.startYLocation;
	}

	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

function zoomToFitAll() {
	const holeBoundaries = getHoleBoundaries();
	const kadBoundaries = getKADBoundaries();
	const surfaceBoundaries = getSurfaceBoundaries(); // NEW
	const imageBoundaries = getImageBoundaries(); // NEW

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	// Include hole boundaries
	if (holeBoundaries) {
		minX = Math.min(minX, holeBoundaries.minX);
		maxX = Math.max(maxX, holeBoundaries.maxX);
		minY = Math.min(minY, holeBoundaries.minY);
		maxY = Math.max(maxY, holeBoundaries.maxY);
	}

	// Include KAD drawing boundaries
	if (kadBoundaries) {
		minX = Math.min(minX, kadBoundaries.minX);
		maxX = Math.max(maxX, kadBoundaries.maxX);
		minY = Math.min(minY, kadBoundaries.minY);
		maxY = Math.max(maxY, kadBoundaries.maxY);
	}

	// NEW: Include surface boundaries
	if (surfaceBoundaries) {
		minX = Math.min(minX, surfaceBoundaries.minX);
		maxX = Math.max(maxX, surfaceBoundaries.maxX);
		minY = Math.min(minY, surfaceBoundaries.minY);
		maxY = Math.max(maxY, surfaceBoundaries.maxY);
	}

	// NEW: Include background image boundaries
	if (imageBoundaries) {
		minX = Math.min(minX, imageBoundaries.minX);
		maxX = Math.max(maxX, imageBoundaries.maxX);
		minY = Math.min(minY, imageBoundaries.minY);
		maxY = Math.max(maxY, imageBoundaries.maxY);
	}

	if (minX === Infinity) {
		// Just set defaults without calling resetZoom()
		currentScale = scale;
		currentFontSize = fontSize;
		updateCentroids();
		drawData(allBlastHoles, selectedHole);
		return;
	}

	centroidX = minX + (maxX - minX) / 2;
	centroidY = minY + (maxY - minY) / 2;

	const dataWidth = maxX - minX;
	const dataHeight = maxY - minY;

	if (dataWidth === 0 || dataHeight === 0) {
		currentScale = 1;
	} else {
		const scaleX = (canvas.width * 0.9) / dataWidth;
		const scaleY = (canvas.height * 0.9) / dataHeight;
		currentScale = Math.min(scaleX, scaleY);
	}

	// Step 1) Sync camera to Three.js after calculating new position/scale
	syncCameraToThreeJS();

	drawData(allBlastHoles, selectedHole);
}
// REPLACE the entire function:
function getSurfaceBoundaries() {
	if (loadedSurfaces.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedSurfaces.forEach((surface) => {
		if (surface.points && surface.points.length > 0) {
			surface.points.forEach((point) => {
				if (point.x < minX) minX = point.x;
				if (point.x > maxX) maxX = point.x;
				if (point.y < minY) minY = point.y;
				if (point.y > maxY) maxY = point.y;
			});
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

// REPLACE the entire function:
function getImageBoundaries() {
	if (loadedImages.size === 0) return null;

	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;

	loadedImages.forEach((image) => {
		if (image.bbox && image.bbox.length >= 4) {
			// image.bbox is [minX, minY, maxX, maxY] format
			if (image.bbox[0] < minX) minX = image.bbox[0];
			if (image.bbox[2] > maxX) maxX = image.bbox[2];
			if (image.bbox[1] < minY) minY = image.bbox[1];
			if (image.bbox[3] > maxY) maxY = image.bbox[3];
		}
	});

	if (minX === Infinity) return null;
	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

function resetZoom() {
	currentScale = scale; // reset the current scale to the original scale
	currentFontSize = fontSize;

	// Reset Three.js camera rotation and orbit to top-down view
	if (threeInitialized && cameraControls) {
		currentRotation = 0; // Reset Z-axis rotation
		// Reset orbit angles
		cameraControls.rotation = 0;
		cameraControls.orbitX = 0;
		cameraControls.orbitY = 0;
		console.log("üì∑ Camera reset to top-down view");
	}

	//calculate the centroids from the data in the maps and points
	updateCentroids();

	// Step 2) Sync camera after resetting
	syncCameraToThreeJS();

	drawData(allBlastHoles, selectedHole);
	zoomToFitAll();
}
///SAVE and LOAD ALLBLASTHOLES ARRAY TO LOCAL STORAGE /////////////////////////////////
// DEPRECATED: This function is deprecated. Use debouncedSaveHoles() or saveHolesToDB() instead.
// Kept for backward compatibility but no longer used for persistence.
function saveHolesToLocalStorage(allBlastHoles) {
	if (allBlastHoles !== null) {
		/* STRUCTURE OF THE POINTS ARRAY
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
		entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,holeTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID,burden,spacing,connectorCurve
	*/
		const lines = allBlastHoles.map((hole) => {
			return `${hole.entityName},${hole.entityType},${hole.holeID},${hole.startXLocation},${hole.startYLocation},${hole.startZLocation},${hole.endXLocation},${hole.endYLocation},${hole.endZLocation},${hole.gradeXLocation},${hole.gradeYLocation},${hole.gradeZLocation},${hole.subdrillAmount},${hole.subdrillLength},${hole.benchHeight},${hole.holeDiameter},${hole.holeType},${hole.fromHoleID},${hole.timingDelayMilliseconds},${hole.colorHexDecimal},${hole.holeLengthCalculated},${hole.holeAngle},${hole.holeBearing},${hole.holeTime},${hole.measuredLength},${hole.measuredLengthTimeStamp},${hole.measuredMass},${hole.measuredMassTimeStamp},${hole.measuredComment},${hole.measuredCommentTimeStamp},${hole.rowID},${hole.posID},${hole.burden},${hole.spacing},${hole.connectorCurve}\n`;
		});

		const csvString = lines.join("\n");
		const pointsMap = new Map();

		localStorage.setItem("kirraDataPoints", csvString);

		for (const entity of pointsMap.values()) {
			// console.log(entity);
		}
	}
	console.log("All blast Holes saved to local storage");
	console.log(allBlastHoles);
}

function refreshPoints() {
	// Step 1) Update play speed input based on hole count
	const playSpeedInput = document.getElementById("playSpeed");
	if (allBlastHoles.length > 1000) {
		playSpeedInput.max = 50;
	} else {
		playSpeedInput.max = 15;
	}

	// Step 2) Validate data integrity (duplicate check)
	const duplicateCheck = checkAndResolveDuplicateHoleIDs(allBlastHoles, "data reload");
	if (duplicateCheck.hasDuplicates) {
		console.warn("?? Data corruption detected during reload - duplicates resolved automatically");
		// Save the corrected data via debounced save
		debouncedSaveHoles();
	}

	// Step 3) Recalculate all derived data
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, deltaX, deltaY);
	contourLinesArray = result.contourLinesArray;
	directionArrows = result.directionArrows;

	// Step 4) Recalculate triangles
	const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

	// Step 5) Redraw and update tree view
	window.threeDataNeedsRebuild = true; // Trigger 3D rebuild after data refresh
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();

	return allBlastHoles;
}

// Use this function whenever you need to refresh the state and redraw the canvas
// For example, after deleting a hole or renumbering holes:
// refreshPoints();

// DEPRECATED: This function is deprecated. Use loadHolesFromDB() instead.
// Kept for backward compatibility but no longer used for persistence.
async function loadHolesFromLocalStorage() {
	// Initialize points as an empty array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}
	/* STRUCTURE OF THE POINTS ARRAY
		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
		entityName,entityType,holeID,startXLocation,startYLocation,startZLocation,endXLocation,endYLocation,endZLocation,gradeXLocation, gradeYLocation, gradeZLocation, subdrillAmount, subdrillLength, benchHeight, holeDiameter,holeType,fromHoleID,timingDelayMilliseconds,colorHexDecimal,holeLengthCalculated,holeAngle,holeBearing,holeTime,measuredLength,measuredLengthTimeStamp,measuredMass,measuredMassTimeStamp,measuredComment,measuredCommentTimeStamp, rowID, posID
	*/
	const csvString = localStorage.getItem("kirraDataPoints");
	//console.log(csvString);
	if (csvString) {
		var parseResult = await parseK2Dcsv(csvString);
		allBlastHoles = parseResult.holes;
		//console.log(points);
		updateCentroids();
		holeTimes = calculateTimes(allBlastHoles);
		const result = recalculateContours(allBlastHoles, deltaX, deltaY);
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;

		// directionArrows now contains the arrow data for later drawing

		const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength); // Recalculate triangles
		drawData(allBlastHoles, selectedHole);
		//console.log the points array in a blob for each entityname
		const blastHolesMap = new Map();
		for (const hole of allBlastHoles) {
			if (!blastHolesMap.has(hole.entityName)) {
				blastHolesMap.set(hole.entityName, {
					entityName: hole.entityName,
					data: [],
				});
			}
			blastHolesMap.get(hole.entityName).data.push(hole);
		}
		for (const entity of blastHolesMap.values()) {
			//console.log(entity);
		}
		console.log("///////////////////POINTS DATA ON LOAD//////////////");
		console.log(allBlastHoles);
		return allBlastHoles;
	}
	return null;
}

// --- IndexedDB & Local Storage Management ---

let db;
const DB_NAME = "Kirra-DATABASE";
const STORE_NAME = "KADDRAWINGS";
const SURFACE_STORE_NAME = "KADSURFACE";
const IMAGE_STORE_NAME = "KADIMAGES";
const BLASTHOLES_STORE_NAME = "BLASTHOLES";
// Step 4) Layer System - Store for drawing and surface layers
const LAYERS_STORE_NAME = "KADLAYERS";

// Define all required stores - THIS WAS MISSING
const REQUIRED_STORES = [STORE_NAME, SURFACE_STORE_NAME, IMAGE_STORE_NAME, BLASTHOLES_STORE_NAME, LAYERS_STORE_NAME];

// Start with a higher version that you'll use going forward
const DB_VERSION = 5; // Set this higher than your current version

async function initDB() {
	return new Promise((resolve, reject) => {
		// Open without version to get current state
		const initialRequest = indexedDB.open(DB_NAME);

		initialRequest.onsuccess = (event) => {
			const db = event.target.result;
			const currentVersion = db.version;
			const existingStores = Array.from(db.objectStoreNames);
			const missingStores = REQUIRED_STORES.filter((store) => !existingStores.includes(store));

			console.log("Current version: " + currentVersion);
			console.log("Existing stores: " + existingStores);
			console.log("Missing stores: " + missingStores);

			if (missingStores.length === 0) {
				// All good, use this connection
				resolve(db);
			} else {
				// Need to upgrade
				db.close();

				const upgradeRequest = indexedDB.open(DB_NAME, currentVersion + 1);

				upgradeRequest.onsuccess = () => resolve(upgradeRequest.result);
				upgradeRequest.onerror = () => reject(upgradeRequest.error);

				upgradeRequest.onupgradeneeded = (event) => {
					const upgradeDb = event.target.result;
					console.log("Upgrading database - creating missing stores");

					missingStores.forEach((storeName) => {
						console.log(`Creating store: ${storeName}`);
						const store = upgradeDb.createObjectStore(storeName, {
							keyPath: "id",
						});

						if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
							store.createIndex("name", "name", {
								unique: false,
							});
							store.createIndex("type", "type", {
								unique: false,
							});
						}
					});
				};
			}
		};

		initialRequest.onerror = () => reject(initialRequest.error);

		// Handle new database creation
		initialRequest.onupgradeneeded = (event) => {
			const db = event.target.result;
			console.log("Creating new database with all stores");

			REQUIRED_STORES.forEach((storeName) => {
				console.log(`Creating store: ${storeName}`);
				const store = db.createObjectStore(storeName, {
					keyPath: "id",
				});

				if (storeName === SURFACE_STORE_NAME || storeName === IMAGE_STORE_NAME) {
					store.createIndex("name", "name", {
						unique: false,
					});
					store.createIndex("type", "type", {
						unique: false,
					});
				}
			});
		};
	});
}

let saveTimeout;
//Staged Saving for large files as these can't be save on the instantquit of a window close.
function debouncedSaveKAD() {
	// Clear any existing pending save
	clearTimeout(saveTimeout);
	// Set a new save to trigger after 2 seconds
	saveTimeout = setTimeout(() => {
		console.log("Auto-saving KAD drawings to DB...");
		// Only save if DB is initialized
		if (db) {
			saveKADToDB(allKADDrawingsMap);
		} else {
			console.log("DB not ready, skipping auto-save");
		}
	}, 2000);
}

function saveKADToDB(mapData) {
	if (!db) {
		console.error("DB not initialized. Cannot save.");
		return;
	}

	const transaction = db.transaction([STORE_NAME], "readwrite");
	const store = transaction.objectStore(STORE_NAME);
	let request;

	if (mapData.size === 0) {
		request = store.delete("kadDrawingData"); // ? Use consistent record key
	} else {
		const dataToStore = Array.from(mapData.entries());
		request = store.put({
			id: "kadDrawingData",
			data: dataToStore,
		}); // ? Proper object format
	}

	request.onerror = (event) => {
		console.error("Error saving KAD data to IndexedDB:", event.target.error);
	};
}

function loadKADFromDB() {
	return new Promise((resolve, reject) => {
		if (!db) {
			console.error("DB not initialized. Cannot load.");
			return reject("DB not initialized");
		}
		const transaction = db.transaction([STORE_NAME], "readonly");
		const store = transaction.objectStore(STORE_NAME);
		const request = store.get("kadDrawingData"); // ? Use same record key

		request.onsuccess = (event) => {
			const result = event.target.result;
			if (result && result.data && result.data.length > 0) {
				allKADDrawingsMap = new Map(result.data); // ? Access the data property
				console.log("‚úÖ //-- LOADED UNIFIED DRAWING OBJECTS FROM IndexedDB --//");
				debouncedUpdateTreeView();
				drawData(allBlastHoles, selectedHole);
				resolve(true);
			} else {
				resolve(false);
			}
		};

		request.onerror = (event) => {
			console.error("Error loading KAD data from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}

// Step 5) Layer System - Save layers to IndexedDB
var layerSaveTimeout;
function debouncedSaveLayers() {
	clearTimeout(layerSaveTimeout);
	layerSaveTimeout = setTimeout(function () {
		console.log("Auto-saving layers to DB...");
		if (db) {
			saveLayersToDB();
		} else {
			console.log("DB not ready, skipping layer auto-save");
		}
	}, 2000);
}

function saveLayersToDB() {
	if (!db) {
		console.error("DB not initialized. Cannot save layers.");
		return;
	}

	var transaction = db.transaction([LAYERS_STORE_NAME], "readwrite");
	var store = transaction.objectStore(LAYERS_STORE_NAME);

	// Step 5a) Convert layer Maps to serializable format
	// Convert Set to Array for JSON serialization
	var drawingLayersArray = [];
	allDrawingLayers.forEach(function (layer, layerId) {
		drawingLayersArray.push({
			layerId: layer.layerId,
			layerName: layer.layerName,
			visible: layer.visible,
			sourceFile: layer.sourceFile,
			importDate: layer.importDate,
			entities: Array.from(layer.entities || [])
		});
	});

	var surfaceLayersArray = [];
	allSurfaceLayers.forEach(function (layer, layerId) {
		surfaceLayersArray.push({
			layerId: layer.layerId,
			layerName: layer.layerName,
			visible: layer.visible,
			sourceFile: layer.sourceFile,
			importDate: layer.importDate,
			entities: Array.from(layer.entities || [])
		});
	});

	var request = store.put({
		id: "layersData",
		drawingLayers: drawingLayersArray,
		surfaceLayers: surfaceLayersArray
	});

	request.onsuccess = function () {
		console.log("‚úÖ Layers saved to IndexedDB");
	};

	request.onerror = function (event) {
		console.error("Error saving layers to IndexedDB:", event.target.error);
	};
}

// Step 6) Layer System - Load layers from IndexedDB
function loadLayersFromDB() {
	return new Promise(function (resolve, reject) {
		if (!db) {
			console.error("DB not initialized. Cannot load layers.");
			return reject("DB not initialized");
		}

		var transaction = db.transaction([LAYERS_STORE_NAME], "readonly");
		var store = transaction.objectStore(LAYERS_STORE_NAME);
		var request = store.get("layersData");

		request.onsuccess = function (event) {
			var result = event.target.result;
			if (result) {
				// Step 6a) Restore drawing layers
				if (result.drawingLayers && result.drawingLayers.length > 0) {
					allDrawingLayers.clear();
					result.drawingLayers.forEach(function (layer) {
						allDrawingLayers.set(layer.layerId, {
							layerId: layer.layerId,
							layerName: layer.layerName,
							visible: layer.visible !== false,
							sourceFile: layer.sourceFile,
							importDate: layer.importDate,
							entities: new Set(layer.entities || [])
						});
					});
					console.log("‚úÖ Loaded " + allDrawingLayers.size + " drawing layers from IndexedDB");
				}

				// Step 6b) Restore surface layers
				if (result.surfaceLayers && result.surfaceLayers.length > 0) {
					allSurfaceLayers.clear();
					result.surfaceLayers.forEach(function (layer) {
						allSurfaceLayers.set(layer.layerId, {
							layerId: layer.layerId,
							layerName: layer.layerName,
							visible: layer.visible !== false,
							sourceFile: layer.sourceFile,
							importDate: layer.importDate,
							entities: new Set(layer.entities || [])
						});
					});
					console.log("‚úÖ Loaded " + allSurfaceLayers.size + " surface layers from IndexedDB");
				}

				resolve(true);
			} else {
				resolve(false);
			}
		};

		request.onerror = function (event) {
			console.error("Error loading layers from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}

// Step 1) Save blast holes to IndexedDB
// Stores entire allBlastHoles array as single record with id "blastHolesData"
function saveHolesToDB(holesArray) {
	if (!db) {
		console.error("DB not initialized. Cannot save holes.");
		return;
	}

	const transaction = db.transaction([BLASTHOLES_STORE_NAME], "readwrite");
	const store = transaction.objectStore(BLASTHOLES_STORE_NAME);
	let request;

	if (!holesArray || holesArray.length === 0) {
		request = store.delete("blastHolesData"); // Delete record if array is empty
	} else {
		request = store.put({
			id: "blastHolesData",
			data: holesArray,
		}); // Store entire array as data property
	}

	request.onerror = (event) => {
		console.error("Error saving holes data to IndexedDB:", event.target.error);
	};

	request.onsuccess = () => {
		console.log("üíæ Blast holes saved to IndexedDB (" + holesArray.length + " holes)");
	};
}

// Step 2) Load blast holes from IndexedDB
// Returns Promise that resolves to boolean indicating if data was loaded
function loadHolesFromDB() {
	return new Promise((resolve, reject) => {
		if (!db) {
			console.error("DB not initialized. Cannot load holes.");
			return reject("DB not initialized");
		}
		const transaction = db.transaction([BLASTHOLES_STORE_NAME], "readonly");
		const store = transaction.objectStore(BLASTHOLES_STORE_NAME);
		const request = store.get("blastHolesData"); // Use same record key

		request.onsuccess = (event) => {
			const dbResult = event.target.result;
			if (dbResult && dbResult.data && Array.isArray(dbResult.data) && dbResult.data.length > 0) {
				allBlastHoles = dbResult.data; // Populate array from stored data
				console.log("üìä Loaded " + allBlastHoles.length + " blast holes from IndexedDB");

				// Step 2a) Perform same initialization as loadHolesFromLocalStorage()
				updateCentroids();
				holeTimes = calculateTimes(allBlastHoles);

				// Step 2a.1) Force pre-calculate contours regardless of display options
				// This ensures contours are cached and ready when the user enables them
				invalidateContourCache();
				var forceCalcResult = forceRecalculateContours(allBlastHoles);
				contourLinesArray = forceCalcResult.contourLinesArray;
				directionArrows = forceCalcResult.directionArrows;

				// Step 2b) Recalculate triangles
				const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

				// Step 2c) Redraw and update tree view
				drawData(allBlastHoles, selectedHole);
				debouncedUpdateTreeView();

				resolve(true);
			} else {
				console.log("No holes data found in IndexedDB");
				resolve(false);
			}
		};

		request.onerror = (event) => {
			console.error("Error loading holes data from IndexedDB:", event.target.error);
			reject(event.target.error);
		};
	});
}

// Step 3) Debounced save function for blast holes
// Staged saving for large files as these can't be saved on instant quit of window close
let holesSaveTimeout;
function debouncedSaveHoles() {
	// Clear any existing pending save
	clearTimeout(holesSaveTimeout);
	// Set a new save to trigger after 2 seconds
	holesSaveTimeout = setTimeout(() => {
		console.log("Auto-saving blast holes to DB...");
		// Only save if DB is initialized
		if (db) {
			saveHolesToDB(allBlastHoles);
		} else {
			console.log("DB not ready, skipping auto-save");
		}
	}, 2000);
}

//Improved saveSurfaceToDB
async function saveSurfaceToDB(surfaceId) {
	return new Promise((resolve, reject) => {
		try {
			// ? FIX: Better validation and error handling
			if (!db) {
				console.error("‚ùå Database not initialized");
				reject(new Error("Database not initialized"));
				return;
			}

			// Step 0) Validate surfaceId before lookups
			if (!surfaceId) {
				console.error("‚ùå Surface id is missing for saveSurfaceToDB");
				reject(new Error("Surface id is missing"));
				return;
			}

			const surface = loadedSurfaces.get(surfaceId);
			if (!surface) {
				console.error("‚ùå Surface not found in loadedSurfaces:", surfaceId);
				reject(new Error(`Surface ${surfaceId} not found`));
				return;
			}

			// ? FIX: Validate surface structure
			if (!surface.points || !Array.isArray(surface.points)) {
				console.error("‚ùå Surface missing points array:", surface);
				reject(new Error("Surface missing valid points array"));
				return;
			}

			if (!surface.triangles || !Array.isArray(surface.triangles)) {
				console.error("‚ùå Surface missing triangles array:", surface);
				reject(new Error("Surface missing valid triangles array"));
				return;
			}

			// ? FIX: Validate triangle format before saving
			const isValidTriangleFormat = surface.triangles.every((triangle) => {
				return triangle.vertices && Array.isArray(triangle.vertices) && triangle.vertices.length === 3 && triangle.vertices.every((vertex) => vertex && typeof vertex.x === "number" && typeof vertex.y === "number" && typeof vertex.z === "number");
			});

			if (!isValidTriangleFormat) {
				console.error("‚ùå Invalid triangle format detected:", surface.triangles.slice(0, 3));
				reject(new Error("Invalid triangle format - vertices must be objects with x,y,z properties"));
				return;
			}

			console.log("üíæ Saving surface to database:", {
				id: surfaceId,
				name: surface.name,
				pointCount: surface.points.length,
				triangleCount: surface.triangles.length,
			});

			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);

			// ? FIX: Create properly structured surface record
			var surfaceRecord = {
				id: surfaceId,
				name: surface.name,
				type: surface.type || "triangulated",
				points: surface.points,
				triangles: surface.triangles,
				visible: surface.visible !== undefined ? surface.visible : true,
				// Step 0a-1) CRITICAL: For textured meshes, ALWAYS use "texture" gradient (ignore saved gradient)
				gradient: surface.isTexturedMesh ? "texture" : (surface.gradient || "default"),
				transparency: surface.transparency || 1.0,
				hillshadeColor: surface.hillshadeColor || null, // Step 0a) Save hillshade color for 2D/3D rendering
				minLimit: surface.minLimit || null,
				maxLimit: surface.maxLimit || null,
				layerId: surface.layerId || null, // Step 28c) Save layerId for layer persistence
				created: surface.created || new Date().toISOString(),
				metadata: surface.metadata || {},
			};

			// Step 1) Add textured mesh fields if this is a textured OBJ
			if (surface.isTexturedMesh) {
				surfaceRecord.isTexturedMesh = true;
				surfaceRecord.objContent = surface.objContent || null;
				surfaceRecord.mtlContent = surface.mtlContent || null;
				surfaceRecord.meshBounds = surface.meshBounds || null;

				// Step 2) Store texture blobs if present
				if (surface.textureBlobs) {
					surfaceRecord.textureBlobs = surface.textureBlobs;
				}

				// Step 2a) Store material properties (serializable, no WebGL resources)
				if (surface.materialProperties) {
					surfaceRecord.materialProperties = surface.materialProperties;
					console.log("üíæ Saving material properties for surface: " + surfaceId);
				} else {
					console.warn("üö® No material properties to save for textured mesh: " + surfaceId);
				}

				// Step 2b) Store flattened image data if present (saves recreation on reload)
				if (surface.flattenedImageDataURL) {
					surfaceRecord.flattenedImageDataURL = surface.flattenedImageDataURL;
					surfaceRecord.flattenedImageBounds = surface.flattenedImageBounds;
					surfaceRecord.flattenedImageDimensions = surface.flattenedImageDimensions;
					console.log("üíæ Saving flattened image data for surface: " + surfaceId);
				}

				console.log("üíæ Saving textured mesh data for surface: " + surfaceId);
			}

			// ? FIX: Add proper transaction handlers
			transaction.oncomplete = () => {
				console.log("‚úÖ Surface saved successfully to database:", surfaceId);
				resolve(true);
			};

			transaction.onerror = (event) => {
				console.error("‚ùå Transaction failed:", event.target.error);
				reject(new Error(`Transaction failed: ${event.target.error}`));
			};

			transaction.onabort = (event) => {
				console.error("‚ùå Transaction aborted:", event.target.error);
				reject(new Error(`Transaction aborted: ${event.target.error}`));
			};

			// Perform the actual save operation
			const request = store.put(surfaceRecord);

			request.onsuccess = (event) => {
				console.log("‚úÖ Surface record stored successfully");
				// Transaction will complete automatically
			};

			request.onerror = (event) => {
				console.error("‚ùå Failed to store surface record:", event.target.error);
				reject(new Error(`Failed to store surface: ${event.target.error}`));
			};
		} catch (error) {
			console.error("‚ùå Unexpected error in saveSurfaceToDB:", error);
			reject(error);
		}
	});
}
// Load a specific surface into the multi-surface system
async function loadSurfaceIntoMemory(surfaceId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const store = transaction.objectStore(SURFACE_STORE_NAME);
		const request = store.get(surfaceId);

		return new Promise((resolve) => {
			request.onsuccess = () => {
				const surfaceData = request.result;
				if (surfaceData) {
					// Step 1) Create base surface entry
					var surfaceEntry = {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						// Step 1a-1) CRITICAL: For textured meshes, ALWAYS use "texture" gradient (ignore saved gradient)
						gradient: surfaceData.isTexturedMesh ? "texture" : (surfaceData.gradient || "default"),
						transparency: surfaceData.transparency || 1.0,
						hillshadeColor: surfaceData.hillshadeColor || null, // Step 0b) Load hillshade color from DB
						minLimit: surfaceData.minLimit || null,
						maxLimit: surfaceData.maxLimit || null,
					};

					// Step 2) Load textured mesh fields if this is a textured mesh
					if (surfaceData.isTexturedMesh) {
						surfaceEntry.isTexturedMesh = true;
						surfaceEntry.objContent = surfaceData.objContent || null;
						surfaceEntry.mtlContent = surfaceData.mtlContent || null;
						surfaceEntry.textureBlobs = surfaceData.textureBlobs || null;
						surfaceEntry.meshBounds = surfaceData.meshBounds || null;
						surfaceEntry.materialProperties = surfaceData.materialProperties || null;
						surfaceEntry.threeJSMesh = null; // Will be rebuilt
						surfaceEntry.flattenedImageDataURL = surfaceData.flattenedImageDataURL || null;
						surfaceEntry.flattenedImageBounds = surfaceData.flattenedImageBounds || null;
						surfaceEntry.flattenedImageDimensions = surfaceData.flattenedImageDimensions || null;

						// Step 3) Rebuild textured mesh asynchronously
						setTimeout(function () {
							rebuildTexturedMesh(surfaceData.id);
						}, 100);
					}

					loadedSurfaces.set(surfaceData.id, surfaceEntry);
					console.log("‚úÖ Surface " + surfaceData.name + " loaded into memory");
				}
				resolve(surfaceData);
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading surface into memory:", error);
		return null;
	}
}

// Step 0a) Load all data types with unified progress dialog
async function loadAllDataWithProgress() {
	var loadingDialog = null;

	try {
		// Step 1) Show progress dialog
		loadingDialog = showLoadingProgressDialog();
		updateLoadingProgress(loadingDialog, "Initializing data load...", 0);

		// Step 2) Load blast holes (0-25%)
		updateLoadingProgress(loadingDialog, "Loading blast holes from IndexedDB...", 5);
		await loadHolesFromDB();
		var holeCount = allBlastHoles ? allBlastHoles.length : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + holeCount + " blast holes", 25);

		// Step 3) Load KAD entities (25-35%)
		updateLoadingProgress(loadingDialog, "Loading KAD entities...", 30);
		await loadKADFromDB();
		var kadCount = allKADDrawingsMap ? allKADDrawingsMap.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + kadCount + " KAD entities", 35);

		// Step 3a) Load layers (35-40%)
		updateLoadingProgress(loadingDialog, "Loading layers...", 37);
		await loadLayersFromDB();
		var drawingLayerCount = allDrawingLayers ? allDrawingLayers.size : 0;
		var surfaceLayerCount = allSurfaceLayers ? allSurfaceLayers.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + drawingLayerCount + " drawing layers, " + surfaceLayerCount + " surface layers", 38);

		// Step 3b) Run migration for entities without layerId
		updateLoadingProgress(loadingDialog, "Migrating entities...", 39);
		migrateEntitiesWithoutLayerId();
		updateLoadingProgress(loadingDialog, "Migration complete", 40);

		// Step 4) Load surfaces (40-70%)
		updateLoadingProgress(loadingDialog, "Loading surfaces...", 45);
		await loadAllSurfacesIntoMemory();
		var surfaceCount = loadedSurfaces ? loadedSurfaces.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + surfaceCount + " surface(s)", 70);

		// Step 5) Load images (70-90%)
		updateLoadingProgress(loadingDialog, "Loading images...", 75);
		await loadAllImagesIntoMemory();
		var imageCount = loadedImages ? loadedImages.size : 0;
		updateLoadingProgress(loadingDialog, "Loaded " + imageCount + " image(s)", 90);

		// Step 6) Complete
		updateLoadingProgress(loadingDialog, "Complete! All data loaded successfully", 100);
		console.log("üìä Data load complete: " + holeCount + " holes, " + kadCount + " KADs, " + surfaceCount + " surfaces, " + imageCount + " images");

		// Step 6a) Flag that 3D geometry needs rebuild after data load
		window.threeDataNeedsRebuild = true;

		// Step 7) Close dialog after brief delay
		setTimeout(function () {
			if (loadingDialog) {
				loadingDialog.close();
			}
		}, 800);
	} catch (error) {
		console.error("‚ùå Error loading data:", error);
		if (loadingDialog) {
			updateLoadingProgress(loadingDialog, "Error: " + error.message, 100, true);
			setTimeout(function () {
				if (loadingDialog) {
					loadingDialog.close();
				}
			}, 3000);
		}
	}
}

// Step 1) Show loading progress dialog for IndexedDB data reload
function showLoadingProgressDialog() {
	// Step 1) Create progress dialog content
	const progressContent = document.createElement("div");
	progressContent.style.textAlign = "center";
	progressContent.innerHTML = '<p>Loading saved data from IndexedDB</p><p>Please wait...</p><div style="width: 100%; background-color: #333; border-radius: 5px; margin: 20px 0;"><div id="loadingProgressBar" style="width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; transition: width 0.3s;"></div></div><p id="loadingProgressText">Initializing...</p>';

	var dialog = new FloatingDialog({
		title: "Reloading Data",
		content: progressContent,
		layoutType: "standard",
		width: 350,
		height: 250,
		showConfirm: false,
		showCancel: true,
		showDeny: false,
		draggable: false,
		resizable: false,
		closeOnOutsideClick: false,
		onCancel: function () {
			// Step 2) Handle Cancel button - abort loading
			console.log("‚úÖ User cancelled data loading");
			dialog.close();
		},
	});

	dialog.show();
	return dialog;
}

// Step 5) Update loading progress dialog
function updateLoadingProgress(dialog, message, percent, isError) {
	if (!dialog || !dialog.element) return;

	var progressText = dialog.element.querySelector("#loadingProgressText");
	var progressBar = dialog.element.querySelector("#loadingProgressBar");

	if (progressText) {
		if (isError) {
			progressText.innerHTML = '<span style="color: #f44336;">? ' + message + "</span>";
		} else {
			progressText.textContent = message;
		}
	}

	if (progressBar) {
		progressBar.style.width = percent + "%";
		if (isError) {
			progressBar.style.backgroundColor = "#f44336";
		}
	}
}

async function loadAllSurfacesIntoMemory() {
	try {
		if (!db) {
			console.error("‚ùå Database not initialized - cannot load surfaces");
			return;
		}

		console.log("üîÑ Loading surfaces from IndexedDB...");
		var transaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		var store = transaction.objectStore(SURFACE_STORE_NAME);
		var request = store.getAll();

		return new Promise(function (resolve) {
			request.onsuccess = function () {
				var surfaces = request.result || [];
				console.log("üìä IndexedDB returned " + surfaces.length + " surface(s)");
				var texturedSurfaceIds = [];

				surfaces.forEach(function (surfaceData, index) {
					console.log("üîç Processing surface " + (index + 1) + ": " + surfaceData.id + ", isTexturedMesh: " + surfaceData.isTexturedMesh);
					// Step 1) Create base surface entry
					var surfaceEntry = {
						id: surfaceData.id,
						name: surfaceData.name,
						points: surfaceData.points,
						triangles: surfaceData.triangles,
						visible: surfaceData.visible !== false,
						// Step 1a) CRITICAL: For textured meshes, ALWAYS use "texture" gradient (ignore saved gradient)
						// Textured meshes MUST show JPG textures, not color gradients like "cividis"
						gradient: surfaceData.isTexturedMesh ? "texture" : surfaceData.gradient || "default",
						transparency: surfaceData.transparency || 1.0,
						hillshadeColor: surfaceData.hillshadeColor || null, // Step 1b) Load hillshade color from DB
						layerId: surfaceData.layerId || null, // Step 28) Restore layerId from DB
					};

					// Step 2) Check if this is a textured mesh
					if (surfaceData.isTexturedMesh) {
						console.log("‚úÖ Found textured mesh: " + surfaceData.id);
						surfaceEntry.isTexturedMesh = true;
						surfaceEntry.objContent = surfaceData.objContent || null;
						surfaceEntry.mtlContent = surfaceData.mtlContent || null;
						surfaceEntry.textureBlobs = surfaceData.textureBlobs || null;
						surfaceEntry.meshBounds = surfaceData.meshBounds || null;
						surfaceEntry.materialProperties = surfaceData.materialProperties || null;
						surfaceEntry.threeJSMesh = null; // Will be rebuilt

						if (surfaceEntry.materialProperties) {
							console.log("üßä Loaded material properties for surface: " + surfaceData.id);
						} else {
							console.warn("üö® No material properties found for textured mesh: " + surfaceData.id);
						}

						if (surfaceEntry.textureBlobs) {
							console.log("üßä Loaded texture blobs for surface: " + surfaceData.id + ", count: " + Object.keys(surfaceEntry.textureBlobs).length);
						} else {
							console.warn("üö® No texture blobs found for textured mesh: " + surfaceData.id);
						}

						// Step 2a) Load flattened image from saved data if available
						if (surfaceData.flattenedImageDataURL) {
							surfaceEntry.flattenedImageDataURL = surfaceData.flattenedImageDataURL;
							surfaceEntry.flattenedImageBounds = surfaceData.flattenedImageBounds;
							surfaceEntry.flattenedImageDimensions = surfaceData.flattenedImageDimensions;
							console.log("üßä Loaded flattened image data from DB for: " + surfaceData.id);
						}

						// Track for later rebuilding
						texturedSurfaceIds.push(surfaceData.id);
						console.log("üìù Added to rebuild list: " + surfaceData.id + ", total textured surfaces: " + texturedSurfaceIds.length);
					}

					loadedSurfaces.set(surfaceData.id, surfaceEntry);
				});

				console.log("üìä Loaded " + loadedSurfaces.size + " surfaces into memory");

				// Step 2a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
				var fullCentroid = calculateDataCentroid();
				emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

				// Step 3) Rebuild Three.js meshes for textured surfaces (staggered to avoid blocking)
				if (texturedSurfaceIds.length > 0) {
					console.log("üß± Rebuilding " + texturedSurfaceIds.length + " textured meshes...");

					texturedSurfaceIds.forEach(function (surfaceId, index) {
						setTimeout(function () {
							rebuildTexturedMesh(surfaceId);
						}, index * 50); // Stagger by 50ms to avoid blocking UI
					});
				}

				resolve();
			};
			request.onerror = function () {
				console.error("‚ùå Failed to load surfaces from IndexedDB");
				resolve();
			};
		});
	} catch (error) {
		console.error("Error loading surfaces:", error);
	}
}

function exportSurfaceToDXF(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (!surface) {
		showModalMessage("Export Failed", "Surface not found", "error");
		return;
	}

	try {
		console.log("Exporting surface " + surface.name + " to DXF");

		// Create DXF content with header
		let dxfContent = "";
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "HEADER\n";
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// Start ENTITIES section
		dxfContent += "0\n";
		dxfContent += "SECTION\n";
		dxfContent += "2\n";
		dxfContent += "ENTITIES\n";

		// Export triangles as 3DFACE entities
		if (surface.triangles && surface.triangles.length > 0) {
			surface.triangles.forEach((triangle) => {
				if (triangle.length >= 3) {
					const p1 = triangle[0];
					const p2 = triangle[1];
					const p3 = triangle[2];

					dxfContent += "0\n";
					dxfContent += "3DFACE\n";
					dxfContent += "8\n";
					dxfContent += "SURFACE_" + surface.name + "\n";

					// First corner
					dxfContent += "10\n";
					dxfContent += p1[0] + "\n";
					dxfContent += "20\n";
					dxfContent += p1[1] + "\n";
					dxfContent += "30\n";
					dxfContent += p1[2] + "\n";

					// Second corner
					dxfContent += "11\n";
					dxfContent += p2[0] + "\n";
					dxfContent += "21\n";
					dxfContent += p2[1] + "\n";
					dxfContent += "31\n";
					dxfContent += p2[2] + "\n";

					// Third corner
					dxfContent += "12\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "22\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "32\n";
					dxfContent += p3[2] + "\n";

					// Fourth corner (same as third for triangle)
					dxfContent += "13\n";
					dxfContent += p3[0] + "\n";
					dxfContent += "23\n";
					dxfContent += p3[1] + "\n";
					dxfContent += "33\n";
					dxfContent += p3[2] + "\n";
				}
			});
		}

		// End ENTITIES section
		dxfContent += "0\n";
		dxfContent += "ENDSEC\n";

		// End of file
		dxfContent += "0\n";
		dxfContent += "EOF\n";

		// Create and download the file
		const blob = new Blob([dxfContent], {
			type: "application/dxf",
		});
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = surface.name + "_surface.dxf";
		document.body.appendChild(a);
		a.click();
		document.body.removeChild(a);
		URL.revokeObjectURL(url);

		showModalMessage("Export Successful", "Surface " + surface.name + " exported as DXF with " + surface.triangles.length + " 3D faces", "success");
	} catch (error) {
		console.error("Error exporting surface to DXF:", error);
		showModalMessage("Export Failed", "Error exporting surface: " + error.message, "error");
	}
}

// Surface visibility management
function setSurfaceVisibility(surfaceId, visible) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = visible;
		console.log("üëÅÔ∏è Surface " + surface.name + " visibility: " + visible);
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleSurfaceVisibility(surfaceId) {
	const surface = loadedSurfaces.get(surfaceId);
	if (surface) {
		surface.visible = !surface.visible;
		setSurfaceVisibility(surfaceId, surface.visible);
	}
}

// Step 28a) Check if a surface is closed (watertight)
// A closed surface has all triangle edges shared by exactly 2 triangles
function isSurfaceClosed(surface) {
	if (!surface || !surface.triangles || surface.triangles.length === 0) {
		return false;
	}

	// Build edge count map
	// Edge key is created by sorting vertex indices to handle both directions
	var edgeCount = new Map();

	function makeEdgeKey(v1, v2) {
		// Create consistent edge key regardless of direction
		var idx1 = v1.x !== undefined ? (v1.x + "," + v1.y + "," + v1.z) : v1.toString();
		var idx2 = v2.x !== undefined ? (v2.x + "," + v2.y + "," + v2.z) : v2.toString();
		return idx1 < idx2 ? idx1 + "|" + idx2 : idx2 + "|" + idx1;
	}

	// Count edges from triangles
	for (var i = 0; i < surface.triangles.length; i++) {
		var tri = surface.triangles[i];
		var verts = tri.vertices || [
			surface.points[tri.a],
			surface.points[tri.b],
			surface.points[tri.c]
		];

		if (!verts || verts.length < 3) continue;

		// Three edges per triangle
		var edges = [
			makeEdgeKey(verts[0], verts[1]),
			makeEdgeKey(verts[1], verts[2]),
			makeEdgeKey(verts[2], verts[0])
		];

		edges.forEach(function (edge) {
			edgeCount.set(edge, (edgeCount.get(edge) || 0) + 1);
		});
	}

	// Check if all edges appear exactly 2 times (shared by 2 triangles)
	for (var entry of edgeCount.entries()) {
		if (entry[1] !== 2) {
			return false; // Found an edge that's not shared by exactly 2 triangles
		}
	}

	return true;
}

// Expose to window for TreeView access
window.isSurfaceClosed = isSurfaceClosed;

// ? Function to remove hidden entities from current selections
function clearHiddenFromSelections() {
	// Clear hidden holes from single selection
	if (selectedHole && !isHoleVisible(selectedHole)) {
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
	}

	// Clear hidden holes from multiple selection
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles = selectedMultipleHoles.filter((hole) => isHoleVisible(hole));
		if (selectedMultipleHoles.length === 0) {
			selectedMultipleHoles = [];
		}
	}

	// Clear hidden KAD objects from selection
	if (selectedKADObject && !isEntityVisible(selectedKADObject.entityName)) {
		selectedKADObject = null;
	}

	// Clear hidden polygons from selection
	if (selectedKADPolygon && !isEntityVisible(selectedKADPolygon.entityName)) {
		selectedKADPolygon = null;
	}

	// Clear from fromHoleStore if hidden
	if (fromHoleStore && !isHoleVisible(fromHoleStore)) {
		fromHoleStore = null;
	}

	// Clear move tool selections
	if (moveToolSelectedHole && moveToolSelectedHole.length > 0) {
		moveToolSelectedHole = moveToolSelectedHole.filter((hole) => isHoleVisible(hole));
		if (moveToolSelectedHole.length === 0) {
			moveToolSelectedHole = null;
			isDraggingHole = false;
		}
	}
}

// ? Helper function to check if an entity/element is visible
function isEntityVisible(entityName, elementId = null) {
	// Check overall group visibility first
	if (!drawingsGroupVisible) return false;

	const entity = allKADDrawingsMap.get(entityName);
	if (!entity) return false;

	// Check entity-level visibility
	if (entity.visible === false) return false;

	// Check sub-group visibility based on entity type
	switch (entity.entityType) {
		case "point":
			if (!pointsGroupVisible) return false;
			break;
		case "line":
			if (!linesGroupVisible) return false;
			break;
		case "poly":
			if (!polygonsGroupVisible) return false;
			break;
		case "circle":
			if (!circlesGroupVisible) return false;
			break;
		case "text":
			if (!textsGroupVisible) return false;
			break;
	}

	// Check element-level visibility if specified
	if (elementId !== null && entity.data) {
		const element = entity.data.find((el) => el.pointID == elementId);
		if (element && element.visible === false) return false;
	}

	return true;
}

// ? Helper function to check if a hole is visible
function isHoleVisible(hole) {
	if (!blastGroupVisible) return false;
	if (hole.visible === false) return false;
	return true;
}

//=== KAD Drawing Visibility Management ===
function setKADEntityVisibility(entityName, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = visible;
		console.log("üëÅÔ∏è KAD Entity " + entityName + " visibility: " + visible);

		// ? Clear hidden entities from selections
		clearHiddenFromSelections();
		// TODO FIX THE REMOVAL OF ENTITIES FROM SELECTIONS
		//! Its not working you can still delete invisible entities. Which is undesirable.
		updateTreeViewVisibilityStates();

		drawData(allBlastHoles, selectedHole);

		// Step 1) Save visibility change to IndexedDB
		if (typeof debouncedSaveKAD === "function") {
			debouncedSaveKAD();
		}
	}
}

function setKADElementVisibility(entityName, pointID, visible) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity && entity.data) {
		const element = entity.data.find((el) => el.pointID == pointID);
		if (element) {
			element.visible = visible;
			console.log("üëÅÔ∏è KAD Element " + entityName + ":" + pointID + " visibility: " + visible);

			// ? Clear hidden entities from selections
			clearHiddenFromSelections();
			drawData(allBlastHoles, selectedHole);
			updateTreeViewVisibilityStates();

			// Step 2) Save visibility change to IndexedDB
			if (typeof debouncedSaveKAD === "function") {
				debouncedSaveKAD();
			}
		}
	}
}

function toggleKADEntityVisibility(entityName) {
	const entity = allKADDrawingsMap.get(entityName);
	if (entity) {
		entity.visible = !entity.visible;
		setKADEntityVisibility(entityName, entity.visible);
	}
}

//=== Blast Hole Visibility Management ===
function setHoleVisibility(holeID, visible) {
	const hole = allBlastHoles.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = visible;
		console.log("üëÅÔ∏è Hole " + holeID + " visibility: " + visible);

		// ? Clear hidden entities from selections
		clearHiddenFromSelections();
		window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
		drawData(allBlastHoles, selectedHole);

		// Step 3) Save visibility change to IndexedDB
		if (typeof debouncedSaveHoles === "function") {
			debouncedSaveHoles();
		}
	}
}

function setEntityVisibility(entityName, visible) {
	const entityHoles = allBlastHoles.filter((h) => h.entityName === entityName);
	entityHoles.forEach((hole) => {
		hole.visible = visible;
	});
	console.log("üëÅÔ∏è Entity " + entityName + " visibility: " + visible + " (affecting " + entityHoles.length + " holes)");

	// ? Clear hidden entities from selections
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);

	// Step 5) Save entity visibility changes to IndexedDB
	if (typeof debouncedSaveHoles === "function") {
		debouncedSaveHoles();
	}
}

function toggleHoleVisibility(holeID) {
	const hole = allBlastHoles.find((h) => h.holeID === holeID);
	if (hole) {
		hole.visible = !hole.visible;
		setHoleVisibility(holeID, hole.visible);
	}
}
//=== Group Visibility Management ===
// ? ADD: Update all group visibility functions to call updateTreeViewVisibilityStates()
function setBlastGroupVisibility(visible) {
	blastGroupVisible = visible;
	console.log("üëÅÔ∏è Blast Group visibility: " + visible);
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setDrawingsGroupVisibility(visible) {
	drawingsGroupVisible = visible;
	console.log("üëÅÔ∏è Drawings Group visibility: " + visible);
	clearHiddenFromSelections();
	window.threeDataNeedsRebuild = true; // Force 3D geometry rebuild on visibility change
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setSurfacesGroupVisibility(visible) {
	surfacesGroupVisible = visible;
	console.log("üëÅÔ∏è Surfaces Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setImagesGroupVisibility(visible) {
	imagesGroupVisible = visible;
	console.log("üëÅÔ∏è Images Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setPointsGroupVisibility(visible) {
	pointsGroupVisible = visible;
	console.log("üëÅÔ∏è Points Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setLinesGroupVisibility(visible) {
	linesGroupVisible = visible;
	console.log("üëÅÔ∏è Lines Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setPolygonsGroupVisibility(visible) {
	polygonsGroupVisible = visible;
	console.log("üëÅÔ∏è Polygons Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setCirclesGroupVisibility(visible) {
	circlesGroupVisible = visible;
	console.log("üëÅÔ∏è Circles Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

function setTextsGroupVisibility(visible) {
	textsGroupVisible = visible;
	console.log("üëÅÔ∏è Texts Group visibility: " + visible);
	clearHiddenFromSelections();
	drawData(allBlastHoles, selectedHole);
	updateTreeViewVisibilityStates(); // ? ADD: Update tree visual states
}

// Delete surface from IndexedDB
async function deleteSurfaceFromDB(surfaceId) {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete surface - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.delete(surfaceId);

			request.onsuccess = () => {
				console.log("‚úÖ Surface " + surfaceId + " deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete surface " + surfaceId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("? Transaction failed for deleting surface " + surfaceId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting surface:", error);
		throw error;
	}
}

// Delete all surfaces from IndexedDB
async function deleteAllSurfacesFromDB() {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete surfaces - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([SURFACE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(SURFACE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				console.log("‚úÖ All surfaces deleted from IndexedDB");
				debouncedUpdateTreeView();
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete all surfaces:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all surfaces:", error);
		throw error;
	}
}

// REPLACE this function to accept imageId parameter:
async function saveImageToDB(imageId) {
	try {
		const image = loadedImages.get(imageId);
		if (!db || !image || !image.canvas) {
			throw new Error("Missing database or image data");
		}

		// Create blob from canvas
		const blob = await new Promise((resolve, reject) => {
			image.canvas.toBlob((result) => {
				if (result) resolve(result);
				else reject(new Error("Failed to create blob"));
			});
		});

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);

			const imageRecord = {
				id: imageId,
				name: image.name,
				type: image.type || "imagery",
				bbox: image.bbox,
				blob: blob,
				visible: image.visible,
				transparency: image.transparency,
				zElevation: image.zElevation !== undefined ? image.zElevation : window.drawingZLevel || 0,
				savedAt: new Date().toISOString(),
			};

			const request = store.put(imageRecord);
			request.onsuccess = () => {
				debouncedUpdateTreeView();
				resolve(imageRecord);
			};
			request.onerror = () => reject(request.error);
			transaction.onerror = () => reject(transaction.error);
		});
	} catch (error) {
		console.error("Error saving image:", error);
		throw error;
	}
}

// Load image from IndexedDB

// Load a specific image into the multi-image system
async function loadImageIntoMemory(imageId) {
	try {
		if (!db) return null;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.get(imageId);

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const imageData = request.result;
				if (imageData) {
					// Convert blob back to canvas
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					img.onload = () => {
						canvas.width = img.width;
						canvas.height = img.height;
						ctx.drawImage(img, 0, 0);

						loadedImages.set(imageId, {
							id: imageId,
							name: imageData.name,
							canvas: canvas,
							bbox: imageData.bbox,
							type: imageData.type,
							visible: imageData.visible !== false,
							transparency: imageData.transparency || 1.0,
							zElevation: imageData.zElevation !== undefined ? imageData.zElevation : window.drawingZLevel || 0,
						});

						console.log("‚úÖ Image " + imageData.name + " loaded into memory");
						resolve(imageData);
					};

					img.src = URL.createObjectURL(imageData.blob);
				} else {
					resolve(null);
				}
			};
			request.onerror = () => resolve(null);
		});
	} catch (error) {
		console.error("Error loading image into memory:", error);
		return null;
	}
}

// Replace your current loadAllImagesIntoMemory function with this:
async function loadAllImagesIntoMemory() {
	try {
		if (!db) return;

		const transaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const store = transaction.objectStore(IMAGE_STORE_NAME);
		const request = store.getAll();

		return new Promise((resolve) => {
			request.onsuccess = async () => {
				const images = request.result || [];

				// Load each image into memory
				for (const imageData of images) {
					const img = new Image();
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");

					await new Promise((imgResolve) => {
						img.onload = () => {
							canvas.width = img.width;
							canvas.height = img.height;
							ctx.drawImage(img, 0, 0);

							loadedImages.set(imageData.id, {
								id: imageData.id,
								name: imageData.name,
								canvas: canvas,
								bbox: imageData.bbox,
								type: imageData.type,
								visible: imageData.visible !== false,
								transparency: imageData.transparency || 1.0,
								zElevation: imageData.zElevation !== undefined ? imageData.zElevation : window.drawingZLevel || 0,
							});

							imgResolve();
						};
						img.onerror = () => imgResolve(); // Continue even if image fails
						img.src = URL.createObjectURL(imageData.blob);
					});
				}

				console.log("üñºÔ∏è Loaded " + loadedImages.size + " images into memory");
				resolve();
			};
			request.onerror = () => {
				console.error("Failed to load images from database");
				resolve();
			};
		});
	} catch (error) {
		console.error("Error loading images into memory:", error);
	}
}
// Image visibility management
function setImageVisibility(imageId, visible) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = visible;
		if (developerModeEnabled) {
			console.log("üëÅÔ∏è Image " + image.name + " visibility: " + visible);
		}
		drawData(allBlastHoles, selectedHole);
	}
}

function toggleImageVisibility(imageId) {
	const image = loadedImages.get(imageId);
	if (image) {
		image.visible = !image.visible;
		setImageVisibility(imageId, image.visible);
	}
}

// Delete image from IndexedDB
async function deleteImageFromDB(imageId) {
	try {
		if (!db) {
			console.log("‚ùå Cannot delete image - database not available");
			return;
		}

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.delete(imageId);

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log(`‚úÖ Image "${imageId}" deleted from IndexedDB`);
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete image " + imageId + ": ," + request.error);
				reject(request.error);
			};

			transaction.onerror = () => {
				console.error("? Transaction failed for deleting image " + imageId + ": ," + transaction.error);
				reject(transaction.error);
			};
		});
	} catch (error) {
		console.error("Error deleting image:", error);
		throw error;
	}
}
// Delete all images from IndexedDB (useful for cleanup)
async function deleteAllImagesFromDB() {
	try {
		if (!db) return;

		return new Promise((resolve, reject) => {
			const transaction = db.transaction([IMAGE_STORE_NAME], "readwrite");
			const store = transaction.objectStore(IMAGE_STORE_NAME);
			const request = store.clear();

			request.onsuccess = () => {
				debouncedUpdateTreeView();
				console.log("‚úÖ All images deleted from IndexedDB");
				resolve();
			};

			request.onerror = () => {
				console.error("? Failed to delete all images:", request.error);
				reject(request.error);
			};
		});
	} catch (error) {
		console.error("Error deleting all images:", error);
		throw error;
	}
}

// Call in console if needed: deleteAllImagesFromDB()

// Debug function - add temporarily to check what's in the database
async function debugDatabaseContents() {
	try {
		if (!db) {
			console.log("Database not initialized");
			return;
		}

		// Check surfaces
		const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
		const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
		const surfaceRequest = surfaceStore.getAll();

		surfaceRequest.onsuccess = () => {
			console.log("üîç Surfaces in database:", surfaceRequest.result.length);
			surfaceRequest.result.forEach((surface) => {
				console.log("  - Surface:", surface.name, "Points:", surface.points?.length, "Triangles:", surface.triangles?.length);
			});
		};

		// Check images
		const imageTransaction = db.transaction([IMAGE_STORE_NAME], "readonly");
		const imageStore = imageTransaction.objectStore(IMAGE_STORE_NAME);
		const imageRequest = imageStore.getAll();

		imageRequest.onsuccess = () => {
			console.log("üîç Images in database:", imageRequest.result.length);
			imageRequest.result.forEach((image) => {
				console.log("  - Image:", image.name, "Type:", image.type, "Bbox:", image.bbox);
			});
		};
	} catch (error) {
		console.error("Error checking database contents:", error);
	}
}

function checkAndPromptForStoredData() {
	// Step 1) Fallback check for localStorage (for backward compatibility)
	const allBlastHolesDataLocalStorage = localStorage.getItem("kirraDataPoints");

	if (!db) {
		// Fallback for when DB fails to initialize
		if (allBlastHolesDataLocalStorage) showPopup(false);
		return;
	}

	// Step 2) Check for holes in IndexedDB
	const holesTransaction = db.transaction([BLASTHOLES_STORE_NAME], "readonly");
	const holesStore = holesTransaction.objectStore(BLASTHOLES_STORE_NAME);
	const holesRequest = holesStore.get("blastHolesData");

	holesRequest.onsuccess = (holesEvent) => {
		const holesData = holesEvent.target.result;
		const hasHolesInDB = holesData && holesData.data && Array.isArray(holesData.data) && holesData.data.length > 0;

		// Step 3) Check for KAD drawings
		const kadTransaction = db.transaction([STORE_NAME], "readonly");
		const kadStore = kadTransaction.objectStore(STORE_NAME);
		const kadRequest = kadStore.get("kadDrawingData");

		kadRequest.onsuccess = (event) => {
			const kadData = event.target.result;

			// Step 4) Check for surfaces
			const surfaceTransaction = db.transaction([SURFACE_STORE_NAME], "readonly");
			const surfaceStore = surfaceTransaction.objectStore(SURFACE_STORE_NAME);
			const surfaceRequest = surfaceStore.getAll();

			surfaceRequest.onsuccess = (surfaceEvent) => {
				const surfaceData = surfaceEvent.target.result || [];

				// Step 5) Check for images
				const imageTransaction = db.transaction([IMAGE_STORE_NAME], "readonly");
				const imageStore = imageTransaction.objectStore(IMAGE_STORE_NAME);
				const imageRequest = imageStore.getAll();

				imageRequest.onsuccess = (imageEvent) => {
					const imageData = imageEvent.target.result || [];

					// Step 6) Show popup if ANY data exists: holes, KAD drawings, surfaces, OR images
					if (hasHolesInDB || allBlastHolesDataLocalStorage || (kadData && kadData.data && kadData.data.length > 0) || surfaceData.length > 0 || imageData.length > 0) {
						showPopup(true);
						debouncedUpdateTreeView();
					}
				};

				imageRequest.onerror = (event) => {
					console.error("Could not check for image data in IndexedDB.", event.target.error);
					// Still show popup if other data exists
					if (hasHolesInDB || allBlastHolesDataLocalStorage || (kadData && kadData.data && kadData.data.length > 0) || surfaceData.length > 0) {
						showPopup(true);
						debouncedUpdateTreeView();
					}
				};
			};
		};

		kadRequest.onerror = (event) => {
			console.error("Could not check for KAD data in IndexedDB.", event.target.error);
			// Still show popup if holes exist
			if (hasHolesInDB || allBlastHolesDataLocalStorage) {
				showPopup(true);
			}
		};
	};

	holesRequest.onerror = (event) => {
		console.error("Could not check for holes data in IndexedDB.", event.target.error);
		// Fallback to localStorage check
		if (allBlastHolesDataLocalStorage) {
			showPopup(false);
		}
	};
}
window.checkAndPromptForStoredData = checkAndPromptForStoredData; // Expose for dialog modules

async function showPopup(isDBReady) {
	console.log("showPopup called with isDBReady:", isDBReady);

	// Step 1) Determine text color based on dark mode
	const textColor = darkModeEnabled ? "#ffffff" : "#000000";

	// Step 2) Create the HTML content for the dialog with proper styling
	const dialogContent = '<div style="text-align: center; padding: 10px 0;">' + '<div class="labelWhite18" style="margin-bottom: 15px; color: ' + textColor + '; font-weight: 500;">' + "Do you want to pick up from where you left off?" + "</div>" + '<div class="labelWhite15" style="margin-bottom: 10px; color: ' + textColor + '; opacity: 0.9;">' + "Your previous work is still available." + "</div>" + "</div>";

	// Step 3) Create promise to handle async dialog response
	return new Promise((resolve) => {
		// Step 4) Create the FloatingDialog instance
		const dialog = new FloatingDialog({
			title: "Welcome back to Kirra!",
			content: dialogContent,
			width: 480,
			height: 220,
			showConfirm: true,
			showCancel: false,
			showDeny: true,
			confirmText: "Continue Previous",
			denyText: "Start Fresh",
			draggable: true,
			resizable: false,
			closeOnOutsideClick: false, // Modal behavior - must click a button
			layoutType: "default",
			onConfirm: async () => {
				// Step 5) User chose to continue previous work
				console.log("User chose to continue previous work");

				// Step 5a) Load all data with progress dialog
				if (isDBReady) {
					try {
						await loadAllDataWithProgress();
					} catch (err) {
						console.error("Failed to load data from DB.", err);
					}
				} else {
					// Fallback to localStorage if DB not ready (shouldn't happen, but safety)
					allBlastHoles = loadHolesFromLocalStorage();
				}

				zoomToFitAll();
				debouncedUpdateTreeView();
				dialog.close();
				resolve("confirmed");
			},
			onDeny: async () => {
				// Step 6) User chose to start fresh
				console.log("User chose to start fresh");
				await clearLoadedData();
				debouncedUpdateTreeView();
				zoomToFitAll();
				dialog.close();
				resolve("denied");
			},
		});

		// Step 7) Override the create method to customize the dialog
		const originalCreate = dialog.create.bind(dialog);
		dialog.create = function () {
			originalCreate();

			// Hide the X close button for modal behavior
			const closeBtn = this.element.querySelector(".floating-dialog-header button");
			if (closeBtn) {
				closeBtn.style.display = "none";
			}

			// Step 8) Style the header
			const header = this.element.querySelector(".floating-dialog-header");
			if (header) {
				header.style.borderBottom = "2px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");
			}

			// Step 9) Add custom styling to buttons
			const footer = this.element.querySelector(".floating-dialog-footer");
			if (footer) {
				// Increase spacing between buttons
				footer.style.gap = "40px";
				footer.style.padding = "12px 20px";
				footer.style.borderTop = "1px solid " + (darkModeEnabled ? "#444" : "#e0e0e0");

				const denyBtn = footer.querySelector(".floating-dialog-btn.deny");
				const confirmBtn = footer.querySelector(".floating-dialog-btn.confirm");

				if (denyBtn && confirmBtn) {
					// Step 10) Style the "Start Fresh" button (orange)
					denyBtn.style.backgroundColor = "#ff9d00";
					denyBtn.style.setProperty("color", "#000000", "important");
					denyBtn.style.borderColor = "#ff9d00";
					denyBtn.style.minWidth = "120px";
					denyBtn.style.padding = "8px 16px";
					denyBtn.style.fontSize = "12px";
					denyBtn.style.fontWeight = "500";
					denyBtn.style.borderRadius = "4px";
					denyBtn.style.transition = "all 0.2s ease";
					// denyBtn.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";

					// Hover effect for Start Fresh button
					denyBtn.onmouseover = function () {
						this.style.backgroundColor = "#e77a00";
						// this.style.boxShadow = "0 3px 6px rgba(255, 157, 0, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					denyBtn.onmouseout = function () {
						this.style.backgroundColor = "#ff9d00";
						// this.style.boxShadow = "0 2px 4px rgba(255, 157, 0, 0.2)";
						// this.style.transform = "translateY(0)";
					};

					// Step 11) Style the "Continue Previous Work" button (green)
					confirmBtn.style.backgroundColor = "#00771c";
					confirmBtn.style.setProperty("color", "#ffffff", "important");
					confirmBtn.style.borderColor = "#00a91c";
					confirmBtn.style.minWidth = "160px";
					confirmBtn.style.padding = "8px 16px";
					confirmBtn.style.fontSize = "12px";
					confirmBtn.style.fontWeight = "500";
					confirmBtn.style.borderRadius = "4px";
					confirmBtn.style.transition = "all 0.2s ease";
					// confirmBtn.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";

					// Hover effect for Continue button
					confirmBtn.onmouseover = function () {
						this.style.backgroundColor = "#008f17";
						// this.style.boxShadow = "0 3px 6px rgba(0, 169, 28, 0.3)";
						// this.style.transform = "translateY(-1px)";
					};
					confirmBtn.onmouseout = function () {
						this.style.backgroundColor = "#00a91c";
						// this.style.boxShadow = "0 2px 4px rgba(0, 169, 28, 0.2)";
						// this.style.transform = "translateY(0)";
					};
				}
			}
		};

		// Step 12) Show the dialog
		dialog.show();
	});
}

// Listen for changes in the kirraDataPoints key
window.addEventListener("storage", function (event) {
	if (event.key === "kirraDataPoints") {
		console.log("kirraDataPoints changed");
	} else {
		console.log("kirraDataPoints not changed");
	}
});

// Replace the entire updateCentroids function with this simplified version:
function updateCentroids() {
	// Calculate centroid of allBlastholes
	let sumX = 0;
	let sumY = 0;
	let records = 0;

	// Include hole points
	if (allBlastHoles !== null) {
		for (let i = 0; i < allBlastHoles.length; i++) {
			sumX += allBlastHoles[i].startXLocation;
			sumY += allBlastHoles[i].startYLocation;
			records++;
		}
	}

	// Include all KAD objects (everything is now in allKADDrawingsMap)
	if (allKADDrawingsMap.size > 0) {
		for (const entity of allKADDrawingsMap.values()) {
			for (const dataPoint of entity.data) {
				sumX += dataPoint.pointXLocation;
				sumY += dataPoint.pointYLocation;
				records++;
			}
		}
	}

	// Include surface points in centroid calculation
	if (loadedSurfaces.size > 0) {
		loadedSurfaces.forEach((surface) => {
			if (surface.points && surface.points.length > 0) {
				// Standard surface with points array
				for (const point of surface.points) {
					sumX += point.x;
					sumY += point.y;
					records++;
				}
			} else if (surface.isTexturedMesh && surface.meshBounds) {
				// Textured mesh (OBJ) - use mesh center
				sumX += (surface.meshBounds.minX + surface.meshBounds.maxX) / 2;
				sumY += (surface.meshBounds.minY + surface.meshBounds.maxY) / 2;
				records++;
			}
		});
	}

	if (records > 0) {
		centroidX = sumX / records;
		centroidY = sumY / records;
	}

	// Step 5) Calculate full centroid including Z and update dataCentroidZ
	var fullCentroid = calculateDataCentroid();

	// Step 5a) CRITICAL FIX: Also update dataCentroidZ when centroids are recalculated
	// This ensures dataCentroidZ is immediately available after imports without waiting for render loop
	dataCentroidZ = fullCentroid.z;
	window.dataCentroidZ = dataCentroidZ;

	// Step 5b) Mark centroid as already calculated to prevent redundant calculation in render loop
	centroidNeedsRecalculation = false;
	window.centroidNeedsRecalculation = false;

	// Step 5c) CRITICAL FIX: Update threeRenderer orbit center when centroids change
	// Without this, the 3D cursor (torus) disappears when orbiting because the view plane
	// is positioned at the old orbitCenterZ (often 0) instead of the actual data Z elevation
	if (threeRenderer && typeof threeRenderer.setOrbitCenter === "function") {
		threeRenderer.setOrbitCenter(fullCentroid.x, fullCentroid.y, fullCentroid.z);
		if (developerModeEnabled) {
			console.log("üéØ Orbit center updated in updateCentroids(): X=" + fullCentroid.x.toFixed(2) + " Y=" + fullCentroid.y.toFixed(2) + " Z=" + fullCentroid.z.toFixed(2));
		}
	}

	// Step 5d) CRITICAL FIX: Update local origin for coordinate conversion (ONE TIME on import)
	// Only update if origin is still at 0,0 - this runs once when first data is imported
	// LAS imports and other surface-only imports need this to work correctly
	if (threeLocalOriginX === 0 && threeLocalOriginY === 0) {
		updateThreeLocalOrigin();
		// Step 5e) Sync ONLY the critical origin values to window for InteractionManager
		// Avoids full exposeGlobalsToWindow() overhead - only syncs what's needed for cursor
		window.threeLocalOriginX = threeLocalOriginX;
		window.threeLocalOriginY = threeLocalOriginY;
		if (developerModeEnabled) {
			console.log("üìç Local origin synced to window: X=" + threeLocalOriginX.toFixed(2) + " Y=" + threeLocalOriginY.toFixed(2));
		}
	}

	// Step 5f) Emit centroid to HUD overlay
	emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);
}

const darkModeToggle = document.getElementById("dark-mode-toggle");
const body = document.body;
const sidenavLeft = document.getElementById("sidenavLeft");
const sidenavRight = document.getElementById("sidenavRight");
// Check if dark mode preference exists in local storage
const darkModePref = localStorage.getItem("darkMode");
if (darkModePref === "true") {
	body.classList.add("dark-mode");
	sidenavLeft.classList.add("dark-mode");
	sidenavRight.classList.add("dark-mode");
	canvas.classList.add("dark-canvas");
	darkModeToggle.checked = true;
}

darkModeToggle.addEventListener("change", () => {
	if (darkModeToggle.checked) {
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		sidenavRight.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
		localStorage.setItem("darkMode", "true");
	} else {
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		sidenavRight.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
		localStorage.setItem("darkMode", "false");
	}
	darkModeEnabled = document.body.classList.contains("dark-mode");
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "darkgrey" : "lightgrey";
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "cyan" : "blue";
	angleDipColor = darkModeEnabled ? "orange" : "darkorange";

	// Step 1) Update Three.js background color
	if (threeInitialized && threeRenderer) {
		threeRenderer.setBackgroundColor(darkModeEnabled);
	}

	// Step 1a) Update base canvas background color
	if (window.baseCanvas && window.baseCtx) {
		window.baseCtx.fillStyle = darkModeEnabled ? "#000000" : "#FFFFFF";
		window.baseCtx.fillRect(0, 0, window.baseCanvas.width, window.baseCanvas.height);
	}

	// Step 1b) Trigger full 3D rebuild to update all colors (hole lines, connectors, etc.)
	if (threeInitialized && onlyShowThreeJS) {
		window.threeDataNeedsRebuild = true;
	}

	// Step 1c) Redraw to apply new colors
	drawData(allBlastHoles, selectedHole);

	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	drawData(allBlastHoles, selectedHole);
});

function endKadTools(forceEnd = false) {
	// Step 1) Check if any KAD drawing tool is active
	var anyKADToolActive = addPointDraw.checked || addLineDraw.checked || addCircleDraw.checked || addPolyDraw.checked || addTextDraw.checked;

	if (anyKADToolActive) {
		// Step 2) Decide: complete entity OR end tool
		if (!createNewEntity && !forceEnd) {
			// Step 2a) Actively drawing AND NOT forceEnd - complete entity, keep tool active
			createNewEntity = true;
			lastKADDrawPoint = null;
			entityName = null;
			clearCurrentDrawingEntity();
			currentDrawingEntityName = null;
			deleteKeyCount = 0;

			updateStatusMessage("Entity finished. Click to start new " + (isDrawingLine ? "line" : isDrawingPoly ? "polygon" : isDrawingCircle ? "circle" : isDrawingPoint ? "point" : "text"));
			setTimeout(function () { updateStatusMessage(""); }, 2000);
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => { drawData(allBlastHoles, selectedHole); }, 10);
			clearKADLeadingLineThreeJSV2();  // ADD THIS

		} else {
			// Step 2b) NOT actively drawing OR forceEnd - turn off tool entirely
			addPointDraw.checked = false;
			addLineDraw.checked = false;
			addCircleDraw.checked = false;
			addPolyDraw.checked = false;
			addTextDraw.checked = false;

			// ALSO uncheck the floating toolbar KAD buttons (the visual buttons)
			addKADPointsTool.checked = false;
			addKADLineTool.checked = false;
			addKADPolygonTool.checked = false;
			addKADCircleTool.checked = false;
			addKADTextTool.checked = false;

			createNewEntity = true;
			lastKADDrawPoint = null;
			entityName = null;
			currentDrawingEntityName = null;
			deleteKeyCount = 0;

			isDrawingPoint = false;
			isDrawingLine = false;
			isDrawingCircle = false;
			isDrawingPoly = false;
			isDrawingText = false;
			clearCurrentDrawingEntity();
			updateStatusMessage("Drawing tools cancelled");
			setTimeout(function () { updateStatusMessage(""); }, 1500);
			drawData(allBlastHoles, selectedHole);
			setTimeout(() => { drawData(allBlastHoles, selectedHole); }, 10);
			clearKADLeadingLineThreeJSV2();  // ADD THIS
		}
	}

	// Step 3) Also handle polygon selection escape
	if (isPolygonSelectionActive) {
		polyPointsX = [];
		polyPointsY = [];
		updateStatusMessage("Polygon selection cancelled");
		setTimeout(function () {
			updateStatusMessage("");
		}, 1500);
		drawData(allBlastHoles, selectedHole);
	}

	// Step 4) Hide pattern tool HUD labels when switching tools
	hidePatternToolLabels();
	// Step 5) Hide drawingDistance panel when KAD tools end
	hideDrawingDistance();
}

function findClosestKadPoint(worldPoint, snapDistance) {
	let closestPoint = null;
	let minDistance = snapDistance;

	for (const [name, entity] of allKADDrawingsMap.entries()) {
		if (entity.entityType === "line" || entity.entityType === "poly") {
			for (let i = 0; i < entity.data.length; i++) {
				const pt = entity.data[i];
				const dx = pt.pointXLocation - worldPoint.x;
				const dy = pt.pointYLocation - worldPoint.y;
				const dist = Math.sqrt(dx * dx + dy * dy);

				if (dist < minDistance) {
					minDistance = dist;
					closestPoint = {
						entityName: name,
						pointIndex: i,
						point: pt,
					};
				}
			}
		}
	}
	return closestPoint;
}

/// VERY SURE THIS DOES NOT GET CALLED.
function handleKADModificationClick(event) {
	// Get the mouse position in world coordinates
	const [worldX, worldY] = canvasToWorld(event.offsetX, event.offsetY);

	// Find the closest KAD entity using our new unified function
	selectedKADPoint = getClickedKADEntity(worldX, worldY);

	if (selectedKADPoint) {
		const entity = selectedKADPoint.entity;
		console.log("DEBUG: entity object:", entity);
		console.log("DEBUG: entity.entityName:", entity.entityName);
		console.log("DEBUG: entity.entityType:", entity.entityType);
		console.log("DEBUG: entity.data:", entity.data);

		console.log("SUCCESS: Modification target found:", entity.entityName);
		updateStatusMessage("Selected entity: " + entity.entityName + " (Right-click to edit)");

		// For lines, points, circles, text - set selectedKADObject (used by highlighting)
		selectedKADObject = {
			entityName: entity.entityName,
			entityType: entity.entityType,
			pointXLocation: selectedKADPoint.clickedX,
			pointYLocation: selectedKADPoint.clickedY,
			// Add other properties as needed by existing code
			...entity.data[0], // Copy properties from first point
		};
		console.log("DEBUG: selectedKADObject created:", selectedKADObject);
		//selectedKADPolygon = null; // Clear the other variable
	} else {
		console.log("No modifiable KAD entity found at click location.");
		updateStatusMessage("");
		// Clear both legacy variables
		selectedKADPolygon = null;
		selectedKADObject = null;
	}

	// Redraw to show highlighting
	drawData(allBlastHoles, selectedHole);
}
/// VERY SURE THIS ABOVE DOES NOT GET CALLED.

window.onload = function () {
	// --- Dark Mode Setup ---
	darkModeEnabled = localStorage.getItem("darkMode") === "true";
	if (darkModeEnabled) {
		darkModeToggle.checked = true;
		body.classList.add("dark-mode");
		sidenavLeft.classList.add("dark-mode");
		canvas.classList.add("dark-canvas");
	} else {
		darkModeToggle.checked = false;
		body.classList.remove("dark-mode");
		sidenavLeft.classList.remove("dark-mode");
		canvas.classList.remove("dark-canvas");
	}

	// --- HUD Overlay System Initialization ---
	// Step 1) Initialize the HUD overlay in the canvas container
	var canvasContainer = document.querySelector(".canvas-container");
	if (canvasContainer) {
		initHUD(canvasContainer);
		// Step 2) Set initial stats with version
		emitStats({ version: buildVersion });
		console.log("[Kirra] HUD overlay system initialized");
	} else {
		console.warn("[Kirra] Canvas container not found - HUD not initialized");
	}

	// ADD WELCOME MESAGES.
	const messages = ["Welcome to Kirra2D!", "Support the development.", "Buy Brent a coffee\nhttps://buymeacoffee.com/brentbuffham"];

	messages.forEach((msg, index) => {
		const delay = 1000 + index * 3000;

		setTimeout(() => {
			updateStatusMessage(msg);

			// ?? Clear the last message 4 seconds after it's shown
			if (index === messages.length - 1) {
				setTimeout(() => updateStatusMessage(""), 4000);
			}
		}, delay);
	});

	// --- Key Listeners ---
	document.addEventListener("keydown", (event) => {
		// Handle drawing key events (delete/backspace) when drawing tools are active
		// BUT only if user is not typing in an input field
		if ((isDrawingPoint || isDrawingLine || isDrawingPoly || isDrawingCircle || isDrawingText) && !event.target.matches('input, textarea, [contenteditable="true"]')) {
			handleDrawingKeyEvents(event);
		}

		// Escape Key to reset tools
		if (event.key === "Escape") {
			console.log("Escape pressed - resetting all");
			resetAllSelectedStores();
			endKadTools();
			selectedPoint = null;
			selectedHole = null;
			selectedPoint = null;
			selectedKADObject = null;
			selectedKADPolygon = null;
			selectedKADPoint = null;
			selectedKADLine = null;
			selectedKADCircle = null;
			selectedKADText = null;
			selectedMultipleHoles = [];
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			hasSelectedMultipleHoles = false;
			clearAllSelectionState();

			if (isPolygonSelectionActive) {
				polyPointsX = [];
				polyPointsY = [];
				updateStatusMessage("Polygon selection cleared - click to start new selection");
			}
			if (isPatternInPolygonActive) {
				selectedPolygon = null;
				patternStartPoint = null;
				patternEndPoint = null;
				patternReferencePoint = null;
				patternPolygonStep = 0;
				updateStatusMessage("Pattern tool reset - select polygon to start");
			} else if (isHolesAlongLineActive) {
				lineStartPoint = null;
				window.lineStartPoint = lineStartPoint; // Keep window in sync
				lineEndPoint = null;
				window.lineEndPoint = lineEndPoint; // Keep window in sync
				holesLineStep = 0;
				window.holesLineStep = holesLineStep; // Keep window in sync
				updateStatusMessage("Holes along line tool reset\nClick to set start point");
			} else if (isHolesAlongPolyLineActive) {
				selectedPolyline = null;
				polylineStartPoint = null;
				polylineEndPoint = null;
				polylineStep = 0;
				updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
			} else if (isRulerActive) {
				rulerStartPoint = null;
				rulerEndPoint = null;
				hideRulerPanel(); // Step #) Hide CSS ruler panel on ESC reset
				updateStatusMessage("Ruler tool reset\nClick to set start point");
			} else if (isRulerProtractorActive) {
				rulerProtractorPoints = [];
				hideProtractorPanel(); // Step #) Hide CSS protractor panel on ESC reset
				updateStatusMessage("Protractor tool reset\nClick to set center point");
			}
			selectedKADPolygon = null;
			selectedMultipleKADObjects = [];
			selectedMultiplePoints = [];
			selectedMultipleHoles = [];
			drawData(allBlastHoles, selectedHole);
			syncCanvasToTreeView(); // Sync cleared selection to TreeView
		}

		// Delete Key for selected KAD objects/vertices
		if ((event.key === "Delete" || event.key === "Backspace") && !event.target.matches('input, textarea, [contenteditable="true"]')) {
			// Step 1) Check if we have KAD selections (not during drawing)
			const hasKADSelection = selectedKADObject || (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0);

			if (hasKADSelection && !isDrawingPoint && !isDrawingLine && !isDrawingPoly && !isDrawingCircle && !isDrawingText) {
				event.preventDefault();
				console.log("‚ùåüîë [DELETE KEY] Deleting selected KAD objects");

				// Step 2) Handle vertex deletion with confirmation
				if (selectedPoint && selectedKADObject) {
					const entity = allKADDrawingsMap.get(selectedKADObject.entityName);
					if (entity && entity.data) {
						const elementIndex = entity.data.findIndex(function (el) { return el.pointID === selectedPoint.pointID; });
						if (elementIndex !== -1) {
							// Show confirmation dialog asking vertex or entity
							const vertexText = selectedKADObject.entityType + " vertex " + selectedPoint.pointID;
							const entityText = selectedKADObject.entityType + " '" + selectedKADObject.entityName + "'";

							showConfirmationThreeDialog(
								"Delete Confirmation",
								"What would you like to delete?",
								"Vertex Only",
								"Cancel",
								"Entire Entity"
							).then(function (result) {
								if (result === 1) {
									// Delete vertex only - capture values before clearing
									const deletedPointID = selectedPoint.pointID;
									entity.data.splice(elementIndex, 1);
									console.log("‚ùåüîë [DELETE KEY] Deleted vertex:", deletedPointID);

									// Delete entity if empty
									if (entity.data.length === 0) {
										allKADDrawingsMap.delete(selectedKADObject.entityName);
										console.log("‚ùåüîë [DELETE KEY] Entity empty - deleted:", selectedKADObject.entityName);
									} else if (typeof renumberEntityPoints === "function") {
										renumberEntityPoints(entity);
									}

									// Clear selection
									selectedPoint = null;
									selectedKADObject = null;
									selectedMultipleKADObjects = [];

									if (typeof debouncedSaveKAD === "function") {
										debouncedSaveKAD();
									}
									window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for deleted vertex
									drawData(allBlastHoles, selectedHole);
									syncCanvasToTreeView();
									updateTreeView();
									updateStatusMessage("Deleted vertex " + deletedPointID);
									setTimeout(function () { updateStatusMessage(""); }, 2000);
								} else if (result === 2) {
									// Delete entire entity - capture values before clearing
									const deletedEntityName = selectedKADObject.entityName;
									allKADDrawingsMap.delete(deletedEntityName);
									console.log("‚ùåüîë [DELETE KEY] Deleted entity:", deletedEntityName);

									selectedPoint = null;
									selectedKADObject = null;
									selectedMultipleKADObjects = [];

									if (typeof debouncedSaveKAD === "function") {
										debouncedSaveKAD();
									}
									window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for deleted entity
									drawData(allBlastHoles, selectedHole);
									syncCanvasToTreeView();
									updateTreeView();
									updateStatusMessage("Deleted entity '" + deletedEntityName + "'");
									setTimeout(function () { updateStatusMessage(""); }, 2000);
								}
								// If result === 0 (Cancel), do nothing
							});
						}
					}
				}
				// Step 3) Handle entity deletion with confirmation
				else if (selectedKADObject) {
					if (allKADDrawingsMap.has(selectedKADObject.entityName)) {
						showConfirmationDialog(
							"Delete Confirmation",
							"Are you sure you want to delete " + selectedKADObject.entityType + " '" + selectedKADObject.entityName + "'?",
							"Delete",
							"Cancel"
						).then(function (confirmed) {
							if (confirmed) {
								allKADDrawingsMap.delete(selectedKADObject.entityName);
								console.log("‚ùåüîë [DELETE KEY] Deleted entity:", selectedKADObject.entityName);

								selectedKADObject = null;
								selectedMultipleKADObjects = [];

								if (typeof debouncedSaveKAD === "function") {
									debouncedSaveKAD();
								}
								window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for deleted KAD entity
								drawData(allBlastHoles, selectedHole);
								syncCanvasToTreeView();
								updateTreeView();
								updateStatusMessage("Deleted KAD entity");
								setTimeout(function () { updateStatusMessage(""); }, 2000);
							}
						});
					}
				}
				// Step 4) Handle multiple entity deletion with confirmation
				else if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
					const count = selectedMultipleKADObjects.length;
					showConfirmationDialog(
						"Delete Confirmation",
						"Are you sure you want to delete " + count + " KAD entities?",
						"Delete All",
						"Cancel"
					).then(function (confirmed) {
						if (confirmed) {
							selectedMultipleKADObjects.forEach(function (kadObj) {
								if (allKADDrawingsMap.has(kadObj.entityName)) {
									allKADDrawingsMap.delete(kadObj.entityName);
								}
							});
							console.log("‚ùåüîë [DELETE KEY] Deleted", count, "entities");

							selectedMultipleKADObjects = [];
							selectedKADObject = null;

							if (typeof debouncedSaveKAD === "function") {
								debouncedSaveKAD();
							}
							window.threeDataNeedsRebuild = true; // Trigger 3D rebuild for deleted KAD entities
							drawData(allBlastHoles, selectedHole);
							syncCanvasToTreeView();
							updateTreeView();
							updateStatusMessage("Deleted " + count + " KAD entities");
							setTimeout(function () { updateStatusMessage(""); }, 2000);
						}
					});
				}
			}
		}
		// Shift Key for multi-select
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = true;
			isMultiHoleSelectionEnabled = true;
		}
	});

	document.addEventListener("keyup", (event) => {
		if (event.key === "Shift") {
			document.getElementById("selectionModeButton").checked = false;
			isMultiHoleSelectionEnabled = false;
		}
	});

	///-------CRITICAL IMPORTANT --------///
	// This code is critical and must be called before any other database operations.
	// It is responsible for initializing the database and loading the stored data.
	// If the database is not initialized, the application will not work correctly.
	// This code should be called only once during application initialization,
	// typically in window.onload or similar startup code, not inside event handlers.
	// This placement means the database initialization would run every time certain keys
	// are pressed, which is inefficient and could cause issues with multiple database
	initDB()
		.then((database) => {
			db = database; // ? Set the global db variable
			console.log("‚úÖ Database initialized successfully");
			updatePopup();
		})
		.catch((err) => {
			console.error("Failed to initialize database. Falling back to Local Storage.", err);
			if (localStorage.getItem("kirraDataPoints")) {
				updatePopup();
			}
		});

	updateColorsForDarkMode();
	clearCanvas();
};

// Add this helper function to centralize color updates
function updateColorsForDarkMode() {
	// Step 1) Update local color variables (must match initial declarations at lines 2941-2946)
	transparentFillColor = darkModeEnabled ? "rgba(0, 128, 255, 0.3)" : "rgba(128, 255, 0, 0.3)";
	fillColor = darkModeEnabled ? "darkgrey" : "lightgrey"; // FIXED: was backwards
	strokeColor = darkModeEnabled ? "white" : "black";
	textFillColor = darkModeEnabled ? "white" : "black";
	depthColor = darkModeEnabled ? "cyan" : "blue"; // FIXED: was backwards (cyan for dark, blue for light)
	angleDipColor = darkModeEnabled ? "orange" : "darkorange"; // FIXED: was different from initial

	// Step 2) Update window globals so Three.js rendering uses correct colors
	window.textFillColor = textFillColor;
	window.depthColor = depthColor;
	window.angleDipColor = angleDipColor;
	window.darkModeEnabled = darkModeEnabled;

	console.log("üé® Colors updated for dark mode:", darkModeEnabled);
}

// Step 4) Add cleanup on page unload to prevent memory leaks
window.addEventListener("beforeunload", function () {
	cleanupAllResources();
	// Save holes immediately on page unload (don't use debounced save)
	if (db && allBlastHoles && allBlastHoles.length > 0) {
		saveHolesToDB(allBlastHoles);
	}
});

function getKADBoundaries() {
	let minX = Infinity;
	let maxX = -Infinity;
	let minY = Infinity;
	let maxY = -Infinity;

	if (allKADDrawingsMap.size === 0) {
		return null;
	}

	for (const entity of allKADDrawingsMap.values()) {
		if (entity.data && Array.isArray(entity.data)) {
			for (const point of entity.data) {
				if (point.pointXLocation < minX) minX = point.pointXLocation;
				if (point.pointXLocation > maxX) maxX = point.pointXLocation;
				if (point.pointYLocation < minY) minY = point.pointYLocation;
				if (point.pointYLocation > maxY) maxY = point.pointYLocation;
			}
		}
	}

	return {
		minX,
		maxX,
		minY,
		maxY,
	};
}

async function clearLoadedData() {
	// Step 1) Clear hole data from memory
	allBlastHoles = [];

	// Step 2) Clear ALL data from IndexedDB - not just KAD data
	if (db) {
		try {
			// Step 2a) Clear KAD data
			const kadTransaction = db.transaction([STORE_NAME], "readwrite");
			const kadStore = kadTransaction.objectStore(STORE_NAME);
			await new Promise((resolve, reject) => {
				const request = kadStore.clear();
				request.onsuccess = () => resolve();
				request.onerror = () => reject(request.error);
			});

			// Step 2b) Clear surface data
			await deleteAllSurfacesFromDB();

			// Step 2c) Clear image data
			await deleteAllImagesFromDB();

			// Step 2d) Clear holes data from IndexedDB
			const holesTransaction = db.transaction([BLASTHOLES_STORE_NAME], "readwrite");
			const holesStore = holesTransaction.objectStore(BLASTHOLES_STORE_NAME);
			await new Promise((resolve, reject) => {
				const request = holesStore.clear();
				request.onsuccess = () => resolve();
				request.onerror = () => reject(request.error);
			});

			console.log("‚úÖ All database data cleared");
		} catch (error) {
			console.error("? Error clearing database:", error);
		}
	}

	// Step 3) Clear localStorage (for backward compatibility)
	localStorage.removeItem("kirraDataPoints");
	console.log("‚úÖ localStorage cleared");

	// Step 4) Clear memory maps
	allKADDrawingsMap.clear();
	loadedSurfaces.clear();
	loadedImages.clear();

	// Step 5) Reset other states if necessary
	selectedHole = null;
	selectedPoint = null;
	selectedMultiplePoints = [];
	selectedKADObject = null;
	selectedKADPolygon = null;
	selectedMultipleKADObjects = [];
	window.selectedKADObject = null;

	// Step 6) Redraw the empty canvas
	drawData(allBlastHoles, selectedHole);

	console.log("‚úÖ All data cleared successfully");
}
window.addEventListener("resize", () => {
	if (htmlUIVersion === "1") {
		canvas.width = document.documentElement.clientWidth - canvasAdjustWidth;
		canvas.height = document.documentElement.clientHeight - document.documentElement.clientHeight * canvasAdjustHeight;
	} else {
		//drawing will handle
	}
	if (Array.isArray(holeTimes)) {
		timeChart();
	}
	debouncedSaveHoles(); // Auto-save holes to IndexedDB

	drawData(allBlastHoles, selectedHole);
});

let isMobile = false;
// Check if the device is a mobile device
//const isMobile = /Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
const isMobileQuery = window.matchMedia("(max-width: 768px)");
if (isMobileQuery.matches) {
	isMobile = true;
} else {
	isMobile = false;
}

document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("openNavLeftBtn").addEventListener("click", openNavLeft);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("openNavRightBtn").addEventListener("click", openNavRight);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("closeNavLeftBtn").addEventListener("click", closeNavLeft);
});
document.addEventListener("DOMContentLoaded", function () {
	document.getElementById("closeNavRightBtn").addEventListener("click", closeNavRight);
});

function openNavLeft() {
	console.log(isMobile);
	const sidenavHeight = 350;
	const screenHeight = window.innerHeight;
	const margin = screenHeight - sidenavHeight;

	if (isMobile) {
		body.style.bottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "0px";
		sidenavLeft.style.top = "60%";
		sidenavLeft.style.width = "100%";
		sidenavLeft.style.height = "350px";
	} else {
		body.style.marginLeft = "315px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "300px";
		sidenavLeft.style.paddingLeft = "5px";
		sidenavLeft.style.paddingRight = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update toolbar position using ToolbarPanel class
	if (toolbarPanel) {
		console.log("Adding sidebar-open class to toolbar");
		console.log("toolbarPanel container:", toolbarPanel.container);
		console.log("Is mobile:", window.matchMedia("(max-width: 1024px)").matches);
		toolbarPanel.updateSidebarState(true);
		// Debug: Check if class was added
		const toolbar = document.getElementById("toolbarPanel");
		console.log("Toolbar classes:", toolbar.className);
	}

	// Step #) Update HUD overlay position
	updateHUDSidebarState(true);
}
function closeNavLeft() {
	if (isMobile) {
		body.style.marginBottom = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.left = "-5px";
		sidenavLeft.style.top = "-5px";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.height = "0px";
	} else {
		body.style.marginLeft = "0px";
		body.style.transition = "0.5s";
		sidenavLeft.style.width = "0px";
		sidenavLeft.style.padding = "0px";
		sidenavLeft.style.margin = "0px";
	}

	// Update floating toolbar position
	if (toolbarPanel) {
		toolbarPanel.updateSidebarState(false);
	}

	// Step #) Update HUD overlay position
	updateHUDSidebarState(false);
}
function openNavRight() {
	if (isMobile) {
		const sidenavHeight = 350; // Change this value to match the actual height of the sidenav
		const screenHeight = window.innerHeight;
		const margin = screenHeight - sidenavHeight;

		body.style.marginBottom = `${margin}px`;
		body.style.transition = "0.5s";
		sidenavRight.style.right = "0px";
		sidenavRight.style.top = "60%";
		sidenavRight.style.width = "100%";
		sidenavRight.style.height = "350px";
		//resize the timechart
		Plotly.relayout("timeChart", {
			width: 280,
		});
	} else {
		body.style.marginRight = "315px"; // Push body to the left
		body.style.transition = "0.5s";
		sidenavRight.style.width = "300px";
		sidenavRight.style.right = "0";
		sidenavRight.style.paddingLeft = "0px";
		sidenavRight.style.paddingRight = "5px";
		sidenavRight.style.margin = "0px";
		//resize the timechart
		timeChart();
		newWidthRight = 315;
		resizeChart();
	}
}
function closeNavRight() {
	if (isMobile) {
		body.style.marginBottom = "0%"; // Push body down
		body.style.transition = "0.5s";
		sidenavRight.style.right = "-5px";
		sidenavRight.style.top = "-5px";
		sidenavRight.style.width = "0px";
		sidenavRight.style.height = "0px";
	} else {
		body.style.marginRight = "0px"; // Reset the margin to default
		body.style.transition = "0.5s";
		sidenavRight.style.width = "0px";
		sidenavRight.style.padding = "0px";
		sidenavRight.style.margin = "0px";
	}
}

//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//
// ToolbarPanel is now imported
const toolbar = document.getElementById("toolbarPanel");

let isDraggingTools = false;
let offsetX, offsetY;

// Step 3) Initialize the new toolbar panel
let toolbarPanel;
// Step 2) Update the DOMContentLoaded section around line 21376
document.addEventListener("DOMContentLoaded", () => {
	toolbarPanel = new ToolbarPanel();
});

//==============================================================//
// TOOL BAR COLLAPSABLE - START
//==============================================================//

// Add event listeners for the floating toolbar buttons
const selectPointerTool = document.getElementById("selectPointer");
const selectByPolygonTool = document.getElementById("selectByPolygon");
const resetViewTool = document.getElementById("resetViewTool");
const moveToTool = document.getElementById("moveToTool");
const bearingTool = document.getElementById("bearingTool");
const rulerTool = document.getElementById("rulerTool");
const rulerProtractorTool = document.getElementById("rulerProtractorTool");

const selectHolesRadio = document.getElementById("selectHoles"); // Step 1) Radio: holes
const selectKADRadio = document.getElementById("selectKAD"); // Step 2) Radio: KAD

// Step 3) Radio change handlers - enforce exclusive selection type
selectHolesRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear KAD selections
		selectedKADObject = null;
		selectedKADPolygon = null;
		selectedMultipleKADObjects = [];
		updateStatusMessage("Selection mode: Holes only");
		drawData(allBlastHoles, selectedHole);
	}
});
selectKADRadio.addEventListener("change", function () {
	if (this.checked) {
		// Clear Hole selections
		selectedHole = null;
		selectedMultipleHoles = [];
		updateStatusMessage("Selection mode: KAD only");
		drawData(allBlastHoles, selectedHole);
	}
});

// Step 5) Add function to connect toolbar tools to their handlers
function initializeToolbarConnections() {
	// Connect radio buttons to their change handlers
	const selectHoles = document.getElementById("selectHoles");
	const selectKAD = document.getElementById("selectKAD");

	if (selectHoles) {
		selectHoles.addEventListener("change", function () {
			if (this.checked) {
				selectedKADObject = null;
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];
				updateStatusMessage("Selection mode: Holes only");
				drawData(allBlastHoles, selectedHole);
			}
		});
	}

	if (selectKAD) {
		selectKAD.addEventListener("change", function () {
			if (this.checked) {
				selectedHole = null;
				selectedMultipleHoles = [];
				updateStatusMessage("Selection mode: KAD only");
				drawData(allBlastHoles, selectedHole);
			}
		});
	}
}

//---------------MOVE TOOL---------------//
// --- Move Tool State ---

let isDraggingHole = false;
let dragStartX = 0,
	dragStartY = 0;
let dragStartWorldX = 0,
	dragStartWorldY = 0;
let dragInitialPositions = [];

// Store the previous tool state to restore it when move tool is deactivated
let previousToolState = {
	isSelectionPointerActive: false,
	isPolygonSelectionActive: false,
	selectionMode: false,
};
// Helper function to remove all canvas listeners
function removeAllCanvasListenersKeepDefault() {
	// Selection tool handlers
	canvas.removeEventListener("click", handleSelection);
	canvas.removeEventListener("touchstart", handleSelection);
	canvas.removeEventListener("click", selectInsidePolygon);
	canvas.removeEventListener("dblclick", completePolygonSelection);
	canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
	canvas.removeEventListener("mousemove", handlePolygonMouseMove);

	// Move tool handlers
	canvas.removeEventListener("mousedown", handleMoveToolMouseDown);
	canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
	canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
	canvas.removeEventListener("touchstart", handleMoveToolMouseDown);
	canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
	canvas.removeEventListener("touchend", handleMoveToolMouseUp);

	// Bearing tool handlers
	canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
	canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
	canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
	canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
	canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
	canvas.removeEventListener("touchend", handleBearingToolMouseUp);
}

//------------------------- MOVE TO TOOL START------------//
// --- Move Tool Activation ---
moveToTool.addEventListener("change", function () {
	if (this.checked) {
		// Step 1) Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;
		endKadTools(true);
		resetFloatingToolbarButtons("moveToTool");
		// DON'T remove all canvas listeners - keep the main mouse tracking
		removeAllCanvasListenersKeepDefault();

		// Step 2) Detect current mode using dimension2D-3DBtn checkbox
		const dimension2D3DBtn = document.getElementById("dimension2D-3DBtn");
		moveToolIn3DMode = dimension2D3DBtn && dimension2D3DBtn.checked;
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;

		if (!targetCanvas) {
			console.error("Move Tool: Target canvas not available");
			updateStatusMessage("Error: Canvas not available");
			this.checked = false;
			return;
		}

		// Store current state to restore later
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled,
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		// Step 3) Activate move tool and attach listeners to appropriate canvas
		isMoveToolActive = true;
		window.isMoveToolActive = true; // Expose to CameraControls
		moveToolSelectedHole = null;
		isDraggingHole = false;
		window.isDraggingHole = false; // Expose to CameraControls for pan blocking
		targetCanvas.addEventListener("mousedown", handleMoveToolMouseDown);
		targetCanvas.addEventListener("touchstart", handleMoveToolMouseDown);

		const modeText = moveToolIn3DMode ? "3D" : "2D";
		updateStatusMessage("Move Tool Activated (" + modeText + " mode)\nSelect a hole and drag to move");
		console.log("üëã Move Tool activated in " + modeText + " mode");
	} else {
		// Step 4) Deactivation - remove listeners from correct canvas based on mode
		resetFloatingToolbarButtons("none");

		// Determine which canvas was used
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;

		if (targetCanvas) {
			// Remove move tool listeners from the target canvas
			targetCanvas.removeEventListener("mousedown", handleMoveToolMouseDown);
			targetCanvas.removeEventListener("touchstart", handleMoveToolMouseDown);
			targetCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			targetCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		// Step 5) Clear move tool state
		isMoveToolActive = false;
		window.isMoveToolActive = false; // Clear from window
		isDraggingHole = false;
		window.isDraggingHole = false; // Clear from window
		moveToolSelectedHole = null;
		moveToolSelectedKAD = null;
		moveToolIn3DMode = false;
		dragPlaneZ = 0;

		// Step 6) Restore default canvas handlers (2D only)
		if (!onlyShowThreeJS) {
			// Remove and re-add default handlers to avoid conflicts
			canvas.removeEventListener("mousedown", handleMouseDown);
			canvas.removeEventListener("mouseup", handleMouseUp);
			canvas.removeEventListener("touchstart", handleTouchStart);
			canvas.removeEventListener("touchend", handleTouchEnd);

			canvas.addEventListener("mousedown", handleMouseDown);
			canvas.addEventListener("mouseup", handleMouseUp);
			canvas.addEventListener("touchstart", handleTouchStart);
			canvas.addEventListener("touchend", handleTouchEnd);
		}

		updateStatusMessage("");

		// Step 7) Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// Step 8) Restore ruler tools if they were active
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}

		// Step 9) Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}
		drawData(allBlastHoles, selectedHole);

		console.log(" Move Tool deactivated");
	}
});

// Handle move tool mouse down - start dragging if holes are selected
// Step 1) Move Tool Mouse Down Handler
// NOTE: This tool SUSPENDS normal panning/dragging behavior
// When Move tool is active, isDragging is not set and panning is disabled
// The tool handles its own dragging behavior for moving KAD vertices/holes
function handleMoveToolMouseDown(event) {
	// Step 1) Guard: Don't start move if connector tools are active
	if (isAddingConnector || isAddingMultiConnector) {
		console.log("üö´ [MOVE TOOL] Blocked - connector tool is active");
		return;
	}

	// Step 1a) Allow Alt+drag to pass through for camera orbit
	if (event.altKey) {
		// Don't block Alt+drag - let CameraControls handle it
		return;
	}

	// Step 2) Check if we're in 3D mode
	if (moveToolIn3DMode && threeRenderer && interactionManager) {
		// 3D Mode Logic
		const targetCanvas = threeRenderer.getCanvas();
		interactionManager.updateMousePosition(event, targetCanvas);

		// Step 2a) Respect radio selection mode
		const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
		const selectingKAD = selectKADRadio && selectKADRadio.checked;

		// Step 2b) Perform raycast once for both KAD and hole detection
		const intersects = interactionManager.raycast();
		console.log("üéØ [MOVE TOOL 3D] Raycast found " + intersects.length + " intersects, selectingKAD: " + selectingKAD + ", selectingHoles: " + selectingHoles);

		if (selectingKAD) {
			// Step 2b.1) Check if we have existing multiple selections
			if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0 && !event.shiftKey) {
				// Use existing multiple selections for dragging
				dragInitialKADPositions = selectedMultipleKADObjects.map(function (obj) {
					return {
						entityName: obj.entityName,
						elementIndex: obj.elementIndex,
						x: obj.pointXLocation,
						y: obj.pointYLocation,
						z: obj.pointZLocation
					};
				});

				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				dragPlaneZ = selectedMultipleKADObjects[0].pointZLocation || 0;
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during KAD drag");
					cameraControls.detachEvents();
				}

				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving " + selectedMultipleKADObjects.length + " KAD points (3D)");
				return;
			}

			// Step 2c) Try to find a KAD vertex in raycast intersects
			let foundKAD = null;

			// Traverse intersects looking for userData.kadId
			for (let i = 0; i < intersects.length; i++) {
				const obj = intersects[i].object;
				if (obj.userData && obj.userData.kadId) {
					// Parse kadId: "entityName:::vertexIndex" or similar
					const parts = obj.userData.kadId.split(":::");
					if (parts.length >= 2) {
						const entityName = parts[0];
						const elementIndex = parseInt(parts[1], 10);
						const entity = allKADDrawingsMap.get(entityName);

						if (entity && entity.data && entity.data[elementIndex]) {
							foundKAD = {
								entityName: entityName,
								elementIndex: elementIndex,
								dataPoint: entity.data[elementIndex],
							};
							break;
						}
					}
				}
			}

			if (foundKAD) {
				// Step 2c) Check if Shift key held for multiple selection
				const dataPoint = foundKAD.dataPoint;
				const entity = allKADDrawingsMap.get(foundKAD.entityName);

				if (event.shiftKey && selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
					// Step 2c.1) Shift+click: Add to existing selection
					const alreadySelected = selectedMultipleKADObjects.find(function (obj) {
						return obj.entityName === foundKAD.entityName && obj.elementIndex === foundKAD.elementIndex;
					});

					if (!alreadySelected) {
						// Add to selection
						const newKADObject = {
							entityName: foundKAD.entityName,
							entityType: entity.entityType,
							elementIndex: foundKAD.elementIndex,
							selectionType: "vertex",
							pointXLocation: dataPoint.pointXLocation,
							pointYLocation: dataPoint.pointYLocation,
							pointZLocation: dataPoint.pointZLocation,
						};
						selectedMultipleKADObjects.push(newKADObject);

						// Create highlight for newly added point
						if (typeof highlightSelectedKADPointThreeJS === "function") {
							highlightSelectedKADPointThreeJS(newKADObject, "multi");
						}
					}

					// Clear single selection
					selectedKADObject = null;
					selectedPoint = null;
				} else {
					// Step 2c.2) Single selection - clear others
					moveToolSelectedKAD = {
						entityName: foundKAD.entityName,
						elementIndex: foundKAD.elementIndex,
						initialX: dataPoint.pointXLocation,
						initialY: dataPoint.pointYLocation,
						initialZ: dataPoint.pointZLocation || 0,
					};
					dragPlaneZ = dataPoint.pointZLocation || 0;

					// Set selected KAD object for highlighting
					selectedKADObject = {
						entityName: foundKAD.entityName,
						entityType: entity.entityType,
						elementIndex: foundKAD.elementIndex,
						selectionType: "vertex",
						pointXLocation: dataPoint.pointXLocation,
						pointYLocation: dataPoint.pointYLocation,
						pointZLocation: dataPoint.pointZLocation,
					};
					selectedPoint = dataPoint;
					selectedKADPolygon = null;
					selectedMultipleKADObjects = [];

					// Step 2e) Create highlight IMMEDIATELY (don't call renderThreeJS - slow!)
					if (typeof highlightSelectedKADPointThreeJS === "function") {
						highlightSelectedKADPointThreeJS(selectedKADObject, "selected");
					}
				}

				// Step 2e.1) Quick render to show highlight(s)
				if (threeRenderer && threeRenderer.renderer) {
					threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
				}

				// Step 2f) Start dragging process
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during KAD drag");
					cameraControls.detachEvents();
				}

				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Move KAD point (3D) - drag to reposition");
				return;
			}
		}

		if (selectingHoles) {
			// Step 2g) Use existing hole selections or try to select a hole via raycasting
			if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
				// Use multiple selected holes
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				moveToolSelectedHole = selectedMultipleHoles;
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during hole drag");
					cameraControls.detachEvents();
				}

				dragPlaneZ = selectedMultipleHoles[0].startZLocation || 0;
				dragInitialPositions = selectedMultipleHoles.map(function (hole) {
					return {
						hole: hole,
						x: hole.startXLocation,
						y: hole.startYLocation,
					};
				});
				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving " + selectedMultipleHoles.length + " holes (3D)");
				return;
			} else if (selectedHole) {
				// Use single selected hole
				// Prevent camera pan during drag
				event.preventDefault();
				event.stopPropagation();

				moveToolSelectedHole = [selectedHole];
				isDraggingHole = true;
				window.isDraggingHole = true; // Expose to CameraControls

				// ? Suspend camera pan during drag
				if (cameraControls) {
					console.log("ü´∑ Suspending camera pan during hole drag");
					cameraControls.detachEvents();
				}

				dragPlaneZ = selectedHole.startZLocation || 0;
				dragInitialPositions = [
					{
						hole: selectedHole,
						x: selectedHole.startXLocation,
						y: selectedHole.startYLocation,
					},
				];
				targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
				targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
				targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Moving hole " + selectedHole.holeID + " (3D)");
				return;
			} else {
				// Step 2h) No existing selection - try to find a hole in raycast intersects
				const clickedHole = interactionManager.findClickedHole(intersects, allBlastHoles || []);
				console.log("üëã [MOVE TOOL 3D] findClickedHole result:", clickedHole);
				if (clickedHole) {
					console.log("üëã [MOVE TOOL 3D] Starting drag for hole: " + clickedHole.holeID + " in " + clickedHole.entityName);

					// Prevent camera pan during drag
					event.preventDefault();
					event.stopPropagation();

					selectedHole = clickedHole;
					moveToolSelectedHole = [clickedHole];
					isDraggingHole = true;
					window.isDraggingHole = true; // Expose to CameraControls

					// ? Suspend camera pan during drag
					if (cameraControls) {
						console.log("ü´∑ Suspending camera pan during hole drag");
						cameraControls.detachEvents();
					}

					dragPlaneZ = clickedHole.startZLocation || 0;
					dragInitialPositions = [
						{
							hole: clickedHole,
							x: clickedHole.startXLocation,
							y: clickedHole.startYLocation,
						},
					];
					targetCanvas.addEventListener("mousemove", handleMoveToolMouseMove);
					targetCanvas.addEventListener("touchmove", handleMoveToolMouseMove);
					targetCanvas.addEventListener("mouseup", handleMoveToolMouseUp);
					targetCanvas.addEventListener("touchend", handleMoveToolMouseUp);

					// Step 2h.1) Create highlight IMMEDIATELY (don't wait for renderThreeJS)
					if (typeof highlightSelectedHoleThreeJS === "function") {
						highlightSelectedHoleThreeJS(clickedHole, "selected");
					}

					// Step 2h.2) Quick render to show highlight
					if (threeRenderer && threeRenderer.renderer) {
						threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
					}

					updateStatusMessage("Moving hole " + clickedHole.holeID + " (3D)");
					return;
				} else {
					// Clicked empty space - clear selection AND remove highlights
					console.log("üí© [MOVE TOOL 3D] No hole found in intersects - clearing selection");
					clearAllSelectionState();
					selectedHole = null;
					selectedMultipleHoles = [];
					moveToolSelectedHole = null;

					// Remove ALL highlights from scene
					if (threeRenderer && threeRenderer.holesGroup) {
						const highlightsToRemove = [];
						threeRenderer.holesGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "selectionHighlight") {
								highlightsToRemove.push(child);
							}
						});
						highlightsToRemove.forEach(function (highlight) {
							threeRenderer.holesGroup.remove(highlight);
							if (highlight.geometry) highlight.geometry.dispose();
							if (highlight.material) highlight.material.dispose();
						});
					}

					// Call drawData with null to prevent highlight recreation (like Escape key does)
					if (typeof drawData === "function") {
						drawData(allBlastHoles, null);
					}
					return;
				}
			}
		}

		// If we reach here, nothing was selected
		return;
	}

	// Step 3) 2D Mode Logic (existing code)
	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	// Step A) Convert CSS pixels -> canvas pixels (fixes staccato/offset on HiDPI)
	const scaleX = canvas.width / rect.width;
	const scaleY = canvas.height / rect.height;
	// Use raw canvas coordinates like the ruler tool
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// Step 10) Respect radio selection mode for polygon selection
	const selectingHoles = selectHolesRadio && selectHolesRadio.checked;
	const selectingKAD = selectKADRadio && selectKADRadio.checked;

	if (selectingKAD) {
		// Prefer moving a KAD vertex
		const clickedKAD = getClickedKADObject(clickX, clickY);
		if (clickedKAD) {
			// Step 3a) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			const entity = allKADDrawingsMap.get(clickedKAD.entityName);
			if (entity && entity.data && entity.data.length > 0) {
				// Resolve target index: vertex or nearest endpoint of segment
				let targetIndex = clickedKAD.elementIndex;
				if (clickedKAD.selectionType === "segment") {
					const worldClick = canvasToWorld(clickX, clickY);
					const i = clickedKAD.segmentIndex;
					const p1 = entity.data[i];
					const p2 = entity.data[(i + 1) % entity.data.length];
					const d1 = Math.hypot(worldClick[0] - p1.pointXLocation, worldClick[1] - p1.pointYLocation);
					const d2 = Math.hypot(worldClick[0] - p2.pointXLocation, worldClick[1] - p2.pointYLocation);
					targetIndex = d1 <= d2 ? i : (i + 1) % entity.data.length;
				}

				// Step 1) Store move target and highlight it
				moveToolSelectedKAD = {
					entityName: clickedKAD.entityName,
					elementIndex: targetIndex,
					// Add initial position storage like holes do
					initialX: entity.data[targetIndex].pointXLocation,
					initialY: entity.data[targetIndex].pointYLocation,
					initialZ: entity.data[targetIndex].pointZLocation,
				};
				moveToolKADOriginalZ = parseFloat(entity.data[targetIndex].pointZLocation) || 0;

				// Step 2) Set selected KAD object for highlighting
				selectedKADObject = {
					entityName: clickedKAD.entityName,
					entityType: entity.entityType,
					elementIndex: targetIndex,
					selectionType: "vertex",
					pointXLocation: entity.data[targetIndex].pointXLocation,
					pointYLocation: entity.data[targetIndex].pointYLocation,
					pointZLocation: entity.data[targetIndex].pointZLocation,
				};
				selectedPoint = entity.data[targetIndex];
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];

				// Step 3) Redraw to show the highlighted selection
				drawData(allBlastHoles, selectedHole);

				// Step 4) Start dragging process
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				updateStatusMessage("Move KAD point - drag to reposition");
				return;
			} else {
				// Step 5) Clicked empty space - clear any KAD selection
				moveToolSelectedKAD = null;
				selectedKADObject = null;
				selectedKADPolygon = null;
				selectedMultipleKADObjects = [];
				resetAllSelectedStores();
				drawData(allBlastHoles, selectedHole);
				return;
			}
		}
	}
	if (selectingHoles) {
		// First priority: Use existing selections without checking for clicked holes
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			// Step 3b) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			// Use multiple selected holes - start dragging immediately
			moveToolSelectedHole = selectedMultipleHoles;
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = selectedMultipleHoles.map((hole) => ({
				hole: hole,
				x: hole.startXLocation,
				y: hole.startYLocation,
			}));
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else if (selectedHole) {
			// Step 3c) Prevent default and stop propagation (starting drag)
			event.preventDefault();
			event.stopPropagation();

			// Use single selected hole - start dragging immediately
			moveToolSelectedHole = [selectedHole];
			isDraggingHole = true;
			dragStartX = clientX;
			dragStartY = clientY;
			dragInitialPositions = [
				{
					hole: selectedHole,
					x: selectedHole.startXLocation,
					y: selectedHole.startYLocation,
				},
			];
			canvas.addEventListener("mousemove", handleMoveToolMouseMove);
			canvas.addEventListener("touchmove", handleMoveToolMouseMove);
			canvas.addEventListener("mouseup", handleMoveToolMouseUp);
			canvas.addEventListener("touchend", handleMoveToolMouseUp);
		} else {
			// No existing selections - check if we clicked on a hole to select it
			const clickedHole = getClickedHole(clickX, clickY);

			if (clickedHole) {
				// Step 3d) Prevent default and stop propagation (starting drag)
				event.preventDefault();
				event.stopPropagation();

				// No holes selected but clicked on a hole - select it and start dragging
				selectedHole = clickedHole;
				moveToolSelectedHole = [clickedHole];
				isDraggingHole = true;
				dragStartX = clientX;
				dragStartY = clientY;
				dragInitialPositions = [
					{
						hole: clickedHole,
						x: clickedHole.startXLocation,
						y: clickedHole.startYLocation,
					},
				];
				canvas.addEventListener("mousemove", handleMoveToolMouseMove);
				canvas.addEventListener("touchmove", handleMoveToolMouseMove);
				canvas.addEventListener("mouseup", handleMoveToolMouseUp);
				canvas.addEventListener("touchend", handleMoveToolMouseUp);
				drawData(allBlastHoles, selectedHole);
			} else {
				// Clicked empty space with no holes selected - clear selection
				selectedHole = null;
				selectedPoint = null;
				//selectedMultiplePoints = [];
				selectedMultipleHoles = [];
				moveToolSelectedHole = null;
				resetAllSelectedStores();
				drawData(allBlastHoles, selectedHole);
			}
		}
	}
}

// Add these listeners in your init function (e.g., DOMContentLoaded or initialize function)
document.addEventListener("keydown", (event) => {
	if (event.key && (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S")) {
		isSelfSnapEnabled = true;
	}
});

document.addEventListener("keyup", (event) => {
	if (event.key && (event.key.toLowerCase() === "s" || event.key.toUpperCase() === "S")) {
		isSelfSnapEnabled = false;
	}
});

// Handle move tool mouse move - move holes
function handleMoveToolMouseMove(event) {
	// Step 0) Guard: Don't continue if connector tools are active
	if (isAddingConnector || isAddingMultiConnector) {
		return;
	}

	console.log("üëã [MOVE TOOL MOUSEMOVE] Called - isDraggingHole:", isDraggingHole, "moveToolSelectedHole:", moveToolSelectedHole, "moveToolSelectedKAD:", moveToolSelectedKAD, "moveToolIn3DMode:", moveToolIn3DMode);
	if (!isDraggingHole || (!moveToolSelectedHole && !moveToolSelectedKAD)) {
		console.log("üëã [MOVE TOOL MOUSEMOVE] Early return - not dragging or no selection");
		return;
	}

	event.preventDefault();
	event.stopPropagation();

	// Step 4) Check if we're in 3D mode
	if (moveToolIn3DMode && threeRenderer && interactionManager) {
		// Step 4b) Update raycaster with current mouse position
		const targetCanvas = threeRenderer.getCanvas();
		interactionManager.updateMousePosition(event, targetCanvas);
		const raycaster = interactionManager.raycaster;

		// Step 4b.1) CRITICAL: Update raycaster ray with new mouse position
		const camera = threeRenderer.camera;
		raycaster.setFromCamera(interactionManager.mouse, camera);
		console.log("üëã [MOVE TOOL 3D MOVE] Mouse NDC: (", interactionManager.mouse.x.toFixed(3), interactionManager.mouse.y.toFixed(3), ")");

		// Step 4c) Declare position variables
		let worldX, worldY, worldZ;
		let snapResult = null;
		const snapRadiusPixels = 20; // Fixed pixel radius
		const snapRadiusWorld = getSnapRadiusInWorldUnits3D(snapRadiusPixels);

		// Step 4d) For HOLES: Use fixed Z plane (2D movement only)
		if (moveToolSelectedHole && dragInitialPositions) {
			// Step 4d.1) Create horizontal plane at object's Z elevation (screen-space following)
			const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -dragPlaneZ);

			// Step 4d.2) Intersect ray with plane to get screen-space position
			const intersectionPoint = new THREE.Vector3();
			const didIntersect = raycaster.ray.intersectPlane(plane, intersectionPoint);

			if (!didIntersect) {
				console.log("üëã [MOVE TOOL 3D MOVE] Ray didn't intersect plane at Z:", dragPlaneZ);
				return;
			}

			// Step 4d.3) Convert from local Three.js coords to world coords
			worldX = intersectionPoint.x + threeLocalOriginX;
			worldY = intersectionPoint.y + threeLocalOriginY;
			worldZ = dragPlaneZ; // Fixed Z for holes
			console.log("üëã [MOVE TOOL 3D MOVE HOLE] Position at:", worldX.toFixed(2), worldY.toFixed(2), worldZ.toFixed(2));

			// Step 4d.4) ONLY if snapping is enabled, override with snap position
			if (snapEnabled) {
				// Moving holes: snap to KAD and surfaces, NOT other holes

				// Calculate mouse screen coordinates for snap
				const rect = targetCanvas.getBoundingClientRect();
				const mouseScreenX = event.clientX - rect.left;
				const mouseScreenY = event.clientY - rect.top;

				snapResult = snapToNearestPointExcludingHolesWithRay(raycaster.ray.origin, raycaster.ray.direction, snapRadiusPixels, mouseScreenX, mouseScreenY);
				// Override screen-space position ONLY if snap found
				if (snapResult && snapResult.snapped) {
					worldX = snapResult.worldX;
					worldY = snapResult.worldY;
					// Keep Z fixed for holes (don't use snapResult.worldZ)
				}
			}
		}
		// Step 4e) For KAD: Use full 3D raycast (XYZ movement)
		else if (moveToolSelectedKAD || (dragInitialKADPositions && dragInitialKADPositions.length > 0)) {
			// Step 4e.1) Use 3D snap raycast to get full XYZ position (same as KAD drawing tools)
			// This allows movement in all 3 dimensions based on what the ray intersects

			// Calculate mouse screen coordinates for snap
			const rect = targetCanvas.getBoundingClientRect();
			const mouseScreenX = event.clientX - rect.left;
			const mouseScreenY = event.clientY - rect.top;

			snapResult = snapToNearestPointWithRay(raycaster.ray.origin, raycaster.ray.direction, snapRadiusPixels, mouseScreenX, mouseScreenY);

			if (snapResult && snapResult.snapped) {
				// Step 4e.2) Use snapped 3D position
				worldX = snapResult.worldX;
				worldY = snapResult.worldY;
				worldZ = snapResult.worldZ || dragPlaneZ; // Use snap Z if available, fallback to initial Z
			} else {
				// Step 4e.3) No snap found - use plane at initial Z as fallback (screen-space XY movement)
				const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -dragPlaneZ);
				const intersectionPoint = new THREE.Vector3();
				const didIntersect = raycaster.ray.intersectPlane(plane, intersectionPoint);

				if (!didIntersect) {
					console.log("üëã [MOVE TOOL 3D MOVE KAD] Ray didn't intersect fallback plane at Z:", dragPlaneZ);
					return;
				}

				worldX = intersectionPoint.x + threeLocalOriginX;
				worldY = intersectionPoint.y + threeLocalOriginY;
				worldZ = dragPlaneZ; // Keep initial Z if no snap
			}
		} else {
			// Step 4e.4) No object selected - should not reach here
			console.log("üëã [MOVE TOOL 3D MOVE] No object selected");
			return;
		}
		// At this point, worldX, worldY, worldZ are set for either holes or KAD

		// Step 4h) Update object position (uses screen-space or snapped position)
		if (moveToolSelectedHole && dragInitialPositions) {
			// Update hole position(s)
			// Calculate reference delta from first hole's initial position
			const firstHole = dragInitialPositions[0];
			const deltaX = worldX - firstHole.x;
			const deltaY = worldY - firstHole.y;
			console.log("üëã [MOVE TOOL 3D] Moving", dragInitialPositions.length, "hole(s), deltaX:", deltaX.toFixed(2), "deltaY:", deltaY.toFixed(2));

			dragInitialPositions.forEach(function (item) {
				const hole = item.hole;
				const newX = parseFloat(item.x) + deltaX;
				const newY = parseFloat(item.y) + deltaY;
				console.log("  üëã Hole", hole.holeID, "from (", item.x.toFixed(2), item.y.toFixed(2), ") to (", newX.toFixed(2), newY.toFixed(2), ")");
				calculateHoleGeometry(hole, newX, 4); // Parameter 4 for X position
				calculateHoleGeometry(hole, newY, 5); // Parameter 5 for Y position

				// Step 4h.1) Update 3D hole position in real-time (without full re-render)
				if (threeRenderer) {
					var holeId = hole.entityName + ":::" + hole.holeID;

					// Step 4h.1a) Check if using instanced rendering
					if (threeRenderer.isUsingInstancedHoles && threeRenderer.isUsingInstancedHoles()) {
						// Use updateHolePosition() for instanced holes
						threeRenderer.updateHolePosition(holeId, newX, newY, hole.startZLocation || 0);

						// Also update highlight position
						var originalLocal = worldToThreeLocal(item.x, item.y);
						var newLocal = worldToThreeLocal(newX, newY);
						var deltaLocalX = newLocal.x - originalLocal.x;
						var deltaLocalY = newLocal.y - originalLocal.y;

						threeRenderer.holesGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "selectionHighlight" && child.userData.holeId === holeId) {
								child.position.set(deltaLocalX, deltaLocalY, 0);
							}
						});
					} else if (threeRenderer.holeMeshMap) {
						// Step 4h.1b) Use traditional holeMeshMap approach for non-instanced holes
						var holeGroup = threeRenderer.holeMeshMap.get(hole.holeID);
						if (holeGroup) {
							// CRITICAL: Calculate DELTA in local coords, not absolute position
							// Hole geometry is already positioned at original collar location
							// We need to OFFSET the group by the movement delta
							var originalLocal = worldToThreeLocal(item.x, item.y);
							var newLocal = worldToThreeLocal(newX, newY);
							var deltaLocalX = newLocal.x - originalLocal.x;
							var deltaLocalY = newLocal.y - originalLocal.y;

							console.log("    3D offset: delta (", deltaLocalX.toFixed(3), deltaLocalY.toFixed(3), ") - was at (", holeGroup.position.x.toFixed(3), holeGroup.position.y.toFixed(3), ")");

							// Update hole group position by DELTA (not absolute position)
							holeGroup.position.set(deltaLocalX, deltaLocalY, 0);

							// Step 4h.1c) Also update highlight position (find and move it)
							threeRenderer.holesGroup.children.forEach(function (child) {
								if (child.userData && child.userData.type === "selectionHighlight" && child.userData.holeId === holeId) {
									// Move highlight by same delta
									child.position.set(deltaLocalX, deltaLocalY, 0);
								}
							});

							// Mark that we need to update connectors/labels after drag completes
							holeGroup.userData.needsUpdate = true;
						}
					}
				}
			});

			// Step 4h.2) Trigger render without recreating geometry
			if (threeRenderer && threeRenderer.renderer) {
				threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
			}
		} else if (dragInitialKADPositions && dragInitialKADPositions.length > 0) {
			// Step 4i) Move multiple KAD points together (full 3D movement)
			const firstKAD = dragInitialKADPositions[0];
			const deltaX = worldX - firstKAD.x;
			const deltaY = worldY - firstKAD.y;
			const deltaZ = worldZ - (firstKAD.z || 0); // Full 3D delta
			console.log("üëã [MOVE TOOL 3D] Moving " + dragInitialKADPositions.length + " KAD points, delta: (" + deltaX.toFixed(2) + ", " + deltaY.toFixed(2) + ", " + deltaZ.toFixed(2) + ")");

			dragInitialKADPositions.forEach(function (item) {
				const entity = allKADDrawingsMap.get(item.entityName);
				if (entity && entity.data && item.elementIndex < entity.data.length) {
					const newX = item.x + deltaX;
					const newY = item.y + deltaY;
					const newZ = (item.z || 0) + deltaZ; // Calculate new Z

					entity.data[item.elementIndex].pointXLocation = newX;
					entity.data[item.elementIndex].pointYLocation = newY;
					entity.data[item.elementIndex].pointZLocation = newZ; // Full 3D update

					// Update visual for this KAD point (3D delta)
					const kadId = item.entityName + ":::" + item.elementIndex;
					const originalLocal = worldToThreeLocal(item.x, item.y);
					const newLocal = worldToThreeLocal(newX, newY);
					const deltaLocalX = newLocal.x - originalLocal.x;
					const deltaLocalY = newLocal.y - originalLocal.y;

					// Move the KAD point mesh with full 3D delta
					threeRenderer.kadGroup.children.forEach(function (child) {
						if (child.userData && child.userData.kadId === kadId) {
							child.position.set(deltaLocalX, deltaLocalY, deltaZ);
						}
					});

					// Move the highlight with full 3D delta
					threeRenderer.kadGroup.children.forEach(function (child) {
						if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
							child.position.set(deltaLocalX, deltaLocalY, deltaZ);
						}
					});
				}
			});

			// Quick render
			if (threeRenderer && threeRenderer.renderer) {
				threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
			}
		} else if (moveToolSelectedKAD) {
			// Step 4i) Update single KAD point position (full 3D movement)
			console.log("üëã [MOVE TOOL 3D] Moving KAD " + moveToolSelectedKAD.entityName + " point " + moveToolSelectedKAD.elementIndex + " to XYZ: (" + worldX.toFixed(2) + ", " + worldY.toFixed(2) + ", " + worldZ.toFixed(2) + ")");
			const entity = allKADDrawingsMap.get(moveToolSelectedKAD.entityName);
			if (entity && entity.data && moveToolSelectedKAD.elementIndex < entity.data.length) {
				const oldX = entity.data[moveToolSelectedKAD.elementIndex].pointXLocation;
				const oldY = entity.data[moveToolSelectedKAD.elementIndex].pointYLocation;
				const oldZ = entity.data[moveToolSelectedKAD.elementIndex].pointZLocation || 0;

				// Update to new 3D position
				entity.data[moveToolSelectedKAD.elementIndex].pointXLocation = worldX;
				entity.data[moveToolSelectedKAD.elementIndex].pointYLocation = worldY;
				entity.data[moveToolSelectedKAD.elementIndex].pointZLocation = worldZ; // Full 3D movement
				console.log("  üëã KAD point moved from (" + oldX.toFixed(2) + ", " + oldY.toFixed(2) + ", " + oldZ.toFixed(2) + ") to (" + worldX.toFixed(2) + ", " + worldY.toFixed(2) + ", " + worldZ.toFixed(2) + ")");

				// Keep highlight in sync while dragging
				if (selectedKADObject && selectedKADObject.entityName === moveToolSelectedKAD.entityName && selectedKADObject.elementIndex === moveToolSelectedKAD.elementIndex) {
					selectedKADObject.pointXLocation = worldX;
					selectedKADObject.pointYLocation = worldY;
					selectedKADObject.pointZLocation = worldZ; // Update Z in selection object
				}

				// Keep selectedPoint in sync while dragging
				selectedPoint = entity.data[moveToolSelectedKAD.elementIndex];

				// Step 4i.1) Update KAD visual in real-time (full 3D delta calculation)
				const kadId = moveToolSelectedKAD.entityName + ":::" + moveToolSelectedKAD.elementIndex;

				// Calculate delta from initial position (including Z)
				const originalLocal = worldToThreeLocal(moveToolSelectedKAD.initialX, moveToolSelectedKAD.initialY);
				const newLocal = worldToThreeLocal(worldX, worldY);
				const deltaLocalX = newLocal.x - originalLocal.x;
				const deltaLocalY = newLocal.y - originalLocal.y;
				const deltaZ = worldZ - (moveToolSelectedKAD.initialZ || 0); // Z delta in world space

				// Find and move the KAD point mesh in kadGroup (3D movement)
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.kadId === kadId) {
						// Move the mesh by full 3D delta
						child.position.set(deltaLocalX, deltaLocalY, deltaZ);
					}
				});

				// Step 4i.1a) Check if highlight exists - recreate if missing (prevents disappearing during drag)
				let highlightFound = false;
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
						highlightFound = true;
						// Move existing highlight by full 3D delta
						child.position.set(deltaLocalX, deltaLocalY, deltaZ);
					}
				});

				// Step 4i.1b) If highlight was removed (e.g. by drawData), recreate it
				if (!highlightFound) {
					console.log("üëã [MOVE TOOL 3D] Highlight missing - recreating for kadId:", kadId);
					if (typeof highlightSelectedKADPointThreeJS === "function" && selectedKADObject) {
						// Update selectedKADObject position to current location before recreating highlight
						selectedKADObject.pointXLocation = worldX;
						selectedKADObject.pointYLocation = worldY;
						selectedKADObject.pointZLocation = worldZ; // Use full 3D position
						highlightSelectedKADPointThreeJS(selectedKADObject, "selected");

						// Move the newly created highlight to the correct position
						threeRenderer.kadGroup.children.forEach(function (child) {
							if (child.userData && child.userData.type === "kadHighlight" && child.userData.kadId === kadId) {
								child.position.set(deltaLocalX, deltaLocalY, deltaZ);
							}
						});
					}
				}

				// Step 4i.2) Quick render to show visual update
				if (threeRenderer && threeRenderer.renderer) {
					threeRenderer.renderer.render(threeRenderer.scene, threeRenderer.camera);
				}
			}
		}

		return;
	}

	// Step 5) 2D Mode Logic (existing code)
	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);
	// Calculate movement delta
	const deltaX = (clientX - dragStartX) / currentScale;
	const deltaY = -(clientY - dragStartY) / currentScale;

	// Step 12) KAD move branch
	if (moveToolSelectedKAD) {
		const entity = allKADDrawingsMap.get(moveToolSelectedKAD.entityName);
		if (entity && entity.data && moveToolSelectedKAD.elementIndex < entity.data.length) {
			const rect = canvas.getBoundingClientRect();
			const scaleX = canvas.width / rect.width;
			const scaleY = canvas.height / rect.height;
			const canvasX = (clientX - rect.left) * scaleX;
			const canvasY = (clientY - rect.top) * scaleY;

			// Convert to world coordinates first
			const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
			const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

			// Use the excluding snap function
			// Use regular snap (including self-snap) if 'S' is held; otherwise exclude
			let snapResult;
			if (isSelfSnapEnabled) {
				snapResult = snapToNearestPoint(rawWorldX, rawWorldY);
			} else {
				snapResult = snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, moveToolSelectedKAD.entityName, moveToolSelectedKAD.elementIndex);
			}

			entity.data[moveToolSelectedKAD.elementIndex].pointXLocation = snapResult.worldX;
			entity.data[moveToolSelectedKAD.elementIndex].pointYLocation = snapResult.worldY;
			entity.data[moveToolSelectedKAD.elementIndex].pointZLocation = snapResult.snapped && snapResult.worldZ ? snapResult.worldZ : moveToolSelectedKAD.initialZ || 0;

			// Keep highlight in sync while dragging
			if (selectedKADObject && selectedKADObject.entityName === moveToolSelectedKAD.entityName && selectedKADObject.elementIndex === moveToolSelectedKAD.elementIndex) {
				selectedKADObject.pointXLocation = snapResult.worldX;
				selectedKADObject.pointYLocation = snapResult.worldY;
				selectedKADObject.pointZLocation = entity.data[moveToolSelectedKAD.elementIndex].pointZLocation;
			}

			// Keep selectedPoint in sync while dragging
			selectedPoint = entity.data[moveToolSelectedKAD.elementIndex];
		}
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Move all selected holes
	dragInitialPositions.forEach(({ hole, x, y }) => {
		calculateHoleGeometry(hole, parseFloat(x) + deltaX, 4); // Parameter 4 for X position
		calculateHoleGeometry(hole, parseFloat(y) + deltaY, 5); // Parameter 5 for Y position
	});

	// Throttle contour recalculation for better performance
	let disableContourThrottling = false; // Temporary flag to disable throttling
	if (disableContourThrottling || !contourUpdatePending) {
		if (!disableContourThrottling) {
			contourUpdatePending = true;
		}

		const updateContours = () => {
			if (allBlastHoles.length > 0) {
				holeTimes = calculateTimes(allBlastHoles);
				const result = recalculateContours(allBlastHoles, 0, 0);
				contourLinesArray = result.contourLinesArray;
				directionArrows = result.directionArrows;
				timeChart();
			}
			if (!disableContourThrottling) {
				contourUpdatePending = false;
			}
		};

		if (disableContourThrottling) {
			updateContours();
		} else {
			requestAnimationFrame(updateContours);
		}
	}

	drawData(allBlastHoles, selectedHole);
}
// Handle move tool mouse up - stop dragging
function handleMoveToolMouseUp(event) {
	if (isDraggingHole) {
		// Prevent other handlers from running (like 3D click handler)
		event.preventDefault();
		event.stopPropagation();

		isDraggingHole = false;
		window.isDraggingHole = false; // Clear from window

		// Step 6) Determine which canvas to remove listeners from
		const targetCanvas = moveToolIn3DMode ? (threeRenderer ? threeRenderer.getCanvas() : null) : canvas;
		if (targetCanvas) {
			targetCanvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			targetCanvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			targetCanvas.removeEventListener("touchend", handleMoveToolMouseUp);
		} else {
			// Fallback: remove from both canvases to be safe
			canvas.removeEventListener("mousemove", handleMoveToolMouseMove);
			canvas.removeEventListener("touchmove", handleMoveToolMouseMove);
			canvas.removeEventListener("mouseup", handleMoveToolMouseUp);
			canvas.removeEventListener("touchend", handleMoveToolMouseUp);
		}

		// Step 7) Check if we're in 3D mode
		if (moveToolIn3DMode) {
			// ? Re-enable camera pan after drag completes
			if (cameraControls) {
				console.log("üé• Restoring camera pan after drag complete");
				cameraControls.resetPanState(); // Clear any stuck states
				cameraControls.attachEvents(); // Re-enable pan/orbit
			}

			// Step 7a) 3D Mode: Clear drag plane Z
			dragPlaneZ = 0;

			// Step 7b) Persist KAD changes if applicable
			if (moveToolSelectedKAD || dragInitialKADPositions) {
				debouncedSaveKAD();
				debouncedUpdateTreeView();
				moveToolSelectedKAD = null;
				dragInitialKADPositions = null;
			}

			// Step 7c) Save hole changes
			if (moveToolSelectedHole) {
				debouncedSaveHoles(); // Auto-save holes to IndexedDB
			}

			// Step 7d) Clear selections AND drag state (BEFORE removing highlights!)
			clearAllSelectionState();
			selectedHole = null;
			selectedPoint = null;
			selectedMultipleHoles = [];
			moveToolSelectedHole = null;
			dragInitialPositions = null; // CRITICAL: Clear to prevent wrong hole moving next time

			// Step 7e) Remove ALL hole highlights from scene
			if (threeRenderer && threeRenderer.holesGroup) {
				const highlightsToRemove = [];
				threeRenderer.holesGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "selectionHighlight") {
						highlightsToRemove.push(child);
					}
				});
				highlightsToRemove.forEach(function (highlight) {
					threeRenderer.holesGroup.remove(highlight);
					if (highlight.geometry) highlight.geometry.dispose();
					if (highlight.material) highlight.material.dispose();
				});
				console.log("üëã [MOVE TOOL] Removed " + highlightsToRemove.length + " hole highlights from scene");
			}

			// Step 7e.1) Remove ALL KAD highlights from scene
			if (threeRenderer && threeRenderer.kadGroup) {
				const kadHighlightsToRemove = [];
				threeRenderer.kadGroup.children.forEach(function (child) {
					if (child.userData && child.userData.type === "kadHighlight") {
						kadHighlightsToRemove.push(child);
					}
				});
				kadHighlightsToRemove.forEach(function (highlight) {
					threeRenderer.kadGroup.remove(highlight);
					if (highlight.geometry) highlight.geometry.dispose();
					if (highlight.material) highlight.material.dispose();
				});
				console.log("üëã [MOVE TOOL] Removed " + kadHighlightsToRemove.length + " KAD highlights from scene");
			}

			// Step 7f) Call drawData with null to prevent highlight recreation (like Escape key does)
			// This ensures no other code recreates highlights after we remove them
			if (typeof drawData === "function") {
				// Step #) Trigger 3D rebuild to reflect moved hole positions
				window.threeDataNeedsRebuild = true;
				drawData(allBlastHoles, null);
			}

			// Step 7g) Set flag to prevent click event from re-selecting the hole
			justFinishedDragging = true;
			setTimeout(function () {
				justFinishedDragging = false;
			}, 100); // Clear flag after 100ms

			console.log("üëã Move Tool mouseup (3D mode) - changes saved");
			return;
		}

		// Step 8) 2D Mode Logic (existing code)
		// Step 13) Persist KAD changes if applicable
		if (moveToolSelectedKAD) {
			debouncedSaveKAD();
			debouncedUpdateTreeView();
			moveToolSelectedKAD = null;
		}

		// Save changes and recalculate everything
		if (moveToolSelectedHole) {
			debouncedSaveHoles(); // Auto-save holes to IndexedDB

			// Recalculate everything after holes are moved
			if (allBlastHoles.length > 0) {
				// Recalculate triangulation
				if (displayContours.checked || displayRelief.checked || displayFirstMovements.checked) {
					const { resultTriangles, reliefTriangles } = delaunayTriangles(allBlastHoles, maxEdgeLength);

					// Recalculate hole times
					holeTimes = calculateTimes(allBlastHoles);

					// Recalculate contours
					const result = recalculateContours(allBlastHoles, 0, 0);
					contourLinesArray = result.contourLinesArray;
					directionArrows = result.directionArrows;
				}
			}
		}
		// Clear single selection and multiple selection AND drag state
		clearAllSelectionState();
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		moveToolSelectedHole = null;
		dragInitialPositions = null; // CRITICAL: Clear to prevent wrong hole moving next time
		// Step #) Trigger 3D rebuild to reflect moved hole positions
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	}
}
//---------------END OF MOVE TOOL---------------//

//---------------BEARING TOOL---------------//
// Add event listener for the bearing tool
bearingTool.addEventListener("change", function () {
	if (this.checked) {
		// Store current selection BEFORE clearing anything
		const preservedMultipleSelection = selectedMultipleHoles ? [...selectedMultipleHoles] : [];
		const preservedSingleSelection = selectedHole;

		resetFloatingToolbarButtons("bearingTool");
		removeAllCanvasListenersKeepDefault();

		// ? ADD: Store current state to restore later (was missing!)
		previousToolState = {
			isSelectionPointerActive: isSelectionPointerActive,
			isPolygonSelectionActive: isPolygonSelectionActive,
			selectionMode: isMultiHoleSelectionEnabled,
		};

		// Disable other tools
		isSelectionPointerActive = false;
		isPolygonSelectionActive = false;

		// Restore preserved selections AFTER reset
		selectedMultipleHoles = preservedMultipleSelection;
		selectedHole = preservedSingleSelection;

		isBearingToolActive = true;
		bearingToolSelectedHole = null;
		isDraggingBearing = false;
		canvas.addEventListener("mousedown", handleBearingToolMouseDown);
		canvas.addEventListener("touchstart", handleBearingToolMouseDown);
		updateStatusMessage("Bearing Tool Activated\nSelect a hole and drag to rotate\nHold 'F' for focus mode");
		// Add keydown listener for F key
		document.addEventListener("keydown", handleBearingToolKeyDown);
		document.addEventListener("keyup", handleBearingToolKeyUp);
	} else {
		resetFloatingToolbarButtons("none");

		// Remove bearing tool listeners
		canvas.removeEventListener("mousedown", handleBearingToolMouseDown);
		canvas.removeEventListener("touchstart", handleBearingToolMouseDown);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Remove key listeners
		document.removeEventListener("keydown", handleBearingToolKeyDown);
		document.removeEventListener("keyup", handleBearingToolKeyUp);

		// ? ADD: Clear bearing tool state
		isBearingToolActive = false;
		isDraggingBearing = false;
		bearingToolSelectedHole = null;

		// ? ADD: Clear the focus mode flag
		isFocusModeActive = false;

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);

		// Restore default canvas handlers so other tools work properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ? ADD: Restore selection tool listeners if they were active
		if (previousToolState && previousToolState.isSelectionPointerActive) {
			isSelectionPointerActive = true;
			canvas.addEventListener("click", handleSelection);
			canvas.addEventListener("touchstart", handleSelection);
		}
		if (previousToolState && previousToolState.isPolygonSelectionActive) {
			isPolygonSelectionActive = true;
			canvas.addEventListener("click", selectInsidePolygon);
			canvas.addEventListener("touchstart", selectInsidePolygonTouch);
			canvas.addEventListener("mousemove", handlePolygonMouseMove);
		}

		// ? ADD: Restore previous tool state
		if (previousToolState) {
			isMultiHoleSelectionEnabled = previousToolState.selectionMode;
		}

		// Restore ruler protractor click handler if it was active
		if (isRulerProtractorActive) {
			canvas.addEventListener("click", handleRulerProtractorClick);
		}
		if (isRulerActive) {
			canvas.addEventListener("click", handleRulerClick);
		}

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

// Track F key state
let isFocusModeActive = false;

// Handle F key press for focus mode
function handleBearingToolKeyDown(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = true;
	}
}

function handleBearingToolKeyUp(event) {
	if (event.key === "f" || event.key === "F") {
		isFocusModeActive = false;
	}
}

// Handle bearing tool mouse down - start dragging if holes are selected
// Step 1) Bearing Tool Mouse Down Handler
// NOTE: This tool SUSPENDS normal panning/dragging behavior
// When Bearing tool is active, isDragging is not set and panning is disabled
// The tool handles its own dragging behavior for rotating holes
function handleBearingToolMouseDown(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// First priority: Use existing selections without checking for clicked holes
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// Use multiple selected holes - start dragging immediately
		bearingToolSelectedHole = selectedMultipleHoles;
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else if (selectedHole) {
		// Use single selected hole - start dragging immediately
		bearingToolSelectedHole = [selectedHole];
		isDraggingBearing = true;
		canvas.addEventListener("mousemove", handleBearingToolMouseMove);
		canvas.addEventListener("touchmove", handleBearingToolMouseMove);
		canvas.addEventListener("mouseup", handleBearingToolMouseUp);
		canvas.addEventListener("touchend", handleBearingToolMouseUp);
	} else {
		// No existing selections - check if we clicked on a hole to select it
		const clickedHole = getClickedHole(clickX, clickY);

		if (clickedHole) {
			// No holes selected but clicked on a hole - select it and start dragging
			selectedHole = clickedHole;
			bearingToolSelectedHole = [clickedHole];
			isDraggingBearing = true;
			canvas.addEventListener("mousemove", handleBearingToolMouseMove);
			canvas.addEventListener("touchmove", handleBearingToolMouseMove);
			canvas.addEventListener("mouseup", handleBearingToolMouseUp);
			canvas.addEventListener("touchend", handleBearingToolMouseUp);
			drawData(allBlastHoles, selectedHole);
		} else {
			// Clicked empty space with no holes selected - clear selection
			selectedHole = null;
			selectedPoint = null;
			//selectedMultiplePoints = []
			selectedMultipleHoles = [];
			bearingToolSelectedHole = null;
			drawData(allBlastHoles, selectedHole);
		}
	}
}
// Handle bearing tool mouse move - rotate bearing
function handleBearingToolMouseMove(event) {
	if (!isDraggingBearing || !bearingToolSelectedHole) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (isFocusModeActive) {
		// Focus mode: Each hole points to mouse location (original behavior)
		bearingToolSelectedHole.forEach((hole) => {
			const eastingDiff = worldX - parseFloat(hole.startXLocation);
			const northingDiff = worldY - parseFloat(hole.startYLocation);

			let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
			if (newBearing < 0) newBearing += 360;

			calculateHoleGeometry(hole, newBearing, 3);
		});
	} else {
		// Default mode: All holes get same bearing based on first hole
		const firstHole = bearingToolSelectedHole[0];
		const eastingDiff = worldX - parseFloat(firstHole.startXLocation);
		const northingDiff = worldY - parseFloat(firstHole.startYLocation);

		let newBearing = Math.atan2(eastingDiff, northingDiff) * (180 / Math.PI);
		if (newBearing < 0) newBearing += 360;

		// Apply the same bearing to all selected holes
		bearingToolSelectedHole.forEach((hole) => {
			calculateHoleGeometry(hole, newBearing, 3);
		});
	}

	drawData(allBlastHoles, selectedHole);
}

// Handle bearing tool mouse up - stop dragging
function handleBearingToolMouseUp(event) {
	if (isDraggingBearing) {
		isDraggingBearing = false;
		canvas.removeEventListener("mousemove", handleBearingToolMouseMove);
		canvas.removeEventListener("touchmove", handleBearingToolMouseMove);
		canvas.removeEventListener("mouseup", handleBearingToolMouseUp);
		canvas.removeEventListener("touchend", handleBearingToolMouseUp);

		// Save changes
		if (bearingToolSelectedHole) {
			debouncedSaveHoles(); // Auto-save holes to IndexedDB
		}
		// Clear single selection and he multiple selection
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		selectedMultipleHoles = [];
		drawData(allBlastHoles, selectedHole);
	}
}

//---------------END OF BEARING TOOL---------------//

//---------------SELECTION TOOLS---------------//
selectPointerTool.addEventListener("change", function () {
	if (this.checked) {
		isSelectionPointerActive = true;
		isPolygonSelectionActive = false;
		isMultiHoleSelectionEnabled = false;
		//selectedKADPolygon = null;

		// Step X) Disable 3D polygon selection if active
		// Fixes QUIRK 3: SelectPointer and SelectPolygon should turn each other off
		if (onlyShowThreeJS && window.polygonSelection3D) {
			window.polygonSelection3D.disable();
			selectByPolygonTool.checked = false;
			if (developerModeEnabled) {
				console.log("‚ùåüî∂ Disabled 3D polygon selection (SelectPointer activated)");
			}
		}

		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectPointerTool");
		clearAllSelectionState();
		endKadTools(true);
		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectPointerTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Enable point selection mode
		canvas.addEventListener("click", handleSelection);
		canvas.addEventListener("touchstart", handleSelection);
		updateStatusMessage("Point selection mode enabled\nShift to select multiple.\n Escape to clear selection.");
		drawData(allBlastHoles, selectedHole);
	} else {
		isSelectionPointerActive = false;
		isMultiHoleSelectionEnabled = false;
		// Disable point selection mode
		canvas.removeEventListener("click", handleSelection);
		canvas.removeEventListener("touchstart", handleSelection);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Update the function to properly check and handle KAD tools
// MOVED TO ContextMenuManager.js - This function is now loaded from external module
// END OF MOVED FUNCTION - kadContextMenu now loaded from ContextMenuManager.js
///-----------------------------RIGHT CLICK STUFF GOES HERE-----------------------------//
// MOVED TO ContextMenuManager.js - This function is now loaded from external module
// END OF MOVED FUNCTION - closeAllContextMenus now loaded from ContextMenuManager.js
// Step 1) 2D context menu event listener - now using ContextMenuManager
// Step 1) 2D context menu event listener - now using ContextMenuManager
canvas.addEventListener("contextmenu", function (e) {
	// Delegate to the centralized context menu manager
	window.handle2DContextMenu(e);
});

function isClickOnSelectedPolygon(worldX, worldY, selectedPolygon) {
	if (!selectedPolygon || !allKADDrawingsMap.has(selectedPolygon.entityName)) {
		return null;
	}

	const entity = allKADDrawingsMap.get(selectedPolygon.entityName);
	const points = entity.data;
	const tolerance = getSnapToleranceInWorldUnits(); // Adjust click tolerance based on zoom

	// Check if click is on any point of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point = points[i];
		const dx = worldX - point.pointXLocation;
		const dy = worldY - point.pointYLocation;
		const distance = Math.sqrt(dx * dx + dy * dy);

		if (distance <= tolerance) {
			// Return the clicked point with metadata - USE DYNAMIC VALUES
			return {
				...point,
				mapType: "allKADDrawingsMap", // ? Use unified map name
				entityType: entity.entityType, // ? Use actual entity type from data
				entityName: entity.entityName, // ? Add entity name for consistency
			};
		}
	}

	// Check if click is on any segment of the selected polygon
	for (let i = 0; i < points.length; i++) {
		const point1 = points[i];
		const point2 = points[(i + 1) % points.length]; // Wrap around to first point

		// Calculate distance from click point to line segment
		const segmentDistance = distanceToLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

		if (segmentDistance <= tolerance) {
			// Return the first point of the segment with metadata - USE DYNAMIC VALUES
			return {
				...point1,
				mapType: "allKADDrawingsMap", // ? Use unified map name
				entityType: entity.entityType, // ? Use actual entity type from data
				entityName: entity.entityName, // ? Add entity name for consistency
			};
		}
	}

	return null;
}

// Helper function to calculate distance from point to line segment
function distanceToLineSegment(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;
	const length = dx * dx + dy * dy;

	if (length === 0) {
		// Points are the same, return distance to point
		const dpx = px - x1;
		const dpy = py - y1;
		return Math.sqrt(dpx * dpx + dpy * dpy);
	}

	// Calculate parameter t for closest point on line segment
	const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / length));

	// Calculate closest point on segment
	const closestX = x1 + t * dx;
	const closestY = y1 + t * dy;

	// Return distance to closest point
	const dcx = px - closestX;
	const dcy = py - closestY;
	return Math.sqrt(dcx * dcx + dcy * dcy);
}

// ENHANCED: Fix getClickedKADObject to return specific element information
function getClickedKADObject(clickX, clickY) {
	const worldX = (clickX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(clickY - canvas.height / 2) / currentScale + centroidY;

	if (developerModeEnabled) {
		console.log("‚¨áÔ∏è [getClickedKADObject] Click at canvas:", clickX, clickY, "| world:", worldX, worldY);
	}


	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		const tolerance = getSnapToleranceInWorldUnits();
		if (developerModeEnabled) {
			console.log("üéØ Snap tolerance:", tolerance, "| Total entities:", allKADDrawingsMap.size);
		}
		let closestMatch = null;
		let minDistance = tolerance;

		// Iterate through all entities
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			// ? CHECK VISIBILITY FIRST - Skip hidden entities
			if (!isEntityVisible(entityName)) {
				if (developerModeEnabled) {
					console.log("  üëª  Skipping hidden entity:", entityName);
				}
				continue;
			}
			if (developerModeEnabled) {
				console.log("  üîç Checking entity:", entityName, "| Type:", entity.entityType, "| Elements:", entity.data.length);
			}

			// For single-point entities (points, circles, text)
			if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
				for (let i = 0; i < entity.data.length; i++) {
					const point = entity.data[i];
					// Step 1) Skip hidden elements - hidden items should not be selectable from canvas
					if (point.visible === false) continue;
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));
					if (developerModeEnabled) {
						console.log("    üìç Element", i, "distance:", distance.toFixed(2), "| tolerance:", tolerance.toFixed(2));
					}

					if (distance <= tolerance && distance < minDistance) {
						if (developerModeEnabled) {
							console.log("    ‚úÖ MATCH FOUND! Entity:", entityName, "Type:", entity.entityType, "Element:", i);
						}
						closestMatch = {
							...point,
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i,
							selectionType: "vertex", // Changed from "point" to "vertex" to match ContextMenuManager expectations
						};
						minDistance = distance;
					}
				}
			}
			// For multi-point entities (lines and polygons) - prioritize SEGMENTS over vertices
			else if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length < 2) continue;

				// FIRST: Check segments (higher priority than vertices)
				const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

				for (let i = 0; i < numSegments; i++) {
					const point1 = points[i];
					const point2 = points[(i + 1) % points.length]; // Wrap for polygons

					// Step 2) Skip segments where either endpoint is hidden - hidden items not selectable from canvas
					if (point1.visible === false || point2.visible === false) continue;

					// Calculate distance from click to line segment
					const segmentDistance = pointToLineSegmentDistance(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

					if (segmentDistance <= tolerance && segmentDistance < minDistance) {
						// Find the closest point on the segment for the clicked location
						const closestPoint = getClosestPointOnLineSegment(worldX, worldY, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

						closestMatch = {
							...point1, // Use first point's properties as base
							mapType: "allKADDrawingsMap",
							entityName: entityName,
							entityType: entity.entityType,
							elementIndex: i,
							segmentIndex: i, // This is the specific segment clicked
							selectionType: "segment",
							clickedX: closestPoint.x,
							clickedY: closestPoint.y,
						};
						minDistance = segmentDistance;
					}
				}

				// SECOND: Check vertices (lower priority, only if no segment found)
				if (!closestMatch) {
					for (let i = 0; i < points.length; i++) {
						const point = points[i];
						// Step 3) Skip hidden vertices - hidden items not selectable from canvas
						if (point.visible === false) continue;
						const distance = Math.sqrt(Math.pow(point.pointXLocation - worldX, 2) + Math.pow(point.pointYLocation - worldY, 2));

						if (distance <= tolerance && distance < minDistance) {
							closestMatch = {
								...point,
								mapType: "allKADDrawingsMap",
								entityName: entityName,
								entityType: entity.entityType,
								elementIndex: i,
								segmentIndex: i,
								selectionType: "vertex",
							};
							minDistance = distance;
						}
					}
				}
			}
		}

		if (developerModeEnabled) {
			console.log("ü§å [getClickedKADObject] Final result:", closestMatch ? closestMatch.entityType + " - " + closestMatch.entityName : "null");
		}
		return closestMatch;
	}

	if (developerModeEnabled) {
		console.log("ü§å [getClickedKADObject] No entities available or empty map");
	}
	return null;
}

// Step 13j.1) Get clicked KAD object in 3D mode (mimics 2D getClickedKADObject)
function getClickedKADObject3D(intersects, clickX, clickY) {
	if (developerModeEnabled) {
		console.log("ü§å 3D [getClickedKADObject3D] Starting - Intersects:", intersects ? intersects.length : 0, "| Click:", clickX, clickY);
	}

	if (!intersects || intersects.length === 0) {
		if (developerModeEnabled) {
			console.log("ü§å 3D [getClickedKADObject3D] No intersects - raycast missed everything");
		}
		return null;
	}

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) {
		if (developerModeEnabled) {
			console.log("ü§å 3D [getClickedKADObject3D] No KAD entities in map");
		}
		return null;
	}

	// Step 13j.1a) Find the first KAD object from raycast intersects
	if (developerModeEnabled) {
		console.log("ü§å 3D Inspecting " + intersects.length + " intersects:");
	}
	for (let i = 0; i < Math.min(5, intersects.length); i++) {
		const userData = intersects[i].object.userData;
		if (developerModeEnabled) {
			console.log("  [" + i + "] distance:", intersects[i].distance.toFixed(2), "| userData:", userData);
		}
	}

	let clickedKADMesh = null;
	for (const intersect of intersects) {
		const userData = intersect.object.userData;
		if (userData && userData.type && userData.type.startsWith("kad") && userData.kadId) {
			clickedKADMesh = intersect.object;
			if (developerModeEnabled) {
				console.log("üëÄ 3D ? Found KAD mesh! Type:", userData.type, "| kadId:", userData.kadId);
			}
			break;
		}
	}

	if (!clickedKADMesh) {
		if (developerModeEnabled) {
			console.log("üßä 3D ‚ùå No KAD mesh in raycast results");
		}
		return null;
	}

	const userData = clickedKADMesh.userData;
	const entityName = userData.kadId; // kadId is the entityName
	const entity = allKADDrawingsMap.get(entityName);
	if (!entity) return null;

	// Step 13j.1b) Check entity visibility
	if (!isEntityVisible(entityName)) return null;

	// Step 13j.1c) Get world position from raycast for distance calculations
	const worldPos = interactionManager.getMouseWorldPositionOnPlane();
	if (!worldPos) return null;

	const tolerance = getSnapToleranceInWorldUnits();

	// Step 13j.1d) Handle single-point entities (points, circles, text)
	if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
		// Step 13j.1d.1) Find closest point within tolerance
		let closestMatch = null;
		let minDistance = tolerance;

		for (let i = 0; i < entity.data.length; i++) {
			const point = entity.data[i];
			// Step 13j.1d.1a) Skip hidden elements - hidden items not selectable from canvas
			if (point.visible === false) continue;
			const distance = Math.sqrt(Math.pow(point.pointXLocation - worldPos.x, 2) + Math.pow(point.pointYLocation - worldPos.y, 2));

			if (distance <= tolerance && distance < minDistance) {
				closestMatch = {
					...point, // Include all point properties (pointXLocation, pointYLocation, color, etc.)
					mapType: "allKADDrawingsMap",
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: i,
					segmentIndex: i,
					selectionType: "vertex", // Changed from "point" to "vertex" to match 2D and ContextMenuManager
				};
				minDistance = distance;
			}
		}

		return closestMatch;
	}

	// Step 13j.1e) Handle multi-point entities (lines and polygons)
	if (entity.entityType === "line" || entity.entityType === "poly") {
		const points = entity.data;
		if (points.length < 2) return null;

		// Step 13j.1e.1) Determine segment index from userData or by finding closest segment
		let segmentIndex = userData.segmentIndex;
		if (segmentIndex === undefined) {
			// Step 13j.1e.1a) Find closest segment to clicked position
			const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;
			let closestSegment = null;
			let minSegmentDistance = tolerance;

			for (let i = 0; i < numSegments; i++) {
				const point1 = points[i];
				const point2 = points[(i + 1) % points.length]; // Wrap for polygons

				// Step 13j.1e.1a.1) Skip segments where either endpoint is hidden
				if (point1.visible === false || point2.visible === false) continue;

				// Calculate distance from click to line segment
				const segmentDistance = pointToLineSegmentDistance(worldPos.x, worldPos.y, point1.pointXLocation, point1.pointYLocation, point2.pointXLocation, point2.pointYLocation);

				if (segmentDistance <= tolerance && segmentDistance < minSegmentDistance) {
					closestSegment = i;
					minSegmentDistance = segmentDistance;
				}
			}

			if (closestSegment !== null) {
				segmentIndex = closestSegment;
			} else {
				// Step 13j.1e.1b) If no segment found, check vertices
				let closestVertex = null;
				let minVertexDistance = tolerance;

				for (let i = 0; i < points.length; i++) {
					const point = points[i];
					// Step 13j.1e.1b.1) Skip hidden vertices
					if (point.visible === false) continue;
					const distance = Math.sqrt(Math.pow(point.pointXLocation - worldPos.x, 2) + Math.pow(point.pointYLocation - worldPos.y, 2));

					if (distance <= tolerance && distance < minVertexDistance) {
						closestVertex = i;
						minVertexDistance = distance;
					}
				}

				if (closestVertex !== null) {
					// Return vertex selection
					const point = points[closestVertex];
					return {
						...point,
						mapType: "allKADDrawingsMap",
						entityName: entityName,
						entityType: entity.entityType,
						elementIndex: closestVertex,
						segmentIndex: closestVertex,
						selectionType: "vertex",
					};
				}

				return null;
			}
		}

		// Step 13j.1e.2) Return segment selection
		const point1 = points[segmentIndex];
		const closestPoint = getClosestPointOnLineSegment(worldPos.x, worldPos.y, point1.pointXLocation, point1.pointYLocation, points[(segmentIndex + 1) % points.length].pointXLocation, points[(segmentIndex + 1) % points.length].pointYLocation);

		return {
			...point1, // Use first point's properties as base
			mapType: "allKADDrawingsMap",
			entityName: entityName,
			entityType: entity.entityType,
			elementIndex: segmentIndex,
			segmentIndex: segmentIndex,
			selectionType: "segment",
			clickedX: closestPoint.x,
			clickedY: closestPoint.y,
		};
	}

	return null;
}

// Helper function to check if a clicked KAD object is currently selected
function isKADObjectSelected(clickedObject) {
	if (!clickedObject) return false;

	// Check against selectedKADObject
	if (selectedKADObject) {
		return selectedKADObject.entityName === clickedObject.entityName && selectedKADObject.elementIndex === clickedObject.elementIndex && selectedKADObject.entityType === clickedObject.entityType;
	}

	// Check against selectedKADPolygon (backward compatibility)
	if (selectedKADPolygon && clickedObject.entityType === "poly") {
		return selectedKADPolygon.entityName === clickedObject.entityName;
	}

	return false;
}

// ENHANCED: Unified KAD Property Editor with FloatingDialog and hide functionality
// MOVED TO KADContextMenu.js - These functions are now loaded from external module
// showKADPropertyEditorPopup, showMultipleKADPropertyEditor, convertLinePolyType, updateKADObjectProperties
// END OF MOVED FUNCTIONS - KAD functions now loaded from KADContextMenu.js

// Helper to update KAD object in map
function updateKADObjectInMap(kadObject) {
	const map = window[kadObject.mapType]; // Get the map (, etc.)
	const entity = map.get(kadObject.entityName);

	if (entity) {
		// Find and update the specific object
		const objectIndex = entity.data.findIndex((item) => item.pointID === kadObject.pointID && item.pointXLocation === kadObject.pointXLocation && item.pointYLocation === kadObject.pointYLocation);

		if (objectIndex !== -1) {
			entity.data[objectIndex] = kadObject;
		}
	}
}

// MOVED TO SurfacesContextMenu.js - This function is now loaded from external module
// END OF MOVED FUNCTION - showSurfaceContextMenu now loaded from SurfacesContextMenu.js

// Add this helper function near your other menu functions
function safeRemoveMenu(menu) {
	try {
		if (menu && document.body.contains(menu)) {
			document.body.removeChild(menu);
		}
	} catch (error) {
		// Menu already removed or not found - ignore
		console.log("Menu already removed");
	}
}

// Update the polygon tool event listener to properly handle conflicts
selectByPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		// Step 1) Check if in 3D mode - use 3D polygon selection
		if (onlyShowThreeJS) {
			console.log("üî∂ Enabling 3D polygon selection mode");

			// Step 1a.1) Reset other tool buttons (mutual exclusion)
			// Fixes QUIRK 3: SelectPointer and SelectPolygon should turn each other off
			resetFloatingToolbarButtons("selectByPolygonTool");

			// Step 1a.2) Explicitly disable Select Pointer tool
			isSelectionPointerActive = false;
			selectPointerTool.checked = false;

			// Step 1b) Initialize 3D polygon selection if needed
			if (!window.polygonSelection3D) {
				window.polygonSelection3D = new PolygonSelection3D(threeRenderer);
			}

			// Step 1c) Enable 3D polygon selection
			window.polygonSelection3D.enable();

			// Step 1d) Update status message
			updateStatusMessage("3D Polygon selection mode enabled\nClick to add vertices.\nDouble-click to complete selection.");

			return;
		}

		// Step 2) 2D polygon selection mode (EXISTING CODE)
		// Uncheck the other buttons
		resetFloatingToolbarButtons("selectByPolygonTool");
		endKadTools(true);
		clearAllSelectionState();
		isPolygonSelectionActive = true;
		selectedHole = null;
		selectedPoint = null;
		//selectedMultiplePoints = []
		isDraggingHole = false;

		// Remove conflicting listeners
		removeAllCanvasListenersKeepDefault();
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["selectByPolygonTool", "defaultListeners"]);
		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		canvas.addEventListener("touchend", handleTouchEnd);

		// ** IMPORTANT - NEVER remove the mouseListeners
		// canvas.removeEventListener("mousemove", handleMouseMove);
		// canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("mousemove", handleMouseMove);
		// canvas.addEventListener("touchmove", handleTouchMove);

		// Add polygon selection listeners
		canvas.addEventListener("click", selectInsidePolygon);
		canvas.addEventListener("dblclick", completePolygonSelection);
		canvas.addEventListener("touchstart", selectInsidePolygonTouch);
		canvas.addEventListener("mousemove", handlePolygonMouseMove);

		// Clear any existing selection
		polyPointsX = [];
		polyPointsY = [];
		selectedMultipleHoles = [];
		updateStatusMessage("Polygon selection mode enabled\nClick to encircle holes.\nDouble-click to complete selection.");
	} else {
		// Step 3) Disable polygon selection
		if (onlyShowThreeJS && window.polygonSelection3D) {
			// Disable 3D polygon selection
			window.polygonSelection3D.disable();
			updateStatusMessage("");
		} else {
			// Disable 2D polygon selection (EXISTING CODE)
			isPolygonSelectionActive = false;

			// Remove polygon listeners
			canvas.removeEventListener("click", selectInsidePolygon);
			canvas.removeEventListener("dblclick", completePolygonSelection);
			canvas.removeEventListener("touchstart", selectInsidePolygonTouch);
			canvas.removeEventListener("mousemove", handlePolygonMouseMove);

			// Clear polygon points
			polyPointsX = [];
			polyPointsY = [];
			drawData(allBlastHoles, selectedHole);
			updateStatusMessage("");
		}
	}
});

function selectInsidePolygon(event) {
	if (!isPolygonSelectionActive) return;

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Remove right-click completion - now handled by double-click

	// Left click - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Improved point-in-polygon test
//! NOW USES THE UNIFIED ISPOINTINPOLYGON FUNCTION
function isPointInPolygon(x, y, polyX, polyY) {
	let inside = false;
	const nvert = polyX.length;

	for (let i = 0, j = nvert - 1; i < nvert; j = i++) {
		// Convert polygon coordinates to match hole coordinates
		if (polyY[i] > y != polyY[j] > y && x < ((polyX[j] - polyX[i]) * (y - polyY[i])) / (polyY[j] - polyY[i]) + polyX[i]) {
			inside = !inside;
		}
	}

	return inside;
}

// Create a new touch handler for polygon selection
function selectInsidePolygonTouch(event) {
	if (!isPolygonSelectionActive) return;

	event.preventDefault(); // Prevent default touch behavior

	const rect = canvas.getBoundingClientRect();
	const touch = event.touches[0] || event.changedTouches[0];
	const clickX = touch.clientX - rect.left;
	const clickY = touch.clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	// Two finger tap to finish polygon and select holes
	if (event.touches.length >= 2) {
		if (polyPointsX.length >= 3) {
			// Clear existing selection
			selectedMultipleHoles = [];

			// Check ALL holes against the polygon
			allBlastHoles.forEach((hole) => {
				if (!hole) return;

				// Get hole coordinates
				const holeX = hole.startXLocation;
				const holeY = hole.startYLocation;

				// console.log("Checking hole:", point.holeID, "at:", holeX, holeY, "against polygon with points:", polyPointsX.length);

				if (isPointInPolygon(holeX, holeY, polyPointsX, polyPointsY)) {
					selectedMultipleHoles.push(hole);
					// console.log("Selected hole:", hole.holeID);
				}
			});

			// Update averages and sliders after selection
			if (selectedMultipleHoles.length > 0) {
				updateSelectionAveragesAndSliders(selectedMultipleHoles);
			}

			console.log("Total holes selected:", selectedMultipleHoles.length);
		}

		// Clear the polygon after selection
		polyPointsX = [];
		polyPointsY = [];
		drawData(allBlastHoles, selectedHole);
		return;
	}

	// Single finger tap - add point to polygon
	polyPointsX.push(worldX);
	polyPointsY.push(worldY);

	// If this is the first point, duplicate it for the moving point
	if (polyPointsX.length === 1) {
		polyPointsX.push(worldX);
		polyPointsY.push(worldY);
	} else {
		// Update the last point (moving point)
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
	}

	drawData(allBlastHoles, selectedHole);
}

// Add mouse move handler for live polygon preview
function handlePolygonMouseMove(event) {
	if (!isPolygonSelectionActive || polyPointsX.length === 0) return;

	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;

	// Convert mouse coordinates to world coordinates
	const worldX = (mouseX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(mouseY - canvas.height / 2) / currentScale + centroidY;

	// Update the last point (moving point)
	if (polyPointsX.length > 0) {
		polyPointsX[polyPointsX.length - 1] = worldX;
		polyPointsY[polyPointsY.length - 1] = worldY;
		drawData(allBlastHoles, selectedHole);
	}
}

//use the same function for the resetView in the resetViewTool
resetViewTool.addEventListener("change", function () {
	if (this.checked) {
		resetZoom();
		drawData(allBlastHoles, selectedHole);
		resetViewTool.checked = false;
	}
});

// #region CUSTOM CSV
//---------------- CUSTOM STRUCTURED CSV IMPORTER - FLOATING DIALOG ONLY ----------------//
fileInputCustomCSV.addEventListener("change", function () {
	const file = this.files[0];
	if (file && file.name.toLowerCase().endsWith(".csv")) {
		Papa.parse(file, {
			skipEmptyLines: true,
			complete: (results) => showCsvImportModal(results.data, file.name),
			error: (error) => {
				const errorDialog = new FloatingDialog({
					title: "Error",
					content: "Could not parse the CSV file: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false,
				});
				errorDialog.show();
			},
		});
	} else if (file) {
		const warningDialog = new FloatingDialog({
			title: "Invalid File",
			content: "Please select a valid .csv file.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false,
		});
		warningDialog.show();
		this.value = "";
	}
});

// ============================================================================
// #region CUSTOM CSV IMPORT/EXPORT - EXTRACTED TO FILEMANAGER
// ============================================================================
// EXTRACTION DATE: 2026-01-04
// EXTRACTION SCOPE: ~3,080 lines (29783-32795)
//
// MOVED TO: src/fileIO/TextIO/CustomBlastHoleTextParser.js (~1,100 lines)
//           src/fileIO/TextIO/CustomBlastHoleTextWriter.js (~220 lines)
//
// WHAT WAS EXTRACTED:
// 1. HOLE_FIELD_MAPPING schema (23 fields with validation) - lines 29783-30001
// 2. processCsvData() and helper functions - lines 30421-30568
// 3. updateHoleFromCsvData() - field mapping and validation
// 4. setHoleDefaults() - default value application
// 5. calculateMissingGeometry() + 14 geometry calculation helpers
// 6. improvedSmartRowDetection() + 49 row detection algorithms - lines 32339-32795
//
// WHAT REMAINS IN KIRRA.JS (UI orchestration):
// 1. fileInputCustomCSV event listener (Papa.parse) - lines 29718-29777
// 2. showCsvImportModal() - FloatingDialog UI - lines 30573-30986
// 3. setupCsvDialogEventListeners() - DOM manipulation - lines 30989-31294
// 4. getColumnOrderFromForm() - form extraction - lines 31296-31308
//
// HOW TO USE THE NEW PARSER:
//   const CustomCSVParser = window.fileManager.parsers.get("custom-csv");
//   const parser = new CustomCSVParser({
//     allBlastHoles: allBlastHoles,
//     developerModeEnabled: developerModeEnabled || false
//   });
//   const result = parser.processCsvData(csvData, columnMapping, fileName);
//   const importedHoles = result.holes;
//   parser.improvedSmartRowDetection(holes, entityName);
//
// NOTE: The code below is marked for potential removal in a future cleanup.
//       It is currently retained for backward compatibility and reference.
// ============================================================================

// ===================================================================
// FIELD MAPPING STRUCTURE (EXTRACTED - See CustomBlastHoleTextParser.js)
// ===================================================================

const HOLE_FIELD_MAPPING = {
	entityName: {
		property: "entityName",
		type: "string",
		default: "Imported_Blast",
		required: false,
		validation: function (value) {
			return true;
		},
	},
	holeID: {
		property: "holeID",
		type: "string",
		required: true,
		validation: function (value) {
			return value && value.trim().length > 0;
		},
	},
	startXLocation: {
		property: "startXLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	startYLocation: {
		property: "startYLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	startZLocation: {
		property: "startZLocation",
		type: "number",
		required: true,
		validation: function (value) {
			return !isNaN(parseFloat(value));
		},
	},
	endXLocation: {
		property: "endXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	endYLocation: {
		property: "endYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	endZLocation: {
		property: "endZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeXLocation: {
		property: "gradeXLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeYLocation: {
		property: "gradeYLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	gradeZLocation: {
		property: "gradeZLocation",
		type: "number",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || !isNaN(parseFloat(value));
		},
	},
	holeDiameter: {
		property: "holeDiameter",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	holeAngle: {
		property: "holeAngle",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= -90 && parseFloat(value) <= 90);
		},
	},
	holeBearing: {
		property: "holeBearing",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0 && parseFloat(value) < 360);
		},
	},
	holeLengthCalculated: {
		property: "holeLengthCalculated",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	subdrillAmount: {
		property: "subdrillAmount",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	benchHeight: {
		property: "benchHeight",
		type: "number",
		default: 10,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	holeType: {
		property: "holeType",
		type: "string",
		default: "Production",
		validation: function (value) {
			return true;
		},
	},
	rowID: {
		property: "rowID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		},
	},
	posID: {
		property: "posID",
		type: "integer",
		default: null,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseInt(value)) && parseInt(value) > 0);
		},
	},
	fromHoleID: {
		property: "fromHoleID",
		type: "string",
		default: null,
		validation: function (value) {
			return true;
		},
	},
	timingDelayMilliseconds: {
		property: "timingDelayMilliseconds",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	holeTime: {
		property: "holeTime",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	colorHexDecimal: {
		property: "colorHexDecimal",
		type: "string",
		default: "red",
		validation: function (value) {
			return true;
		},
	},
	measuredLength: {
		property: "measuredLength",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	measuredMass: {
		property: "measuredMass",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	measuredComment: {
		property: "measuredComment",
		type: "string",
		default: "None",
		validation: function (value) {
			return true;
		},
	},
	entityType: {
		property: "entityType",
		type: "string",
		default: "hole",
		validation: function (value) {
			return true;
		},
	},
	subdrillLength: {
		property: "subdrillLength",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)));
		},
	},
	burden: {
		property: "burden",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	spacing: {
		property: "spacing",
		type: "number",
		default: 0,
		validation: function (value) {
			return value === null || value === undefined || (!isNaN(parseFloat(value)) && parseFloat(value) >= 0);
		},
	},
	measuredLengthTimeStamp: {
		property: "measuredLengthTimeStamp",
		type: "string",
		default: "09/05/1975 00:00:00",
		validation: function (value) {
			return true;
		},
	},
	measuredMassTimeStamp: {
		property: "measuredMassTimeStamp",
		type: "string",
		default: "09/05/1975 00:00:00",
		validation: function (value) {
			return true;
		},
	},
	measuredCommentTimeStamp: {
		property: "measuredCommentTimeStamp",
		type: "string",
		default: "09/05/1975 00:00:00",
		validation: function (value) {
			return true;
		},
	},
};

/**
 * Enhanced updateHoleFromCsvData function that properly calculates geometry
 */
function updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit) {
	// Update basic properties first
	Object.keys(HOLE_FIELD_MAPPING).forEach(function (fieldName) {
		const mapping = HOLE_FIELD_MAPPING[fieldName];
		const rawValue = getValue(fieldName);

		// Skip if no value provided and not required
		if ((rawValue === undefined || rawValue === null || rawValue === "") && !mapping.required) {
			if (hole[mapping.property] === undefined && mapping.default !== null) {
				hole[mapping.property] = mapping.default;
			}
			return;
		}

		// Validate the value
		if (!mapping.validation(rawValue)) {
			console.warn("Invalid value for field " + fieldName + ": " + rawValue);
			if (mapping.required) {
				throw new Error("Invalid value for required field " + fieldName + ": " + rawValue);
			}
			return;
		}

		// Convert and assign the value
		let convertedValue;
		switch (mapping.type) {
			case "number":
				convertedValue = parseFloat(rawValue);
				// Handle diameter units
				if (fieldName === "holeDiameter" && !isNaN(convertedValue)) {
					switch (diameterUnit) {
						case "m":
							convertedValue = convertedValue * 1000;
							break;
						case "in":
							convertedValue = convertedValue * 25.4;
							break;
					}
				}
				// Handle angle convention
				if (fieldName === "holeAngle" && !isNaN(convertedValue)) {
					if (angleConvention === "dip") {
						convertedValue = 90 - convertedValue;
					}
				}
				break;
			case "integer":
				convertedValue = parseInt(rawValue);
				break;
			default:
				convertedValue = String(rawValue).trim();
				break;
		}

		hole[mapping.property] = convertedValue;
	});

	// Ensure all required properties exist
	setHoleDefaults(hole);

	// Step 3) Set timingDelayMilliseconds to holeTime
	// This ensures imported holes use hole time as their delay
	if (hole.holeTime !== undefined && !isNaN(hole.holeTime)) {
		hole.timingDelayMilliseconds = hole.holeTime;
	}

	// Calculate missing geometry - this is the key fix
	calculateMissingGeometry(hole);
}

// function calculateMissingGeometry(hole) {
//     const hasEndCoords = hole.endXLocation !== hole.startXLocation || hole.endYLocation !== hole.startYLocation || hole.endZLocation !== hole.startZLocation;

//     if (hasEndCoords && (hole.holeAngle === 0 || hole.holeBearing === 0 || hole.holeLengthCalculated === 0)) {
//         // Calculate from end coordinates - FIXED CALCULATIONS
//         const dx = hole.endXLocation - hole.startXLocation;
//         const dy = hole.endYLocation - hole.startYLocation;
//         const dz = hole.endZLocation - hole.startZLocation; // Note: should be negative for downward holes

//         const length = Math.sqrt(dx * dx + dy * dy + dz * dz);

//         if (length > 0) {
//             hole.holeLengthCalculated = length;

//             // FIXED: Proper bearing calculation
//             // 0? = North, 90? = East, 180? = South, 270? = West
//             let bearing = Math.atan2(dx, dy) * (180 / Math.PI);
//             if (bearing < 0) bearing += 360;
//             hole.holeBearing = bearing;

//             // FIXED: Proper angle calculation
//             // 0? = vertical down, 90? = horizontal
//             const horizontalDistance = Math.sqrt(dx * dx + dy * dy);
//             if (horizontalDistance > 0) {
//                 hole.holeAngle = Math.atan2(horizontalDistance, Math.abs(dz)) * (180 / Math.PI);
//             } else {
//                 hole.holeAngle = 0; // Vertical
//             }
//         }
//     } else if (!hasEndCoords || hole.holeLengthCalculated === 0) {
//         // Calculate from angle/bearing/length or set defaults
//         if (hole.holeLengthCalculated === 0) {
//             const benchHeight = hole.benchHeight || 10;
//             const subdrillAmount = hole.subdrillAmount || 1;
//             hole.holeLengthCalculated = benchHeight + subdrillAmount;
//         }

//         // FIXED: Proper coordinate calculation from angle and bearing
//         calculateHoleEndCoordinates(hole);
//     }
// }
// GEOMETRY CONFLICT RESOLUTION - Priority-based calculation
// Priority 1: CollarXYZ + ToeXYZ (coordinates take precedence - IGNORE L/A/B if provided)
// Priority 2: CollarXYZ + L/A/B + Subdrill (forward calculation)
// Priority 3: ToeXYZ + L/A/B + Subdrill (REVERSE calculation - back-calculate CollarXYZ)
// Priority 4: CollarXYZ + ToeXYZ (no subdrill - calculate L/A/B, estimate subdrill)
// Priority 5: CollarXYZ only (use defaults)
function calculateMissingGeometry(hole) {
	// Step 1) Determine what data we have
	var hasCollarXYZ = isValidCoordinate(hole.startXLocation) &&
		isValidCoordinate(hole.startYLocation) &&
		isValidCoordinate(hole.startZLocation);

	var hasToeXYZ = isValidCoordinate(hole.endXLocation) &&
		isValidCoordinate(hole.endYLocation) &&
		isValidCoordinate(hole.endZLocation) &&
		coordsDifferFromCollar(hole, "end");

	var hasLAB = (hole.holeLengthCalculated > 0) &&
		(hole.holeAngle !== undefined && hole.holeAngle !== null) &&
		(hole.holeBearing !== undefined && hole.holeBearing !== null);

	// Step 1b) Subdrill can be positive, zero, OR negative - all are valid
	var hasSubdrill = hole.subdrillAmount !== undefined &&
		hole.subdrillAmount !== null &&
		!isNaN(hole.subdrillAmount);

	// Step 2) PRIORITY 1: CollarXYZ + ToeXYZ (coordinates take precedence - IGNORE L/A/B)
	if (hasCollarXYZ && hasToeXYZ) {
		console.log("CSV Import: PRIORITY 1 - Using CollarXYZ + ToeXYZ (ignoring L/A/B if provided)");
		calculateFromCollarAndToe(hole, hasSubdrill);
		return;
	}

	// Step 3) PRIORITY 2: CollarXYZ + L/A/B + Subdrill (forward calculation)
	if (hasCollarXYZ && hasLAB && hasSubdrill) {
		console.log("CSV Import: PRIORITY 2 - Using CollarXYZ + L/A/B + Subdrill");
		calculateFromDesignParams(hole);
		return;
	}

	// Step 4) PRIORITY 3: ToeXYZ + L/A/B + Subdrill (REVERSE calculation)
	if (!hasCollarXYZ && hasToeXYZ && hasLAB && hasSubdrill) {
		console.log("CSV Import: PRIORITY 3 - REVERSE CALC - ToeXYZ + L/A/B -> CollarXYZ");
		calculateCollarFromToe(hole);
		return;
	}

	// Step 5) PRIORITY 4: CollarXYZ + L/A/B (no subdrill - calculate with default subdrill)
	if (hasCollarXYZ && hasLAB && !hasSubdrill) {
		console.log("CSV Import: PRIORITY 4 - Using CollarXYZ + L/A/B (default subdrill)");
		hole.subdrillAmount = 1; // Default subdrill
		calculateFromDesignParams(hole);
		return;
	}

	// Step 6) PRIORITY 5: CollarXYZ only (use defaults)
	if (hasCollarXYZ) {
		console.log("CSV Import: PRIORITY 5 - Using CollarXYZ only (applying defaults)");
		applyDefaultGeometry(hole);
		calculateFromDesignParams(hole);
		return;
	}

	// Step 7) No valid data - cannot calculate
	console.warn("CSV Import: No valid geometry data found for hole " + hole.holeID);
}

// Step 8) Helper: Check if coordinate is valid (not NaN, not undefined)
function isValidCoordinate(value) {
	return value !== undefined && value !== null && !isNaN(value);
}

// Step 9) Helper: Check if end/grade coordinates differ from collar
function coordsDifferFromCollar(hole, type) {
	if (type === "end") {
		return (hole.endXLocation !== hole.startXLocation ||
			hole.endYLocation !== hole.startYLocation ||
			hole.endZLocation !== hole.startZLocation);
	}
	return false;
}

// Step 10) Calculate Length, Angle, Bearing from CollarXYZ and ToeXYZ
function calculateFromCollarAndToe(hole, hasSubdrill) {
	var dx = hole.endXLocation - hole.startXLocation;
	var dy = hole.endYLocation - hole.startYLocation;
	var dz = hole.startZLocation - hole.endZLocation; // Positive = down

	// Step 10a) Calculate Length
	hole.holeLengthCalculated = Math.sqrt(dx * dx + dy * dy + dz * dz);

	if (hole.holeLengthCalculated > 0) {
		// Step 10b) Calculate Bearing: 0=North, 90=East (clockwise)
		var bearing = Math.atan2(dx, dy) * (180 / Math.PI);
		if (bearing < 0) bearing += 360;
		hole.holeBearing = bearing;

		// Step 10c) Calculate Angle: 0=vertical, 90=horizontal
		var horizontalDist = Math.sqrt(dx * dx + dy * dy);
		if (horizontalDist > 0) {
			hole.holeAngle = Math.atan2(horizontalDist, dz) * (180 / Math.PI);
		} else {
			hole.holeAngle = 0; // Vertical hole
		}

		// Step 10d) Calculate GradeXYZ from subdrill
		if (hasSubdrill) {
			// Step 10d-i) Use provided subdrill (respects 0, positive, AND negative values)
			calculateGradeFromSubdrill(hole);
		} else {
			// Step 10d-ii) No subdrill provided - estimate as 10% of length or 1m, whichever is smaller
			hole.subdrillAmount = Math.min(hole.holeLengthCalculated * 0.1, 1);
			calculateGradeFromSubdrill(hole);
		}

		// Step 10e) Calculate BenchHeight
		hole.benchHeight = hole.startZLocation - hole.gradeZLocation;
	}
}

// Step 11) Calculate GradeXYZ from ToeXYZ and Subdrill
function calculateGradeFromSubdrill(hole) {
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);
	var subdrill = hole.subdrillAmount || 0;

	// Step 11a) subdrill is the VERTICAL distance (gradeZ - toeZ)
	// Calculate horizontal displacement using tan(angle)
	var subdrillVertical = subdrill;
	var subdrillHorizontal = subdrill * Math.tan(angleRad);

	hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.sin(bearingRad);
	hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.cos(bearingRad);
	hole.gradeZLocation = hole.endZLocation + subdrillVertical;
}

// Step 12) Calculate ToeXYZ and GradeXYZ from design parameters (CollarXYZ + L/A/B + Subdrill)
function calculateFromDesignParams(hole) {
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);

	// Step 12a) Calculate horizontal and vertical components
	var horizontalDist = hole.holeLengthCalculated * Math.sin(angleRad);
	var verticalDist = hole.holeLengthCalculated * Math.cos(angleRad);

	// Step 12b) Calculate ToeXYZ (end coordinates)
	hole.endXLocation = hole.startXLocation + horizontalDist * Math.sin(bearingRad);
	hole.endYLocation = hole.startYLocation + horizontalDist * Math.cos(bearingRad);
	hole.endZLocation = hole.startZLocation - verticalDist; // Going down

	// Step 12c) Calculate GradeXYZ from subdrill
	calculateGradeFromSubdrill(hole);

	// Step 12d) Calculate BenchHeight
	hole.benchHeight = hole.startZLocation - hole.gradeZLocation;
}

// Step 13) Apply default geometry values
function applyDefaultGeometry(hole) {
	if (!hole.holeLengthCalculated || hole.holeLengthCalculated <= 0) {
		var benchHeight = hole.benchHeight || 10;
		var subdrill = hole.subdrillAmount || 1;
		hole.holeLengthCalculated = benchHeight + subdrill;
	}
	if (hole.holeAngle === undefined || hole.holeAngle === null) {
		hole.holeAngle = 0; // Vertical
	}
	if (hole.holeBearing === undefined || hole.holeBearing === null) {
		hole.holeBearing = 0; // North
	}
	if (hole.subdrillAmount === undefined || hole.subdrillAmount === null) {
		hole.subdrillAmount = 1;
	}
}

// Step 14) REVERSE GEOMETRY: Calculate CollarXYZ from ToeXYZ + Length + Angle + Bearing + Subdrill
// This is used when importing data that only has toe coordinates (end of hole)
function calculateCollarFromToe(hole) {
	var length = hole.holeLengthCalculated;
	var angleRad = hole.holeAngle * (Math.PI / 180);
	var bearingRad = hole.holeBearing * (Math.PI / 180);
	var subdrill = hole.subdrillAmount || 0;

	// Step 14a) Calculate horizontal and vertical components
	var horizontalDist = length * Math.sin(angleRad);
	var verticalDist = length * Math.cos(angleRad);

	// Step 14b) Back-calculate CollarXYZ from ToeXYZ (reverse direction)
	// Toe is at the END (endXYZ), Collar is at the START (startXYZ)
	// Collar = Toe - (direction vector)
	// Direction is: start -> end = (horizontal * sin(bearing), horizontal * cos(bearing), -vertical)
	// So reverse: Collar = Toe - direction = Toe - (horizontal * sin(bearing), horizontal * cos(bearing), -vertical)
	hole.startXLocation = hole.endXLocation - horizontalDist * Math.sin(bearingRad);
	hole.startYLocation = hole.endYLocation - horizontalDist * Math.cos(bearingRad);
	hole.startZLocation = hole.endZLocation + verticalDist; // Up from toe (add because going up)

	// Step 14c) Calculate GradeXYZ (subdrill amount above toe along hole direction)
	// subdrill is the VERTICAL distance (gradeZ - toeZ)
	var subdrillVertical = subdrill;
	var subdrillHorizontal = subdrill * Math.tan(angleRad);

	hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.sin(bearingRad);
	hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.cos(bearingRad);
	hole.gradeZLocation = hole.endZLocation + subdrillVertical;

	// Step 14d) Calculate BenchHeight = CollarZ - GradeZ
	hole.benchHeight = hole.startZLocation - hole.gradeZLocation;

	console.log("Reverse geometry calculated: CollarZ=" + hole.startZLocation.toFixed(2) +
		", GradeZ=" + hole.gradeZLocation.toFixed(2) +
		", ToeZ=" + hole.endZLocation.toFixed(2) +
		", BenchHeight=" + hole.benchHeight.toFixed(2));
}

function calculateHoleEndCoordinates(hole) {
	const angleRad = hole.holeAngle * (Math.PI / 180);
	const bearingRad = hole.holeBearing * (Math.PI / 180);

	// FIXED: Proper bearing to direction calculation
	// Bearing: 0? = North (positive Y), 90? = East (positive X)
	const horizontalDistance = hole.holeLengthCalculated * Math.sin(angleRad);
	const verticalDistance = hole.holeLengthCalculated * Math.cos(angleRad);

	// Calculate end coordinates
	hole.endXLocation = hole.startXLocation + horizontalDistance * Math.sin(bearingRad);
	hole.endYLocation = hole.startYLocation + horizontalDistance * Math.cos(bearingRad);
	hole.endZLocation = hole.startZLocation - verticalDistance; // Going down

	// Calculate grade coordinates
	// Step 1) Calculate actual bench height: total length minus subdrill
	const subdrillAmount = hole.subdrillAmount || 0;
	const actualBenchHeight = hole.holeLengthCalculated - subdrillAmount;

	// ALTERATION: Fixed grade coordinate calculation to use sin/cos instead of tan
	// This matches the calculation pattern used for end coordinates and ensures consistency
	// Previous code used Math.tan() which was incorrect - grade should use same trig functions as end coordinates
	// Step 2) Calculate grade coordinates at the actual bench height
	const gradeAngleRad = hole.holeAngle * (Math.PI / 180);
	const gradeHorizontalDistance = actualBenchHeight * Math.sin(gradeAngleRad);
	const gradeVerticalDistance = actualBenchHeight * Math.cos(gradeAngleRad);

	hole.gradeXLocation = hole.startXLocation + gradeHorizontalDistance * Math.sin(bearingRad);
	hole.gradeYLocation = hole.startYLocation + gradeHorizontalDistance * Math.cos(bearingRad);
	hole.gradeZLocation = hole.startZLocation - gradeVerticalDistance;
}

/**
 * Set default properties and ensure all required fields are populated
 */
function setHoleDefaults(hole) {
	hole.entityType = "hole";
	if (hole.visible === undefined) hole.visible = true;
	if (!hole.fromHoleID || hole.fromHoleID === null) {
		hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
	}
	if (!hole.measuredLengthTimeStamp) hole.measuredLengthTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredMassTimeStamp) hole.measuredMassTimeStamp = "09/05/1975 00:00:00";
	if (!hole.measuredCommentTimeStamp) hole.measuredCommentTimeStamp = "09/05/1975 00:00:00";

	// Ensure numeric properties are valid
	const numericProps = ["startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeLengthCalculated", "holeAngle", "holeBearing", "holeDiameter", "subdrillAmount", "benchHeight", "timingDelayMilliseconds", "holeTime", "measuredLength", "measuredMass"];

	numericProps.forEach(function (prop) {
		if (isNaN(hole[prop])) {
			switch (prop) {
				case "startXLocation":
				case "startYLocation":
				case "startZLocation":
					throw new Error("Invalid coordinates for hole " + hole.holeID);
				case "endXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "endYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "endZLocation":
					hole[prop] = hole.startZLocation;
					break;
				case "gradeXLocation":
					hole[prop] = hole.startXLocation;
					break;
				case "gradeYLocation":
					hole[prop] = hole.startYLocation;
					break;
				case "gradeZLocation":
					hole[prop] = hole.startZLocation - 10;
					break;
				case "holeLengthCalculated":
					hole[prop] = 10;
					break;
				case "benchHeight":
					hole[prop] = 10;
					break;
				default:
					hole[prop] = 0;
					break;
			}
		}
	});
}

/**
 * Main CSV processing function
 */
function processCsvData(data, columnOrder, fileName) {
	const entityName = fileName.split(".")[0] || "Imported_Blast_" + Math.floor(Math.random() * 16777215).toString(16);
	const headerRows = parseInt(columnOrder.headerRows, 10) || 0;
	const angleConvention = columnOrder.angle_convention || "angle";
	const diameterUnit = columnOrder.diameter_unit || "mm";
	const duplicateHandling = columnOrder.duplicate_handling || "update-blast-hole";

	const addedHoles = [];
	const updatedHoles = [];

	// Process each data row
	data.slice(headerRows).forEach(function (row, index) {
		const getValue = function (colName) {
			const colIndex = columnOrder[colName];
			if (colIndex !== undefined && colIndex !== null && colIndex !== "" && colIndex !== "0") {
				const val = row[parseInt(colIndex, 10) - 1];
				return val !== undefined && val !== null ? String(val).trim() : undefined;
			}
			return undefined;
		};

		// Validate mandatory fields
		const holeID = getValue("holeID");
		const startX = parseFloat(getValue("startXLocation"));
		const startY = parseFloat(getValue("startYLocation"));
		const startZ = parseFloat(getValue("startZLocation"));

		if (!holeID || isNaN(startX) || isNaN(startY) || isNaN(startZ)) {
			console.warn("Skipping row " + (index + headerRows + 1) + ": Missing mandatory fields");
			return;
		}

		const holeEntityName = getValue("entityName") || entityName;
		let rowID = getValue("rowID");
		let posID = getValue("posID");

		//Add all the undeclared values.
		let burden = getValue("burden");
		let spacing = getValue("spacing");
		let connectorCurve = getValue("connectorCurve");
		let measuredLength = getValue("measuredLength");
		let measuredMass = getValue("measuredMass");
		let measuredComment = getValue("measuredComment");
		let measuredLengthTimeStamp = getValue("measuredLengthTimeStamp");
		let measuredMassTimeStamp = getValue("measuredMassTimeStamp");
		let measuredCommentTimeStamp = getValue("measuredCommentTimeStamp");
		let colorHexDecimal = getValue("colorHexDecimal");
		let holeTime = getValue("holeTime");
		let timingDelayMilliseconds = getValue("timingDelayMilliseconds");
		let fromHoleID = getValue("fromHoleID");
		let holeType = getValue("holeType");
		let holeLengthCalculated = getValue("holeLengthCalculated");
		let holeAngle = getValue("holeAngle");
		let holeBearing = getValue("holeBearing");
		let holeDiameter = getValue("holeDiameter");
		let subdrillAmount = getValue("subdrillAmount");
		let subdrillLength = getValue("subdrillLength");
		let benchHeight = getValue("benchHeight");

		if (rowID && !isNaN(rowID)) rowID = parseInt(rowID);
		else rowID = null;
		if (posID && !isNaN(posID)) posID = parseInt(posID);
		else posID = null;

		// Check for duplicates
		let existingHoleIndex = -1;
		let isUpdate = false;
		let hole = null;

		if (duplicateHandling === "update-blast-hole") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return h.entityName === holeEntityName && h.holeID === holeID;
			});
		} else if (duplicateHandling === "update-location") {
			existingHoleIndex = allBlastHoles.findIndex(function (h) {
				return Math.abs(h.startXLocation - startX) <= 0.01 && Math.abs(h.startYLocation - startY) <= 0.01;
			});
		}

		if (existingHoleIndex !== -1 && duplicateHandling !== "skip") {
			hole = allBlastHoles[existingHoleIndex];
			isUpdate = true;
		} else if (existingHoleIndex !== -1 && duplicateHandling === "skip") {
			return;
		} else {
			// Create new hole
			hole = {
				entityName: holeEntityName,
				entityType: "hole",
				holeID: holeID,
				startXLocation: startX,
				startYLocation: startY,
				startZLocation: startZ,
				endXLocation: startX,
				endYLocation: startY,
				endZLocation: startZ,
				gradeXLocation: startX,
				gradeYLocation: startY,
				gradeZLocation: startZ - 10,
				subdrillAmount: subdrillAmount || 0,
				subdrillLength: subdrillLength || 0,
				benchHeight: benchHeight || 10,
				holeDiameter: holeDiameter || 0,
				holeType: holeType || "Production",
				fromHoleID: fromHoleID || holeEntityName + ":::" + holeID,
				timingDelayMilliseconds: timingDelayMilliseconds || 0,
				colorHexDecimal: colorHexDecimal || "red",
				holeLengthCalculated: holeLengthCalculated || 0,
				holeAngle: holeAngle || 0,
				holeBearing: holeBearing || 0,
				holeTime: holeTime || 0,
				measuredLength: measuredLength || 0,
				measuredLengthTimeStamp: measuredLengthTimeStamp || "09/05/1975 00:00:00",
				measuredMass: measuredMass || 0,
				measuredMassTimeStamp: measuredMassTimeStamp || "09/05/1975 00:00:00",
				measuredComment: measuredComment || "None",
				measuredCommentTimeStamp: measuredCommentTimeStamp || "09/05/1975 00:00:00",
				visible: true,
				rowID: rowID,
				posID: posID,
				burden: burden || 0,
				spacing: spacing || 0,
				connectorCurve: connectorCurve || 0,
			};
		}

		// Update hole properties
		try {
			updateHoleFromCsvData(hole, getValue, angleConvention, diameterUnit);
		} catch (error) {
			console.error("Error updating hole " + holeID + ":", error);
			return;
		}

		// Add to tracking arrays
		if (isUpdate) {
			updatedHoles.push(hole);
		} else {
			allBlastHoles.push(hole);
			addedHoles.push(hole);
		}
	});

	const importedHoles = addedHoles.concat(updatedHoles);
	console.log("CSV Import Results: added=" + addedHoles.length + ", updated=" + updatedHoles.length);

	return importedHoles;
}

/**
 * FloatingDialog CSV Import Modal with Aesthetic Groupings and Two Tables
 * 
 */
//TODO: THIS showCsvImportModal needs to be extracted to the src/dialog/generic folder.
function showCsvImportModal(csvData, fileName) {
	if (!csvData || csvData.length === 0) {
		const errorDialog = new FloatingDialog({
			title: "Empty File",
			content: "The selected CSV file is empty or could not be read.",
			layoutType: "default",
			width: 300,
			height: 120,
			showConfirm: true,
			confirmText: "OK",
			showCancel: false,
		});
		errorDialog.show();
		return;
	}

	const headerRowForPreview = csvData[0];
	const columnOptions = headerRowForPreview
		.map(function (header, index) {
			return '<option value="' + (index + 1) + '">Col ' + (index + 1) + ": " + header + "</option>";
		})
		.join("");
	const ignoreOption = '<option value="0">-- calculate --</option>';

	// Define field groups for aesthetic organization
	const fieldGroups = [
		{
			title: "Hole Identifiers",
			fields: [
				{ name: "entityName", label: "Blast Name", required: false },
				{ name: "holeID", label: "Hole ID*", required: true },
				{ name: "holeType", label: "Hole Type", required: false },
				{ name: "rowID", label: "Row ID", required: false },
				{ name: "posID", label: "Position ID", required: false },
			],
		},
		{
			title: "Hole Location - Collar",
			fields: [
				{ name: "startXLocation", label: "Start X(mE)*", required: true },
				{ name: "startYLocation", label: "Start Y(mN)*", required: true },
				{ name: "startZLocation", label: "Start Z(mRL)*", required: true },
			],
		},
		{
			title: "Hole Location - End/Toe",
			fields: [
				{ name: "endXLocation", label: "End X(mE)", required: false },
				{ name: "endYLocation", label: "End Y(mN)", required: false },
				{ name: "endZLocation", label: "End Z(mRL)", required: false },
			],
		},
		{
			title: "Hole Location - Grade",
			fields: [
				{ name: "gradeXLocation", label: "Grade X(mE)", required: false },
				{ name: "gradeYLocation", label: "Grade Y(mN)", required: false },
				{ name: "gradeZLocation", label: "Grade Z(mRL)", required: false },
			],
		},
		{
			title: "Hole Geometry",
			fields: [
				{ name: "holeAngle", label: "Hole Angle/Dip", required: false },
				{ name: "holeBearing", label: "Hole Bearing", required: false },
				{ name: "holeLengthCalculated", label: "Hole Length", required: false },
				{ name: "benchHeight", label: "Bench Height(m)", required: false },
				{ name: "subdrillAmount", label: "Subdrill(m)", required: false },
				{ name: "holeDiameter", label: "Diameter", required: false },
			],
		},
		{
			title: "Timing & Connections",
			fields: [
				{ name: "fromHoleID", label: "From Hole ID", required: false },
				{
					name: "timingDelayMilliseconds",
					label: "Timing Delay",
					required: false,
				},
				{ name: "colorHexDecimal", label: "Tie Color", required: false },
				{ name: "initiationTime", label: "Initiation Time", required: false },
			],
		},
		{
			title: "Measured Values",
			fields: [
				{ name: "measuredLength", label: "Measured Length", required: false },
				{ name: "measuredMass", label: "Measured Mass", required: false },
				{ name: "measuredComment", label: "Measured Comment", required: false },
			],
		},
	];

	// Create main content container
	const mainContainer = document.createElement("div");
	mainContainer.style.display = "flex";
	mainContainer.style.flexDirection = "column";
	mainContainer.style.height = "100%";

	// Header section with file info and basic settings
	const headerSection = document.createElement("div");
	headerSection.style.padding = "10px";
	headerSection.style.borderBottom = "1px solid var(--light-mode-border)";
	headerSection.className = "button-container-2col";

	headerSection.innerHTML =
		'<label class="labelWhite15"><strong>File:</strong> ' +
		fileName +
		"</label>" +
		"<div></div>" +
		'<label class="labelWhite15"><strong>Rows:</strong> ' +
		csvData.length +
		"</label>" +
		'<label class="labelWhite15"><strong>Columns:</strong> ' +
		csvData[0].length +
		"</label>" +
		'<label class="labelWhite12">Header rows to skip:</label>' +
		'<input type="number" id="csv-header-rows" value="1" min="0" max="10">' +
		'<label class="labelWhite12">Column Detection:</label>' +
		'<select id="csv-column-detection">' +
		'<option value="auto">Auto detect columns</option>' +
		'<option value="last-used">Use last used column order</option>' +
		'<option value="manual">Manual - don\'t detect columns</option>' +
		"</select>" +
		'<label class="labelWhite12">Auto-detect spatial rows:</label>' +
		'<input type="checkbox" id="csv-auto-detect-rows" checked>' +
		'<label class="labelWhite12">Duplicate Handling:</label>' +
		"<div>" +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-blast-hole" checked> Update by Blast+ID</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="update-location"> Update by location</label><br>' +
		'<label class="labelWhite12"><input type="radio" name="csv-duplicate-handling" value="skip"> Skip duplicates</label>' +
		"</div>" +
		'<label class="labelWhite12">Angle Convention:</label>' +
		'<select id="csv-angle-convention">' +
		'<option value="angle">Angle (0¬∞ = vertical)</option>' +
		'<option value="dip">Dip (0¬∞ = horizontal)</option>' +
		"</select>" +
		'<label class="labelWhite12">Diameter Units:</label>' +
		'<select id="csv-diameter-unit">' +
		'<option value="mm">mm</option>' +
		'<option value="m">m</option>' +
		'<option value="in">inches</option>' +
		"</select>";

	// Content area with three panels: mapping, original data, mapped data
	const contentArea = document.createElement("div");
	contentArea.style.flex = "1";
	contentArea.style.display = "flex";
	contentArea.style.overflow = "hidden";

	// Left panel - Field mapping with groups
	const leftPanel = document.createElement("div");
	leftPanel.style.width = "40%";
	leftPanel.style.padding = "10px";
	leftPanel.style.overflowY = "auto";
	leftPanel.style.borderRight = "1px solid var(--light-mode-border)";

	const mappingTitle = document.createElement("h3");
	mappingTitle.textContent = "Column Mapping";
	mappingTitle.className = "labelWhite15";
	mappingTitle.style.margin = "0 0 10px 0";
	leftPanel.appendChild(mappingTitle);

	// Add field groups to left panel
	fieldGroups.forEach(function (group) {
		const groupDiv = document.createElement("div");
		groupDiv.style.marginBottom = "15px";
		groupDiv.style.border = "1px solid var(--light-mode-border)";
		groupDiv.style.borderRadius = "4px";
		groupDiv.style.padding = "8px";

		const groupTitle = document.createElement("h4");
		groupTitle.textContent = group.title;
		groupTitle.className = "labelWhite12";
		groupTitle.style.margin = "0 0 8px 0";
		groupTitle.style.fontWeight = "bold";
		groupTitle.style.borderBottom = "1px solid var(--light-mode-border)";
		groupTitle.style.paddingBottom = "4px";
		groupDiv.appendChild(groupTitle);

		const fieldsContainer = document.createElement("div");
		fieldsContainer.className = "button-container-2col";

		group.fields.forEach(function (field) {
			const label = document.createElement("label");
			label.textContent = field.label;
			label.className = "labelWhite12";

			const select = document.createElement("select");
			select.id = "csv-col-" + field.name;
			select.name = field.name;

			if (!field.required) {
				select.innerHTML = ignoreOption + columnOptions;
			} else {
				select.innerHTML = columnOptions;
			}

			fieldsContainer.appendChild(label);
			fieldsContainer.appendChild(select);
		});

		groupDiv.appendChild(fieldsContainer);
		leftPanel.appendChild(groupDiv);
	});

	// Right panel - Data previews
	const rightPanel = document.createElement("div");
	rightPanel.style.width = "60%";
	rightPanel.style.padding = "10px";
	rightPanel.style.overflowY = "auto";
	rightPanel.style.display = "flex";
	rightPanel.style.flexDirection = "column";

	// Original data table
	const originalTitle = document.createElement("h4");
	originalTitle.textContent = "Original Data Preview";
	originalTitle.className = "labelWhite12";
	originalTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(originalTitle);

	const originalTableContainer = document.createElement("div");
	originalTableContainer.style.maxHeight = "200px";
	originalTableContainer.style.overflow = "auto";
	originalTableContainer.style.border = "1px solid var(--light-mode-border)";
	originalTableContainer.style.marginBottom = "15px";

	const originalTable = document.createElement("table");
	originalTable.style.width = "100%";
	originalTable.style.borderCollapse = "collapse";
	originalTable.style.fontSize = "10px";

	const originalThead = document.createElement("thead");
	const originalTbody = document.createElement("tbody");
	originalThead.id = "csv-original-headers";
	originalTbody.id = "csv-original-body";

	originalTable.appendChild(originalThead);
	originalTable.appendChild(originalTbody);
	originalTableContainer.appendChild(originalTable);
	rightPanel.appendChild(originalTableContainer);

	// Mapped data table
	const mappedTitle = document.createElement("h4");
	mappedTitle.textContent = "Mapped Data Preview";
	mappedTitle.className = "labelWhite12";
	mappedTitle.style.margin = "0 0 5px 0";
	rightPanel.appendChild(mappedTitle);

	const mappedTableContainer = document.createElement("div");
	mappedTableContainer.style.maxHeight = "200px";
	mappedTableContainer.style.overflow = "auto";
	mappedTableContainer.style.border = "1px solid var(--light-mode-border)";
	mappedTableContainer.style.marginBottom = "10px";

	const mappedTable = document.createElement("table");
	mappedTable.style.width = "100%";
	mappedTable.style.borderCollapse = "collapse";
	mappedTable.style.fontSize = "10px";

	const mappedThead = document.createElement("thead");
	const mappedTbody = document.createElement("tbody");
	mappedThead.id = "csv-mapped-headers";
	mappedTbody.id = "csv-mapped-body";

	mappedTable.appendChild(mappedThead);
	mappedTable.appendChild(mappedTbody);
	mappedTableContainer.appendChild(mappedTable);
	rightPanel.appendChild(mappedTableContainer);

	// Assemble main container
	mainContainer.appendChild(headerSection);
	contentArea.appendChild(leftPanel);
	contentArea.appendChild(rightPanel);
	mainContainer.appendChild(contentArea);

	// Create the dialog
	const dialog = new FloatingDialog({
		title: "Import CSV: Map Columns",
		content: mainContainer,
		layoutType: "wide",
		width: 1200,
		height: 700,
		showConfirm: true,
		showCancel: true,
		confirmText: "Import",
		cancelText: "Cancel",
		onConfirm: function () {
			try {
				// Step 1) Get column mapping from form
				const columnOrder = getColumnOrderFromForm();

				// Step 2) Use FileManager Custom CSV parser
				const CustomCSVParser = window.fileManager.parsers.get("custom-csv");
				if (!CustomCSVParser) {
					throw new Error("Custom CSV parser not found in FileManager");
				}

				// Step 3) Instantiate parser with dependencies
				const parser = new CustomCSVParser({
					allBlastHoles: allBlastHoles,
					developerModeEnabled: developerModeEnabled || false
				});

				// Step 4) Parse CSV data
				const result = parser.processCsvData(csvData, columnOrder, fileName);
				const importedHoles = result.holes;

				if (importedHoles && importedHoles.length > 0) {
					// CRITICAL: Recalculate everything after import like existing code does
					let sumX = 0,
						sumY = 0;
					allBlastHoles.forEach(function (hole) {
						sumX += hole.startXLocation;
						sumY += hole.startYLocation;
					});
					centroidX = sumX / allBlastHoles.length;
					centroidY = sumY / allBlastHoles.length;

					// Step 0a) Emit centroid to HUD overlay (includes Z from calculateDataCentroid)
					var fullCentroid = calculateDataCentroid();
					emitCentroid(fullCentroid.x, fullCentroid.y, fullCentroid.z);

					// Step 1) Apply smart row detection to imported holes (using parser method)
					const entitiesForRowDetection = new Map();
					importedHoles.forEach(function (hole) {
						if (!entitiesForRowDetection.has(hole.entityName)) {
							entitiesForRowDetection.set(hole.entityName, []);
						}
						entitiesForRowDetection.get(hole.entityName).push(hole);
					});

					// Step 2) Run smart row detection for each entity using parser
					entitiesForRowDetection.forEach(function (holes, entityName) {
						parser.improvedSmartRowDetection(holes, entityName);
					});

					// Step 3) Auto-assign rowID/posID for holes that still don't have them
					const unassignedHoles = importedHoles.filter(function (hole) {
						return hole.rowID === null || hole.rowID === 0 || hole.posID === null || hole.posID === 0;
					});
					unassignedHoles.forEach(function (hole) {
						if (!hole.rowID || hole.rowID === 0) {
							hole.rowID = getNextRowID(hole.entityName);
						}
						if (!hole.posID || hole.posID === 0) {
							hole.posID = 1;
						}
					});

					// Step 4) Calculate burden and spacing for holes that need it
					// Group imported holes by entity that need burden/spacing calculation
					const entitiesToCalculate = new Map();
					importedHoles.forEach(function (hole) {
						// Only recalculate if default value of 1 (preserve user-supplied values including 0)
						const needsCalculation =
							(hole.burden === undefined || hole.burden === null || hole.burden === 1) &&
							(hole.spacing === undefined || hole.spacing === null || hole.spacing === 1);

						if (needsCalculation) {
							if (!entitiesToCalculate.has(hole.entityName)) {
								entitiesToCalculate.set(hole.entityName, []);
							}
							entitiesToCalculate.get(hole.entityName).push(hole);
						}
					});

					// Calculate burden/spacing for each entity
					entitiesToCalculate.forEach(function (holes, entityName) {
						if (holes.length > 0) {
							console.log("Calculating burden/spacing for " + holes.length + " holes in entity: " + entityName);
							calculateBurdenAndSpacingForHoles(holes);
						}
					});

					// Recalculate dependent data structures - ESSENTIAL for proper display
					if (allBlastHoles.length > 0) {
						const triangleResult = delaunayTriangles(allBlastHoles, maxEdgeLength);
						holeTimes = calculateTimes(allBlastHoles);

						// Recalculate contours
						const contourResult = recalculateContours(allBlastHoles, deltaX, deltaY);
						contourLinesArray = contourResult.contourLinesArray;
						directionArrows = contourResult.directionArrows;
					}

					// Update displays
					timeChart();
					// Step #) Trigger 3D rebuild to show imported CSV data immediately
					window.threeDataNeedsRebuild = true;
					drawData(allBlastHoles, null);

					// Update tree view if available
					if (typeof debouncedUpdateTreeView === "function") {
						debouncedUpdateTreeView();
					}

					const successDialog = new FloatingDialog({
						title: "Successful Import",
						content: "Imported " + importedHoles.length + " holes successfully.",
						layoutType: "default",
						width: 300,
						height: 120,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false,
					});
					successDialog.show();
				} else {
					const errorDialog = new FloatingDialog({
						title: "Failed Import",
						content: "No valid holes could be imported. Please check your column mapping and file format.",
						layoutType: "default",
						width: 400,
						height: 140,
						showConfirm: true,
						confirmText: "OK",
						showCancel: false,
					});
					errorDialog.show();
				}
			} catch (error) {
				console.error("Import error:", error);
				const errorDialog = new FloatingDialog({
					title: "Import Error",
					content: "An error occurred during import: " + error.message,
					layoutType: "default",
					width: 400,
					height: 140,
					showConfirm: true,
					confirmText: "OK",
					showCancel: false,
				});
				errorDialog.show();
			}

			// Step 4) Save imported holes to IndexedDB
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}

			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		},
		onCancel: function () {
			// Reset file input
			document.getElementById("fileInputCustomCSV").value = "";
		},
	});

	// Show the dialog
	dialog.show();

	// Set up event listeners and auto-detection after dialog is shown
	setupCsvDialogEventListeners(csvData, fieldGroups);
}

// Helper function to set up event listeners
function setupCsvDialogEventListeners(csvData, fieldGroups) {
	// Get saved column order from localStorage
	let savedColumnOrder = {};
	try {
		savedColumnOrder = JSON.parse(localStorage.getItem("csvColumnOrder") || "{}");
	} catch (e) {
		console.warn("Error parsing saved column order:", e);
		savedColumnOrder = {};
	}

	// Auto-mapping keywords
	const mappingKeywords = {
		entityName: ["blast", "pattern", "blast name", "pattern name", "blastid"],
		holeID: ["id", "holeid", "holeno", "name", "holename", "pointid", "no", "hole id"],
		startXLocation: ["x", "cx", "easting", "collar x", "startx", "start easting", "start east", "start x"],
		startYLocation: ["y", "cy", "northing", "collar y", "starty", "start northing", "start north", "start y"],
		startZLocation: ["z", "cz", "rl", "collar z", "elevation", "zcoord", "startz", "start elevation", "start z"],
		endXLocation: ["endx", "toex", "end easting", "end east", "tx", "end x", "toe x"],
		endYLocation: ["endy", "toey", "end northing", "end north", "ty", "end y", "toe y"],
		endZLocation: ["endz", "toez", "toerl", "end elevation", "tz", "end z", "toe z"],
		gradeXLocation: ["gradex", "grade easting", "grade east", "gx", "grade x"],
		gradeYLocation: ["gradey", "grade northing", "grade north", "gy", "grade y"],
		gradeZLocation: ["gradez", "grade elevation", "gz", "grade z"],
		holeDiameter: ["diameter", "dia", "diam", "holediameter", "hole diameter"],
		subdrillAmount: ["subdrill", "subdrill amount", "sub drill amount", "sub drill"],
		benchHeight: ["bench", "benchheight", "bench height"],
		holeType: ["type", "holetype", "hole type", "material type", "materialtype"],
		holeLengthCalculated: ["length", "holelength", "hole length"],
		holeBearing: ["bearing", "azimuth", "azi", "bea", "heading", "holebearing", "hole bearing"],
		holeAngle: ["angle", "dip", "mast angle", "holeangle", "hole angle"],
		rowID: ["rowid", "row id", "row", "echelon", "rowno", "row number"],
		posID: ["posid", "pos id", "position", "pos", "position id", "pos number", "posno"],
		holeTime: ["initiation", "initiationtime", "initiation time", "firing time", "firingtime", "holetime", "hole time"],
		fromHoleID: ["from", "fromhole", "from hole", "tie from", "tiefrom"],
		timingDelayMilliseconds: ["delay", "timing", "timingdelay", "timing delay", "ms", "milliseconds"],
		colorHexDecimal: ["color", "colour", "tie color", "tiecolor"],
		measuredLength: ["measured length", "measuredlength", "actual length", "actuallength"],
		measuredMass: ["measured mass", "measuredmass", "actual mass", "actualmass", "kg", "weight"],
		measuredComment: ["comment", "comments", "note", "notes", "measured comment"],
	};

	const headerRow = csvData[0].map(function (h) {
		return String(h || "")
			.toLowerCase()
			.replace(/[^a-z0-9]/g, "");
	});

	// Function to update both data previews
	const updateBothPreviews = function () {
		updateOriginalPreview();
		updateMappedPreview();
	};

	// Function to update original data preview
	const updateOriginalPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-original-headers");
		const previewBody = document.getElementById("csv-original-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Add headers
		if (csvData.length > 0) {
			csvData[0].forEach(function (header, index) {
				const th = document.createElement("th");
				th.textContent = "Col " + (index + 1) + ": " + header;
				th.style.padding = "4px 6px";
				th.style.border = "1px solid var(--light-mode-border)";
				th.style.backgroundColor = "rgba(50,50,50,0.3)";
				th.style.fontSize = "10px";
				th.className = "labelWhite12";
				previewHeaders.appendChild(th);
			});
		}

		// Add preview rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			row.forEach(function (cell) {
				const td = document.createElement("td");
				td.textContent = cell || "";
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";
				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});
	};

	// Function to update mapped data preview
	const updateMappedPreview = function () {
		const headerCount = parseInt(document.getElementById("csv-header-rows").value, 10) || 0;
		const previewHeaders = document.getElementById("csv-mapped-headers");
		const previewBody = document.getElementById("csv-mapped-body");

		if (!previewHeaders || !previewBody) return;

		previewHeaders.innerHTML = "";
		previewBody.innerHTML = "";

		// Get current mapping
		const mappedFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				const selectEl = document.getElementById("csv-col-" + field.name);
				if (selectEl && selectEl.value !== "0") {
					mappedFields.push({
						name: field.name,
						label: field.label,
						columnIndex: parseInt(selectEl.value) - 1,
						required: field.required,
					});
				}
			});
		});

		// Add mapped headers
		mappedFields.forEach(function (field) {
			const th = document.createElement("th");
			th.textContent = field.label + (field.required ? " *" : "");
			th.style.padding = "4px 6px";
			th.style.border = "1px solid var(--light-mode-border)";
			th.style.backgroundColor = "rgba(50,50,50,0.3)";
			th.style.fontSize = "10px";
			th.className = "labelWhite12";
			if (field.required) {
				th.style.fontWeight = "bold";
			}
			previewHeaders.appendChild(th);
		});

		// Add mapped data rows (5 rows max)
		csvData.slice(headerCount, headerCount + 5).forEach(function (row) {
			const tr = document.createElement("tr");
			mappedFields.forEach(function (field) {
				const td = document.createElement("td");
				const cellValue = row[field.columnIndex] || "";
				td.textContent = cellValue;
				td.style.padding = "2px 6px";
				td.style.border = "1px solid var(--light-mode-border)";
				td.style.backgroundColor = "rgba(50,50,50,0.15";
				td.style.fontSize = "10px";
				td.className = "labelWhite12";

				// Highlight missing required fields
				if (field.required && (!cellValue || cellValue.trim() === "")) {
					td.style.backgroundColor = "rgba(255, 107, 107, 0.3)";
				}

				tr.appendChild(td);
			});
			previewBody.appendChild(tr);
		});

		// Show message if no fields are mapped
		if (mappedFields.length === 0) {
			const tr = document.createElement("tr");
			const td = document.createElement("td");
			td.colSpan = 1;
			td.textContent = "No fields mapped. Please select columns for the required fields.";
			td.style.textAlign = "center";
			td.style.fontStyle = "italic";
			td.style.padding = "10px";
			td.className = "labelWhite12";
			tr.appendChild(td);
			previewBody.appendChild(tr);
		}
	};

	// Function to apply auto-detection
	const applyAutoDetection = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			const keywords = mappingKeywords[field.name] || [];
			const colIndex = headerRow.findIndex(function (header) {
				return keywords.some(function (kw) {
					return header.includes(kw);
				});
			});

			if (colIndex !== -1) {
				selectEl.value = (colIndex + 1).toString();
			} else {
				selectEl.value = "0";
			}
		});

		updateMappedPreview();
	};

	// Function to apply last used settings
	const applyLastUsed = function () {
		const allFields = [];
		fieldGroups.forEach(function (group) {
			group.fields.forEach(function (field) {
				allFields.push(field);
			});
		});

		allFields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (!selectEl) return;

			if (savedColumnOrder[field.name]) {
				selectEl.value = savedColumnOrder[field.name];
			}
		});

		// Apply saved settings for other fields
		if (savedColumnOrder.angle_convention) {
			const angleEl = document.getElementById("csv-angle-convention");
			if (angleEl) angleEl.value = savedColumnOrder.angle_convention;
		}

		if (savedColumnOrder.diameter_unit) {
			const diameterEl = document.getElementById("csv-diameter-unit");
			if (diameterEl) diameterEl.value = savedColumnOrder.diameter_unit;
		}

		updateMappedPreview();
	};

	// Set up column detection dropdown listener
	const columnDetectionSelect = document.getElementById("csv-column-detection");
	if (columnDetectionSelect) {
		columnDetectionSelect.addEventListener("change", function (e) {
			if (e.target.value === "auto") {
				applyAutoDetection();
			} else if (e.target.value === "last-used") {
				applyLastUsed();
			}
			// For "manual", do nothing - let user set manually
		});
	}

	// Set up header rows input listener
	const headerRowsEl = document.getElementById("csv-header-rows");
	if (headerRowsEl) {
		headerRowsEl.addEventListener("input", updateBothPreviews);
	}

	// Set up listeners for all select dropdowns to update mapped preview
	fieldGroups.forEach(function (group) {
		group.fields.forEach(function (field) {
			const selectEl = document.getElementById("csv-col-" + field.name);
			if (selectEl) {
				selectEl.addEventListener("change", updateMappedPreview);
			}
		});
	});

	// Initialize both previews and apply initial detection
	updateBothPreviews();
	applyAutoDetection();
}

// Helper function to get column order from form
function getColumnOrderFromForm() {
	const headerRowsEl = document.getElementById("csv-header-rows");
	const angleConventionEl = document.getElementById("csv-angle-convention");
	const diameterUnitEl = document.getElementById("csv-diameter-unit");
	const autoDetectRowsEl = document.getElementById("csv-auto-detect-rows");

	const order = {
		headerRows: headerRowsEl ? headerRowsEl.value : "1",
		angle_convention: angleConventionEl ? angleConventionEl.value : "angle",
		diameter_unit: diameterUnitEl ? diameterUnitEl.value : "mm",
		auto_detect_rows: autoDetectRowsEl ? autoDetectRowsEl.checked : true,
	};

	// Get duplicate handling option
	const duplicateHandling = document.querySelector('input[name="csv-duplicate-handling"]:checked');
	order.duplicate_handling = duplicateHandling ? duplicateHandling.value : "update-blast-hole";

	// Get all field mappings
	const allFieldNames = ["entityName", "holeID", "startXLocation", "startYLocation", "startZLocation", "endXLocation", "endYLocation", "endZLocation", "gradeXLocation", "gradeYLocation", "gradeZLocation", "holeDiameter", "subdrillAmount", "benchHeight", "holeType", "holeLengthCalculated", "holeBearing", "holeAngle", "rowID", "posID", "initiationTime", "fromHoleID", "timingDelayMilliseconds", "colorHexDecimal", "measuredLength", "measuredMass", "measuredComment"];

	allFieldNames.forEach(function (fieldName) {
		const selectEl = document.getElementById("csv-col-" + fieldName);
		order[fieldName] = selectEl ? selectEl.value : "0";
	});

	// Save the column order to localStorage for future use
	try {
		localStorage.setItem("csvColumnOrder", JSON.stringify(order));
	} catch (e) {
		console.warn("Error saving column order to localStorage:", e);
	}

	return order;
}

/**
 * Custom CSV Export Dialog - Select columns and configure export options
 */
function showCustomCsvExportModal() {
	// Step 1) Get visible holes to export
	var visibleHoles = window.allBlastHoles.filter(function (hole) {
		return window.isHoleVisible(hole);
	});

	if (visibleHoles.length === 0) {
		showModalMessage("No Data", "No visible holes to export", "warning");
		return;
	}

	// Step 2) Define available columns (ALL blast hole fields)
	var availableColumns = [
		// Identifiers
		{ name: "entityName", label: "Blast Name", group: "Identifiers" },
		{ name: "entityType", label: "Entity Type", group: "Identifiers" },
		{ name: "holeID", label: "Hole ID", group: "Identifiers" },
		{ name: "holeType", label: "Hole Type", group: "Identifiers" },
		{ name: "rowID", label: "Row ID", group: "Identifiers" },
		{ name: "posID", label: "Position ID", group: "Identifiers" },
		// Collar (Start)
		{ name: "startXLocation", label: "Start X (mE)", group: "Collar" },
		{ name: "startYLocation", label: "Start Y (mN)", group: "Collar" },
		{ name: "startZLocation", label: "Start Z (mRL)", group: "Collar" },
		// Toe (End)
		{ name: "endXLocation", label: "End X (mE)", group: "Toe" },
		{ name: "endYLocation", label: "End Y (mN)", group: "Toe" },
		{ name: "endZLocation", label: "End Z (mRL)", group: "Toe" },
		// Grade
		{ name: "gradeXLocation", label: "Grade X (mE)", group: "Grade" },
		{ name: "gradeYLocation", label: "Grade Y (mN)", group: "Grade" },
		{ name: "gradeZLocation", label: "Grade Z (mRL)", group: "Grade" },
		// Geometry
		{ name: "holeAngle", label: "Hole Angle (0¬∞ = vertical)", group: "Geometry" },
		{ name: "holeDip", label: "Hole Dip (0¬∞ = horizontal)", group: "Geometry" },
		{ name: "holeBearing", label: "Hole Bearing", group: "Geometry" },
		{ name: "holeLengthCalculated", label: "Hole Length", group: "Geometry" },
		{ name: "holeDiameter", label: "Diameter", group: "Geometry" },
		{ name: "subdrillAmount", label: "Subdrill Amount", group: "Geometry" },
		{ name: "subdrillLength", label: "Subdrill Length", group: "Geometry" },
		{ name: "benchHeight", label: "Bench Height", group: "Geometry" },
		{ name: "burden", label: "Burden", group: "Geometry" },
		{ name: "spacing", label: "Spacing", group: "Geometry" },
		// Timing
		{ name: "fromHoleID", label: "From Hole ID", group: "Timing" },
		{ name: "timingDelayMilliseconds", label: "Timing Delay (ms)", group: "Timing" },
		{ name: "holeTime", label: "Initiation Time", group: "Timing" },
		{ name: "colorHexDecimal", label: "Tie Color", group: "Timing" },
		// Measured
		{ name: "measuredLength", label: "Measured Length", group: "Measured" },
		{ name: "measuredLengthTimeStamp", label: "Measured Length Timestamp", group: "Measured" },
		{ name: "measuredMass", label: "Measured Mass", group: "Measured" },
		{ name: "measuredMassTimeStamp", label: "Measured Mass Timestamp", group: "Measured" },
		{ name: "measuredComment", label: "Measured Comment", group: "Measured" },
		{ name: "measuredCommentTimeStamp", label: "Measured Comment Timestamp", group: "Measured" }
	];

	// Step 3) Load saved preferences or use defaults
	var savedPrefs = localStorage.getItem("kirra_csv_export_prefs");
	var selectedColumns, diameterUnit, subdrillNegative, includeHeaders, customHeaders, customFields;

	if (savedPrefs) {
		try {
			var prefs = JSON.parse(savedPrefs);
			selectedColumns = prefs.columnOrder || ["holeID", "startXLocation", "startYLocation", "startZLocation", "holeAngle", "holeBearing", "holeLengthCalculated", "holeDiameter", "subdrillAmount", "benchHeight", "rowID", "posID"];
			diameterUnit = prefs.diameterUnit || "mm";
			subdrillNegative = prefs.subdrillNegative || false;
			includeHeaders = prefs.includeHeaders !== false; // Default true
			customHeaders = prefs.customHeaders || {}; // Map of column name to custom header
			customFields = prefs.customFields || []; // Array of {enabled, name, value}
		} catch (e) {
			console.warn("Failed to parse CSV export preferences:", e);
			selectedColumns = ["holeID", "startXLocation", "startYLocation", "startZLocation", "holeAngle", "holeBearing", "holeLengthCalculated", "holeDiameter", "subdrillAmount", "benchHeight", "rowID", "posID"];
			diameterUnit = "mm";
			subdrillNegative = false;
			includeHeaders = true;
			customHeaders = {};
			customFields = [];
		}
	} else {
		selectedColumns = ["holeID", "startXLocation", "startYLocation", "startZLocation", "holeAngle", "holeBearing", "holeLengthCalculated", "holeDiameter", "subdrillAmount", "benchHeight", "rowID", "posID"];
		diameterUnit = "mm";
		subdrillNegative = false;
		includeHeaders = true;
		customHeaders = {};
		customFields = [];
	}

	// Step 4) Create dialog content with 2-column layout
	var contentHTML = '<div style="display: flex; flex-direction: column; height: 100%; overflow: hidden;">';

	// Generate default filename with fresh timestamp
	var entityName = visibleHoles.length > 0 && visibleHoles[0].entityName ? visibleHoles[0].entityName : "Blast";
	var timestamp = new Date().toISOString().slice(0, 19).replace(/[-:]/g, "").replace("T", "_");
	var defaultFilename = "CSV_" + entityName + "_" + timestamp;

	// Header section
	contentHTML += '<div style="padding: 10px; border-bottom: 1px solid var(--light-mode-border);" class="button-container-2col">';
	contentHTML += '<label class="labelWhite15">Filename (without .csv):</label>';
	contentHTML += '<input type="text" id="export-csv-filename" value="' + defaultFilename + '" style="width: 230px; padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += '<label class="labelWhite15"><strong>Holes to Export:</strong> ' + visibleHoles.length + '</label>';
	contentHTML += '<div></div>';
	contentHTML += '<label class="labelWhite12">Include column headers:</label>';
	contentHTML += '<input type="checkbox" id="export-csv-include-headers"' + (includeHeaders ? ' checked' : '') + '>';
	contentHTML += '<label class="labelWhite12">Convert diameter to:</label>';
	contentHTML += '<select id="export-csv-diameter-unit">';
	contentHTML += '<option value="mm"' + (diameterUnit === 'mm' ? ' selected' : '') + '>Millimeters</option>';
	contentHTML += '<option value="m"' + (diameterUnit === 'm' ? ' selected' : '') + '>Meters</option>';
	contentHTML += '<option value="in"' + (diameterUnit === 'in' ? ' selected' : '') + '>Inches</option>';
	contentHTML += '</select>';
	contentHTML += '<label class="labelWhite12">Convert subdrill to negative:</label>';
	contentHTML += '<input type="checkbox" id="export-csv-subdrill-negative"' + (subdrillNegative ? ' checked' : '') + '>';
	contentHTML += '</div>';

	// Main 2-column layout
	contentHTML += '<div style="display: flex; flex: 1; overflow: hidden; gap: 10px; padding: 10px;">';

	// LEFT COLUMN: Checkboxes for selecting columns
	contentHTML += '<div style="flex: 0 0 45%; overflow-y: auto; border-right: 2px solid var(--accent-color); padding-right: 10px;">';
	contentHTML += '<label class="labelWhite15" style="margin-bottom: 10px; display: block;"><strong>Select Columns to Export:</strong></label>';

	// Group columns by category
	var groups = {};
	for (var i = 0; i < availableColumns.length; i++) {
		var col = availableColumns[i];
		if (!groups[col.group]) groups[col.group] = [];
		groups[col.group].push(col);
	}

	// Render checkboxes grouped by category
	Object.keys(groups).forEach(function (groupName) {
		contentHTML += '<div style="margin-bottom: 15px;">';
		contentHTML += '<label class="labelWhite12" style="font-weight: bold; color: var(--accent-color);">' + groupName + ':</label><br>';

		groups[groupName].forEach(function (col) {
			var isChecked = selectedColumns.indexOf(col.name) !== -1 ? 'checked' : '';
			var customHeader = customHeaders[col.name] || '';
			contentHTML += '<div style="margin-left: 15px; margin-bottom: 3px; display: flex; align-items: center; gap: 5px;">';
			contentHTML += '<label class="labelWhite12" style="cursor: pointer; width: 210px; flex-shrink: 0;">';
			contentHTML += '<input type="checkbox" class="csv-export-checkbox" data-col-name="' + col.name + '" data-col-label="' + col.label + '" value="' + col.name + '" ' + isChecked + '> ';
			contentHTML += col.label;
			contentHTML += '</label>';
			contentHTML += '<input type="text" class="csv-custom-header" data-col-name="' + col.name + '" data-default-label="' + col.label + '" value="' + customHeader + '" placeholder="Custom header" style="width: 220px; padding: 2px 5px; font-size: 11px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; text-align: right;">';
			contentHTML += '</div>';
		});

		contentHTML += '</div>';
	});

	contentHTML += '</div>';

	// RIGHT COLUMN: Drag-and-drop column ordering
	contentHTML += '<div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">';
	contentHTML += '<label class="labelWhite15" style="margin-bottom: 10px;"><strong>Column Order (Drag to Reorder):</strong></label>';
	contentHTML += '<div id="csv-column-order-list" style="flex: 1; overflow-y: auto; background: var(--dark-mode-bg); border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 5px;">';
	contentHTML += '</div>';
	contentHTML += '</div>';

	contentHTML += '</div>';

	// Custom fields section at bottom
	contentHTML += '<div style="padding: 10px; border-top: 2px solid var(--accent-color);">';
	contentHTML += '<label class="labelWhite15" style="margin-bottom: 10px; display: block;"><strong>Custom Text Fields (3 maximum):</strong></label>';

	// Ensure we have at least 3 custom field objects
	while (customFields.length < 3) {
		customFields.push({ enabled: false, name: '', value: '' });
	}

	for (var i = 0; i < 3; i++) {
		var field = customFields[i];
		contentHTML += '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">';
		contentHTML += '<input type="checkbox" id="custom-field-' + i + '-enabled"' + (field.enabled ? ' checked' : '') + '>';
		contentHTML += '<label class="labelWhite12" style="min-width: 110px;">Custom Field #' + (i + 1) + ':</label>';
		contentHTML += '<label class="labelWhite12" style="min-width: 50px;">Name:</label>';
		contentHTML += '<input type="text" id="custom-field-' + i + '-name" value="' + (field.name || '') + '" placeholder="e.g., Instruction" style="flex: 1; padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '<label class="labelWhite12" style="min-width: 50px;">Value:</label>';
		contentHTML += '<input type="text" id="custom-field-' + i + '-value" value="' + (field.value || '') + '" placeholder="e.g., Over drill 0.2m for fall back" style="flex: 2; padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px;">';
		contentHTML += '</div>';
	}

	contentHTML += '</div>';
	contentHTML += '</div>';

	// Step 5) Create dialog
	var dialog = new FloatingDialog({
		title: "Custom CSV Export - Select Columns",
		content: contentHTML,
		layoutType: "default",
		width: 900,
		height: 800,
		showConfirm: true,
		showCancel: true,
		confirmText: "Export",
		cancelText: "Cancel",
		onConfirm: async function () {
			try {
				// Step 10) Get filename from input field
				var filenameElement = document.getElementById("export-csv-filename");
				if (!filenameElement) {
					showModalMessage("Export Error", "Filename input field not found in dialog", "error");
					return;
				}
				var filename = filenameElement.value.trim();

				// Ensure .csv extension
				if (!filename.toLowerCase().endsWith(".csv")) {
					filename += ".csv";
				}


				// Step 6) Get selected columns in order from the sortable list
				var orderList = document.getElementById("csv-column-order-list");
				var columnOrder = [];
				var items = orderList.querySelectorAll(".csv-column-item");

				for (var i = 0; i < items.length; i++) {
					columnOrder.push(items[i].getAttribute("data-col-name"));
				}

				if (columnOrder.length === 0) {
					showModalMessage("No Columns", "Please select at least one column to export", "warning");
					return;
				}

				// Step 7) Get export options
				var includeHeaders = document.getElementById("export-csv-include-headers").checked;
				var diameterUnit = document.getElementById("export-csv-diameter-unit").value;
				var subdrillNegative = document.getElementById("export-csv-subdrill-negative").checked;

				// Step 7a) Collect custom headers
				var customHeaders = {};
				var customHeaderInputs = document.querySelectorAll(".csv-custom-header");
				for (var i = 0; i < customHeaderInputs.length; i++) {
					var input = customHeaderInputs[i];
					var colName = input.getAttribute("data-col-name");
					var customHeader = input.value.trim();
					if (customHeader) {
						customHeaders[colName] = customHeader;
					}
				}

				// Step 7b) Collect custom fields (don't add to columnOrder - already in sortable list)
				var customFields = [];
				for (var i = 0; i < 3; i++) {
					var enabled = document.getElementById("custom-field-" + i + "-enabled").checked;
					var name = document.getElementById("custom-field-" + i + "-name").value.trim();
					var value = document.getElementById("custom-field-" + i + "-value").value.trim();
					customFields.push({ enabled: enabled, name: name, value: value });
				}

				// Step 8) Save preferences to localStorage
				localStorage.setItem("kirra_csv_export_prefs", JSON.stringify({
					columnOrder: columnOrder,
					diameterUnit: diameterUnit,
					subdrillNegative: subdrillNegative,
					includeHeaders: includeHeaders,
					customHeaders: customHeaders,
					customFields: customFields
				}));

				// Step 9) Use FileManager CustomBlastHoleTextWriter
				var Writer = window.fileManager.writers.get("custom-csv");
				if (!Writer) {
					throw new Error("Custom CSV writer not found in FileManager");
				}

				var writer = new Writer({
					columnOrder: columnOrder,
					diameterUnit: diameterUnit,
					subdrillNegative: subdrillNegative,
					includeHeaders: includeHeaders,
					customHeaders: customHeaders,
					customFields: customFields,
					decimalPlaces: 4,
					fieldMapping: HOLE_FIELD_MAPPING
				});

				// Step 9) Generate CSV
				var blob = await writer.write({ holes: visibleHoles });



				// Step 11) Try to use File System Access API for custom filename
				if (window.showSaveFilePicker) {
					try {
						var fileHandle = await window.showSaveFilePicker({
							suggestedName: filename,
							types: [{
								description: 'CSV Files',
								accept: { 'text/csv': ['.csv'] }
							}]
						});

						// Ensure filename has .csv extension
						var finalFilename = fileHandle.name;
						if (!finalFilename.toLowerCase().endsWith('.csv')) {
							finalFilename += '.csv';
						}

						var writable = await fileHandle.createWritable();
						await writable.write(blob);
						await writable.close();

						var message = "Exported " + visibleHoles.length + " holes with " + columnOrder.length + " columns to " + finalFilename;
						showModalMessage("Export Success", message, "success");
					} catch (error) {
						if (error.name !== 'AbortError') {
							console.error("File System Access API error:", error);
							// Fallback to standard download
							writer.downloadFile(blob, filename);
						}
						// If AbortError, user cancelled - do nothing
					}
				} else {
					// Fallback for browsers that don't support File System Access API
					writer.downloadFile(blob, filename);
				}

				console.log("Exported " + visibleHoles.length + " holes with " + columnOrder.length + " columns");
			} catch (error) {
				console.error("Custom CSV export error:", error);
				showModalMessage("Export Failed", "Error: " + error.message, "error");
			}
		}
	});

	dialog.show();

	// Initialize column order list after dialog is rendered
	setTimeout(function () {
		// Add enabled custom fields to selectedColumns before initializing
		for (var i = 0; i < customFields.length; i++) {
			if (customFields[i].enabled && customFields[i].name) {
				var customFieldKey = "customField" + i;
				if (selectedColumns.indexOf(customFieldKey) === -1) {
					selectedColumns.push(customFieldKey);
				}
			}
		}

		initializeCsvColumnOrder(availableColumns, selectedColumns);
	}, 100);
}

/**
 * Initialize CSV column order list with drag-and-drop functionality
 */
function initializeCsvColumnOrder(availableColumns, selectedColumns) {
	var orderList = document.getElementById("csv-column-order-list");
	if (!orderList) return;

	// Create a map for quick label lookup
	var columnMap = {};
	for (var i = 0; i < availableColumns.length; i++) {
		columnMap[availableColumns[i].name] = availableColumns[i].label;
	}

	// Function to get display label for a column (custom header or default)
	function getDisplayLabel(colName) {
		// Check if this is a custom field
		if (colName.startsWith("customField")) {
			var fieldIndex = parseInt(colName.replace("customField", ""));
			var nameInput = document.getElementById("custom-field-" + fieldIndex + "-name");
			return nameInput ? nameInput.value.trim() || "Custom Field #" + (fieldIndex + 1) : "Custom Field #" + (fieldIndex + 1);
		}

		// Check for custom header
		var customHeaderInput = document.querySelector('.csv-custom-header[data-col-name="' + colName + '"]');
		if (customHeaderInput && customHeaderInput.value.trim()) {
			return customHeaderInput.value.trim();
		}

		// Return default label
		return columnMap[colName] || colName;
	}

	// Function to render the column order list
	function renderColumnList() {
		orderList.innerHTML = "";

		// Get current selected columns from checkboxes
		var checkboxes = document.querySelectorAll(".csv-export-checkbox");
		var currentSelected = [];

		for (var i = 0; i < checkboxes.length; i++) {
			if (checkboxes[i].checked) {
				currentSelected.push(checkboxes[i].getAttribute("data-col-name"));
			}
		}

		// Merge with existing order (preserve order for columns that are still selected)
		var orderedColumns = [];
		for (var i = 0; i < selectedColumns.length; i++) {
			var colName = selectedColumns[i];
			// Include if it's checked OR if it's a custom field
			if (currentSelected.indexOf(colName) !== -1 || colName.startsWith("customField")) {
				orderedColumns.push(colName);
			}
		}

		// Add newly selected columns at the end
		for (var i = 0; i < currentSelected.length; i++) {
			if (orderedColumns.indexOf(currentSelected[i]) === -1) {
				orderedColumns.push(currentSelected[i]);
			}
		}

		// Update global selectedColumns
		selectedColumns.length = 0;
		for (var i = 0; i < orderedColumns.length; i++) {
			selectedColumns.push(orderedColumns[i]);
		}

		// Render each column as a draggable item
		for (var i = 0; i < orderedColumns.length; i++) {
			var colName = orderedColumns[i];
			var colLabel = getDisplayLabel(colName);

			var item = document.createElement("div");
			item.className = "csv-column-item";
			item.setAttribute("data-col-name", colName);
			item.setAttribute("draggable", "true");
			item.style.cssText = "padding: 8px; margin: 3px 0; background: var(--button-bg); border: 1px solid var(--light-mode-border); border-radius: 4px; cursor: move; user-select: none; display: flex; align-items: center; gap: 8px;";

			// Add drag handle icon
			var handle = document.createElement("span");
			handle.textContent = "‚ãÆ‚ãÆ";
			handle.style.cssText = "color: var(--accent-color); font-weight: bold;";
			item.appendChild(handle);

			// Add column number
			var number = document.createElement("span");
			number.textContent = (i + 1) + ".";
			number.style.cssText = "color: var(--accent-color); font-weight: bold; min-width: 25px;";
			item.appendChild(number);

			// Add column label
			var label = document.createElement("span");
			label.textContent = colLabel;
			label.style.cssText = "flex: 1; color: var(--text-color);";
			item.appendChild(label);

			// Add drag event listeners
			item.addEventListener("dragstart", handleDragStart);
			item.addEventListener("dragover", handleDragOver);
			item.addEventListener("drop", handleDrop);
			item.addEventListener("dragend", handleDragEnd);

			orderList.appendChild(item);
		}

		// Show message if no columns selected
		if (orderedColumns.length === 0) {
			orderList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-color); opacity: 0.6;">Select columns from the left to add them here</div>';
		}
	}

	// Drag and drop variables
	var draggedItem = null;

	function handleDragStart(e) {
		draggedItem = this;
		this.style.opacity = "0.5";
		e.dataTransfer.effectAllowed = "move";
	}

	function handleDragOver(e) {
		if (e.preventDefault) {
			e.preventDefault();
		}
		e.dataTransfer.dropEffect = "move";

		// Add visual feedback
		var items = orderList.querySelectorAll(".csv-column-item");
		for (var i = 0; i < items.length; i++) {
			items[i].style.borderColor = "var(--light-mode-border)";
		}

		if (this !== draggedItem && this.classList.contains("csv-column-item")) {
			this.style.borderColor = "var(--accent-color)";
		}

		return false;
	}

	function handleDrop(e) {
		if (e.stopPropagation) {
			e.stopPropagation();
		}

		if (draggedItem !== this && this.classList.contains("csv-column-item")) {
			// Get all items
			var items = Array.from(orderList.querySelectorAll(".csv-column-item"));
			var draggedIndex = items.indexOf(draggedItem);
			var targetIndex = items.indexOf(this);

			// Reorder the selectedColumns array
			var col = selectedColumns.splice(draggedIndex, 1)[0];
			selectedColumns.splice(targetIndex, 0, col);

			// Re-render
			renderColumnList();
		}

		return false;
	}

	function handleDragEnd(e) {
		this.style.opacity = "1";
		var items = orderList.querySelectorAll(".csv-column-item");
		for (var i = 0; i < items.length; i++) {
			items[i].style.borderColor = "var(--light-mode-border)";
		}
	}

	// Listen for checkbox changes
	var checkboxes = document.querySelectorAll(".csv-export-checkbox");
	for (var i = 0; i < checkboxes.length; i++) {
		checkboxes[i].addEventListener("change", renderColumnList);
	}

	// Listen for custom header input changes
	var customHeaderInputs = document.querySelectorAll(".csv-custom-header");
	for (var i = 0; i < customHeaderInputs.length; i++) {
		customHeaderInputs[i].addEventListener("input", renderColumnList);
	}

	// Listen for custom field checkbox and name changes
	for (var i = 0; i < 3; i++) {
		(function (fieldIndex) {
			var customFieldCheckbox = document.getElementById("custom-field-" + fieldIndex + "-enabled");
			var customFieldName = document.getElementById("custom-field-" + fieldIndex + "-name");
			var customFieldKey = "customField" + fieldIndex;

			var updateCustomField = function () {
				var isEnabled = customFieldCheckbox && customFieldCheckbox.checked;
				var hasName = customFieldName && customFieldName.value.trim();

				if (isEnabled && hasName) {
					// Add to selectedColumns if not already there
					if (selectedColumns.indexOf(customFieldKey) === -1) {
						selectedColumns.push(customFieldKey);
					}
				} else {
					// Remove from selectedColumns
					var index = selectedColumns.indexOf(customFieldKey);
					if (index !== -1) {
						selectedColumns.splice(index, 1);
					}
				}
				renderColumnList();
			};

			if (customFieldCheckbox) {
				customFieldCheckbox.addEventListener("change", updateCustomField);
			}

			if (customFieldName) {
				customFieldName.addEventListener("input", updateCustomField);
			}
		})(i);
	}

	// Initial render
	renderColumnList();
}

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// ===================================================================
// CONSOLIDATED SMART ROW DETECTION FUNCTIONS
// ===================================================================
// #region HDBSCAN-ROW-DETECTION

/**
 * SEQUENCE-BASED ROW DETECTION
 *
 * This function attempts to detect rows based on the naming/numbering pattern of hole IDs.
 * It analyzes the hole ID patterns and determines the best approach for grouping holes into rows.
 *
 * HOLE ID PATTERN ANALYSIS:
 * - Pure numeric (1, 2, 3, 4...) - Sequential numbered holes
 * - Alphanumeric (A1, A2, B1, B2...) - Letter+number combinations
 * - Mixed patterns - Combination of both
 * - Other patterns - Random text, symbols, etc.
 *
 * @param {Array} holesData - Array of hole objects with holeID properties
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection occurred, false if should fall back to spatial detection
 *
 * DETECTION CASES:
 * 1. All alphanumeric: Analyzes if letters represent rows (A1,A2,B1,B2) or types (I1,I2,B1,B2)
 * 2. Mixed numeric/alphanumeric: Sorts and applies spatial detection algorithms
 * 3. Pure numeric sequential: Applies geometric line-fitting or RDP algorithms
 */
function trySequenceBasedDetection(holesData, entityName) {
	// Initialize counters for different hole ID patterns
	let numericCount = 0; // Pure numbers: "1", "2", "123"
	let alphaNumericCount = 0; // Letter+number: "A1", "BUF5", "I23"
	let otherCount = 0; // Everything else: "Hole-A", "X", symbols

	// Analyze each hole ID to determine its pattern type
	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			// Regex matches pure numeric strings
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			// Regex matches one or more letters followed by one or more digits
			alphaNumericCount++;
		} else {
			// Everything that doesn't fit the above patterns
			otherCount++;
		}
	});

	// Log the pattern analysis for debugging
	console.log("Hole ID pattern analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
	});

	// CASE 1: ALL ALPHANUMERIC PATTERNS (A1, A2, B1, B2, etc.)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		// Delegate to specialized function that determines if letters are rows or hole types
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: MIXED NUMERIC AND ALPHANUMERIC PATTERNS
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");

		// Create a unified sequence for spatial detection since numbering is inconsistent
		// Give each hole a sequential number for geometric analysis
		const allHoles = holesData
			.map((hole, index) => ({ hole, num: index + 1 }))
			.sort((a, b) => {
				// Custom sort: pure numbers first (in numeric order), then alphanumeric (alphabetically)
				const aIsNum = /^\d+$/.test(a.hole.holeID);
				const bIsNum = /^\d+$/.test(b.hole.holeID);

				if (aIsNum && bIsNum) {
					// Both are numeric - sort numerically
					return parseInt(a.hole.holeID) - parseInt(b.hole.holeID);
				}
				if (aIsNum && !bIsNum) return -1; // Numeric comes before alphanumeric
				if (!aIsNum && bIsNum) return 1; // Alphanumeric comes after numeric
				// Both alphanumeric - sort alphabetically
				return a.hole.holeID.localeCompare(b.hole.holeID);
			});

		// Use spatial detection algorithms since sequence-based logic won't work reliably
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}

	// CASE 3: PURE NUMERIC SEQUENTIAL PATTERNS (1, 2, 3, 4...)
	// Convert hole IDs to numbers and sort them
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num)) // Remove any that couldn't be parsed as numbers
		.sort((a, b) => a.num - b.num); // Sort numerically

	// Validate that we have enough holes and all were numeric
	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		// Not all holes were numeric, or too few holes for pattern detection
		return false;
	}

	// Check if the sequence is continuous (1,2,3,4... with no gaps)
	const firstNum = numericHoles[0].num;
	const isSequential = numericHoles.every((item, index) => item.num === firstNum + index);

	if (!isSequential) {
		// Numbers have gaps (like 1,2,4,7...) - not suitable for sequence-based detection
		return false;
	}

	// Choose geometric algorithm based on developer mode setting
	if (developerModeEnabled) {
		console.log("Using OPTION 2: Modified RDP Algorithm");
		return detectRowsUsingRDP(numericHoles, entityName);
	} else {
		console.log("Using OPTION 1: Sequential Line Fitting Algorithm");
		return detectRowsUsingLineFitting(numericHoles, entityName);
	}
}
/**
 * ALPHANUMERIC HOLE PATTERN HANDLER
 *
 * This function specifically handles holes with alphanumeric IDs (like A1, A2, B1, B2, or I1, I2, B1, B2).
 * It must determine whether the letters represent:
 * 1. ROW IDENTIFIERS (A=row1, B=row2, C=row3...) - Common in mining software
 * 2. HOLE TYPE PREFIXES (I=infill, B=buffer, P=production...) - Also common in mining
 *
 * DECISION LOGIC:
 * - If letters are sequential single characters (A,B,C,D...) ? Likely rows
 * - If letters are multi-character codes (INF,BUF,PRD...) ? Likely hole types
 * - If mixed pattern ? Fall back to spatial detection
 *
 * @param {Array} holesData - Array of hole objects with alphanumeric holeIDs
 * @param {string} entityName - Name of blast entity for generating row IDs
 * @returns {boolean} - true if successful detection, false to fall back to spatial
 *
 * EXAMPLES:
 * Row pattern: A1,A2,A3,B1,B2,B3,C1,C2 ? A=row1, B=row2, C=row3
 * Type pattern: I1,I2,B1,B2,P1,P2 ? Use spatial detection instead
 */
function handleAlphaNumericHoles(holesData, entityName) {
	// Map to group holes by their letter prefix
	const rowGroups = new Map();

	// Array to store parsed hole information
	const parsedHoles = [];

	// Parse each hole ID to extract letter prefix and numeric suffix
	holesData.forEach((hole) => {
		// Regex: ^([A-Z]+)(\d+)$ - captures letter(s) + number(s)
		// Examples: "A1"?["A","1"], "INF23"?["INF","23"], "B5"?["B","5"]
		const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
		if (match) {
			const letter = match[1].toUpperCase(); // Letter prefix (A, B, INF, etc.)
			const number = parseInt(match[2]); // Numeric suffix (1, 2, 23, etc.)

			// Store parsed information for analysis
			parsedHoles.push({
				hole: hole,
				letter: letter,
				number: number,
			});

			// Group holes by their letter prefix
			if (!rowGroups.has(letter)) {
				rowGroups.set(letter, []);
			}
			rowGroups.get(letter).push({
				hole: hole,
				letter: letter,
				number: number,
			});
		}
	});

	// Extract all unique letter prefixes for analysis
	const letterGroups = Array.from(rowGroups.keys());
	console.log("Found letter groups:", letterGroups.join(", "));

	// HEURISTIC ANALYSIS: Determine if letters represent rows or hole types
	//
	// INDICATORS FOR ROW USAGE:
	// 1. Single letters (A, B, C) are more likely rows than multi-letter codes
	// 2. Sequential single letters (A, B, C, D) strongly suggest row naming
	// 3. Consistent pattern across all holes
	//
	// INDICATORS FOR TYPE USAGE:
	// 1. Multi-letter codes (INF, BUF, PRD) suggest hole type abbreviations
	// 2. Non-sequential letters (A, I, B, P) suggest different types
	// 3. Mixed single/multi letter combinations

	const singleLetters = letterGroups.filter((l) => l.length === 1).sort();
	const multiLetters = letterGroups.filter((l) => l.length > 1);

	// Check if single letters form a sequential pattern (A, B, C, D...)
	let isSequentialRows = false;
	if (singleLetters.length >= 2) {
		isSequentialRows = singleLetters.every((letter, index) => {
			if (index === 0) return true; // First letter is always valid
			// Check if each letter is exactly 1 ASCII value higher than previous
			// A=65, B=66, C=67... so B-A=1, C-B=1, etc.
			return letter.charCodeAt(0) - singleLetters[index - 1].charCodeAt(0) === 1;
		});
	}

	// DECISION CRITERIA: Use letters as row identifiers if:
	// 1. All letters are sequential single characters (A,B,C,D...)
	// 2. We have at least 3 different letters (need multiple rows)
	// 3. No multi-letter codes present (pure single-letter pattern)
	const useLettersAsRows = isSequentialRows && singleLetters.length >= 3 && multiLetters.length === 0;

	if (useLettersAsRows) {
		console.log("Letters appear to represent rows (A, B, C pattern)");

		// TREAT LETTERS AS ROW IDENTIFIERS
		// Each letter prefix becomes a separate row, numbered sequentially
		const startingRowID = getNextRowID(entityName);

		singleLetters.forEach((rowLetter, rowIndex) => {
			const row = rowGroups.get(rowLetter);
			// Sort holes within each row by their numeric suffix (A1, A2, A3...)
			row.sort((a, b) => a.number - b.number);

			const rowID = startingRowID + rowIndex;

			// Assign row and position IDs to each hole in this letter group
			row.forEach((item, index) => {
				item.hole.rowID = rowID;
				item.hole.posID = index + 1; // Position within row (1, 2, 3...)
			});

			console.log("Row " + rowLetter + " ‚Üí rowID " + rowID + " with " + row.length + " holes");
		});

		return true; // Successfully used letter-based row detection
	} else {
		console.log("Letters appear to be hole type prefixes (I=infill, B=buffer, etc.)");
		console.log("Falling back to spatial detection for mixed alphanumeric pattern");

		// TREAT LETTERS AS HOLE TYPE PREFIXES
		// Since letters don't represent rows, we need to use spatial detection
		// Convert to format expected by geometric line fitting algorithms
		const allHoles = [];
		let counter = 1;

		// Create a logical ordering for spatial analysis:
		// Sort letter groups alphabetically, then sort holes within each group numerically
		letterGroups.sort().forEach((letter) => {
			const group = rowGroups.get(letter);
			group.sort((a, b) => a.number - b.number); // I1, I2, I3... then B1, B2, B3...
			group.forEach((item) => {
				allHoles.push({
					hole: item.hole,
					num: counter++, // Give sequential numbers for geometric analysis
				});
			});
		});

		// Apply spatial detection algorithms since hole naming doesn't indicate rows
		if (developerModeEnabled) {
			console.log("Using OPTION 2: Modified RDP Algorithm for mixed pattern");
			return detectRowsUsingRDP(allHoles, entityName);
		} else {
			console.log("Using OPTION 1: Sequential Line Fitting Algorithm for mixed pattern");
			return detectRowsUsingLineFitting(allHoles, entityName);
		}
	}
}
/**
 * OPTION 1: SEQUENTIAL LINE FITTING ALGORITHM (Main Geometric Algorithm)
 *
 * This is the primary geometric algorithm for detecting rows in blast patterns.
 * It works by finding the longest sequences of holes that can be fit to straight lines,
 * using a tolerance based on hole diameter.
 *
 * ALGORITHM CONCEPT:
 * 1. For each hole, try to build the longest possible straight line of consecutive holes
 * 2. Use geometric line fitting to ensure holes are truly aligned
 * 3. Tolerance is based on hole diameter (2x diameter distance allowed from line)
 * 4. Process holes in order, marking used holes to avoid duplication
 *
 * STRENGTHS:
 * - Works well for regular drilling patterns
 * - Respects hole sequence (numbered 1,2,3,4...)
 * - Good for straight or slightly curved rows
 *
 * WEAKNESSES:
 * - Can break up rows if there are small alignment irregularities
 * - Requires sequential hole numbering to work optimally
 * - May create too many single-hole rows in irregular patterns
 *
 * @param {Array} numericHoles - Array of {hole, num} objects sorted by hole number
 * @param {string} entityName - Blast entity name for generating row IDs
 * @returns {boolean} - true if detection was successful
 */
function detectRowsUsingLineFitting(numericHoles, entityName) {
	// Need at least 2 holes to form any meaningful pattern
	if (numericHoles.length < 2) return false;

	// Calculate tolerance based on hole diameter
	// Default 115mm diameter if not specified (typical blast hole size)
	const holeDiameter = numericHoles[0].hole.holeDiameter || 115; // mm
	const tolerance = (holeDiameter * 2) / 1000; // Convert to meters (2x diameter)

	console.log("Line fitting tolerance:", tolerance.toFixed(3) + "m (2x diameter)");

	// Arrays to store detected rows and track which holes have been used
	const rows = [];
	const used = new Set(); // Set of hole indices that have been assigned to rows

	// MAIN ALGORITHM: Try to build rows starting from each unused hole
	// Process holes in sequence order (1, 2, 3, 4...) to maintain logical flow
	for (let startIdx = 0; startIdx < numericHoles.length; startIdx++) {
		if (used.has(startIdx)) continue; // Skip holes already assigned to rows

		// Find the longest sequence of consecutive holes that form a straight line
		const row = findLongestLineSequence(numericHoles, startIdx, tolerance, used);

		if (row.length >= 2) {
			// Only accept sequences with at least 2 holes as valid rows
			rows.push(row);

			// Mark all holes in this row as used
			row.forEach((hole) => used.add(numericHoles.indexOf(hole)));

			console.log("Found row with", row.length, "holes:", row.map((h) => h.num).join(","));
		}
	}

	// CLEANUP: Handle single holes that didn't fit into any row
	// These become individual single-hole rows (may indicate outliers or edge holes)
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
			console.log("Single hole row:", numericHoles[i].num);
		}
	}

	// ASSIGNMENT: Give each detected row a unique ID and assign positions within rows
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1; // Position within row (1, 2, 3...)
		});
	});

	console.log("Line fitting detected", rows.length, "rows");
	return rows.length > 0;
}

/**
 * FIND LONGEST LINE SEQUENCE HELPER
 *
 * Starting from a given hole, this function extends forward through consecutive holes
 * to build the longest possible sequence that forms a straight line within tolerance.
 *
 * ALGORITHM:
 * 1. Start with the given hole as the first point in the sequence
 * 2. Try adding each subsequent consecutive hole to the sequence
 * 3. Test if the extended sequence still forms a valid straight line
 * 4. Stop when adding the next hole would break the line constraint
 * 5. Return the longest valid sequence found
 *
 * KEY BEHAVIOR:
 * - Only looks FORWARD in the hole sequence (maintains drilling order)
 * - Stops at first hole that doesn't fit (ensures continuous sequences)
 * - Skips holes already used by previous rows
 *
 * @param {Array} numericHoles - All holes sorted by sequence number
 * @param {number} startIdx - Index of hole to start sequence from
 * @param {number} tolerance - Maximum distance allowed from line (meters)
 * @param {Set} used - Set of hole indices already assigned to other rows
 * @returns {Array} - Longest sequence of holes forming a straight line
 */
function findLongestLineSequence(numericHoles, startIdx, tolerance, used) {
	// Start sequence with the given hole
	const sequence = [numericHoles[startIdx]];

	// Try to extend the sequence by finding consecutive holes that fit the line
	// Only look FORWARD to maintain hole sequence order (drilling progression)
	for (let nextIdx = startIdx + 1; nextIdx < numericHoles.length; nextIdx++) {
		if (used.has(nextIdx)) continue; // Skip holes already used by other rows

		// Test if adding this hole would still form a valid straight line
		const testSequence = [...sequence, numericHoles[nextIdx]];

		if (sequenceFitsLine(testSequence, tolerance)) {
			// Hole fits the line - add it to the sequence and continue
			sequence.push(numericHoles[nextIdx]);
		} else {
			// Hole doesn't fit the line - stop extending sequence
			// This ensures rows are continuous (no gaps in hole sequence)
			break;
		}
	}

	return sequence;
}

/**
 * SEQUENCE LINE FITTING VALIDATOR
 *
 * Tests whether a sequence of holes can be considered to form a straight line
 * within the specified tolerance. Uses simple linear regression approach.
 *
 * GEOMETRIC METHOD:
 * 1. Define line using first and last points in sequence
 * 2. Calculate perpendicular distance from each intermediate point to this line
 * 3. If any point is farther than tolerance from line, sequence fails
 * 4. If all points are within tolerance, sequence passes
 *
 * ASSUMPTIONS:
 * - Uses first and last points to define the "ideal" line
 * - Assumes drilling follows a reasonably straight path
 * - Tolerance accounts for small drilling irregularities and survey errors
 *
 * @param {Array} sequence - Array of hole objects to test for linearity
 * @param {number} tolerance - Maximum allowed distance from line (meters)
 * @returns {boolean} - true if sequence forms a valid straight line
 */
function sequenceFitsLine(sequence, tolerance) {
	// Single hole or pair always forms a valid "line"
	if (sequence.length < 2) return true;

	// Extract coordinate points from hole objects
	const points = sequence.map((item) => ({
		x: item.hole.startXLocation,
		y: item.hole.startYLocation,
	}));

	// Define line using first and last points (endpoints of sequence)
	// This represents the "ideal" straight line the holes should follow
	const start = points[0];
	const end = points[points.length - 1];

	// Test all intermediate points (exclude endpoints since they define the line)
	for (let i = 1; i < points.length - 1; i++) {
		const distance = distancePointToLine(points[i], start, end);
		if (distance > tolerance) {
			// Found a point too far from the line - sequence is not straight enough
			return false;
		}
	}

	// All intermediate points are within tolerance - sequence is acceptably straight
	return true;
}

/**
 * POINT-TO-LINE DISTANCE CALCULATOR
 *
 * Calculates the perpendicular (shortest) distance from a point to a line segment.
 * Uses the standard point-to-line distance formula from analytic geometry.
 *
 * MATHEMATICAL FORMULA:
 * For line defined by points (x1,y1) and (x2,y2), and test point (x0,y0):
 * distance = |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)? + (x2-x1)?)
 *
 * SPECIAL CASES:
 * - If line endpoints are identical (zero length), distance is 0
 * - Formula gives perpendicular distance, not diagonal distance
 *
 * @param {Object} point - Point to test {x, y}
 * @param {Object} lineStart - Line start point {x, y}
 * @param {Object} lineEnd - Line end point {x, y}
 * @returns {number} - Perpendicular distance from point to line (meters)
 */
function distancePointToLine(point, lineStart, lineEnd) {
	// Calculate line vector components
	const dx = lineEnd.x - lineStart.x;
	const dy = lineEnd.y - lineStart.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);

	// Handle degenerate case where line endpoints are identical
	if (lineLength === 0) return 0; // Start and end are the same point

	// Apply point-to-line distance formula
	// |((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)| / sqrt((y2-y1)? + (x2-x1)?)
	const distance = Math.abs((dy * point.x - dx * point.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x) / lineLength);

	return distance;
}

// ============================================================================
// #endregion CUSTOM CSV IMPORT/EXPORT - EXTRACTED TO FILEMANAGER
// ============================================================================
// The above code section (HOLE_FIELD_MAPPING through row detection functions)
// has been extracted to FileManager modules. See comment at line 29779 for details.
// This code is retained for backward compatibility during transition period.
// ============================================================================

/**
 * CALCULATE BURDEN AND SPACING FOR HOLES
 *
 * Calculates burden and spacing for holes based on their row assignments:
 * - Spacing: Distance to next hole in the same row (along row direction)
 * - Burden: PERPENDICULAR distance between rows (not hypotenuse)
 */
function calculateBurdenAndSpacingForHoles(holes) {
	if (!holes || holes.length === 0) return;

	// Group holes by entity name
	var entitiesByName = new Map();
	holes.forEach(function (hole) {
		if (!entitiesByName.has(hole.entityName)) {
			entitiesByName.set(hole.entityName, []);
		}
		entitiesByName.get(hole.entityName).push(hole);
	});

	// Calculate burden and spacing for each entity
	entitiesByName.forEach(function (entityHoles, entityName) {
		// Group holes by row
		var rowMap = new Map();
		entityHoles.forEach(function (hole) {
			var rowKey = hole.rowID || 0;
			if (!rowMap.has(rowKey)) {
				rowMap.set(rowKey, []);
			}
			rowMap.get(rowKey).push(hole);
		});

		// Sort holes within each row by posID
		rowMap.forEach(function (rowHoles) {
			rowHoles.sort(function (a, b) {
				return (a.posID || 0) - (b.posID || 0);
			});
		});

		// Calculate spacing (distance to next hole in same row)
		rowMap.forEach(function (rowHoles) {
			for (var i = 0; i < rowHoles.length; i++) {
				var hole = rowHoles[i];
				if (i < rowHoles.length - 1) {
					var nextHole = rowHoles[i + 1];
					var dx = nextHole.startXLocation - hole.startXLocation;
					var dy = nextHole.startYLocation - hole.startYLocation;
					hole.spacing = Math.round(Math.sqrt(dx * dx + dy * dy) * 1000) / 1000; // Round to 3 decimal places
				} else {
					// Last hole in row - use average spacing of row
					if (rowHoles.length > 1) {
						var totalSpacing = 0;
						for (var j = 0; j < rowHoles.length - 1; j++) {
							totalSpacing += rowHoles[j].spacing;
						}
						hole.spacing = Math.round((totalSpacing / (rowHoles.length - 1)) * 1000) / 1000; // Round to 3 decimal places
					} else {
						hole.spacing = 0;
					}
				}
			}
		});

		// Determine row orientation (direction along rows)
		var rowOrientation = estimateRowOrientation(entityHoles);
		console.log("Row orientation for " + entityName + ": " + rowOrientation.toFixed(2) + "¬∞");

		// Convert compass bearing to radians
		var rowBearingRadians = ((90 - rowOrientation) * Math.PI) / 180;
		var burdenBearingRadians = rowBearingRadians - Math.PI / 2; // Perpendicular to row

		// Project all holes onto burden axis (perpendicular to rows)
		entityHoles.forEach(function (hole) {
			hole.burdenProjection =
				hole.startXLocation * Math.cos(burdenBearingRadians) +
				hole.startYLocation * Math.sin(burdenBearingRadians);
		});

		// Calculate burden as perpendicular distance between rows
		var sortedRows = Array.from(rowMap.keys()).sort(function (a, b) { return a - b; });

		sortedRows.forEach(function (rowID, rowIndex) {
			var rowHoles = rowMap.get(rowID);

			// Calculate average burden projection for this row
			var avgBurdenProj = 0;
			rowHoles.forEach(function (hole) {
				avgBurdenProj += hole.burdenProjection;
			});
			avgBurdenProj /= rowHoles.length;

			// Find burden to adjacent rows
			var burdenToNext = 0;
			var burdenToPrev = 0;

			if (rowIndex < sortedRows.length - 1) {
				var nextRowID = sortedRows[rowIndex + 1];
				var nextRowHoles = rowMap.get(nextRowID);
				var nextAvgProj = 0;
				nextRowHoles.forEach(function (hole) {
					nextAvgProj += hole.burdenProjection;
				});
				nextAvgProj /= nextRowHoles.length;
				burdenToNext = Math.abs(nextAvgProj - avgBurdenProj);
			}

			if (rowIndex > 0) {
				var prevRowID = sortedRows[rowIndex - 1];
				var prevRowHoles = rowMap.get(prevRowID);
				var prevAvgProj = 0;
				prevRowHoles.forEach(function (hole) {
					prevAvgProj += hole.burdenProjection;
				});
				prevAvgProj /= prevRowHoles.length;
				burdenToPrev = Math.abs(avgBurdenProj - prevAvgProj);
			}

			// Assign burden to each hole in row (rounded to 3 decimal places)
			rowHoles.forEach(function (hole) {
				if (rowIndex === 0) {
					// First row - use burden to next row
					hole.burden = Math.round((burdenToNext || 0) * 1000) / 1000;
				} else if (rowIndex === sortedRows.length - 1) {
					// Last row - use burden to previous row
					hole.burden = Math.round((burdenToPrev || 0) * 1000) / 1000;
				} else {
					// Middle rows - use average of both
					hole.burden = Math.round(((burdenToPrev + burdenToNext) / 2) * 1000) / 1000;
				}
			});
		});

		// Clean up temporary projection properties
		entityHoles.forEach(function (hole) {
			delete hole.burdenProjection;
		});

		console.log("Calculated burden and spacing for " + entityHoles.length + " holes in entity: " + entityName);
	});
}

/**
 * ESTIMATE ROW ORIENTATION
 *
 * Determines the dominant direction along which holes are aligned in rows.
 * Returns compass bearing in degrees (0¬∞ = North, 90¬∞ = East)
 */
function estimateRowOrientation(holes) {
	if (!holes || holes.length < 2) return 0;

	// Use PCA (Principal Component Analysis) to find dominant direction
	var meanX = 0;
	var meanY = 0;
	holes.forEach(function (hole) {
		meanX += hole.startXLocation;
		meanY += hole.startYLocation;
	});
	meanX /= holes.length;
	meanY /= holes.length;

	var covarXX = 0;
	var covarXY = 0;
	var covarYY = 0;

	holes.forEach(function (hole) {
		var dx = hole.startXLocation - meanX;
		var dy = hole.startYLocation - meanY;
		covarXX += dx * dx;
		covarXY += dx * dy;
		covarYY += dy * dy;
	});

	// Calculate principal direction (eigenvector of covariance matrix)
	var trace = covarXX + covarYY;
	var det = covarXX * covarYY - covarXY * covarXY;
	var eigenvalue1 = (trace + Math.sqrt(trace * trace - 4 * det)) / 2;

	// Principal direction angle
	var angle;
	if (Math.abs(covarXY) > 1e-10) {
		angle = Math.atan2(eigenvalue1 - covarXX, covarXY);
	} else {
		angle = covarXX > covarYY ? 0 : Math.PI / 2;
	}

	// Convert to compass bearing (0¬∞ = North, 90¬∞ = East)
	var bearing = 90 - (angle * 180) / Math.PI;
	if (bearing < 0) bearing += 360;
	if (bearing >= 360) bearing -= 360;

	return bearing;
}

/**
 * HDBSCAN-BASED ROW DETECTION (RECOMMENDED APPROACH)
 *
 * This algorithm uses hierarchical density-based clustering to detect rows
 * in blast hole patterns. It's superior to the existing algorithms because:
 * - No need to specify number of rows beforehand
 * - Handles varying row densities automatically
 * - Robust to noise and irregular patterns
 * - Works with any hole naming convention
 */

function detectRowsUsingHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using HDBSCAN for row detection on " + holesData.length + " holes");

	// Extract coordinates for clustering
	const points = holesData.map((hole) => [hole.startXLocation, hole.startYLocation]);

	// Calculate minimum cluster size based on expected holes per row
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20)); // Estimate 20 rows max

	// Since we don't have HDBSCAN library, we'll implement a simplified version
	// In production, use: import { HDBSCAN } from 'hdbscan-js';
	const clusters = simplifiedHDBSCAN(points, minClusterSize);

	// Convert clusters to row assignments
	assignClustersToRows(holesData, clusters, entityName);

	console.log("HDBSCAN detected " + clusters.length + " rows");
	return clusters.length > 0;
}

/**
 * SIMPLIFIED HDBSCAN IMPLEMENTATION
 *
 * This is a simplified version for demonstration. In production,
 * use a proper HDBSCAN library like hdbscan-js or sklearn in Python
 */
function simplifiedHDBSCAN(points, minClusterSize) {
	// Step 1: Calculate distance matrix
	const distances = calculateDistanceMatrix(points);

	// Step 2: Build minimum spanning tree based on mutual reachability
	const mst = buildMinimumSpanningTree(points, distances, minClusterSize);

	// Step 3: Build cluster hierarchy
	const hierarchy = buildClusterHierarchy(mst);

	// Step 4: Extract stable clusters
	const clusters = extractStableClusters(hierarchy, minClusterSize);

	return clusters;
}

/**
 * SIMPLIFIED HDBSCAN WITH DISTANCE MATRIX
 *
 * This function runs HDBSCAN clustering using a pre-calculated distance matrix
 * instead of calculating distances from point coordinates.
 *
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n?n distance matrix
 * @param {number} minClusterSize - Minimum number of points required to form a cluster
 * @returns {Array<Array<number>>} Array of clusters, where each cluster is an array of point indices
 */
function simplifiedHDBSCANWithDistanceMatrix(distanceMatrix, minClusterSize) {
	// Step 2) Validate input parameters
	if (!distanceMatrix || !Array.isArray(distanceMatrix) || distanceMatrix.length === 0) {
		console.warn("Invalid distance matrix provided to simplifiedHDBSCANWithDistanceMatrix");
		return [];
	}

	const n = distanceMatrix.length;

	// Step 3) Validate that distance matrix is square
	if (distanceMatrix.some((row) => !Array.isArray(row) || row.length !== n)) {
		console.warn("Distance matrix is not square or properly formatted");
		return [];
	}

	console.log("Running HDBSCAN with pre-calculated " + n + "√ó" + n + " distance matrix");

	// Step 4) Build minimum spanning tree using the provided distance matrix
	const mst = buildMinimumSpanningTreeFromMatrix(distanceMatrix, minClusterSize);

	// Step 5) Build cluster hierarchy using existing function
	const hierarchy = buildClusterHierarchy(mst);

	// Step 6) Extract stable clusters using existing function
	const clusters = extractStableClusters(hierarchy, minClusterSize);

	console.log("HDBSCAN with distance matrix detected " + clusters.length + " clusters");
	return clusters;
}

/**
 * BUILD MINIMUM SPANNING TREE FROM DISTANCE MATRIX
 *
 * Step 1) This is a variant of the existing buildMinimumSpanningTree function
 * that works with a pre-calculated distance matrix instead of calculating distances.
 *
 * @param {Array<Array<number>>} distanceMatrix - Pre-calculated n?n distance matrix
 * @param {number} minPts - Minimum points parameter for core distance calculation
 * @returns {Array<Object>} Minimum spanning tree edges with {from, to, weight} structure
 */
function buildMinimumSpanningTreeFromMatrix(distanceMatrix, minPts) {
	const n = distanceMatrix.length;
	const edges = [];

	// Step 2) Calculate core distances (distance to k-th nearest neighbor)
	const coreDistances = [];
	for (let i = 0; i < n; i++) {
		// Step 3) Get all distances for point i and sort them
		const dists = distanceMatrix[i].slice(); // Copy the row
		dists.sort((a, b) => a - b);

		// Step 4) Use k-th nearest neighbor distance as core distance
		// Ensure we don't exceed array bounds
		const kIndex = Math.min(minPts, dists.length - 1);
		coreDistances[i] = dists[kIndex];
	}

	// Step 5) Calculate mutual reachability distances and create edges
	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			// Step 6) Mutual reachability is the maximum of:
			// - Core distance of point i
			// - Core distance of point j
			// - Direct distance between points i and j
			const mutualReachability = Math.max(coreDistances[i], coreDistances[j], distanceMatrix[i][j]);

			edges.push({
				from: i,
				to: j,
				weight: mutualReachability,
			});
		}
	}

	// Step 7) Sort edges by weight (Kruskal's algorithm)
	edges.sort((a, b) => a.weight - b.weight);

	// Step 8) Build MST using Union-Find algorithm
	const parent = Array(n)
		.fill()
		.map((_, i) => i);
	const mst = [];

	// Step 9) Union-Find helper functions
	function find(x) {
		if (parent[x] !== x) {
			parent[x] = find(parent[x]); // Path compression
		}
		return parent[x];
	}

	function union(x, y) {
		const px = find(x);
		const py = find(y);
		if (px !== py) {
			parent[px] = py;
			return true;
		}
		return false;
	}

	// Step 10) Build MST by adding edges that don't create cycles
	for (const edge of edges) {
		if (union(edge.from, edge.to)) {
			mst.push(edge);
			// Step 11) Stop when we have n-1 edges (complete spanning tree)
			if (mst.length === n - 1) break;
		}
	}

	console.log("Built MST from distance matrix with " + mst.length + " edges");
	return mst;
}

function calculateDistanceMatrix(points) {
	const n = points.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const dx = points[i][0] - points[j][0];
			const dy = points[i][1] - points[j][1];
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances[i][j] = distances[j][i] = dist;
		}
	}

	return distances;
}

function buildMinimumSpanningTree(points, distances, minPts) {
	const n = points.length;
	const edges = [];

	// Calculate core distances (distance to k-th nearest neighbor)
	const coreDistances = points.map((point, i) => {
		const dists = distances[i].slice();
		dists.sort((a, b) => a - b);
		return dists[minPts]; // k-th nearest neighbor distance
	});

	// Calculate mutual reachability distances and create edges
	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			const mutualReachability = Math.max(coreDistances[i], coreDistances[j], distances[i][j]);
			edges.push({ from: i, to: j, weight: mutualReachability });
		}
	}

	// Sort edges by weight (Kruskal's algorithm)
	edges.sort((a, b) => a.weight - b.weight);

	// Build MST using Union-Find
	const parent = Array(n)
		.fill()
		.map((_, i) => i);
	const mst = [];

	function find(x) {
		if (parent[x] !== x) {
			parent[x] = find(parent[x]);
		}
		return parent[x];
	}

	function union(x, y) {
		const px = find(x);
		const py = find(y);
		if (px !== py) {
			parent[px] = py;
			return true;
		}
		return false;
	}

	for (const edge of edges) {
		if (union(edge.from, edge.to)) {
			mst.push(edge);
			if (mst.length === n - 1) break;
		}
	}

	return mst;
}

function buildClusterHierarchy(mst) {
	// Sort MST edges by weight (reverse order for hierarchy building)
	const sortedEdges = mst.slice().sort((a, b) => b.weight - a.weight);

	const hierarchy = [];
	const components = new Map();
	let nextClusterId = 0;

	// Initialize each point as its own component
	for (const edge of mst) {
		if (!components.has(edge.from)) components.set(edge.from, [edge.from]);
		if (!components.has(edge.to)) components.set(edge.to, [edge.to]);
	}

	// Build hierarchy by merging components
	for (const edge of sortedEdges) {
		const comp1 = components.get(edge.from);
		const comp2 = components.get(edge.to);

		if (comp1 && comp2 && comp1 !== comp2) {
			const merged = [...comp1, ...comp2];
			const clusterId = nextClusterId++;

			hierarchy.push({
				id: clusterId,
				points: merged,
				distance: edge.weight,
				children: [comp1, comp2],
			});

			// Update component references
			for (const point of merged) {
				components.set(point, merged);
			}
		}
	}

	return hierarchy;
}

function extractStableClusters(hierarchy, minClusterSize) {
	// Simplified cluster extraction - select clusters with good stability
	const clusters = [];
	const processed = new Set();

	// Sort by cluster size and distance for stability
	const candidates = hierarchy
		.filter((cluster) => cluster.points.length >= minClusterSize)
		.sort((a, b) => {
			// Prefer larger clusters with smaller distances (more stable)
			const stabilityA = a.points.length / (1 + a.distance);
			const stabilityB = b.points.length / (1 + b.distance);
			return stabilityB - stabilityA;
		});

	for (const candidate of candidates) {
		// Check if any points are already assigned to a cluster
		if (!candidate.points.some((point) => processed.has(point))) {
			clusters.push(candidate.points);
			for (const point of candidate.points) {
				processed.add(point);
			}
		}
	}

	return clusters;
}

/**
 * ENHANCED GRID-BASED CLUSTERING (ALTERNATIVE APPROACH)
 *
 * This algorithm uses an adaptive grid structure to detect rows,
 * inspired by spatial co-location pattern mining techniques
 */
function detectRowsUsingAdaptiveGrid(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Adaptive Grid clustering for row detection");

	// Calculate bounding box and optimal grid size
	const bounds = calculateBounds(holesData);
	const gridSize = estimateOptimalGridSize(holesData, bounds);

	// Create adaptive grid
	const grid = createAdaptiveGrid(holesData, bounds, gridSize);

	// Find connected components in grid
	const components = findGridComponents(grid);

	// Convert components to rows
	const rows = componentsToRows(components, holesData);

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, index) => {
		const rowID = startingRowID + index;
		row.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});

	console.log("Adaptive Grid detected " + rows.length + " rows");
	return rows.length > 0;
}

function calculateBounds(holesData) {
	const xs = holesData.map((h) => h.startXLocation);
	const ys = holesData.map((h) => h.startYLocation);

	return {
		minX: Math.min(...xs),
		maxX: Math.max(...xs),
		minY: Math.min(...ys),
		maxY: Math.max(...ys),
	};
}

function estimateOptimalGridSize(holesData, bounds) {
	// Estimate grid size based on average hole spacing
	const distances = [];

	for (let i = 0; i < holesData.length; i++) {
		for (let j = i + 1; j < holesData.length; j++) {
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const dist = Math.sqrt(dx * dx + dy * dy);
			distances.push(dist);
		}
	}

	distances.sort((a, b) => a - b);

	// Use median of shortest 10% of distances as grid size
	const shortDistances = distances.slice(0, Math.floor(distances.length * 0.1));
	const medianSpacing = shortDistances[Math.floor(shortDistances.length / 2)];

	return medianSpacing * 1.5; // 1.5x median spacing for grid size
}

function createAdaptiveGrid(holesData, bounds, gridSize) {
	const grid = new Map();

	holesData.forEach((hole, index) => {
		const cellX = Math.floor((hole.startXLocation - bounds.minX) / gridSize);
		const cellY = Math.floor((hole.startYLocation - bounds.minY) / gridSize);
		const key = cellX + "," + cellY;

		if (!grid.has(key)) {
			grid.set(key, []);
		}
		grid.get(key).push({ hole, index });
	});

	return grid;
}

function findGridComponents(grid) {
	const visited = new Set();
	const components = [];

	for (const [cellKey, holes] of grid) {
		if (!visited.has(cellKey) && holes.length > 0) {
			const component = [];
			const queue = [cellKey];
			visited.add(cellKey);

			while (queue.length > 0) {
				const currentKey = queue.shift();
				const currentHoles = grid.get(currentKey) || [];
				component.push(...currentHoles);

				// Check adjacent cells
				const [x, y] = currentKey.split(",").map(Number);
				const neighbors = [
					[x - 1, y],
					[x + 1, y],
					[x, y - 1],
					[x, y + 1], // 4-connected
					[x - 1, y - 1],
					[x - 1, y + 1],
					[x + 1, y - 1],
					[x + 1, y + 1], // 8-connected
				];

				for (const [nx, ny] of neighbors) {
					const neighborKey = nx + "," + ny;
					if (grid.has(neighborKey) && !visited.has(neighborKey)) {
						visited.add(neighborKey);
						queue.push(neighborKey);
					}
				}
			}

			if (component.length > 0) {
				components.push(component);
			}
		}
	}

	return components;
}

function componentsToRows(components, holesData) {
	return components.map((component) => {
		// Sort holes within component by position along dominant axis
		const holes = component.map((item) => item.hole);

		// Determine dominant direction for sorting
		const direction = estimateRowDirection(holes);

		// Sort holes along the row direction
		holes.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		return holes;
	});
}

function estimateRowDirection(holes) {
	if (holes.length < 2) return 0;

	// Use PCA to find principal direction
	const meanX = holes.reduce((sum, h) => sum + h.startXLocation, 0) / holes.length;
	const meanY = holes.reduce((sum, h) => sum + h.startYLocation, 0) / holes.length;

	let covarXX = 0,
		covarXY = 0,
		covarYY = 0;

	holes.forEach((hole) => {
		const dx = hole.startXLocation - meanX;
		const dy = hole.startYLocation - meanY;
		covarXX += dx * dx;
		covarXY += dx * dy;
		covarYY += dy * dy;
	});

	// Calculate principal direction (eigenvector of covariance matrix)
	const trace = covarXX + covarYY;
	const det = covarXX * covarYY - covarXY * covarXY;
	const eigenvalue1 = (trace + Math.sqrt(trace * trace - 4 * det)) / 2;

	// Principal direction angle
	if (Math.abs(covarXY) > 1e-10) {
		return Math.atan2(eigenvalue1 - covarXX, covarXY);
	} else {
		return covarXX > covarYY ? 0 : Math.PI / 2;
	}
}

// Helper function to assign clusters to rows
function assignClustersToRows(holesData, clusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	clusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;
		const rowHoles = cluster.map((pointIndex) => holesData[pointIndex]);

		// Sort holes within row by spatial position
		const direction = estimateRowDirection(rowHoles);
		rowHoles.sort((a, b) => {
			const projA = a.startXLocation * Math.cos(direction) + a.startYLocation * Math.sin(direction);
			const projB = b.startXLocation * Math.cos(direction) + b.startYLocation * Math.sin(direction);
			return projA - projB;
		});

		// Assign row and position IDs
		rowHoles.forEach((hole, pos) => {
			hole.rowID = rowID;
			hole.posID = pos + 1;
		});
	});
}

/**
 * UPDATED SMART ROW DETECTION WITH SEQUENCE PRIORITY
 *
 * This maintains the priority of sequential hole numbering while using
 * better algorithms when sequence-based detection fails
 */
function improvedSmartRowDetection(holesData, entityName) {
	if (!holesData || holesData.length === 0) return;

	console.log("Improved smart row detection for " + holesData.length + " holes in entity: " + entityName);

	// METHOD 1: ALWAYS TRY SEQUENCE-BASED DETECTION FIRST (HIGHEST PRIORITY)
	// This respects the drilling order and numbered patterns which are most reliable
	if (trySequenceBasedDetection(holesData, entityName)) {
		console.log("Used sequence-based row detection (PRIORITY METHOD)");
		return;
	}

	// METHOD 2: Enhanced spatial detection with sequence weighting
	// Use HDBSCAN but weight points based on sequence proximity
	if (detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName)) {
		console.log("Used sequence-weighted HDBSCAN row detection");
		return;
	}

	// METHOD 3: Try pure spatial HDBSCAN (when sequence is completely random)
	if (detectRowsUsingHDBSCAN(holesData, entityName)) {
		console.log("Used pure spatial HDBSCAN row detection");
		return;
	}

	// METHOD 4: Try Adaptive Grid clustering
	if (detectRowsUsingAdaptiveGrid(holesData, entityName)) {
		console.log("Used Adaptive Grid row detection");
		return;
	}

	// METHOD 5: Fallback to your existing bearing-based detection
	useBearingBasedDetection(holesData, entityName);
	console.log("Used bearing-based spatial detection as fallback");
}

/**
 * SEQUENCE-WEIGHTED HDBSCAN
 *
 * This combines the power of HDBSCAN with respect for hole numbering sequence.
 * Points that are close in sequence get a distance penalty reduction, making
 * them more likely to cluster together even if slightly farther apart spatially.
 */
function detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName) {
	if (!holesData || holesData.length === 0) return false;

	console.log("Using Sequence-Weighted HDBSCAN for row detection");

	// First, try to extract numeric sequence from hole IDs
	const sequenceInfo = extractSequenceInformation(holesData);

	if (!sequenceInfo.hasValidSequence) {
		console.log("No valid sequence found, falling back to pure spatial HDBSCAN");
		return false;
	}

	// Create distance matrix that considers both spatial and sequence proximity
	const weightedDistances = calculateSequenceWeightedDistances(holesData, sequenceInfo);

	// Run HDBSCAN with the weighted distances
	const minClusterSize = Math.max(2, Math.floor(holesData.length / 20));
	const clusters = simplifiedHDBSCANWithDistanceMatrix(weightedDistances, minClusterSize);

	// Post-process clusters to respect sequence order within rows
	const orderedClusters = orderClustersbySequence(clusters, holesData, sequenceInfo);

	// Assign to rows
	assignOrderedClustersToRows(holesData, orderedClusters, entityName);

	console.log("Sequence-Weighted HDBSCAN detected " + orderedClusters.length + " rows");
	return orderedClusters.length > 0;
}

/**
 * EXTRACT SEQUENCE INFORMATION
 *
 * Analyzes hole IDs to determine if there's a meaningful sequence that should
 * be preserved during clustering
 */
function extractSequenceInformation(holesData) {
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;
	const sequenceMap = new Map(); // Maps holeID to sequence number

	// Analyze hole ID patterns (same as your existing logic)
	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
			sequenceMap.set(hole.holeID, parseInt(hole.holeID));
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
			// For alphanumeric, use the numeric part as sequence
			const match = hole.holeID.match(/(\d+)$/);
			if (match) {
				sequenceMap.set(hole.holeID, parseInt(match[1]));
			}
		} else {
			otherCount++;
			// For other patterns, use index as sequence
			sequenceMap.set(hole.holeID, index);
		}
	});

	// Determine if we have a valid sequence
	const hasValidSequence =
		numericCount > holesData.length * 0.7 || // 70% numeric
		alphaNumericCount > holesData.length * 0.7; // 70% alphanumeric

	console.log("Sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
		hasValidSequence: hasValidSequence,
	});

	return {
		hasValidSequence,
		sequenceMap,
		totalHoles: holesData.length,
	};
}

/**
 * CALCULATE SEQUENCE-WEIGHTED DISTANCES
 *
 * Modifies spatial distances to give preference to holes that are close
 * in the numbering sequence, making them more likely to cluster together
 */
function calculateSequenceWeightedDistances(holesData, sequenceInfo) {
	const n = holesData.length;
	const distances = Array(n)
		.fill()
		.map(() => Array(n).fill(0));

	// Get sequence numbers for all holes
	const sequences = holesData.map((hole) => sequenceInfo.sequenceMap.get(hole.holeID) || 0);
	const maxSequenceDiff = Math.max(...sequences) - Math.min(...sequences);

	for (let i = 0; i < n; i++) {
		for (let j = i + 1; j < n; j++) {
			// Calculate spatial distance
			const dx = holesData[i].startXLocation - holesData[j].startXLocation;
			const dy = holesData[i].startYLocation - holesData[j].startYLocation;
			const spatialDistance = Math.sqrt(dx * dx + dy * dy);

			// Calculate sequence distance (normalized)
			const sequenceDiff = Math.abs(sequences[i] - sequences[j]);
			const normalizedSequenceDiff = sequenceDiff / maxSequenceDiff;

			// SEQUENCE WEIGHTING FORMULA:
			// - If holes are close in sequence (low sequenceDiff), reduce distance
			// - If holes are far in sequence (high sequenceDiff), increase distance
			// - Weight factor controls how much sequence matters vs spatial distance
			const sequenceWeight = 0.3; // 30% influence from sequence
			const sequencePenalty = 1 + sequenceWeight * normalizedSequenceDiff;
			const sequenceBonus = Math.max(0.5, 1 - sequenceWeight * Math.exp(-sequenceDiff / 5));

			// Apply sequence weighting
			let weightedDistance;
			if (sequenceDiff <= 3) {
				// Holes very close in sequence get a distance bonus
				weightedDistance = spatialDistance * sequenceBonus;
			} else {
				// Holes far in sequence get a distance penalty
				weightedDistance = spatialDistance * sequencePenalty;
			}

			distances[i][j] = distances[j][i] = weightedDistance;
		}
	}

	return distances;
}

/**
 * ORDER CLUSTERS BY SEQUENCE
 *
 * After clustering, ensure holes within each cluster are ordered by sequence
 */
function orderClustersbySequence(clusters, holesData, sequenceInfo) {
	return clusters.map((cluster) => {
		// Get holes in this cluster
		const clusterHoles = cluster.map((index) => ({
			hole: holesData[index],
			index: index,
			sequence: sequenceInfo.sequenceMap.get(holesData[index].holeID) || 0,
		}));

		// Sort by sequence number
		clusterHoles.sort((a, b) => a.sequence - b.sequence);

		return clusterHoles.map((item) => item.index);
	});
}

/**
 * ASSIGN ORDERED CLUSTERS TO ROWS
 *
 * Assigns cluster results to rows while preserving sequence order
 */
function assignOrderedClustersToRows(holesData, orderedClusters, entityName) {
	const startingRowID = getNextRowID(entityName);

	orderedClusters.forEach((cluster, clusterIndex) => {
		const rowID = startingRowID + clusterIndex;

		cluster.forEach((holeIndex, positionInRow) => {
			const hole = holesData[holeIndex];
			hole.rowID = rowID;
			hole.posID = positionInRow + 1; // Position respects sequence order
		});

		console.log("Row " + rowID + " has " + cluster.length + " holes in sequence order");
	});
}

/**
 * ENHANCED SEQUENCE-BASED DETECTION (REPLACES YOUR EXISTING VERSION)
 *
 * This improves your existing trySequenceBasedDetection with better algorithms
 * while maintaining the priority of sequential numbering
 */
function enhancedSequenceBasedDetection(holesData, entityName) {
	// Same pattern analysis as your original code
	let numericCount = 0;
	let alphaNumericCount = 0;
	let otherCount = 0;

	holesData.forEach((hole) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericCount++;
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			alphaNumericCount++;
		} else {
			otherCount++;
		}
	});

	console.log("Enhanced sequence analysis:", {
		numeric: numericCount,
		alphaNumeric: alphaNumericCount,
		other: otherCount,
	});

	// CASE 1: All alphanumeric (keep your existing logic)
	if (alphaNumericCount === holesData.length) {
		console.log("All holes are alphanumeric - analyzing pattern");
		return handleAlphaNumericHoles(holesData, entityName);
	}

	// CASE 2: Mixed patterns - improved handling
	if (numericCount > 0 && alphaNumericCount > 0) {
		console.log("Mixed numeric and alphanumeric pattern detected");
		return handleMixedSequencePattern(holesData, entityName);
	}

	// CASE 3: Pure numeric - enhanced algorithms
	const numericHoles = holesData
		.map((hole) => ({ hole, num: parseInt(hole.holeID) }))
		.filter((item) => !isNaN(item.num))
		.sort((a, b) => a.num - b.num);

	if (numericHoles.length !== holesData.length || numericHoles.length < 4) {
		return false; // Not suitable for sequence-based detection
	}

	// Check sequence continuity with gap tolerance
	const gaps = analyzeSequenceGaps(numericHoles);

	if (gaps.hasReasonablePattern) {
		console.log("Using enhanced sequence-based detection with gap tolerance");
		return enhancedSequentialDetection(numericHoles, entityName, gaps);
	}

	return false; // Fall back to spatial detection
}

/**
 * ANALYZE SEQUENCE GAPS
 *
 * Determines if the numeric sequence has a reasonable pattern even with gaps
 */
function analyzeSequenceGaps(numericHoles) {
	const numbers = numericHoles.map((item) => item.num);
	const gaps = [];

	for (let i = 1; i < numbers.length; i++) {
		gaps.push(numbers[i] - numbers[i - 1]);
	}

	// Analyze gap pattern
	const gapCounts = {};
	gaps.forEach((gap) => {
		gapCounts[gap] = (gapCounts[gap] || 0) + 1;
	});

	const uniqueGaps = Object.keys(gapCounts)
		.map(Number)
		.sort((a, b) => a - b);
	const mostCommonGap = uniqueGaps.reduce((a, b) => (gapCounts[a] > gapCounts[b] ? a : b));
	const gapVariability = uniqueGaps.length;

	// Consider pattern reasonable if:
	// - Most common gap is 1 (consecutive numbering)
	// - OR gaps are small and consistent (like 1,2,1,2,1...)
	// - OR large gaps but very consistent (like 10,10,10... for every 10th hole)
	const hasReasonablePattern =
		mostCommonGap === 1 || // Mostly consecutive
		(gapVariability <= 3 && Math.max(...uniqueGaps) <= 5) || // Small, consistent gaps
		(gapVariability === 1 && gaps.length > 5); // Very consistent larger gaps

	console.log("Gap analysis:", {
		gaps: gaps.slice(0, 10), // First 10 gaps
		mostCommonGap,
		gapVariability,
		hasReasonablePattern,
	});

	return {
		hasReasonablePattern,
		mostCommonGap,
		gaps,
		gapVariability,
	};
}

/**
 * ENHANCED SEQUENTIAL DETECTION
 *
 * Uses improved algorithms while respecting sequence order
 */
function enhancedSequentialDetection(numericHoles, entityName, gapInfo) {
	// Choose algorithm based on gap pattern
	if (gapInfo.mostCommonGap === 1 && gapInfo.gapVariability <= 2) {
		// Mostly consecutive - use improved line fitting
		console.log("Using improved sequential line fitting");
		return improvedSequentialLineFitting(numericHoles, entityName);
	} else if (gapInfo.gapVariability === 1) {
		// Consistent gaps - use pattern-based detection
		console.log("Using pattern-based detection for consistent gaps");
		return patternBasedSequentialDetection(numericHoles, entityName, gapInfo.mostCommonGap);
	} else {
		// Irregular gaps - use sequence-aware spatial clustering
		console.log("Using sequence-aware spatial clustering for irregular gaps");
		return sequenceAwareSpatialClustering(numericHoles, entityName);
	}
}

/**
 * PATTERN-BASED SEQUENTIAL DETECTION
 *
 * For holes with consistent gaps (like every 5th hole: 5,10,15,20...)
 */
function patternBasedSequentialDetection(numericHoles, entityName, pattern) {
	const tolerance = calculateAdaptiveTolerance(numericHoles);
	const rows = [];
	const used = new Set();

	// Group holes by their position in the pattern cycle
	const patternGroups = new Map();

	numericHoles.forEach((item, index) => {
		const patternPosition = item.num % pattern;
		if (!patternGroups.has(patternPosition)) {
			patternGroups.set(patternPosition, []);
		}
		patternGroups.get(patternPosition).push({ item, index });
	});

	// Process each pattern group as potential rows
	for (const [position, group] of patternGroups) {
		if (group.length >= 2) {
			// Test if this group forms good spatial rows
			const groupItems = group.map((g) => g.item);
			const spatialRows = detectSpatialRowsInGroup(groupItems, tolerance);

			spatialRows.forEach((row) => {
				if (row.length >= 2) {
					rows.push(row);
					row.forEach((hole) => {
						const originalIndex = numericHoles.indexOf(hole);
						if (originalIndex !== -1) used.add(originalIndex);
					});
				}
			});
		}
	}

	// Handle remaining holes
	for (let i = 0; i < numericHoles.length; i++) {
		if (!used.has(i)) {
			rows.push([numericHoles[i]]);
		}
	}

	// Assign row IDs
	const startingRowID = getNextRowID(entityName);
	rows.forEach((row, rowIndex) => {
		const rowID = startingRowID + rowIndex;
		row.forEach((item, posIndex) => {
			item.hole.rowID = rowID;
			item.hole.posID = posIndex + 1;
		});
	});

	console.log("Pattern-based detection found " + rows.length + " rows");
	return rows.length > 0;
}

/**
 * HANDLE MIXED SEQUENCE PATTERNS
 *
 * Better handling for mixed numeric/alphanumeric patterns while preserving sequence
 */
function handleMixedSequencePattern(holesData, entityName) {
	console.log("Enhanced mixed pattern handling");

	// Create unified sequence that preserves the original intent
	const sequencedHoles = createUnifiedSequence(holesData);

	// Try to detect patterns in the unified sequence
	if (sequencedHoles.hasValidPattern) {
		return enhancedSequentialDetection(sequencedHoles.holes, entityName, sequencedHoles.gapInfo);
	}

	// If no valid pattern, use sequence-weighted spatial clustering
	console.log("No clear pattern, using sequence-weighted spatial clustering");
	return detectRowsUsingSequenceWeightedHDBSCAN(holesData, entityName);
}

function createUnifiedSequence(holesData) {
	// Separate holes by type and create logical ordering
	const numericHoles = [];
	const alphaNumericHoles = [];
	const otherHoles = [];

	holesData.forEach((hole, index) => {
		if (/^\d+$/.test(hole.holeID)) {
			numericHoles.push({
				hole,
				num: parseInt(hole.holeID),
				originalIndex: index,
			});
		} else if (/^[A-Z]+\d+$/i.test(hole.holeID)) {
			const match = hole.holeID.match(/^([A-Z]+)(\d+)$/i);
			if (match) {
				alphaNumericHoles.push({
					hole,
					letter: match[1],
					num: parseInt(match[2]),
					originalIndex: index,
				});
			}
		} else {
			otherHoles.push({ hole, num: index, originalIndex: index });
		}
	});

	// Create unified sequence
	let unifiedSequence = [];
	let counter = 1;

	// Add numeric holes first (sorted)
	numericHoles.sort((a, b) => a.num - b.num);
	numericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add alphanumeric holes (sorted by letter then number)
	alphaNumericHoles.sort((a, b) => {
		if (a.letter !== b.letter) {
			return a.letter.localeCompare(b.letter);
		}
		return a.num - b.num;
	});
	alphaNumericHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Add other holes last
	otherHoles.forEach((item) => {
		unifiedSequence.push({ hole: item.hole, num: counter++ });
	});

	// Analyze the unified sequence
	const gapInfo = analyzeSequenceGaps(unifiedSequence);

	return {
		holes: unifiedSequence,
		hasValidPattern: gapInfo.hasReasonablePattern,
		gapInfo,
	};
}

// #endregion HDBSCAN-ROW-DETECTION

//---------------- END CUSTOM STRUCTURED CSV IMPORTER ----------------//
// #endregion CUSTOM CSV

//---------------- START RULER TOOL ----------------//
// Add these global variables for ruler functionality (around line 80)

// Helper function to format numbers to 2 decimal places
function formatTo2Decimals(num) {
	return parseFloat(num).toFixed(2);
}

// Helper function to format numbers to 1 decimal place
function formatTo1Decimal(num) {
	return parseFloat(num).toFixed(1);
}

function drawRuler(startX, startY, startZ, endX, endY, endZ) {
	// Handle undefined/null Z values - use 0 as fallback
	const safeStartZ = startZ || 0;
	const safeEndZ = endZ || 0;

	// Calculate differences (following your formula exactly)
	const deltaX = endX - startX; // ‚çôX
	const deltaY = endY - startY; // ‚çôY
	const deltaZ = safeEndZ - safeStartZ; // ‚çôZ

	// Calculate 2D plan distance (horizontal distance, hypotenuse of blue triangle D)
	// Plan Length = v(?X? + ?Y?)
	const planDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

	// Calculate true 3D distance (hypotenuse of purple triangle C)
	// Total Length = v(‚çôX + ‚çôY + ‚çôZ)
	const totalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);

	// Calculate bearing angle (horizontal direction)
	const lineAngle = (Math.atan2(deltaY, deltaX) * 180) / Math.PI;

	// Calculate elevation angle A (green angle from horizontal plane)
	// Angle A = arctan(|‚çôZ| / Plan Length)
	const elevationAngle = planDistance > 0 ? (Math.atan(Math.abs(deltaZ) / planDistance) * 180) / Math.PI : 0;

	// Calculate slope percentage for additional context
	const slopePercent = planDistance > 0 ? (Math.abs(deltaZ) / planDistance) * 100 : 0;

	// Convert world coordinates to canvas coordinates
	const canvasStartX = (startX - centroidX) * currentScale + canvas.width / 2;
	const canvasStartY = -(startY - centroidY) * currentScale + canvas.height / 2;
	const canvasEndX = (endX - centroidX) * currentScale + canvas.width / 2;
	const canvasEndY = -(endY - centroidY) * currentScale + canvas.height / 2;

	// Draw main ruler line
	ctx.beginPath();
	ctx.moveTo(canvasStartX, canvasStartY);
	ctx.lineTo(canvasEndX, canvasEndY);
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 2;
	ctx.stroke();

	// Step #) Emit ruler measurements to CSS HUD panel (instead of drawing on ctx)
	// The CSS panel follows the mouse automatically via RulerPanel.js
	showRulerPanel({
		z1: safeStartZ,
		z2: safeEndZ,
		planDistance: planDistance,
		totalDistance: totalDistance,
		deltaZ: deltaZ,
		elevationAngle: elevationAngle,
		slopePercent: slopePercent,
		// Pass canvas position for panel positioning near ruler end
		mouseX: canvasEndX,
		mouseY: canvasEndY
	});

	// Draw meter increments (perpendicular tick marks) - use plan distance for tick spacing
	if (planDistance > 0) {
		for (let i = 0; i <= Math.floor(planDistance); i++) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.2m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.2 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.2 * Math.sin(perpAngle);
			const tick2X = tickX - 0.2 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.2 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}

		// Draw half-meter increments (shorter tick marks)
		for (let i = 0.5; i < planDistance; i += 1) {
			// Calculate position along the line
			const ratio = i / planDistance;
			const tickX = startX + ratio * (endX - startX);
			const tickY = startY + ratio * (endY - startY);

			// Calculate perpendicular offset (0.1m each side)
			const perpAngle = ((lineAngle + 90) * Math.PI) / 180;
			const tick1X = tickX + 0.1 * Math.cos(perpAngle);
			const tick1Y = tickY + 0.1 * Math.sin(perpAngle);
			const tick2X = tickX - 0.1 * Math.cos(perpAngle);
			const tick2Y = tickY - 0.1 * Math.sin(perpAngle);

			// Convert to canvas coordinates
			const canvasTick1X = (tick1X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick1Y = -(tick1Y - centroidY) * currentScale + canvas.height / 2;
			const canvasTick2X = (tick2X - centroidX) * currentScale + canvas.width / 2;
			const canvasTick2Y = -(tick2Y - centroidY) * currentScale + canvas.height / 2;

			// Draw tick mark
			ctx.beginPath();
			ctx.moveTo(canvasTick1X, canvasTick1Y);
			ctx.lineTo(canvasTick2X, canvasTick2Y);
			ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
			ctx.lineWidth = 1;
			ctx.stroke();
		}
	}
}
// Convert the Java paintAngleMeasure function
function drawProtractor(p1X, p1Y, p2X, p2Y, p3X, p3Y) {
	// Don't draw anything if p2 and p3 are the same as p1 (first click only)
	if (p2X === p1X && p2Y === p1Y && p3X === p1X && p3Y === p1Y) {
		return;
	}

	// Calculate distances
	const d1 = Math.sqrt(Math.pow(p2X - p1X, 2) + Math.pow(p2Y - p1Y, 2));
	const d2 = Math.sqrt(Math.pow(p3X - p1X, 2) + Math.pow(p3Y - p1Y, 2));

	// Calculate bearings (North = 0?, East = 90?)
	const bearing1 = (90 - (Math.atan2(p2Y - p1Y, p2X - p1X) * 180) / Math.PI + 360) % 360;
	const bearing2 = (90 - (Math.atan2(p3Y - p1Y, p3X - p1X) * 180) / Math.PI + 360) % 360;

	// Calculate angle between the two lines
	let angle = Math.abs(bearing1 - bearing2);
	if (angle > 180) angle = 360 - angle;

	// Convert to canvas coordinates
	const canvasP1X = (p1X - centroidX) * currentScale + canvas.width / 2;
	const canvasP1Y = -(p1Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP2X = (p2X - centroidX) * currentScale + canvas.width / 2;
	const canvasP2Y = -(p2Y - centroidY) * currentScale + canvas.height / 2;
	const canvasP3X = (p3X - centroidX) * currentScale + canvas.width / 2;
	const canvasP3Y = -(p3Y - centroidY) * currentScale + canvas.height / 2;

	// Draw lines
	ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
	ctx.lineWidth = 1;

	// First line (center to p2)
	if (d1 > 0) {
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP2X, canvasP2Y);
		ctx.stroke();

		// Step #) Show CSS panel with first leg data only (if second leg not yet set)
		if (d2 === 0 || (p3X === p1X && p3Y === p1Y)) {
			showProtractorPanel({
				d1: d1,
				bearing1: bearing1,
				mouseX: canvasP2X,
				mouseY: canvasP2Y
			});
		}
	}

	// Second line (center to p3) - only if p3 is different from p1
	if (d2 > 0 && !(p3X === p1X && p3Y === p1Y)) {
		ctx.strokeStyle = darkModeEnabled ? "#00cccc" : "#004444";
		ctx.lineWidth = 1;
		ctx.beginPath();
		ctx.moveTo(canvasP1X, canvasP1Y);
		ctx.lineTo(canvasP3X, canvasP3Y);
		ctx.stroke();

		// Step #) Emit protractor measurements to CSS HUD panel
		showProtractorPanel({
			d1: d1,
			d2: d2,
			bearing1: bearing1,
			bearing2: bearing2,
			innerAngle: angle,
			outerAngle: 360 - angle,
			mouseX: canvasP1X,
			mouseY: canvasP1Y
		});

		// Draw arc between the lines
		const arcRadius = (Math.min(d1, d2) / 3) * currentScale;
		if (arcRadius > 5) {
			// Calculate the actual angles of the lines in canvas coordinates
			const angle1 = Math.atan2(canvasP2Y - canvasP1Y, canvasP2X - canvasP1X);
			const angle2 = Math.atan2(canvasP3Y - canvasP1Y, canvasP3X - canvasP1X);

			// Calculate the difference between angles
			let angleDiff = angle2 - angle1;

			// Normalize to [-p, p]
			while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
			while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

			// Always draw the smaller arc (interior angle)
			let startAngle, endAngle, counterClockwise;

			if (Math.abs(angleDiff) <= Math.PI) {
				// The direct path is the smaller arc
				startAngle = angle1;
				endAngle = angle2;
				counterClockwise = angleDiff > 0;
			} else {
				// The direct path is the larger arc, so we need to go the other way
				startAngle = angle2;
				endAngle = angle1;
				counterClockwise = angleDiff < 0;
			}

			ctx.beginPath();
			ctx.arc(canvasP1X, canvasP1Y, arcRadius, startAngle, endAngle, counterClockwise);
			ctx.strokeStyle = "#FF0000"; // Red for arc
			ctx.lineWidth = 2;
			ctx.stroke();
		}
	}
}
// Add event listeners for the ruler tools
rulerTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerActive = true;
		rulerStartPoint = null;
		rulerEndPoint = null;
		canvas.addEventListener("click", handleRulerClick);
		updateStatusMessage("Ruler Tool Activated\nSelect 2 points to measure distance\nChange tool to remove.");
	} else {
		isRulerActive = false;
		rulerStartPoint = null;
		rulerEndPoint = null;
		hideRulerPanel(); // Step #) Hide CSS ruler panel when toggled off
		canvas.removeEventListener("click", handleRulerClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});
//Protractor Tool addlistener
rulerProtractorTool.addEventListener("change", function () {
	if (this.checked) {
		resetFloatingToolbarButtons("rulerProtractorTool");
		// Disable other tools
		switches.forEach((switchElement) => {
			if (switchElement && switchElement !== this) switchElement.checked = false;
		});
		setAllBoolsToFalse();
		isRulerProtractorActive = true;
		rulerProtractorPoints = [];
		canvas.addEventListener("click", handleRulerProtractorClick);
		updateStatusMessage("Protractor Tool Activated\nSelect 3 points to measure bearing\nChange tool to remove.");
	} else {
		isRulerProtractorActive = false;
		rulerProtractorPoints = [];
		hideProtractorPanel(); // Step #) Hide CSS protractor panel when toggled off
		canvas.removeEventListener("click", handleRulerProtractorClick);
		drawData(allBlastHoles, selectedHole);
		updateStatusMessage("");
	}
});

// Handle ruler clicks
function handleRulerClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	if (!rulerStartPoint) {
		// First click - set start point, ruler will now follow mouse
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
		rulerEndPoint = null;
	} else if (!rulerEndPoint) {
		// Second click - lock in the end point, measurement is complete
		rulerEndPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
	} else {
		// Third click - start new measurement
		rulerStartPoint = {
			x: worldX,
			y: worldY,
			z: snapResult.worldZ,
		};
		rulerEndPoint = null;
	}
	drawData(allBlastHoles, selectedHole);
}
// Handle ruler bearing clicks (3 points)
function handleRulerProtractorClick(event) {
	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;
	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	rulerProtractorPoints.push({
		x: worldX,
		y: worldY,
	});

	if (rulerProtractorPoints.length > 3) {
		// Start new measurement after 3 points
		rulerProtractorPoints = [
			{
				x: worldX,
				y: worldY,
			},
		];
	}

	drawData(allBlastHoles, selectedHole);
}

//----------------- END RULER TOOLS --------------------//
// Add these tool references after the existing ones
const patternInPolygonTool = document.getElementById("patternInPolygonTool");
const holesAlongLineTool = document.getElementById("holesAlongLineTool");
const holesAlongPolyLineTool = document.getElementById("holesAlongPolyLineTool");

// Add state variables for the new tools
let isPatternInPolygonActive = false;
let isHolesAlongLineActive = false;
let isHolesAlongPolyLineActive = false;

// Pattern in Polygon Tool state
let patternPolygonStep = 0; // 0=select polygon, 1=select start point, 2=select end point, 3=select reference point
let selectedPolygon = null;
let patternStartPoint = null;
let patternEndPoint = null;
let patternReferencePoint = null;
// KAD Polygon selection for editing

// Holes Along Line Tool state
let holesLineStep = 0; // 0=select start point, 1=select end point
let lineStartPoint = null;
let lineEndPoint = null;

// Holes Along PolyLine Tool state
let lastClickTime = null;
// Add state variables for the polyline tool
let polylineStep = 0; // 0=select line/polygon, 1=select start point, 2=select end point
let selectedPolyline = null;
let polylineStartPoint = null;
let polylineEndPoint = null;

// Add this wherever I finish clipping holes to polygon boundaries
function finalizePatternInPolygon(entityName) {
	// After clipping operations are complete
	renumberPatternAfterClipping(entityName);

	// Recalculate times and redraw
	holeTimes = calculateTimes(allBlastHoles);
	const result = recalculateContours(allBlastHoles, 0, 0);
	if (result) {
		contourLinesArray = result.contourLinesArray;
		directionArrows = result.directionArrows;
	}

	drawData(allBlastHoles, selectedHole);
	updateTreeView(); // Update the tree to show new numbering
}

//---------------PATTERN IN POLYGON TOOL---------------//
patternInPolygonTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("patternInPolygonTool");
		// This function did not work and was causing issues with the tool
		// removeEventListenersExcluding(["patternInPolygonTool", "selectPointerTool", "defaultListeners"]);

		endKadTools(true);
		isPatternInPolygonActive = true;
		patternPolygonStep = 0;
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;

		canvas.addEventListener("click", handlePatternInPolygonClick);
		canvas.addEventListener("touchstart", handlePatternInPolygonClick);

		updateStatusMessage("Step 1: Click on a polygon to select it");
	} else {
		resetFloatingToolbarButtons("none");
		isPatternInPolygonActive = false;
		patternPolygonStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolygon = null;
		patternStartPoint = null;
		patternEndPoint = null;
		patternReferencePoint = null;
		// Clear both local and window selectedKADObject to remove polygon highlight in 3D
		selectedKADObject = null;
		selectedKADPolygon = null;
		window.selectedKADObject = null;

		// Clear 3D visuals (leading line and markers)
		clearKADLeadingLineThreeJS();
		if (window.patternTool3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.patternTool3DGroup);
			window.patternTool3DGroup = null;
		}

		canvas.removeEventListener("click", handlePatternInPolygonClick);
		canvas.removeEventListener("touchstart", handlePatternInPolygonClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handlePatternInPolygonClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	// FIX: Check if worldX/worldY already set by 3D mode (avoid double conversion)
	var using3DCoordinates = false;
	if (window.worldX !== undefined && window.worldY !== undefined) {
		// Use coordinates already set by 3D click handler (already snapped)
		worldX = window.worldX;
		worldY = window.worldY;
		using3DCoordinates = true;
		// Clear window variables to prevent stale values
		window.worldX = undefined;
		window.worldY = undefined;
	} else {
		// 2D mode: Convert canvas coordinates to world coordinates with snapping
		const rect = canvas.getBoundingClientRect();
		const clickX = clientX - rect.left;
		const clickY = clientY - rect.top;

		const snapResult = canvasToWorldWithSnap(clickX, clickY);
		worldX = snapResult.worldX;
		worldY = snapResult.worldY;

		// Show snap feedback if snapped
		if (snapResult.snapped) {
			updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
			setTimeout(() => updateStatusMessage(""), 1500);
		}
	}

	switch (patternPolygonStep) {
		case 0: // Select polygon
			// The equivalent 3D(ThreeJS) Mode Selection function is handlePatternInPolygonClick3D or similar.
			const clickedEntityInfo = getClickedKADEntity(worldX, worldY);
			if (clickedEntityInfo && clickedEntityInfo.entity.entityType === "poly") {
				selectedPolygon = clickedEntityInfo.entity; // ? Extract just the entity
				// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
				selectedKADObject = clickedEntityInfo;
				selectedKADPolygon = clickedEntityInfo; // Backward compatibility
				// REUSE: Set window.selectedKADObject so highlightSelectedKADThreeJS() handles highlight in 3D
				window.selectedKADObject = clickedEntityInfo;
				patternPolygonStep = 1;
				updateStatusMessage("Step 2: Click to select pattern start point");
			} else {
				updateStatusMessage("No polygon found.\nStep 1: Click on a polygon to select it");
			}
			break;

		case 1: // Select start point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var startZ = window.worldZ;
			if (startZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				startZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternStartPoint = {
				x: worldX,
				y: worldY,
				z: startZ
			};
			patternPolygonStep = 2;
			updateStatusMessage("Step 3: Click to select pattern\nend point (for orientation)");
			console.log("Pattern start point set to:", worldX.toFixed(2), worldY.toFixed(2), startZ?.toFixed(2));
			break;

		case 2: // Select end point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var endZ = window.worldZ;
			if (endZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				endZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternEndPoint = {
				x: worldX,
				y: worldY,
				z: endZ
			};
			patternPolygonStep = 3;
			updateStatusMessage("Step 4: Click to select reference point");
			console.log("Pattern end point set to:", worldX.toFixed(2), worldY.toFixed(2), endZ?.toFixed(2));
			break;

		case 3: // Select reference point
			// FIX: Get Z from window.worldZ (set by 3D click) or polygon
			var refZ = window.worldZ;
			if (refZ === undefined && selectedPolygon && selectedPolygon.data && selectedPolygon.data.length > 0) {
				var firstPt = selectedPolygon.data[0];
				refZ = firstPt.pointZLocation || firstPt.z || dataCentroidZ || 0;
			}
			patternReferencePoint = {
				x: worldX,
				y: worldY,
				z: refZ
			};
			updateStatusMessage("Reference point selected");
			console.log("Pattern reference point set to:", worldX.toFixed(2), worldY.toFixed(2));
			showPatternInPolygonPopup();
			// Dont deactivate the tool here - let the popup handle it
			// patternInPolygonTool.checked = false;
			// patternInPolygonTool.dispatchEvent(new Event("change")); // ? THIS IS THE PROBLEM!
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
//---------------HOLES ALONG POLYLINE TOOL---------------//
holesAlongPolyLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongPolyLineTool");

		endKadTools(true);
		isHolesAlongPolyLineActive = true;
		polylineStep = 0;
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.addEventListener("click", handleHolesAlongPolyLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Set cursor to indicate selection mode
		canvas.style.cursor = "crosshair";

		updateStatusMessage("Step 1: Click on an existing line,\npolyline, or polygon edge to select it.");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongPolyLineActive = false;
		polylineStep = 0;

		// CRITICAL: Clear all selection state to prevent old selections from appearing
		selectedPolyline = null;
		polylineStartPoint = null;
		polylineEndPoint = null;

		canvas.removeEventListener("click", handleHolesAlongPolyLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongPolyLineClick);

		// Reset cursor
		canvas.style.cursor = "default";

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});
// Updated click handler with multi-step process
function handleHolesAlongPolyLineClick(event) {
	if (!isHolesAlongPolyLineActive) return;

	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (polylineStep) {
		case 0: // Select line/polygon
			// Use the same robust selection method as the select pointer tool
			const clickedKADObject = getClickedKADObject(clickX, clickY);


			if (clickedKADObject && (clickedKADObject.entityType === "line" || clickedKADObject.entityType === "poly")) {
				var entity = allKADDrawingsMap.get(clickedKADObject.entityName);
				selectedPolyline = {
					type: clickedKADObject.entityType === "line" ? "line" : "polygon",
					vertices: entity.data.map((point) => ({
						x: point.pointXLocation,
						y: point.pointYLocation,
						z: point.pointZLocation || point.z || dataCentroidZ || 0, // FIX: Include Z values
					})),
					entity: entity,
				};
				// CRITICAL: Set local module variable so exposeGlobalsToWindow() doesn't overwrite it
				selectedKADObject = clickedKADObject;
				window.selectedKADObject = clickedKADObject; // Set for highlighting
				// FIX: Also set selectedKADPolygon for backward compatibility
				selectedKADPolygon = clickedKADObject;
				polylineStep = 1;
				updateStatusMessage("Step 2: Click on a vertex or point along the " + selectedPolyline.type + " to set the start point.");
				console.log("Selected " + selectedPolyline.type + " with", selectedPolyline.vertices.length, "vertices");
				break;
			}

			updateStatusMessage("No line or polygon found. Step 1: Click on an existing line, polyline, or polygon edge.");
			break;

		case 1: // Select start point
			polylineStartPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineStartPoint) {
				polylineStep = 2;
				updateStatusMessage("Step 3: Click on another vertex along the line to set the end point.");
				console.log("Start point set at:", polylineStartPoint);
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;

		case 2: // Select end point
			polylineEndPoint = findClosestVertex(worldX, worldY, selectedPolyline.vertices);
			if (polylineEndPoint) {
				console.log("End point set at:", polylineEndPoint);

				// Create path from start to end point - now with polygon awareness
				const isPolygon = selectedPolyline.type === "polygon";
				const pathVertices = createPathBetweenVertices(selectedPolyline.vertices, polylineStartPoint, polylineEndPoint, isPolygon);

				if (pathVertices.length >= 2) {
					// Pass the polygon type and original vertices to the popup for reverse handling
					window.showHolesAlongPolylinePopup(pathVertices, selectedPolyline);
				} else {
					updateStatusMessage("Invalid path between selected points. Please try again.");
					polylineStep = 1;
					polylineStartPoint = null;
					polylineEndPoint = null;
				}

				// DON'T deactivate the tool here - let the popup handle it
				// holesAlongPolyLineTool.checked = false;
				// holesAlongPolyLineTool.dispatchEvent(new Event("change"));
			} else {
				updateStatusMessage("Click closer to a vertex on the selected line/polygon.");
			}
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
// Expose handleHolesAlongPolyLineClick globally for PatternGenerationDialogs.js
window.handleHolesAlongPolyLineClick = handleHolesAlongPolyLineClick;
// Expose handleHolesAlongLineClick globally for PatternGenerationDialogs.js
window.handleHolesAlongLineClick = handleHolesAlongLineClick;
//---------------HOLES ALONG LINE TOOL---------------//
holesAlongLineTool.addEventListener("change", function () {
	if (this.checked) {
		setAllBoolsToFalse();
		setMultipleSelectionModeToFalse();
		resetSwitchesTogglesOptionalDisplay();
		removeAllCanvasListenersKeepDefault();
		resetFloatingToolbarButtons("holesAlongLineTool");

		endKadTools(true);
		isHolesAlongLineActive = true;
		holesLineStep = 0;
		window.holesLineStep = holesLineStep; // Keep window in sync
		lineStartPoint = null;
		window.lineStartPoint = lineStartPoint; // Keep window in sync
		lineEndPoint = null;
		window.lineEndPoint = lineEndPoint; // Keep window in sync

		canvas.addEventListener("click", handleHolesAlongLineClick);
		canvas.addEventListener("touchstart", handleHolesAlongLineClick);

		updateStatusMessage("Step 1: Click to select line start point");
	} else {
		resetFloatingToolbarButtons("none");
		isHolesAlongLineActive = false;
		holesLineStep = 0;
		window.holesLineStep = holesLineStep; // Keep window in sync

		// Clear line points to remove visual feedback
		lineStartPoint = null;
		window.lineStartPoint = lineStartPoint; // Keep window in sync
		lineEndPoint = null;
		window.lineEndPoint = lineEndPoint; // Keep window in sync

		// Clear 3D visuals (leading line and markers)
		clearKADLeadingLineThreeJS();
		if (window.holesAlongLine3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.holesAlongLine3DGroup);
			window.holesAlongLine3DGroup = null;
		}
		hideDrawingDistance();

		canvas.removeEventListener("click", handleHolesAlongLineClick);
		canvas.removeEventListener("touchstart", handleHolesAlongLineClick);

		// Remove the default canvas handlers to avoid conflicts
		canvas.removeEventListener("mousedown", handleMouseDown);
		// canvas.removeEventListener("mousemove", handleMouseMove);
		canvas.removeEventListener("mouseup", handleMouseUp);
		canvas.removeEventListener("touchstart", handleTouchStart);
		// canvas.removeEventListener("touchmove", handleTouchMove);
		canvas.removeEventListener("touchend", handleTouchEnd);
		// Restore default canvas handlers so the tool works properly
		canvas.addEventListener("mousedown", handleMouseDown);
		// 		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("mouseup", handleMouseUp);
		canvas.addEventListener("touchstart", handleTouchStart);
		// canvas.addEventListener("touchmove", handleTouchMove);
		canvas.addEventListener("touchend", handleTouchEnd);

		updateStatusMessage("");
		drawData(allBlastHoles, selectedHole);
	}
});

function handleHolesAlongLineClick(event) {
	event.preventDefault();
	event.stopPropagation();

	const clientX = event.clientX || (event.touches && event.touches[0].clientX);
	const clientY = event.clientY || (event.touches && event.touches[0].clientY);

	const rect = canvas.getBoundingClientRect();
	const clickX = clientX - rect.left;
	const clickY = clientY - rect.top;

	// SNAPPIN SNAP:
	const snapResult = canvasToWorldWithSnap(clickX, clickY);
	worldX = snapResult.worldX;
	worldY = snapResult.worldY;
	// Step #) Capture Z from snap result (uses snapped object's Z or drawing elevation)
	var worldZ = snapResult.worldZ !== undefined ? snapResult.worldZ : (drawingZValue || 0);

	// Show snap feedback if snapped
	if (snapResult.snapped) {
		updateStatusMessage("Snapped to " + snapResult.snapTarget.description);
		setTimeout(() => updateStatusMessage(""), 1500);
	}

	switch (holesLineStep) {
		case 0: // Select start point
			lineStartPoint = {
				x: worldX,
				y: worldY,
				z: worldZ
			};
			window.lineStartPoint = lineStartPoint; // Keep window in sync
			holesLineStep = 1;
			window.holesLineStep = holesLineStep; // Keep window in sync
			updateStatusMessage("Step 2: Click to select line end point");
			break;

		case 1: // Select end point
			lineEndPoint = {
				x: worldX,
				y: worldY,
				z: worldZ
			};
			window.lineEndPoint = lineEndPoint; // Keep window in sync
			window.showHolesAlongLinePopup();
			break;
	}

	drawData(allBlastHoles, selectedHole);
}
// Helper function to update status messages
function updateStatusMessage(message) {
	// You can display this in a status bar or console
	//console.log(message);
	statusMessage = message;
	// If you have a status element in your HTML, update it:
	// document.getElementById("statusMessage").textContent = message;
}
// Enhanced snapping function for CAD vertices and hole points
function findNearestSnapPoint(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	let closestPoint = null;
	let minDistance = tolerance;
	let snapType = null;

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "polygons for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Polygon", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Polygon vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY,
						};
						snapType = "CAD Polygon Vertex";
						console.log("Found closer CAD polygon vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search CAD vertices from allKADDrawingsMap
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		console.log("Searching", allKADDrawingsMap.size, "lines for vertices");
		allKADDrawingsMap.forEach((entity, key) => {
			if (entity.data && entity.data.length > 0) {
				console.log("Line", key, "has", entity.data.length, "vertices");
				entity.data.forEach((point, pointIndex) => {
					const vertexX = point.pointXLocation;
					const vertexY = point.pointYLocation;
					const distance = Math.sqrt(Math.pow(worldX - vertexX, 2) + Math.pow(worldY - vertexY, 2));
					console.log("Line vertex", pointIndex, "at", vertexX.toFixed(2), vertexY.toFixed(2), "distance:", distance.toFixed(2));
					if (distance < minDistance) {
						minDistance = distance;
						closestPoint = {
							x: vertexX,
							y: vertexY,
						};
						snapType = "CAD Line Vertex";
						console.log("Found closer CAD line vertex, distance:", distance.toFixed(2));
					}
				});
			}
		});
	} else {
		console.log("No allKADDrawingsMap found or empty");
	}

	// Search hole collar allBlastHoles
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole, holeIndex) => {
			// Collar point
			if (hole.startXLocation !== undefined && hole.startYLocation !== undefined) {
				const collarDistance = Math.sqrt(Math.pow(worldX - hole.startXLocation, 2) + Math.pow(worldY - hole.startYLocation, 2));
				if (collarDistance < minDistance) {
					minDistance = collarDistance;
					closestPoint = {
						x: hole.startXLocation,
						y: hole.startYLocation,
					};
					snapType = "Hole Collar (" + hole.holeID + ")";
					console.log("Found closer hole collar, distance:", collarDistance.toFixed(2));
				}
			}

			// Grade point (if exists)
			if (hole.gradeXLocation !== undefined && hole.gradeYLocation !== undefined) {
				const gradeDistance = Math.sqrt(Math.pow(worldX - hole.gradeXLocation, 2) + Math.pow(worldY - hole.gradeYLocation, 2));
				if (gradeDistance < minDistance) {
					minDistance = gradeDistance;
					closestPoint = {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
					};
					snapType = "Hole Grade (" + hole.holeID + ")";
					console.log("Found closer hole grade, distance:", gradeDistance.toFixed(2));
				}
			}

			// Toe point (calculated from hole geometry)
			if (hole.endXLocation !== undefined && hole.endYLocation !== undefined) {
				const toeDistance = Math.sqrt(Math.pow(worldX - hole.endXLocation, 2) + Math.pow(worldY - hole.endYLocation, 2));
				if (toeDistance < minDistance) {
					minDistance = toeDistance;
					closestPoint = {
						x: hole.endXLocation,
						y: hole.endYLocation,
					};
					snapType = "Hole Toe (" + hole.holeID + ")";
					console.log("Found closer hole toe, distance:", toeDistance.toFixed(2));
				}
			}
		});
	} else {
		console.log("No holes found or allBlastHoles array is empty");
	}

	if (closestPoint) {
		// Snap found
	} else {
		// No snap found
	}

	return closestPoint
		? {
			point: closestPoint,
			type: snapType,
			distance: minDistance,
		}
		: null;
}
// Helper function to find the closest vertex to a click point (keep original for compatibility)
function findClosestVertex(clickX, clickY, vertices, tolerance = getSnapToleranceInWorldUnits()) {
	let closestVertex = null;
	let minDistance = tolerance;

	vertices.forEach((vertex, index) => {
		const distance = Math.sqrt(Math.pow(clickX - vertex.x, 2) + Math.pow(clickY - vertex.y, 2));
		if (distance < minDistance) {
			minDistance = distance;
			closestVertex = {
				...vertex,
				index: index,
			};
		}
	});

	return closestVertex;
}
// Helper function to create a path between two vertices
// Now properly handles polygons as closed shapes
function createPathBetweenVertices(vertices, startVertex, endVertex, isPolygon = false) {
	const startIndex = startVertex.index;
	const endIndex = endVertex.index;

	if (startIndex === endIndex) {
		return [startVertex];
	}

	let pathVertices = [];

	if (!isPolygon) {
		// For open polylines/lines - original logic
		if (startIndex < endIndex) {
			for (let i = startIndex; i <= endIndex; i++) {
				pathVertices.push(vertices[i]);
			}
		} else {
			for (let i = startIndex; i >= endIndex; i--) {
				pathVertices.push(vertices[i]);
			}
		}
	} else {
		// For polygons - handle as closed loop
		const totalVertices = vertices.length;

		// Calculate forward path distance (going from start to end in forward direction)
		let forwardDistance;
		if (endIndex >= startIndex) {
			forwardDistance = endIndex - startIndex;
		} else {
			forwardDistance = totalVertices - startIndex + endIndex;
		}

		// Calculate backward path distance (going from start to end in backward direction)
		let backwardDistance;
		if (startIndex >= endIndex) {
			backwardDistance = startIndex - endIndex;
		} else {
			backwardDistance = startIndex + (totalVertices - endIndex);
		}

		// Choose the shorter path by default (can be overridden by reverse option)
		let useForwardPath = forwardDistance <= backwardDistance;

		if (useForwardPath) {
			// Forward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex + 1) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		} else {
			// Backward path around the polygon
			let currentIndex = startIndex;
			while (true) {
				pathVertices.push(vertices[currentIndex]);
				if (currentIndex === endIndex) break;

				currentIndex = (currentIndex - 1 + totalVertices) % totalVertices;

				// Safety check to prevent infinite loop
				if (pathVertices.length > totalVertices) break;
			}
		}

		console.log("Polygon path created:", {
			startIndex: startIndex,
			endIndex: endIndex,
			forwardDistance: forwardDistance,
			backwardDistance: backwardDistance,
			usedForwardPath: useForwardPath,
			pathLength: pathVertices.length,
		});
	}

	return pathVertices;
}

function toRadians(degrees) {
	return (degrees * Math.PI) / 180;
}

function toDegrees(radians) {
	return (radians * 180) / Math.PI;
}

function toBearing(degrees) {
	return (degrees + 90) % 360;
}
// ADDED ROWID AND POSID
function generatePatternInPolygon(patternSettings) {
	if (!selectedPolygon || !patternStartPoint || !patternEndPoint || !patternReferencePoint) {
		console.error("Missing pattern data");
		return;
	}

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	console.log("Generating pattern in polygon. REF X:[" + patternReferencePoint.x + ", " + patternReferencePoint.y + "]");

	// Extract pattern settings
	const { blastName, burden, spacing, spacingOffset, collarZ, gradeZ, subdrill, angle, bearing, diameter, type, startNumber, nameTypeIsNumerical, useGradeZ, length, patternType } = patternSettings;

	// Calculate the orientation angle from start to end point
	const dx = patternEndPoint.x - patternStartPoint.x;
	const dy = patternEndPoint.y - patternStartPoint.y;

	// Calculate orientation (bearing from first to second point)
	let orientation = ((Math.atan2(dy, dx) * 180) / Math.PI + 360) % 360;

	console.log("Line bearing (Start to End):", orientation.toFixed(2) + "¬∞");

	// Get polygon vertices
	const polygonVertices = selectedPolygon.data.map((point) => ({
		x: point.pointXLocation,
		y: point.pointYLocation,
	}));

	console.log("Polygon vertices:", polygonVertices.length);

	// Find polygon bounds
	let minX = Infinity,
		maxX = -Infinity,
		minY = Infinity,
		maxY = -Infinity;
	polygonVertices.forEach((vertex) => {
		const x = vertex.x;
		const y = vertex.y;
		minX = Math.min(minX, x);
		maxX = Math.max(maxX, x);
		minY = Math.min(minY, y);
		maxY = Math.max(maxY, y);
	});

	const polygonWidth = maxX - minX;
	const polygonHeight = maxY - minY;
	const polygonDiagonal = Math.sqrt(polygonWidth * polygonWidth + polygonHeight * polygonHeight);

	// Use the reference point as pattern origin
	const patternOriginX = patternReferencePoint.x;
	const patternOriginY = patternReferencePoint.y;
	console.log("Pattern in polygon. ORIGIN  X:[" + patternOriginX + ", " + patternOriginY + "]");

	// Store original holes count to identify new holes
	const originalHolesCount = allBlastHoles.length;

	// Generate the pattern grid
	const rowBearing = orientation;
	const columnBearing = (orientation + 90) % 360;

	console.log("Row bearing:", rowBearing.toFixed(2) + "¬∞");
	console.log("Column bearing:", columnBearing.toFixed(2) + "¬∞");

	const rowRadians = toRadians(rowBearing);
	const columnRadians = toRadians(columnBearing);

	// Calculate grid extents based on polygon size
	const bufferFactor = 10.0;
	const maxDistance = polygonDiagonal * bufferFactor;

	const numRows = Math.ceil(maxDistance / burden);
	const numCols = Math.ceil(maxDistance / spacing);

	const halfRows = Math.floor(numRows / 2);
	const halfCols = Math.floor(numCols / 2);

	// Find the grid point closest to (0,0)
	let centerGridX = 0;
	let centerGridY = 0;
	let minDistToCenter = Infinity;

	for (let i = -1; i <= 1; i++) {
		for (let k = -1; k <= 1; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const gridX = colOffset;
			const gridY = i * burden;
			const distToCenter = Math.sqrt(gridX * gridX + gridY * gridY);

			if (distToCenter < minDistToCenter) {
				minDistToCenter = distToCenter;
				centerGridX = gridX;
				centerGridY = gridY;
			}
		}
	}

	const gridXOffset = -centerGridX;
	const gridYOffset = -centerGridY;

	console.log("Grid adjustment: Found center grid point at (" + centerGridX.toFixed(2) + ", " + centerGridY.toFixed(2) + "), applying offset (" + gridXOffset.toFixed(2) + ", " + gridYOffset.toFixed(2) + ")");

	// Collect all holes that will be inside the polygon WITH their original grid coordinates
	const holesInPolygon = [];

	// Generate grid of holes - collect valid holes first
	for (let i = -halfRows; i <= halfRows; i++) {
		for (let k = -halfCols; k <= halfCols; k++) {
			let colOffset = k * spacing;
			const isStaggered = patternType === "staggered" || (patternType === undefined && spacingOffset !== 0);
			if (isStaggered && i % 2 !== 0) {
				colOffset += spacingOffset * spacing;
			}

			const adjustedColOffset = colOffset + gridXOffset;
			const adjustedRowOffset = i * burden + gridYOffset;

			// Calculate position using row and column bearings
			const yFromColumn = adjustedRowOffset * Math.sin(columnRadians);
			const xFromColumn = adjustedRowOffset * Math.cos(columnRadians);
			const yFromRow = adjustedColOffset * Math.sin(rowRadians);
			const xFromRow = adjustedColOffset * Math.cos(rowRadians);

			const holeX = patternOriginX + xFromColumn + xFromRow;
			const holeY = patternOriginY + yFromColumn + yFromRow;

			// Check if hole is inside polygon
			if (isPointInPolygonVertices(holeX, holeY, polygonVertices)) {
				holesInPolygon.push({
					x: holeX,
					y: holeY,
					originalGridRow: i,
					originalGridCol: k,
					isStaggered: isStaggered && i % 2 !== 0,
				});
			}
		}
	}

	// Group holes by their ORIGINAL GRID ROW
	const uniqueGridRows = [...new Set(holesInPolygon.map((hole) => hole.originalGridRow))];
	uniqueGridRows.sort((a, b) => a - b);

	console.log("Unique grid rows found:", uniqueGridRows);

	const rows = [];
	uniqueGridRows.forEach((gridRowIndex) => {
		const holesInThisGridRow = holesInPolygon.filter((hole) => hole.originalGridRow === gridRowIndex);

		const rowBearingRadians = (90 - orientation) * (Math.PI / 180);
		holesInThisGridRow.forEach((hole) => {
			hole.spacingProjection = hole.x * Math.cos(rowBearingRadians) + hole.y * Math.sin(rowBearingRadians);
		});

		holesInThisGridRow.sort((a, b) => a.spacingProjection - b.spacingProjection);
		rows.push(holesInThisGridRow);
	});

	// Determine the actual grid ranges
	let minActualRow = Math.min(...uniqueGridRows);
	let maxActualRow = Math.max(...uniqueGridRows);
	let minActualCol = Infinity;
	let maxActualCol = -Infinity;

	holesInPolygon.forEach((hole) => {
		minActualCol = Math.min(minActualCol, hole.originalGridCol);
		maxActualCol = Math.max(maxActualCol, hole.originalGridCol);
	});

	console.log("Actual grid range: rows " + minActualRow + " to " + maxActualRow + ", cols " + minActualCol + " to " + maxActualCol);

	// Get the starting rowID for this pattern (first row will get this rowID)
	const startingRowID = getNextRowID(blastName);
	console.log("Starting rowID for polygon pattern:", startingRowID);

	let holeCounter = startNumber;

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	// Process rows from first (lowest row letter) to last (highest row letter)
	for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
		// Check for cancellation before each row
		if (window.holeGenerationCancelled) {
			console.log("Pattern generation cancelled by user");
			break;
		}

		const row = rows[rowIndex];

		// Each row in the pattern gets its own rowID
		const currentRowID = startingRowID + rowIndex;

		// Calculate actual row letter based on the row's original grid position
		const actualRowGridIndex = row[0].originalGridRow;
		const rowLetterIndex = actualRowGridIndex - minActualRow;

		let rowLetter = "A";
		for (let l = 0; l < rowLetterIndex; l++) {
			rowLetter = incrementLetter(rowLetter);
		}

		// Process holes in this row
		for (let colIndex = 0; colIndex < row.length; colIndex++) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Pattern generation cancelled by user");
				break;
			}

			const hole = row[colIndex];

			let holeID;
			if (nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				const actualColGridIndex = hole.originalGridCol;
				let colNumber = actualColGridIndex - minActualCol + 1;

				// Apply offset logic based on spacingOffset value and row position
				if (spacingOffset <= -1) {
					colNumber = colNumber + rowLetterIndex;
				} else if (spacingOffset > -1 && spacingOffset < 1) {
					// colNumber stays the same
				} else if (spacingOffset >= 1) {
					// colNumber stays the same
				}

				holeID = rowLetter + colNumber;
			}

			// Position ID is sequential for each hole in this row (starts at 1 for each row)
			const posID = colIndex + 1;

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Polygon pattern generation cancelled by user - stopping hole addition");
				break;
			}

			// Add hole using existing addHole function with rowID and posID
			addHole(true, useGradeZ, blastName, holeID, hole.x, hole.y, collarZ, gradeZ, diameter, type, length, subdrill, angle, bearing, currentRowID, posID, burden, spacing);
		}
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled polygon pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalHolesCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Polygon pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated pattern in polygon with " + holesAdded + " holes across " + rows.length + " rows (rowIDs " + startingRowID + "-" + (startingRowID + rows.length - 1) + ")");

		//! REDO with the FloatingDialog class
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated in the polygon. Please check your pattern settings and polygon shape.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog
		// else {
		// 	showModalMessage("Pattern Generated", "Successfully generated " + holesAdded + " holes in the polygon across " + rows.length + " rows (Rows " + startingRowID + "-" + (startingRowID + rows.length - 1) + ").", "success");
		// }
	}

	// Update display
	// Step #) Trigger 3D rebuild to show newly generated pattern in polygon
	window.threeDataNeedsRebuild = true;
	drawData(allBlastHoles, selectedHole);
	if (!window.holeGenerationCancelled) {
		debouncedSaveHoles(); // Auto-save holes to IndexedDB (only if not cancelled, since we already saved above)
	}
}

// Expose generatePatternInPolygon globally for PatternGenerationDialogs.js
window.generatePatternInPolygon = generatePatternInPolygon;

// Step 1) Converted to FloatingDialog class
// Function to show holes along line popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
// Update the generateHolesAlongLine function to correctly apply the bearing:
// Update the generateHolesAlongLine function to use rowID/posID:
function generateHolesAlongLine(params) {
	//! REDO with the FloatingDialog class
	if (!lineStartPoint || !lineEndPoint) {
		console.error("Missing line points");
		return;
	}

	console.log("Generating holes along line...");
	console.log("Start:", lineStartPoint);
	console.log("End:", lineEndPoint);
	console.log("Parameters:", params);

	// Initialize allBlastHoles array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
		console.log("Initialized empty allBlastHoles array");
	}

	// Calculate line length and direction
	const dx = lineEndPoint.x - lineStartPoint.x;
	const dy = lineEndPoint.y - lineStartPoint.y;
	const lineLength = Math.sqrt(dx * dx + dy * dy);
	const unitX = dx / lineLength;
	const unitY = dy / lineLength;

	// Calculate line bearing in world coordinates
	const lineBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;
	console.log("Line bearing:", lineBearing.toFixed(2) + "¬∞");

	// Generate holes along the line
	const numHoles = Math.floor(lineLength / params.spacing) + 1;
	const entityName = params.blastName || "LinePattern_" + Date.now();
	const originalHolesCount = allBlastHoles.length;

	// Calculate hole bearing based on user preference
	const holeBearing = params.useLineBearing ? (lineBearing + 90) % 360 : params.bearing;
	console.log("Using hole bearing:", holeBearing.toFixed(2) + "¬∞");

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for line pattern");

	// Initialize cancellation flag and track starting hole count for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern
	window.holeGenerationStartCount = allBlastHoles ? allBlastHoles.length : 0; // Track starting count

	// Generate holes starting from the first point
	for (let i = 0; i < numHoles; i++) {
		// Check for cancellation before each hole
		if (window.holeGenerationCancelled) {
			console.log("Hole generation cancelled by user");
			break;
		}

		const distanceAlongLine = i * params.spacing;
		const holeX = lineStartPoint.x + unitX * distanceAlongLine;
		const holeY = lineStartPoint.y + unitY * distanceAlongLine;

		// Calculate hole ID
		let holeID;
		if (params.nameTypeIsNumerical) {
			holeID = params.startNumber + i;
		} else {
			// Use alphabetical naming like A1, A2, etc.
			const letter = String.fromCharCode(65 + Math.floor(i / 26));
			const number = (i % 26) + 1;
			holeID = letter + number;
		}

		// Position ID is sequential for each hole in this row
		const posID = i + 1;

		// Check for cancellation right before adding hole
		if (window.holeGenerationCancelled) {
			console.log("Line pattern generation cancelled by user - stopping hole addition");
			break;
		}

		// Add hole to points array with rowID and posID
		addHole(
			true, // useCustomHoleID - always true for pattern generation
			params.useGradeZ, // useGradeZ from params
			entityName,
			holeID, // holeID
			holeX, // startX
			holeY, // startY
			params.collarZ, // startZ
			params.gradeZ, // gradeZ
			params.diameter, // diameter
			params.type, // holeType
			params.length, // length
			params.subdrill, // subdrill
			params.angle, // angle
			holeBearing, // bearing - use calculated bearing perpendicular to line if useLineBearing is true
			rowID, // rowID - all holes in this line get the same rowID
			posID, // posID - sequential position in the row
			params.burden, // burden - Need to add to the show dialog popup for every hole add.
			params.spacing // spacing
		);
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled line pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Redraw
	debouncedUpdateTreeView(); // Use debounced version
	// Step #) Trigger 3D rebuild to show newly generated holes along line
	window.threeDataNeedsRebuild = true;
	drawData(allBlastHoles, selectedHole);

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalHolesCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Line pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated " + holesAdded + " holes along line with rowID " + rowID);
		debouncedSaveHoles(); // Auto-save holes to IndexedDB

		//! REDO with the FloatingDialog class
		// Show success/failure message with custom styling
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated along the line. Please check your line and spacing settings.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog 
		// else {
		// 	showModalMessage("Line Pattern Generated", `Successfully generated ${holesAdded} holes along the line (Row ${rowID}).`, "success");
		// }
	}
}
// Expose generateHolesAlongLine globally for PatternGenerationDialogs.js
window.generateHolesAlongLine = generateHolesAlongLine;
// Expose global variables for PatternGenerationDialogs.js
window.holesAlongLineTool = holesAlongLineTool;
window.lineStartPoint = lineStartPoint;
window.lineEndPoint = lineEndPoint;
window.holesLineStep = holesLineStep;
/**
 * Finds the KAD entity (line or poly) closest to a world coordinate click.
 * This function unifies the logic for selecting both open and closed polylines.
 * @param {number} worldX The x-coordinate of the click in world units.
 * @param {number} worldY The y-coordinate of the click in world units.
 * @returns {object|null} The selected entity object or null if nothing is found.
 */
function getClickedKADEntity(worldX, worldY) {
	if (allKADDrawingsMap.size === 0) return null;

	const tolerance = getSnapToleranceInWorldUnits();
	const candidateEntities = [];

	// Check each line or poly entity
	for (const [name, entity] of allKADDrawingsMap.entries()) {
		// ? CHECK VISIBILITY FIRST - Skip hidden entities
		if (!isEntityVisible(name)) continue;

		const points = entity.data;
		if (points.length < 1) continue;

		let minDistance = Infinity;
		let clickedVertex = null;
		let clickedSegment = null;
		const isClosed = entity.entityType === "poly";

		// For single-point entities (points, circles, text), only check the point
		if (entity.entityType === "point" || entity.entityType === "circle" || entity.entityType === "text") {
			const point = points[0]; // These entities have only one point
			const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));

			if (distance <= tolerance) {
				candidateEntities.push({
					entity: entity,
					minDistance: distance,
					selectionType: "point",
					clickedVertex: {
						index: 0,
						x: point.pointXLocation,
						y: point.pointYLocation,
						distance: distance,
					},
					clickedSegment: null,
				});
			}
			continue; // Skip to next entity
		}
		if (entity.entityType === "line") {
			// For lines, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}
		if (entity.entityType === "poly") {
			// For polygons, check vertices first (higher priority)
			for (let i = 0; i < points.length; i++) {
				const point = points[i];
				const distance = Math.sqrt(Math.pow(worldX - point.pointXLocation, 2) + Math.pow(worldY - point.pointYLocation, 2));
			}
		}

		// If no vertex found, check segments
		if (!clickedVertex) {
			const numSegments = isClosed ? points.length : points.length - 1;
			for (let i = 0; i < numSegments; i++) {
				const p1 = points[i];
				const p2 = points[(i + 1) % points.length]; // Wraps around for closed polys

				const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

				if (distance <= tolerance && distance < minDistance) {
					minDistance = distance;
					clickedSegment = {
						startIndex: i,
						endIndex: (i + 1) % points.length,
						startPoint: {
							x: p1.pointXLocation,
							y: p1.pointYLocation,
						},
						endPoint: {
							x: p2.pointXLocation,
							y: p2.pointYLocation,
						},
						distance: distance,
					};
				}
			}
		}

		// If we found a vertex or segment, add this entity as a candidate
		if (clickedVertex || clickedSegment) {
			candidateEntities.push({
				entity: entity,
				minDistance: minDistance,
				selectionType: clickedVertex ? "vertex" : "segment",
				clickedVertex: clickedVertex,
				clickedSegment: clickedSegment,
			});
		}
	}

	if (candidateEntities.length === 0) {
		console.log("No KAD entities found near click location");
		return null;
	}

	// Sort by distance (closest first)
	candidateEntities.sort((a, b) => a.minDistance - b.minDistance);
	const selected = candidateEntities[0];

	console.log("Found", candidateEntities.length, "entities near click.");
	console.log("Selected entity:", selected.entity.entityName, "by", selected.selectionType, "at distance:", selected.minDistance.toFixed(3));

	// Determine the snap point
	let snappedX = worldX;
	let snappedY = worldY;

	if (selected.clickedVertex) {
		snappedX = selected.clickedVertex.x;
		snappedY = selected.clickedVertex.y;
	} else if (selected.clickedSegment) {
		const seg = selected.clickedSegment;
		const closestPoint = getClosestPointOnLineSegment(worldX, worldY, seg.startPoint.x, seg.startPoint.y, seg.endPoint.x, seg.endPoint.y);
		snappedX = closestPoint.x;
		snappedY = closestPoint.y;
	}

	return {
		entity: selected.entity,
		clickedX: snappedX,
		clickedY: snappedY,
		selectionType: selected.selectionType,
		clickedVertex: selected.clickedVertex,
		clickedSegment: selected.clickedSegment,
	};
}
// Helper function to get interpolation parameter (0 to 1) for Z interpolation
function getInterpolationParameter(px, py, x1, y1, x2, y2) {
	const dx = x2 - x1;
	const dy = y2 - y1;

	if (Math.abs(dx) > Math.abs(dy)) {
		return (px - x1) / dx;
	} else if (dy !== 0) {
		return (py - y1) / dy;
	} else {
		return 0; // Line segment is a point
	}
}
// Enhanced helper function to get closest point on line segment (add Z support)
function getClosestPointOnLineSegment(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		return {
			x: x1,
			y: y1,
			z: z1,
		};
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const result = {
		x: x1 + t * C,
		y: y1 + t * D,
	};

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		result.z = z1 + t * (z2 - z1);
	}

	return result;
}
//Add this helper function for point-in-polygon detection
function isPointInPolygonVertices(x, y, vertices) {
	let inside = false;
	for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
		if (vertices[i].y > y !== vertices[j].y > y && x < ((vertices[j].x - vertices[i].x) * (y - vertices[i].y)) / (vertices[j].y - vertices[i].y) + vertices[i].x) {
			inside = !inside;
		}
	}
	return inside;
}
// Add this new function to detect clicked lines
function getClickedLine(worldX, worldY, tolerance = getSnapToleranceInWorldUnits()) {
	if (allKADDrawingsMap.size === 0) return null;

	// Check each line entity
	for (const entity of allKADDrawingsMap.values()) {
		const linePoints = entity.data;
		if (linePoints.length < 2) continue; // Need at least 2 points for a line

		// Check each line segment
		for (let i = 0; i < linePoints.length - 1; i++) {
			const p1 = linePoints[i];
			const p2 = linePoints[i + 1];

			// Calculate distance from click point to line segment
			const distance = pointToLineSegmentDistance(worldX, worldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

			if (distance <= tolerance) {
				console.log("Found line:", entity);
				return {
					entity: entity,
					points: linePoints,
					segmentIndex: i,
					startPoint: {
						x: p1.pointXLocation,
						y: p1.pointYLocation,
					},
					endPoint: {
						x: p2.pointXLocation,
						y: p2.pointYLocation,
					},
				};
			}
		}
	}

	return null;
}
// Enhanced helper function for point-to-line-segment distance (add Z support)
function pointToLineSegmentDistance(px, py, x1, y1, x2, y2, z1 = null, z2 = null) {
	const A = px - x1;
	const B = py - y1;
	const C = x2 - x1;
	const D = y2 - y1;

	const dot = A * C + B * D;
	const lenSq = C * C + D * D;

	if (lenSq === 0) {
		// Line segment is actually a point
		return Math.sqrt(A * A + B * B);
	}

	let t = dot / lenSq;
	t = Math.max(0, Math.min(1, t));

	const projection_x = x1 + t * C;
	const projection_y = y1 + t * D;

	const dx = px - projection_x;
	const dy = py - projection_y;

	const distance = Math.sqrt(dx * dx + dy * dy);

	// Add Z interpolation if Z values are provided
	if (z1 !== null && z2 !== null) {
		const interpolatedZ = z1 + t * (z2 - z1);
		return {
			distance: distance,
			z: interpolatedZ,
		};
	}

	return distance;
}

// Add this new function for the pattern in polygon popup
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js
function showPatternInPolygonPopup() {
	window.showPatternDialog("polygon_pattern", null, null);
}

function drawPatternInPolygonVisual() {
	if (!isPatternInPolygonActive) {
		// Hide overlay labels when tool is not active
		hidePatternToolLabels();
		return;
	}

	// Prepare overlay label data
	var overlayData = {
		toolType: "polygon"
	};

	// Draw selected polygon outline in bright color
	if (selectedPolygon) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		const polygonPoints = selectedPolygon.data; // ? Just use .data, not .points || .data
		if (polygonPoints && polygonPoints.length > 0) {
			ctx.beginPath();
			polygonPoints.forEach((point, index) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);

				if (index === 0) {
					ctx.moveTo(canvasX, canvasY);
				} else {
					ctx.lineTo(canvasX, canvasY);
				}
			});
			ctx.closePath();
			ctx.stroke();

			// Draw vertices as small circles
			polygonPoints.forEach((point) => {
				const x = point.pointXLocation || point.x;
				const y = point.pointYLocation || point.y;
				const [canvasX, canvasY] = worldToCanvas(x, y);
				ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
				ctx.beginPath();
				ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
				ctx.fill();
			});
		}
	}

	// Draw start point (bright green)
	if (patternStartPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.startPoint = patternStartPoint;
		overlayData.startCanvasX = startX + canvas.getBoundingClientRect().left;
		overlayData.startCanvasY = startY + canvas.getBoundingClientRect().top;

		// Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!patternEndPoint) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);

			// Calculate preview distance
			const dx = currentMouseWorldX - patternStartPoint.x;
			const dy = currentMouseWorldY - patternStartPoint.y;
			const lineLength = Math.sqrt(dx * dx + dy * dy);

			// Add preview distance to overlay
			if (lineLength > 5) {
				const midX = (startX + currentMouseCanvasX) / 2;
				const midY = (startY + currentMouseCanvasY) / 2;
				overlayData.distance = lineLength;
				overlayData.midCanvasX = midX + canvas.getBoundingClientRect().left;
				overlayData.midCanvasY = midY + canvas.getBoundingClientRect().top;

				// Normalized line direction vector
				const dirX = dx / lineLength;
				const dirY = -dy / lineLength;

				// Perpendicular vector (-90¬∞ from line direction)
				const perpX = dirY;
				const perpY = -dirX;

				const arrowLength = 50;
				const arrowWidth = 24;
				const arrowOffset = 40;

				// Base point of the arrow (center of base)
				const baseX = midX + perpX * arrowOffset;
				const baseY = midY + perpY * arrowOffset;

				// Tip of the arrow (move further left)
				const tipX = baseX + perpX * arrowLength;
				const tipY = baseY + perpY * arrowLength;

				// Perpendicular to arrow direction (same as line dir!)
				const sideX = dirX * (arrowWidth / 2);
				const sideY = dirY * (arrowWidth / 2);

				// Base left/right points
				const leftX = baseX + sideX;
				const leftY = baseY + sideY;
				const rightX = baseX - sideX;
				const rightY = baseY - sideY;

				// Draw arrow (direction indicator)
				ctx.beginPath();
				ctx.moveTo(tipX, tipY); // Tip
				ctx.lineTo(leftX, leftY); // Left corner of base
				ctx.lineTo(rightX, rightY); // Right corner of base
				ctx.closePath();

				ctx.fillStyle = "#00ff00";
				ctx.globalAlpha = 0.3;
				ctx.fill();
				ctx.lineWidth = 2;
				ctx.strokeStyle = "#009900";
				ctx.globalAlpha = 1.0;
				ctx.stroke();
			}
		}
	}

	// Draw end point (bright red)
	if (patternEndPoint) {
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.endPoint = patternEndPoint;
		overlayData.endCanvasX = endX + canvas.getBoundingClientRect().left;
		overlayData.endCanvasY = endY + canvas.getBoundingClientRect().top;
	}

	// Draw reference point (magenta)
	if (patternReferencePoint) {
		const [refX, refY] = worldToCanvas(patternReferencePoint.x, patternReferencePoint.y);
		ctx.fillStyle = "rgba(255, 0, 255, 0.6)";
		ctx.beginPath();
		ctx.arc(refX, refY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Add to overlay data for label
		overlayData.refPoint = patternReferencePoint;
		overlayData.refCanvasX = refX + canvas.getBoundingClientRect().left;
		overlayData.refCanvasY = refY + canvas.getBoundingClientRect().top;
	}

	// Draw line from start to end to show spacing direction
	if (patternStartPoint && patternEndPoint) {
		const [startX, startY] = worldToCanvas(patternStartPoint.x, patternStartPoint.y);
		const [endX, endY] = worldToCanvas(patternEndPoint.x, patternEndPoint.y);

		// Draw the main line
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 1;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Calculate line length for overlay
		const dx = patternEndPoint.x - patternStartPoint.x;
		const dy = patternEndPoint.y - patternStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		// Set distance at midpoint for overlay
		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		overlayData.distance = lineLength;
		overlayData.midCanvasX = midX + canvas.getBoundingClientRect().left;
		overlayData.midCanvasY = midY + canvas.getBoundingClientRect().top;
	}

	// Update overlay labels (moved from canvas text to HUD overlay)
	showPatternToolLabels(overlayData);
}

// 3D Visual feedback for Pattern in Polygon tool
// NOTE: The polygon itself is drawn by the main KAD drawing loop
// NOTE: The leading line is drawn by drawKADLeadingLineThreeJSV2 in handle3DMouseMove
// This function ONLY draws: point markers (green start, red end, magenta ref) and triangle arrow
function drawPatternInPolygon3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isPatternInPolygonActive || !threeInitialized || !threeRenderer) {
		if (window.patternTool3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.patternTool3DGroup);
			window.patternTool3DGroup = null;
		}
		clearKADLeadingLineThreeJS();
		return;
	}

	// Step 0a) Clear previous pattern tool 3D objects
	if (window.patternTool3DGroup) {
		threeRenderer.scene.remove(window.patternTool3DGroup);
		window.patternTool3DGroup = null;
	}

	// Step 0b) Create new group for pattern tool visuals
	window.patternTool3DGroup = new THREE.Group();
	window.patternTool3DGroup.name = "patternTool3DVisuals";

	// Step 0c) Calculate Z values - MUST MATCH drawKADLeadingLineThreeJSV2 exactly
	// Leading line uses: startZ = patternStartPoint.z || dataCentroidZ || 0
	// Leading line uses: endZ = currentMouseIndicatorZ
	var lineStartZ = patternStartPoint ? (patternStartPoint.z || dataCentroidZ || 0) : (dataCentroidZ || 0);

	// Step 1) Draw start point marker (bright green) - at SAME position as leading line start
	if (patternStartPoint) {
		var startLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		var startMarker = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, lineStartZ, 0.8, "rgba(0, 255, 0, 1.0)");
		if (startMarker) window.patternTool3DGroup.add(startMarker);
		console.log("üü¢ PatternInPoly START marker at local:", startLocal.x.toFixed(2), startLocal.y.toFixed(2), "Z:", lineStartZ.toFixed(2));
	}

	// Step 2) Draw end point marker (bright red) - at SAME position as leading line end
	if (patternEndPoint) {
		var endLocal = worldToThreeLocal(patternEndPoint.x, patternEndPoint.y);
		var endZ = patternEndPoint.z || dataCentroidZ || 0;
		var endMarker = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 1.0)");
		if (endMarker) window.patternTool3DGroup.add(endMarker);
		console.log("üî¥ PatternInPoly END marker at local:", endLocal.x.toFixed(2), endLocal.y.toFixed(2), "Z:", endZ.toFixed(2));
	} else if (patternStartPoint && currentMouseIndicatorX !== undefined && currentMouseIndicatorY !== undefined) {
		// Preview mode - use currentMouseIndicator (same as leading line end)
		var previewEndLocal = worldToThreeLocal(currentMouseIndicatorX, currentMouseIndicatorY);
		var previewEndZ = currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : lineStartZ;
		var previewMarker = GeometryFactory.createKADPointHighlight(previewEndLocal.x, previewEndLocal.y, previewEndZ, 0.6, "rgba(255, 0, 0, 0.5)");
		if (previewMarker) window.patternTool3DGroup.add(previewMarker);
		console.log("üî¥ PatternInPoly PREVIEW END marker at local:", previewEndLocal.x.toFixed(2), previewEndLocal.y.toFixed(2), "Z:", previewEndZ.toFixed(2));
	}

	// Step 3) Draw reference point marker (magenta/pink)
	if (patternReferencePoint) {
		var refLocal = worldToThreeLocal(patternReferencePoint.x, patternReferencePoint.y);
		var refZ = patternReferencePoint.z || dataCentroidZ || 0;
		var refMarker = GeometryFactory.createKADPointHighlight(refLocal.x, refLocal.y, refZ, 0.8, "rgba(255, 0, 255, 1.0)");
		if (refMarker) window.patternTool3DGroup.add(refMarker);
	}

	// Step 4) Calculate line direction for triangle arrow positioning
	var sLocal = null;
	var eLocal = null;
	var dx = 0;
	var dy = 0;
	var lineLength = 0;
	var lineEndZ = lineStartZ;

	if (patternStartPoint && patternEndPoint) {
		sLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		eLocal = worldToThreeLocal(patternEndPoint.x, patternEndPoint.y);
		dx = patternEndPoint.x - patternStartPoint.x;
		dy = patternEndPoint.y - patternStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
		lineEndZ = patternEndPoint.z || dataCentroidZ || 0;
	} else if (patternStartPoint && !patternEndPoint && currentMouseIndicatorX !== undefined && currentMouseIndicatorY !== undefined) {
		sLocal = worldToThreeLocal(patternStartPoint.x, patternStartPoint.y);
		eLocal = worldToThreeLocal(currentMouseIndicatorX, currentMouseIndicatorY);
		dx = currentMouseIndicatorX - patternStartPoint.x;
		dy = currentMouseIndicatorY - patternStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
		lineEndZ = currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : lineStartZ;
	}

	// Step 5) Draw triangle arrow at midpoint
	if (sLocal && eLocal && lineLength > 1) {
		var dirX = dx / lineLength;
		var dirY = dy / lineLength;
		var startVec = new THREE.Vector3(sLocal.x, sLocal.y, lineStartZ);
		var endVec = new THREE.Vector3(eLocal.x, eLocal.y, lineEndZ);
		var midPoint = new THREE.Vector3().lerpVectors(startVec, endVec, 0.5);

		var perpX = dirY;
		var perpY = -dirX;
		var perpAngle = Math.atan2(perpY, perpX);

		var triangleSize = 3.0;
		var triangleShape = new THREE.Shape();
		triangleShape.moveTo(0, triangleSize);
		triangleShape.lineTo(-triangleSize / 2, 0);
		triangleShape.lineTo(triangleSize / 2, 0);
		triangleShape.lineTo(0, triangleSize);

		var extrudeSettings = { depth: 0.2, bevelEnabled: false };
		var triangleGeom = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
		var triangleMat = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.6,
			side: THREE.DoubleSide
		});
		var triangle = new THREE.Mesh(triangleGeom, triangleMat);
		triangle.position.copy(midPoint);
		triangle.rotation.z = perpAngle + Math.PI / 2;
		window.patternTool3DGroup.add(triangle);

		var edgeGeom = new THREE.EdgesGeometry(triangleGeom);
		var edgeMat = new THREE.LineBasicMaterial({ color: 0x008800 });
		var edges = new THREE.LineSegments(edgeGeom, edgeMat);
		edges.position.copy(triangle.position);
		edges.rotation.copy(triangle.rotation);
		window.patternTool3DGroup.add(edges);
		console.log("üî∫ PatternInPoly TRIANGLE at midpoint:", midPoint.x.toFixed(2), midPoint.y.toFixed(2), midPoint.z.toFixed(2));
	}

	// Step 6) Add group to scene
	threeRenderer.scene.add(window.patternTool3DGroup);
	console.log("‚úÖ PatternInPoly 3D group added to scene, children:", window.patternTool3DGroup.children.length);
}

// 3D Visual feedback for Holes Along Line tool
// NOTE: The leading line is drawn by drawKADLeadingLineThreeJSV2 in handle3DMouseMove
// This function ONLY draws: point markers (green start, red end) and triangle arrow pointing toward END
function drawHolesAlongLine3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isHolesAlongLineActive || !threeInitialized || !threeRenderer) {
		if (window.holesAlongLine3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.holesAlongLine3DGroup);
			window.holesAlongLine3DGroup = null;
		}
		clearKADLeadingLineThreeJS();
		return;
	}

	// Step 0a) Clear previous 3D objects
	if (window.holesAlongLine3DGroup) {
		threeRenderer.scene.remove(window.holesAlongLine3DGroup);
		window.holesAlongLine3DGroup = null;
	}

	// Step 0b) Create new group for tool visuals
	window.holesAlongLine3DGroup = new THREE.Group();
	window.holesAlongLine3DGroup.name = "holesAlongLine3DVisuals";

	// Step 0c) Calculate Z values - use snapped/clicked Z, NOT dataCentroidZ
	// NOTE: Check for undefined specifically because Z=0 is valid
	var lineStartZ = (lineStartPoint && lineStartPoint.z !== undefined) ? lineStartPoint.z : (currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : 0);

	// Step 1) Draw start point marker (bright green) - at SAME position as leading line start
	if (lineStartPoint) {
		var startLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		var startMarker = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, lineStartZ, 0.8, "rgba(0, 255, 0, 1.0)");
		if (startMarker) window.holesAlongLine3DGroup.add(startMarker);
	}

	// Step 2) Draw end point marker (bright red) - at SAME position as leading line end
	if (lineEndPoint) {
		var endLocal = worldToThreeLocal(lineEndPoint.x, lineEndPoint.y);
		var endZ = lineEndPoint.z !== undefined ? lineEndPoint.z : lineStartZ;
		var endMarker = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 1.0)");
		if (endMarker) window.holesAlongLine3DGroup.add(endMarker);
	} else if (lineStartPoint && currentMouseIndicatorX !== undefined && currentMouseIndicatorY !== undefined) {
		// Preview mode - use currentMouseIndicatorZ (same as leading line end)
		var previewEndLocal = worldToThreeLocal(currentMouseIndicatorX, currentMouseIndicatorY);
		var previewEndZ = currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : lineStartZ;
		var previewMarker = GeometryFactory.createKADPointHighlight(previewEndLocal.x, previewEndLocal.y, previewEndZ, 0.6, "rgba(255, 0, 0, 0.5)");
		if (previewMarker) window.holesAlongLine3DGroup.add(previewMarker);
	}

	// Step 3) Calculate line direction for triangle arrow positioning
	var sLocal = null;
	var eLocal = null;
	var dx = 0;
	var dy = 0;
	var lineLength = 0;
	var lineEndZ = lineStartZ;

	if (lineStartPoint && lineEndPoint) {
		sLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		eLocal = worldToThreeLocal(lineEndPoint.x, lineEndPoint.y);
		dx = lineEndPoint.x - lineStartPoint.x;
		dy = lineEndPoint.y - lineStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
		lineEndZ = lineEndPoint.z !== undefined ? lineEndPoint.z : lineStartZ;
	} else if (lineStartPoint && !lineEndPoint && currentMouseIndicatorX !== undefined && currentMouseIndicatorY !== undefined) {
		sLocal = worldToThreeLocal(lineStartPoint.x, lineStartPoint.y);
		eLocal = worldToThreeLocal(currentMouseIndicatorX, currentMouseIndicatorY);
		dx = currentMouseIndicatorX - lineStartPoint.x;
		dy = currentMouseIndicatorY - lineStartPoint.y;
		lineLength = Math.sqrt(dx * dx + dy * dy);
		lineEndZ = currentMouseIndicatorZ !== undefined ? currentMouseIndicatorZ : lineStartZ;
	}

	// Step 4) Draw triangle arrow at midpoint - points TOWARD END (along line direction)
	if (sLocal && eLocal && lineLength > 1) {
		var dirX = dx / lineLength;
		var dirY = dy / lineLength;
		var startVec = new THREE.Vector3(sLocal.x, sLocal.y, lineStartZ);
		var endVec = new THREE.Vector3(eLocal.x, eLocal.y, lineEndZ);
		var midPoint = new THREE.Vector3().lerpVectors(startVec, endVec, 0.5);

		// Triangle points toward END (along line direction, NOT perpendicular)
		var lineAngle = Math.atan2(dirY, dirX);

		var triangleSize = 2.0;
		var triangleShape = new THREE.Shape();
		triangleShape.moveTo(0, triangleSize);
		triangleShape.lineTo(-triangleSize / 2, 0);
		triangleShape.lineTo(triangleSize / 2, 0);
		triangleShape.lineTo(0, triangleSize);

		var extrudeSettings = { depth: 0.2, bevelEnabled: false };
		var triangleGeom = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
		var triangleMat = new THREE.MeshBasicMaterial({
			color: 0x00ff00,
			transparent: true,
			opacity: 0.6,
			side: THREE.DoubleSide
		});
		var triangle = new THREE.Mesh(triangleGeom, triangleMat);
		triangle.position.copy(midPoint);
		// Rotate to point along line direction toward END
		triangle.rotation.z = lineAngle - Math.PI / 2;
		window.holesAlongLine3DGroup.add(triangle);

		var edgeGeom = new THREE.EdgesGeometry(triangleGeom);
		var edgeMat = new THREE.LineBasicMaterial({ color: 0x008800 });
		var edges = new THREE.LineSegments(edgeGeom, edgeMat);
		edges.position.copy(triangle.position);
		edges.rotation.copy(triangle.rotation);
		window.holesAlongLine3DGroup.add(edges);
	}

	// Step 5) Add group to scene
	threeRenderer.scene.add(window.holesAlongLine3DGroup);
}

// Add this function to draw poly line selection visuals
function drawPatternOnPolylineVisual() {
	if (!isHolesAlongPolyLineActive) return;

	// Add safety checks
	if (!selectedPolyline || !selectedPolyline.vertices || !Array.isArray(selectedPolyline.vertices)) {
		console.log("Can't draw along Polyline as there is no selectedPolyline, vertices or array");
		return;
	}

	// Step 1) Build overlay data for HUD labels (consistent with patternInPolygon)
	var overlayData = { toolType: "polyline" };
	var canvasRect = canvas.getBoundingClientRect();

	// Step 2) Draw selected polyline in bright color
	if (selectedPolyline) {
		ctx.strokeStyle = "#00FF00"; // Bright green
		ctx.lineWidth = 3;
		ctx.setLineDash([]);

		ctx.beginPath();
		selectedPolyline.vertices.forEach((vertex, index) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});

		// Close polygon if it's a polygon type
		if (selectedPolyline.type === "polygon") {
			ctx.closePath();
		}

		ctx.stroke();

		// Step 2a) Draw vertices as small circles
		selectedPolyline.vertices.forEach((vertex) => {
			const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});

		// Step 2b) Highlight active segment (where holes will be placed) in cyan
		if (polylineStartPoint && polylineEndPoint) {
			// Find the segment indices for START and END
			var startIdx = -1;
			var endIdx = -1;
			for (var i = 0; i < selectedPolyline.vertices.length; i++) {
				var v = selectedPolyline.vertices[i];
				if (Math.abs(v.x - polylineStartPoint.x) < 0.01 && Math.abs(v.y - polylineStartPoint.y) < 0.01) {
					startIdx = i;
				}
				if (Math.abs(v.x - polylineEndPoint.x) < 0.01 && Math.abs(v.y - polylineEndPoint.y) < 0.01) {
					endIdx = i;
				}
			}

			// Draw active segments in cyan with thicker line
			if (startIdx !== -1 && endIdx !== -1 && startIdx !== endIdx) {
				ctx.strokeStyle = "#00FFFF"; // Cyan for active segment
				ctx.lineWidth = 5;
				ctx.setLineDash([]);
				ctx.beginPath();

				var minIdx = Math.min(startIdx, endIdx);
				var maxIdx = Math.max(startIdx, endIdx);

				for (var j = minIdx; j <= maxIdx; j++) {
					var vertex = selectedPolyline.vertices[j];
					const [canvasX, canvasY] = worldToCanvas(vertex.x, vertex.y);
					if (j === minIdx) {
						ctx.moveTo(canvasX, canvasY);
					} else {
						ctx.lineTo(canvasX, canvasY);
					}
				}
				ctx.stroke();
			}
		}
	}

	// Step 3) Draw start point (bright green)
	if (polylineStartPoint) {
		const [startX, startY] = worldToCanvas(polylineStartPoint.x, polylineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 3a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.startPoint = polylineStartPoint;
		overlayData.startCanvasX = startX + canvasRect.left;
		overlayData.startCanvasY = startY + canvasRect.top;
	}

	// Step 4) Draw end point (bright red)
	if (polylineEndPoint) {
		const [endX, endY] = worldToCanvas(polylineEndPoint.x, polylineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 4a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.endPoint = polylineEndPoint;
		overlayData.endCanvasX = endX + canvasRect.left;
		overlayData.endCanvasY = endY + canvasRect.top;
	}

	// Step 5) Calculate total distance along polyline path if both points selected
	if (polylineStartPoint && polylineEndPoint && selectedPolyline && selectedPolyline.vertices) {
		var totalDist = 0;
		var startIdx = -1;
		var endIdx = -1;

		// Find indices
		for (var i = 0; i < selectedPolyline.vertices.length; i++) {
			var v = selectedPolyline.vertices[i];
			if (Math.abs(v.x - polylineStartPoint.x) < 0.01 && Math.abs(v.y - polylineStartPoint.y) < 0.01) {
				startIdx = i;
			}
			if (Math.abs(v.x - polylineEndPoint.x) < 0.01 && Math.abs(v.y - polylineEndPoint.y) < 0.01) {
				endIdx = i;
			}
		}

		if (startIdx !== -1 && endIdx !== -1) {
			var minIdx = Math.min(startIdx, endIdx);
			var maxIdx = Math.max(startIdx, endIdx);

			for (var j = minIdx; j < maxIdx; j++) {
				var v1 = selectedPolyline.vertices[j];
				var v2 = selectedPolyline.vertices[j + 1];
				var dx = v2.x - v1.x;
				var dy = v2.y - v1.y;
				totalDist += Math.sqrt(dx * dx + dy * dy);
			}

			// Calculate midpoint in canvas coords
			var midVertex = selectedPolyline.vertices[Math.floor((minIdx + maxIdx) / 2)];
			var [midX, midY] = worldToCanvas(midVertex.x, midVertex.y);
			overlayData.distance = totalDist;
			overlayData.midCanvasX = midX + canvasRect.left;
			overlayData.midCanvasY = midY + canvasRect.top;
		}
	}

	// Step 6) Update HUD overlay labels (consistent styling with patternInPolygon)
	showPatternToolLabels(overlayData);
}

// 3D Visual feedback for Holes Along Polyline tool
// Matches the clean, minimal 2D aesthetic with thin lines and small markers
function drawHolesAlongPolyline3DVisual() {
	// Step 0) Guard checks - clean up if tool inactive
	if (!isHolesAlongPolyLineActive || !threeInitialized || !threeRenderer) {
		if (window.holesAlongPolyline3DGroup && threeRenderer && threeRenderer.scene) {
			threeRenderer.scene.remove(window.holesAlongPolyline3DGroup);
			window.holesAlongPolyline3DGroup = null;
		}
		// Step 0.1) Hide HUD labels when tool is inactive
		hidePatternToolLabels();
		return;
	}

	// Step 0a) Safety checks
	if (!selectedPolyline || !selectedPolyline.vertices || !Array.isArray(selectedPolyline.vertices)) {
		return;
	}

	// Step 0b) Clear previous 3D objects
	if (window.holesAlongPolyline3DGroup) {
		threeRenderer.scene.remove(window.holesAlongPolyline3DGroup);
		window.holesAlongPolyline3DGroup = null;
	}

	// Step 0c) Create new group for tool visuals
	window.holesAlongPolyline3DGroup = new THREE.Group();
	window.holesAlongPolyline3DGroup.name = "holesAlongPolyline3DVisuals";

	// Step 0d) Get Z elevation from selected polyline's actual Z values
	var drawZ = (dataCentroidZ || 0) + 0.5;
	// FIX: Use actual Z from selected polyline if available
	if (selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
		var firstVtx = selectedPolyline.vertices[0];
		drawZ = (firstVtx.z || dataCentroidZ || 0) + 0.5;
	}

	// Step 0e) Get resolution for fat lines
	var resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);

	// NOTE: We do NOT draw the polyline outline here - it's already drawn by the main KAD drawing loop
	// The polyline is displayed in its original color from the KAD entity

	// Step 1) Highlight active segment (where holes will be placed) in cyan using fat lines
	if (polylineStartPoint && polylineEndPoint && selectedPolyline) {
		// Step 1a) Find the segment indices for START and END
		// FIX: Use entity.data to find indices (same as what we use for segments) for perfect alignment
		var startIdx = -1;
		var endIdx = -1;
		var searchPoints = selectedPolyline.entity && selectedPolyline.entity.data ? selectedPolyline.entity.data : selectedPolyline.vertices;

		for (var k = 0; k < searchPoints.length; k++) {
			var pt = searchPoints[k];
			var ptX = pt.pointXLocation || pt.x;
			var ptY = pt.pointYLocation || pt.y;
			if (Math.abs(ptX - polylineStartPoint.x) < 0.01 && Math.abs(ptY - polylineStartPoint.y) < 0.01) {
				startIdx = k;
				// FIX: Ensure polylineStartPoint has Z value from point
				var ptZ = pt.pointZLocation || pt.z;
				if (ptZ !== undefined && ptZ !== null && polylineStartPoint.z === undefined) {
					polylineStartPoint.z = ptZ;
				}
			}
			if (Math.abs(ptX - polylineEndPoint.x) < 0.01 && Math.abs(ptY - polylineEndPoint.y) < 0.01) {
				endIdx = k;
				// FIX: Ensure polylineEndPoint has Z value from point
				var ptZ = pt.pointZLocation || pt.z;
				if (ptZ !== undefined && ptZ !== null && polylineEndPoint.z === undefined) {
					polylineEndPoint.z = ptZ;
				}
			}
		}

		// Step 2b) Draw active segments in cyan using fat lines (thicker than green outline)
		if (startIdx !== -1 && endIdx !== -1 && startIdx !== endIdx) {
			var minIdx = Math.min(startIdx, endIdx);
			var maxIdx = Math.max(startIdx, endIdx);
			// Track if we're going from high index to low (reversed direction)
			var isReversed = startIdx > endIdx;

			// Step 2c) Collect cyan segments for active path
			// FIX: Use actual entity geometry (entity.data) instead of vertices array to ensure perfect alignment
			// This matches how drawKADEntityHighlight() works - uses entity.data directly
			var cyanSegments = [];
			if (selectedPolyline.entity && selectedPolyline.entity.data) {
				// Use entity.data directly (same as highlight function) for perfect geometry match
				var entityPoints = selectedPolyline.entity.data;
				var isClosedShape = selectedPolyline.type === "polygon";
				var numSegments = isClosedShape ? entityPoints.length : entityPoints.length - 1;

				for (var m = minIdx; m < maxIdx && m < numSegments; m++) {
					var point1 = entityPoints[m];
					var point2 = isClosedShape ? entityPoints[(m + 1) % entityPoints.length] : entityPoints[m + 1];

					var segLocal1 = worldToThreeLocal(point1.pointXLocation, point1.pointYLocation);
					var segLocal2 = worldToThreeLocal(point2.pointXLocation, point2.pointYLocation);

					// Use actual Z from entity points (same as highlight function)
					var cyanZ1 = (point1.pointZLocation || dataCentroidZ || 0) + 0.2;
					var cyanZ2 = (point2.pointZLocation || dataCentroidZ || 0) + 0.2;

					cyanSegments.push({
						x1: segLocal1.x, y1: segLocal1.y, z1: cyanZ1,
						x2: segLocal2.x, y2: segLocal2.y, z2: cyanZ2
					});
				}
			} else {
				// Fallback to vertices if entity.data not available
				for (var m = minIdx; m < maxIdx; m++) {
					var segVertex1 = selectedPolyline.vertices[m];
					var segVertex2 = selectedPolyline.vertices[m + 1];
					var segLocal1 = worldToThreeLocal(segVertex1.x, segVertex1.y);
					var segLocal2 = worldToThreeLocal(segVertex2.x, segVertex2.y);
					var cyanZ1 = (segVertex1.z !== undefined && segVertex1.z !== null) ? segVertex1.z + 0.2 : drawZ + 0.2;
					var cyanZ2 = (segVertex2.z !== undefined && segVertex2.z !== null) ? segVertex2.z + 0.2 : drawZ + 0.2;
					cyanSegments.push({
						x1: segLocal1.x, y1: segLocal1.y, z1: cyanZ1,
						x2: segLocal2.x, y2: segLocal2.y, z2: cyanZ2
					});
				}
			}

			// Step 2d) Create cyan fat lines for active segment (slightly thicker)
			if (cyanSegments.length > 0) {
				var cyanLines = GeometryFactory._createHighlightLinesBatch(cyanSegments, 5, resolution, "rgba(0, 255, 255, 1.0)");

				if (cyanLines) {
					window.holesAlongPolyline3DGroup.add(cyanLines);
				}
			}

			// Step 2e) Add small pyramid arrow at midpoint of active segment
			if (cyanSegments.length >= 1) {
				// Step 2f) Calculate midpoint and direction along active segment path
				var totalLength = 0;
				var segLengths = [];
				for (var n = 0; n < cyanSegments.length; n++) {
					var seg = cyanSegments[n];
					var dx = seg.x2 - seg.x1;
					var dy = seg.y2 - seg.y1;
					var len = Math.sqrt(dx * dx + dy * dy);
					segLengths.push(len);
					totalLength += len;
				}

				// Step 2g) Find midpoint along path
				var halfLength = totalLength / 2;
				var accumulated = 0;
				var midX = 0, midY = 0, dirX = 0, dirY = 0;
				for (var p = 0; p < cyanSegments.length; p++) {
					if (accumulated + segLengths[p] >= halfLength) {
						// Midpoint is on this segment
						var t = (halfLength - accumulated) / segLengths[p];
						var seg2 = cyanSegments[p];
						midX = seg2.x1 + t * (seg2.x2 - seg2.x1);
						midY = seg2.y1 + t * (seg2.y2 - seg2.y1);
						// Direction is along this segment toward end
						var segDx = seg2.x2 - seg2.x1;
						var segDy = seg2.y2 - seg2.y1;
						var segLen = Math.sqrt(segDx * segDx + segDy * segDy);
						if (segLen > 0) {
							dirX = segDx / segLen;
							dirY = segDy / segLen;
						}
						break;
					}
					accumulated += segLengths[p];
				}

				// Removed pyramid from HolesAlongPolyLine tool as per user requirements
			}
		}
	}

	// Step 3) Draw start point as billboard point (bright green)
	if (polylineStartPoint) {
		var startLocal = worldToThreeLocal(polylineStartPoint.x, polylineStartPoint.y);
		// FIX: Use actual Z from polylineStartPoint (check for undefined/null, not falsy)
		var startZ = (polylineStartPoint.z !== undefined && polylineStartPoint.z !== null) ? polylineStartPoint.z + 0.2 : drawZ + 0.2;
		var startPoint = GeometryFactory.createKADPointHighlight(startLocal.x, startLocal.y, startZ, 0.8, "rgba(0, 255, 0, 1.0)");
		window.holesAlongPolyline3DGroup.add(startPoint);
	}

	// Step 4) Draw end point as billboard point (bright red)
	if (polylineEndPoint) {
		var endLocal = worldToThreeLocal(polylineEndPoint.x, polylineEndPoint.y);
		// FIX: Use actual Z from polylineEndPoint (check for undefined/null, not falsy)
		var endZ = (polylineEndPoint.z !== undefined && polylineEndPoint.z !== null) ? polylineEndPoint.z + 0.2 : drawZ + 0.2;
		var endPoint = GeometryFactory.createKADPointHighlight(endLocal.x, endLocal.y, endZ, 0.8, "rgba(255, 0, 0, 1.0)");
		window.holesAlongPolyline3DGroup.add(endPoint);
	}

	// Step 5) Add group to scene
	threeRenderer.scene.add(window.holesAlongPolyline3DGroup);

	// Step 6) Build overlay data for HUD labels (consistent with 2D)
	var overlayData = { toolType: "polyline" };

	// Step 6a) Add start point label
	if (polylineStartPoint) {
		// FIX: Use actual Z from polylineStartPoint or selected polyline
		var startZ = polylineStartPoint.z;
		if (!startZ && selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
			// Find matching vertex Z
			for (var vIdx = 0; vIdx < selectedPolyline.vertices.length; vIdx++) {
				var vtx = selectedPolyline.vertices[vIdx];
				if (Math.abs(vtx.x - polylineStartPoint.x) < 0.01 && Math.abs(vtx.y - polylineStartPoint.y) < 0.01) {
					startZ = vtx.z || dataCentroidZ || 0;
					break;
				}
			}
		}
		var screenStart = worldToScreen(polylineStartPoint.x, polylineStartPoint.y, startZ || dataCentroidZ || 0);
		if (screenStart) {
			overlayData.startPoint = polylineStartPoint;
			overlayData.startCanvasX = screenStart.x;
			overlayData.startCanvasY = screenStart.y;
		}
	}

	// Step 6b) Add end point label
	if (polylineEndPoint) {
		// FIX: Use actual Z from polylineEndPoint or selected polyline
		var endZ = polylineEndPoint.z;
		if (!endZ && selectedPolyline && selectedPolyline.vertices && selectedPolyline.vertices.length > 0) {
			// Find matching vertex Z
			for (var vIdx = 0; vIdx < selectedPolyline.vertices.length; vIdx++) {
				var vtx = selectedPolyline.vertices[vIdx];
				if (Math.abs(vtx.x - polylineEndPoint.x) < 0.01 && Math.abs(vtx.y - polylineEndPoint.y) < 0.01) {
					endZ = vtx.z || dataCentroidZ || 0;
					break;
				}
			}
		}
		var screenEnd = worldToScreen(polylineEndPoint.x, polylineEndPoint.y, endZ || dataCentroidZ || 0);
		if (screenEnd) {
			overlayData.endPoint = polylineEndPoint;
			overlayData.endCanvasX = screenEnd.x;
			overlayData.endCanvasY = screenEnd.y;
		}
	}

	// Step 6c) Add distance label if both points selected
	if (polylineStartPoint && polylineEndPoint && selectedPolyline && selectedPolyline.vertices) {
		// Calculate total distance along polyline path
		var startIdx = -1;
		var endIdx = -1;
		for (var idx = 0; idx < selectedPolyline.vertices.length; idx++) {
			var vtx = selectedPolyline.vertices[idx];
			if (Math.abs(vtx.x - polylineStartPoint.x) < 0.01 && Math.abs(vtx.y - polylineStartPoint.y) < 0.01) {
				startIdx = idx;
			}
			if (Math.abs(vtx.x - polylineEndPoint.x) < 0.01 && Math.abs(vtx.y - polylineEndPoint.y) < 0.01) {
				endIdx = idx;
			}
		}

		if (startIdx !== -1 && endIdx !== -1) {
			var totalDist = 0;
			var minI = Math.min(startIdx, endIdx);
			var maxI = Math.max(startIdx, endIdx);
			for (var dIdx = minI; dIdx < maxI; dIdx++) {
				var v1 = selectedPolyline.vertices[dIdx];
				var v2 = selectedPolyline.vertices[dIdx + 1];
				var ddx = v2.x - v1.x;
				var ddy = v2.y - v1.y;
				totalDist += Math.sqrt(ddx * ddx + ddy * ddy);
			}

			// Get midpoint along active segment
			var midVertex = selectedPolyline.vertices[Math.floor((minI + maxI) / 2)];
			var screenMid = worldToScreen(midVertex.x, midVertex.y, midVertex.z || dataCentroidZ || 0);
			if (screenMid) {
				overlayData.distance = totalDist;
				overlayData.midCanvasX = screenMid.x;
				overlayData.midCanvasY = screenMid.y;
			}
		}
	}

	// Step 6d) Show HUD overlay labels
	showPatternToolLabels(overlayData);
}

// Function to draw KAD polygon selection visuals
function drawKADPolygonHighlightSelectedVisuals() {
	if (!selectedKADPolygon || !isSelectionPointerActive) return;

	// Draw selected polygon outline in bright color
	ctx.strokeStyle = "#00FF00"; // Bright green like pattern tool
	ctx.lineWidth = 3;
	ctx.setLineDash([]);

	const polygonPoints = selectedKADPolygon.points || selectedKADPolygon.data;
	if (polygonPoints && polygonPoints.length > 0) {
		ctx.beginPath();
		polygonPoints.forEach((point, index) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);

			if (index === 0) {
				ctx.moveTo(canvasX, canvasY);
			} else {
				ctx.lineTo(canvasX, canvasY);
			}
		});
		ctx.closePath();
		ctx.stroke();

		// Draw vertices as small red circles like pattern tool
		polygonPoints.forEach((point) => {
			const x = point.pointXLocation || point.x;
			const y = point.pointYLocation || point.y;
			const [canvasX, canvasY] = worldToCanvas(x, y);
			ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
			ctx.beginPath();
			ctx.arc(canvasX, canvasY, 4, 0, 2 * Math.PI);
			ctx.fill();
		});
	}
}
// Step 1) Helper function moved to canvas2DDrawSelection.js module
// drawKADHighlightSelectionVisuals is now imported from module

function getEntityFromKADObject(kadObject) {
	// Everything is now in the unified map
	return allKADDrawingsMap.get(kadObject.entityName);
}

function drawHolesAlongLineVisuals() {
	// Only draw visuals if holes along line tool is active
	if (!isHolesAlongLineActive) return;

	// Step 1) Build overlay data for HUD labels (consistent with patternInPolygon)
	var overlayData = { toolType: "line" };
	var canvasRect = canvas.getBoundingClientRect();

	// Step 2) Draw start point (bright green) when selected
	if (lineStartPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		ctx.fillStyle = "rgba(0, 255, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(startX, startY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 2a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.startPoint = lineStartPoint;
		overlayData.startCanvasX = startX + canvasRect.left;
		overlayData.startCanvasY = startY + canvasRect.top;

		// Step 2b) Draw interactive preview line to mouse cursor when start point is set but end point isn't
		if (!lineEndPoint && holesLineStep === 1) {
			ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
			ctx.lineWidth = 1;
			ctx.setLineDash([5, 5]);
			ctx.beginPath();
			ctx.moveTo(startX, startY);
			ctx.lineTo(currentMouseCanvasX, currentMouseCanvasY);
			ctx.stroke();
			ctx.setLineDash([]);

			// Step 2c) Calculate preview distance for HUD overlay
			const dx = currentMouseWorldX - lineStartPoint.x;
			const dy = currentMouseWorldY - lineStartPoint.y;
			const previewLength = Math.sqrt(dx * dx + dy * dy);

			if (previewLength > 5) {
				const midX = (startX + currentMouseCanvasX) / 2;
				const midY = (startY + currentMouseCanvasY) / 2;
				overlayData.distance = previewLength;
				overlayData.midCanvasX = midX + canvasRect.left;
				overlayData.midCanvasY = midY + canvasRect.top;
			}
		}
	}

	// Step 3) Draw end point (bright red) when selected
	if (lineEndPoint) {
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);
		ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
		ctx.beginPath();
		ctx.arc(endX, endY, 6, 0, 2 * Math.PI);
		ctx.fill();

		// Step 3a) Add to overlay data for HUD label (no ctx.fillText)
		overlayData.endPoint = lineEndPoint;
		overlayData.endCanvasX = endX + canvasRect.left;
		overlayData.endCanvasY = endY + canvasRect.top;
	}

	// Step 4) Draw line connecting start and end points when both are selected
	if (lineStartPoint && lineEndPoint) {
		const [startX, startY] = worldToCanvas(lineStartPoint.x, lineStartPoint.y);
		const [endX, endY] = worldToCanvas(lineEndPoint.x, lineEndPoint.y);

		// Step 4a) Draw the main line (dashed green)
		ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
		ctx.lineWidth = 2;
		ctx.setLineDash([10, 5]);
		ctx.beginPath();
		ctx.moveTo(startX, startY);
		ctx.lineTo(endX, endY);
		ctx.stroke();
		ctx.setLineDash([]);

		// Step 4b) Calculate line length and set distance for HUD overlay
		const dx = lineEndPoint.x - lineStartPoint.x;
		const dy = lineEndPoint.y - lineStartPoint.y;
		const lineLength = Math.sqrt(dx * dx + dy * dy);

		const midX = (startX + endX) / 2;
		const midY = (startY + endY) / 2;
		overlayData.distance = lineLength;
		overlayData.midCanvasX = midX + canvasRect.left;
		overlayData.midCanvasY = midY + canvasRect.top;
	}

	// Step 5) Update HUD overlay labels (consistent styling with patternInPolygon)
	showPatternToolLabels(overlayData);
}
// Add this new function to generate holes along a polyline or polygon edge
// ADDED ROWID AND POSID
function generateHolesAlongPolyline(params, vertices) {
	if (!vertices || vertices.length < 2) {
		console.error("Not enough vertices to generate holes");
		return;
	}

	console.log("Generating holes along polyline with", vertices.length, "vertices");
	console.log("Parameters:", params);

	// Initialize points array if it's null
	if (allBlastHoles === null) {
		allBlastHoles = [];
	}

	const entityName = params.blastName || "PolylinePattern_" + Date.now();
	const originalPointsCount = allBlastHoles.length;
	let holeCounter = params.startNumber || 1;
	let currentLetter = "A";

	// Get the next row ID for this pattern
	const rowID = getNextRowID(entityName);
	console.log("Assigned rowID:", rowID, "for polyline pattern");

	// Initialize cancellation flag for this pattern generation
	if (typeof window.holeGenerationCancelled === "undefined") {
		window.holeGenerationCancelled = false;
	}
	window.holeGenerationCancelled = false; // Reset for new pattern

	// Calculate total length of the polyline for progress tracking
	let totalLength = 0;
	for (let i = 0; i < vertices.length - 1; i++) {
		const dx = vertices[i + 1].x - vertices[i].x;
		const dy = vertices[i + 1].y - vertices[i].y;
		totalLength += Math.sqrt(dx * dx + dy * dy);
	}

	// Process each segment of the polyline
	let accumulatedLength = 0;
	let nextHoleDistance = 0;
	let positionCounter = 1; // Track position within the row

	for (let i = 0; i < vertices.length - 1; i++) {
		// Check for cancellation before each segment
		if (window.holeGenerationCancelled) {
			console.log("Hole generation cancelled by user");
			break;
		}
		const startPoint = vertices[i];
		const endPoint = vertices[i + 1];

		// Calculate segment properties
		const dx = endPoint.x - startPoint.x;
		const dy = endPoint.y - startPoint.y;
		const segmentLength = Math.sqrt(dx * dx + dy * dy);
		const unitX = dx / segmentLength;
		const unitY = dy / segmentLength;

		// Calculate segment bearing in world coordinates
		const segmentBearing = ((Math.atan2(dx, dy) * 180) / Math.PI + 360) % 360;

		// Calculate hole bearing based on user preference
		const holeBearing = params.useLineBearing ? (segmentBearing + 90) % 360 : params.bearing;

		// Place holes along this segment
		let distanceAlongSegment = nextHoleDistance;

		while (distanceAlongSegment < segmentLength) {
			// Check for cancellation before each hole
			if (window.holeGenerationCancelled) {
				console.log("Hole generation cancelled by user");
				break;
			}

			// Calculate hole position
			const holeX = startPoint.x + unitX * distanceAlongSegment;
			const holeY = startPoint.y + unitY * distanceAlongSegment;

			// Calculate hole ID
			let holeID;
			if (params.nameTypeIsNumerical) {
				holeID = holeCounter++;
			} else {
				// Use alphabetical naming like A1, A2, etc.
				const number = holeCounter % 26 || 26;
				if (number === 1 && holeCounter > 1) {
					// Increment letter when we wrap around
					if (currentLetter === "Z") {
						currentLetter = "AA";
					} else if (currentLetter.endsWith("Z")) {
						currentLetter = currentLetter.substring(0, currentLetter.length - 1) + "AA";
					} else {
						currentLetter = String.fromCharCode(currentLetter.charCodeAt(currentLetter.length - 1) + 1);
					}
				}
				holeID = currentLetter + number;
				holeCounter++;
			}

			// Check for cancellation right before adding hole
			if (window.holeGenerationCancelled) {
				console.log("Polyline pattern generation cancelled by user - stopping hole addition");
				break;
			}

			// Add hole with rowID and posID
			addHole(
				true, // useCustomHoleID
				params.useGradeZ, // useGradeZ
				entityName,
				holeID,
				holeX,
				holeY,
				params.collarZ,
				params.gradeZ,
				params.diameter,
				params.type,
				params.length,
				params.subdrill,
				params.angle,
				holeBearing,
				rowID, // All holes in this polyline get the same rowID
				positionCounter, // Sequential position along the polyline
				params.burden, // burden TODO: Add to the show dialog popup for every hole add.
				params.spacing // spacing TODO: Add to the show dialog popup for every hole add.
			);

			positionCounter++; // Increment position counter
			// Move to next hole position
			distanceAlongSegment += params.spacing;
		}

		// Calculate remaining distance for the next segment
		nextHoleDistance = distanceAlongSegment - segmentLength;
		accumulatedLength += segmentLength;
	}

	// Check if generation was cancelled and remove added holes
	let holesWereRemoved = false;
	if (window.holeGenerationCancelled && typeof window.holeGenerationStartCount !== "undefined" && allBlastHoles) {
		const startCount = window.holeGenerationStartCount;
		const currentCount = allBlastHoles.length;
		if (currentCount > startCount) {
			console.log("Removing " + (currentCount - startCount) + " holes added during cancelled polyline pattern generation");
			allBlastHoles.splice(startCount, currentCount - startCount);
			holesWereRemoved = true;
			// Save to IndexedDB to persist the removal
			if (typeof debouncedSaveHoles === "function") {
				debouncedSaveHoles();
			}
		}
	}

	// Redraw
	// Step #) Trigger 3D rebuild to show newly generated holes along polyline
	window.threeDataNeedsRebuild = true;
	drawData(allBlastHoles, selectedHole);

	// Recalculate holesAdded AFTER potential removal
	const holesAdded = allBlastHoles.length - originalPointsCount;

	// Check if cancelled OR if holes were removed (cancellation happened)
	if (window.holeGenerationCancelled || holesWereRemoved) {
		console.log("Polyline pattern generation was cancelled");
		showModalMessage("Pattern Generation Cancelled", "Hole generation was stopped by user action. No holes were added.", "warning");
	} else {
		console.log("Generated " + holesAdded + " holes along polyline with rowID " + rowID);
		debouncedSaveHoles(); // Auto-save holes to IndexedDB

		// Show success/failure message with custom styling
		if (holesAdded === 0) {
			showModalMessage("No Holes Generated", "No holes were generated along the polyline. Please check your settings.", "warning");
		}
		//commented out as it is causing confusion when the cncels generation by the proximity warning dialog
		// else if (holesAdded > 0) {
		// 	showModalMessage("Polyline Pattern Generated", "Successfully generated " + holesAdded + " holes along the polyline (Row " + rowID + ").", "success");
		// }
	}
}
// Expose generateHolesAlongPolyline globally for PatternGenerationDialogs.js
window.generateHolesAlongPolyline = generateHolesAlongPolyline;
// Moved to src/dialog/popups/generic/PatternGenerationDialogs.js

///----------------- ASSIGN HOLE START Z TO A SURFACE TOOL and ASSIGN HOLE GRADE Z to a surface -----------------///
// WITH this multi-surface system:
let loadedSurfaces = new Map(); // Map<surfaceId, {id, name, points, triangles, visible, gradient}>

// Step 0) Surface 2D rendering cache - stores pre-rendered surface images for performance
// Cache is invalidated when: surface properties change, zoom changes beyond threshold, or surface is modified
let surface2DCache = new Map(); // Map<surfaceId, {canvas, ctx, zoom, centroidX, centroidY, bounds, gradient, minLimit, maxLimit, transparency}>
const SURFACE_CACHE_ZOOM_THRESHOLD = 1.5; // Re-render if zoom changes by more than 50%
const SURFACE_CACHE_OVERSAMPLE = 1.0; // Render at 1x resolution (can increase for quality)

// Step 0a) Check if surface cache is valid for current view
function isSurfaceCacheValid(surfaceId, surface) {
	var cache = surface2DCache.get(surfaceId);
	if (!cache) return false;

	// Step 0b) Check if surface properties changed
	if (cache.gradient !== (surface.gradient || "default")) return false;
	if (cache.minLimit !== surface.minLimit) return false;
	if (cache.maxLimit !== surface.maxLimit) return false;
	if (cache.transparency !== (surface.transparency || 1.0)) return false;
	if (cache.hillshadeColor !== (surface.hillshadeColor || null)) return false;

	// Step 0c) Check if zoom changed too much
	var zoomRatio = currentScale / cache.zoom;
	if (zoomRatio > SURFACE_CACHE_ZOOM_THRESHOLD || zoomRatio < (1 / SURFACE_CACHE_ZOOM_THRESHOLD)) {
		return false;
	}

	return true;
}

// Step 0d) Render surface to off-screen canvas cache
function renderSurfaceToCache(surfaceId, surface, surfaceMinZ, surfaceMaxZ) {
	// Step 1) Calculate surface bounds in world coordinates
	var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
	surface.points.forEach(function (point) {
		if (point.x < minX) minX = point.x;
		if (point.x > maxX) maxX = point.x;
		if (point.y < minY) minY = point.y;
		if (point.y > maxY) maxY = point.y;
	});

	// Step 2) Add padding to bounds (5% each side)
	var padX = (maxX - minX) * 0.05;
	var padY = (maxY - minY) * 0.05;
	minX -= padX; maxX += padX;
	minY -= padY; maxY += padY;

	// Step 3) Calculate canvas size based on world bounds and current scale
	var worldWidth = maxX - minX;
	var worldHeight = maxY - minY;
	var cacheWidth = Math.ceil(worldWidth * currentScale * SURFACE_CACHE_OVERSAMPLE);
	var cacheHeight = Math.ceil(worldHeight * currentScale * SURFACE_CACHE_OVERSAMPLE);

	// Step 4) Limit max cache size to prevent memory issues
	var maxCacheSize = 4096;
	if (cacheWidth > maxCacheSize || cacheHeight > maxCacheSize) {
		var scaleDown = maxCacheSize / Math.max(cacheWidth, cacheHeight);
		cacheWidth = Math.ceil(cacheWidth * scaleDown);
		cacheHeight = Math.ceil(cacheHeight * scaleDown);
	}

	// Step 5) Create or reuse off-screen canvas
	var cacheCanvas = document.createElement("canvas");
	cacheCanvas.width = cacheWidth;
	cacheCanvas.height = cacheHeight;
	var cacheCtx = cacheCanvas.getContext("2d");

	// Step 6) Set up transform to map world coords to cache canvas
	// Cache canvas origin is at (minX, maxY) in world coords (Y flipped)
	var cacheScale = cacheWidth / worldWidth;

	// Step 7) Clear and set up context
	cacheCtx.clearRect(0, 0, cacheWidth, cacheHeight);

	// Step 8) Draw each triangle to cache canvas
	var gradient = surface.gradient || "default";
	var transparency = surface.transparency || 1.0;

	surface.triangles.forEach(function (triangle) {
		var p1 = triangle.vertices[0];
		var p2 = triangle.vertices[1];
		var p3 = triangle.vertices[2];

		// Convert world coords to cache canvas coords
		var x1 = (p1.x - minX) * cacheScale;
		var y1 = (maxY - p1.y) * cacheScale; // Y flipped
		var x2 = (p2.x - minX) * cacheScale;
		var y2 = (maxY - p2.y) * cacheScale;
		var x3 = (p3.x - minX) * cacheScale;
		var y3 = (maxY - p3.y) * cacheScale;

		var z1 = p1.z;
		var z2 = p2.z;
		var z3 = p3.z;

		// Draw triangle with solid color (average elevation)
		var avgZ = (z1 + z2 + z3) / 3;

		cacheCtx.globalAlpha = transparency;
		cacheCtx.beginPath();
		cacheCtx.moveTo(x1, y1);
		cacheCtx.lineTo(x2, y2);
		cacheCtx.lineTo(x3, y3);
		cacheCtx.closePath();

		// Handle hillshade specially
		if (gradient === "hillshade") {
			var aspectData = getTriangleAspect(triangle);
			var hillshadeColor = getHillshadeColor(aspectData.aspect, aspectData.slope, aspectData.isFlat, lightBearing, lightElevation, surface.hillshadeColor || null);
			cacheCtx.fillStyle = hillshadeColor;
		} else {
			cacheCtx.fillStyle = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, surface.minLimit, surface.maxLimit);
		}
		cacheCtx.fill();
	});

	// Step 9) Store cache entry
	surface2DCache.set(surfaceId, {
		canvas: cacheCanvas,
		zoom: currentScale,
		bounds: { minX: minX, maxX: maxX, minY: minY, maxY: maxY },
		gradient: gradient,
		minLimit: surface.minLimit,
		maxLimit: surface.maxLimit,
		transparency: transparency,
		hillshadeColor: surface.hillshadeColor || null
	});

	if (developerModeEnabled) {
		console.log("üì¶ Surface cache created for " + surfaceId + ": " + cacheWidth + "x" + cacheHeight + " at zoom " + currentScale.toFixed(2));
	}

	return surface2DCache.get(surfaceId);
}

// Step 0e) Draw cached surface to main canvas
function drawCachedSurface(cache) {
	if (!cache || !cache.canvas) return false;

	// Step 1) Calculate where to draw the cached image on main canvas
	var topLeft = worldToCanvas(cache.bounds.minX, cache.bounds.maxY);
	var bottomRight = worldToCanvas(cache.bounds.maxX, cache.bounds.minY);

	var destX = topLeft[0];
	var destY = topLeft[1];
	var destWidth = bottomRight[0] - topLeft[0];
	var destHeight = bottomRight[1] - topLeft[1];

	// Step 2) Draw the cached canvas image
	ctx.drawImage(cache.canvas, destX, destY, destWidth, destHeight);

	return true;
}

// Step 0f) Invalidate surface cache (call when surface properties change)
function invalidateSurfaceCache(surfaceId) {
	if (surfaceId) {
		surface2DCache.delete(surfaceId);
	} else {
		// Invalidate all caches
		surface2DCache.clear();
	}
}

// Step 0g) Export invalidate function for use in context menu
window.invalidateSurfaceCache = invalidateSurfaceCache;

const assignSurfaceToHolesTool = document.getElementById("assignSurfaceTool");
const assignGradeTool = document.getElementById("assignGradeTool");
let showSurfaceLegend = true; // Add legend visibility control
let currentGradient = "default"; // Default gradient
// Add these variables near your other surface variables
let surfaceTransparency = 1.0; // Default fully opaque (same as image.transparency pattern)

//IMPORTANT - THIS IS THE FUNCTION THAT ASSIGNS THE HOLE TO THE SURFACE
function assignHoleToSurface(hole) {
	const surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation);
	if (surfaceZ !== null) {
		hole.startZLocation = surfaceZ;
		hole.gradeZLocation = surfaceZ + hole.length; // Adjust grade accordingly
		// console.log("Assigned hole: " + hole.holeID + " to surface elevation: " + surfaceZ.toFixed(2) + "m");
	}
}
// NEW: Check if click point is actually on a surface triangle
function isPointInSurface(x, y) {
	// Check all loaded surfaces
	if (loadedSurfaces.size === 0) {
		return null; // Changed from false to null
	}

	// Convert canvas coordinates to world coordinates
	const worldX = (x - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(y - canvas.height / 2) / currentScale + centroidY;

	// Check if point is inside any triangle of any visible surface
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		// Check if point is inside any triangle
		for (let triangle of surface.triangles) {
			if (isPointInTriangle(worldX, worldY, triangle.vertices)) {
				return surfaceId; // Return the specific surface ID
			}
		}
	}

	return null; // Changed from false to null
}
// Determines if a point is inside a triangle using barycentric coordinates.
function isPointInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a >= 0 && b >= 0 && c >= 0;
}
// Interpolates the Z value of a point inside a triangle using barycentric coordinates.
function interpolateZInTriangle(x, y, vertices) {
	const [v0, v1, v2] = vertices;
	const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);
	const a = ((v1.y - v2.y) * (x - v2.x) + (v2.x - v1.x) * (y - v2.y)) / denom;
	const b = ((v2.y - v0.y) * (x - v2.x) + (v0.x - v2.x) * (y - v2.y)) / denom;
	const c = 1 - a - b;
	return a * v0.z + b * v1.z + c * v2.z;
}

// Interpolates the Z value of a point on the surface.
function interpolateZFromSurface(x, y, surfaceId = null) {
	// If surfaceId is specified, only check that surface
	if (surfaceId) {
		const surface = loadedSurfaces.get(surfaceId);
		if (surface && surface.visible && surface.triangles && surface.triangles.length > 0) {
			for (const triangle of surface.triangles) {
				if (isPointInTriangle(x, y, triangle.vertices)) {
					return interpolateZInTriangle(x, y, triangle.vertices);
				}
			}
		}
		return null; // Point not on specified surface
	}

	// Original behavior: Find triangle containing point (x, y) from all loaded surfaces
	for (let [surfaceId, surface] of loadedSurfaces) {
		if (!surface.visible || !surface.triangles || surface.triangles.length === 0) {
			continue;
		}

		for (const triangle of surface.triangles) {
			if (isPointInTriangle(x, y, triangle.vertices)) {
				return interpolateZInTriangle(x, y, triangle.vertices);
			}
		}
	}
	return null; // Point not on surface
}

// Loads a point cloud file and processes it.
function loadPointCloudFile(file) {
	var fileExtension = file.name.split(".").pop().toLowerCase();

	// Step 1) OBJ files should use the textured mesh loader with auto-discovery
	if (fileExtension === "obj") {
		loadOBJWithAutoDiscovery(file);
		return;
	}

	// Step 2) All other point cloud formats - standard loading
	var reader = new FileReader();

	// Show loading progress
	updateStatusMessage("Loading surface file: " + file.name + "...");

	reader.onload = function (e) {
		var content = e.target.result;
		var points;

		try {
			switch (fileExtension) {
				case "xyz":
					points = parseXYZFile(content);
					break;
				case "asc":
					points = parseASCFile(content);
					break;
				case "txt":
					points = parseTXTFile(content);
					break;
				case "csv":
					points = parseCSVPointCloud(content);
					break;
				case "ply":
					points = parsePLYFile(content);
					break;
				case "pts":
					points = parsePTSFile(content);
					break;
				default:
					// Default to the existing parser for backward compatibility
					points = parsePointCloudData(content);
			}

			if (points && points.length > 0) {
				// Step 3) Always show import dialog for user control over options
				showPointCloudImportDialog(points, file.name);
			} else {
				updateStatusMessage("No valid points found in: " + file.name);
			}
		} catch (error) {
			console.error("Error parsing surface file:", error);
			updateStatusMessage("Error loading surface file: " + error.message);
		}
	};
	reader.readAsText(file);
}

// Step 1) Auto-discover companion MTL/texture files for OBJ
async function loadOBJWithAutoDiscovery(objFile) {
	try {
		updateStatusMessage("Loading OBJ: " + objFile.name + " (searching for MTL/textures...)");

		var objContent = await readFileAsText(objFile);
		var baseName = objFile.name.replace(/\.obj$/i, "");

		// Step 2) Parse OBJ to check for material library reference and extract points
		var objData = parseOBJFile(objContent, null);

		// Step 3) Try to auto-discover companion files using File System Access API
		var mtlContent = null;
		var textureBlobs = {};
		var companionFilesFound = false;

		// Step 4) Check if browser supports File System Access API and file has handle
		if (objFile.handle && objFile.handle.getParent) {
			// We have directory access - can auto-discover
			try {
				var dirHandle = await objFile.handle.getParent();
				var result = await discoverCompanionFiles(dirHandle, baseName);
				mtlContent = result.mtlContent;
				textureBlobs = result.textureBlobs;
				companionFilesFound = result.found;
			} catch (err) {
				console.log("üß≠ Directory access not available, trying alternative method");
			}
		}

		// Step 5) If no companion files found via directory access, try URL-based discovery
		if (!companionFilesFound && objData.materialLibrary) {
			// Check if we're running locally with file:// protocol or have server access
			try {
				var result = await discoverCompanionFilesViaFetch(objFile, baseName, objData.materialLibrary);
				mtlContent = result.mtlContent;
				textureBlobs = result.textureBlobs;
				companionFilesFound = result.found;
			} catch (err) {
				console.log("üß≠ Fetch-based discovery not available");
			}
		}

		// Step 6) ALWAYS use Three.js OBJLoader for reliable triangle parsing
		// This ensures consistent topology whether the OBJ has textures or not
		console.log("üîé Using Three.js OBJLoader for reliable mesh parsing");
		updateStatusMessage("Loading OBJ with Three.js loader...");

		// Update objData with mtlContent if found
		if (mtlContent) {
			objData.mtlContent = mtlContent;
		}

		// Step 7) Use Three.js loader (works with or without MTL/textures)
		await loadOBJWithTextureThreeJS(objFile.name, objContent, mtlContent, textureBlobs, objData);

	} catch (error) {
		console.error("‚ùå Error in loadOBJWithAutoDiscovery:", error);
		updateStatusMessage("Error loading OBJ: " + error.message);
	}
}

// Step 1) Discover companion files via directory handle (File System Access API)
async function discoverCompanionFiles(dirHandle, baseName) {
	var mtlContent = null;
	var textureBlobs = {};
	var found = false;

	try {
		// Step 2) Iterate through directory entries
		for await (var entry of dirHandle.values()) {
			if (entry.kind !== "file") continue;

			var fileName = entry.name;
			var fileNameLower = fileName.toLowerCase();
			var baseNameLower = baseName.toLowerCase();

			// Step 3) Check for MTL file
			if (fileNameLower === baseNameLower + ".mtl") {
				var mtlFile = await entry.getFile();
				mtlContent = await mtlFile.text();
				found = true;
				console.log("üîé Found MTL: " + fileName);
			}

			// Step 4) Check for texture files (same base name or referenced in MTL)
			var ext = fileName.split(".").pop().toLowerCase();
			if (ext === "jpg" || ext === "jpeg" || ext === "png" || ext === "gif" || ext === "bmp") {
				// Check if it starts with base name or is commonly used
				if (fileNameLower.startsWith(baseNameLower) || fileNameLower.includes(baseNameLower) || fileNameLower === "texture." + ext || fileNameLower === "diffuse." + ext) {
					var texFile = await entry.getFile();
					textureBlobs[fileName] = await texFile.arrayBuffer().then(function (buf) {
						return new Blob([buf], { type: texFile.type });
					});
					found = true;
					console.log("üîé Found texture: " + fileName);
				}
			}
		}
	} catch (err) {
		console.warn("Error discovering companion files:", err);
	}

	return { mtlContent: mtlContent, textureBlobs: textureBlobs, found: found };
}

// Step 1) Discover companion files via fetch (for server-hosted files)
async function discoverCompanionFilesViaFetch(objFile, baseName, materialLibrary) {
	var mtlContent = null;
	var textureBlobs = {};
	var found = false;

	// Step 2) This only works if we have URL access to the files
	// For local file:// URLs, this won't work due to CORS
	// For http:// URLs, it might work if same-origin

	try {
		// Step 3) Get the base URL from the file
		var fileURL = "";
		if (objFile.path) {
			// Electron or similar - has path
			var pathParts = objFile.path.split(/[/\\]/);
			pathParts.pop(); // Remove filename
			fileURL = pathParts.join("/") + "/";
		} else if (objFile.webkitRelativePath) {
			// Directory upload
			var pathParts = objFile.webkitRelativePath.split("/");
			pathParts.pop();
			fileURL = pathParts.join("/") + "/";
		}

		if (!fileURL) {
			return { mtlContent: null, textureBlobs: {}, found: false };
		}

		// Step 4) Try to fetch MTL
		var mtlFileName = materialLibrary || baseName + ".mtl";
		try {
			var mtlResponse = await fetch(fileURL + mtlFileName);
			if (mtlResponse.ok) {
				mtlContent = await mtlResponse.text();
				found = true;
				console.log("üîé Fetched MTL: " + mtlFileName);

				// Step 5) Parse MTL to find texture references
				var textureRefs = extractTextureRefsFromMTL(mtlContent);

				// Step 6) Fetch each texture
				for (var i = 0; i < textureRefs.length; i++) {
					var texName = textureRefs[i];
					try {
						var texResponse = await fetch(fileURL + texName);
						if (texResponse.ok) {
							var blob = await texResponse.blob();
							textureBlobs[texName] = blob;
							console.log("üîé Fetched texture: " + texName);
						}
					} catch (texErr) {
						console.warn("Could not fetch texture: " + texName);
					}
				}
			}
		} catch (mtlErr) {
			console.warn("Could not fetch MTL: " + mtlFileName);
		}
	} catch (err) {
		console.warn("Error in fetch-based discovery:", err);
	}

	return { mtlContent: mtlContent, textureBlobs: textureBlobs, found: found };
}

// Step 1) Extract texture file references from MTL content
function extractTextureRefsFromMTL(mtlContent) {
	var textureRefs = [];
	var lines = mtlContent.split("\n");

	lines.forEach(function (line) {
		var trimmed = line.trim();
		// Look for map_Kd (diffuse texture), map_Ka (ambient), map_Ks (specular), etc.
		if (trimmed.startsWith("map_Kd ") || trimmed.startsWith("map_Ka ") || trimmed.startsWith("map_Ks ") || trimmed.startsWith("map_Bump ") || trimmed.startsWith("bump ")) {
			var parts = trimmed.split(/\s+/);
			if (parts.length >= 2) {
				var texFile = parts[parts.length - 1]; // Last part is usually the filename
				if (textureRefs.indexOf(texFile) === -1) {
					textureRefs.push(texFile);
				}
			}
		}
	});

	return textureRefs;
}

// Step 1a) Extract material properties from MTL content (serializable for IndexedDB)
function extractMaterialProperties(mtlContent) {
	var materialProperties = {};
	var lines = mtlContent.split("\n");
	var currentMaterial = null;

	lines.forEach(function (line) {
		var trimmed = line.trim();

		// Skip empty lines and comments
		if (!trimmed || trimmed.startsWith("#")) {
			return;
		}

		var parts = trimmed.split(/\s+/);
		var command = parts[0];

		// New material definition
		if (command === "newmtl") {
			currentMaterial = parts.slice(1).join(" ").trim();
			materialProperties[currentMaterial] = {
				name: currentMaterial,
				Ka: [0, 0, 0], // Ambient color (default black)
				Kd: [1, 1, 1], // Diffuse color (default white)
				Ks: [0, 0, 0], // Specular color (default black)
				Ns: 0, // Shininess (default 0)
				map_Kd: null, // Diffuse texture filename
				map_Ka: null, // Ambient texture filename
				map_Ks: null, // Specular texture filename
				illum: 2, // Illumination model (default 2)
			};
		}
		// Ambient color
		else if (command === "Ka" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Ka = [parseFloat(parts[1]) || 0, parseFloat(parts[2]) || 0, parseFloat(parts[3]) || 0];
		}
		// Diffuse color
		else if (command === "Kd" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Kd = [parseFloat(parts[1]) || 1, parseFloat(parts[2]) || 1, parseFloat(parts[3]) || 1];
		}
		// Specular color
		else if (command === "Ks" && currentMaterial && parts.length >= 4) {
			materialProperties[currentMaterial].Ks = [parseFloat(parts[1]) || 0, parseFloat(parts[2]) || 0, parseFloat(parts[3]) || 0];
		}
		// Shininess
		else if (command === "Ns" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].Ns = parseFloat(parts[1]) || 0;
		}
		// Diffuse texture map
		else if (command === "map_Kd" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Kd = parts.slice(1).join(" ").trim();
		}
		// Ambient texture map
		else if (command === "map_Ka" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Ka = parts.slice(1).join(" ").trim();
		}
		// Specular texture map
		else if (command === "map_Ks" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].map_Ks = parts.slice(1).join(" ").trim();
		}
		// Illumination model
		else if (command === "illum" && currentMaterial && parts.length >= 2) {
			materialProperties[currentMaterial].illum = parseInt(parts[1]) || 2;
		}
	});

	return materialProperties;
}

// Step 1b) Create THREE.Material from stored properties + texture (already loaded THREE.Texture object)
function createMaterialFromProperties(materialProps, texture, textureName) {
	if (!materialProps) {
		// Fallback: create default material
		materialProps = {
			Kd: [1, 1, 1],
			Ns: 0,
			map_Kd: textureName,
		};
	}

	// CRITICAL FIX: Use MeshPhongMaterial to match MTLLoader's behavior
	// MTLLoader creates MeshPhongMaterial, not MeshStandardMaterial
	// CRITICAL FIX 2: Use ColorManagement.toWorkingColorSpace() to match MTLLoader EXACTLY
	var diffuseColor = THREE.ColorManagement.toWorkingColorSpace(
		new THREE.Color().fromArray(materialProps.Kd || [1, 1, 1]),
		THREE.SRGBColorSpace
	);

	var specularColor = materialProps.Ks
		? THREE.ColorManagement.toWorkingColorSpace(
			new THREE.Color().fromArray(materialProps.Ks),
			THREE.SRGBColorSpace
		)
		: new THREE.Color(0, 0, 0);

	var material = new THREE.MeshPhongMaterial({
		color: diffuseColor,
		specular: specularColor,
		shininess: materialProps.Ns !== undefined ? materialProps.Ns : 30,
		side: THREE.DoubleSide,
		transparent: false,
		opacity: 1.0,
	});

	console.log("üé® createMaterialFromProperties: Created material with emissive: " + material.emissive.getHexString() + ", emissiveIntensity: " + material.emissiveIntensity);

	// Apply texture if available (texture is already a THREE.Texture object)
	if (texture && texture instanceof THREE.Texture) {
		material.map = texture;
		material.needsUpdate = true;
		console.log("üé® createMaterialFromProperties: Texture applied to material, colorSpace: " + texture.colorSpace + ", image: " + (texture.image ? "loaded" : "null"));
		console.log("üé® createMaterialFromProperties: Created MeshPhongMaterial with Kd: [" + materialProps.Kd.join(", ") + "], Ks: [" + (materialProps.Ks || [0, 0, 0]).join(", ") + "], Ns: " + (materialProps.Ns || 30));
	} else {
		console.warn("üö® createMaterialFromProperties: No valid texture provided!");
	}

	return material;
}

// Step 1) Create surface from parsed OBJ data (preserves original faces)
function createSurfaceFromOBJData(objData, fileName) {
	var surfaceId = fileName;

	// Step 2) Use triangles from OBJ parser (preserves original mesh topology)
	var triangles = objData.triangles;

	if (!triangles || triangles.length === 0) {
		console.warn("No triangles in OBJ data, falling back to Delaunator");
		createSurfaceFromPoints(objData.points, fileName, true);
		return;
	}

	// Step 3) Add to loadedSurfaces
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: fileName,
		points: objData.points,
		triangles: triangles,
		visible: true,
		gradient: "default",
		transparency: 1.0,
		isTexturedMesh: false,
	});

	console.log("üßä Surface created from OBJ: " + fileName + " (" + objData.points.length + " points, " + triangles.length + " triangles)");

	// Step 4) Save to database
	saveSurfaceToDB(surfaceId)
		.then(function () {
			console.log("‚úÖ OBJ surface saved to database: " + surfaceId);
		})
		.catch(function (err) {
			console.error("‚ùå Failed to save OBJ surface:", err);
		});

	// Step 5) Update UI
	updateCentroids();
	drawData(allBlastHoles, selectedHole);
	debouncedUpdateTreeView();
	updateStatusMessage("Loaded OBJ surface: " + fileName + " (" + triangles.length + " triangles)");
}

// Process surface points with progress indication
function processSurfacePoints(points, fileName) {
	updateStatusMessage("Creating surface from " + points.length.toLocaleString() + " points...");

	// Use setTimeout to allow UI update before processing
	setTimeout(async () => {
		// Make this async
		try {
			createSurfaceFromPoints(points, fileName, false);

			// ADD SURFACE SAVE HERE
			try {
				await saveSurfaceToDB(fileName || "surface_" + Date.now());
				// console.log("üíæ Surface saved from processSurfacePoints:", fileName);
			} catch (saveError) {
				console.error("‚ùå Failed to save surface from processSurfacePoints:", saveError);
			}

			updateStatusMessage("Surface loaded: " + fileName + " (" + points.length.toLocaleString() + " points)");

			// Update TreeView to show new surface
			if (typeof debouncedUpdateTreeView === "function") {
				debouncedUpdateTreeView();
			}
		} catch (error) {
			console.error("Error creating surface:", error);
			updateStatusMessage("Error creating surface: " + error.message);
		}
	}, 100);
}
// Step 1) Enhanced OBJ parser - extracts vertices, faces, UVs, normals, and material references
//=============================================================
// VERBOSE REMOVAL COMMENT - parseOBJFile function extracted
//=============================================================
// Step 1) Function (185 lines, lines 36644-36828) was extracted to src/fileIO/ThreeJSMeshIO/OBJParser.js
// Step 2) Reason: Part of FileManager IO System modularization (Phase 2)
// Step 3) Date: 2026-01-03
// Step 4) The function is now exposed via FileManager.parse() with format "obj"
// Step 5) Handles vertices, faces, UVs, normals, materials, n-gon triangulation
// Step 6) Returns structured data: { vertices, faces, uvs, normals, triangles, materialLibrary, hasTexture, hasFaces }
// Step 7) Backward compatibility maintained via wrapper function below

function parseOBJFile(content, mtlContent) {
	try {
		// Step 1) Use FileManager to parse OBJ data
		var OBJParser = window.fileManager.parsers.get("obj");
		if (!OBJParser) {
			throw new Error("OBJ parser not found in FileManager. Ensure init.js is loaded.");
		}

		var parser = new OBJParser();
		var result = parser.parseOBJData(content, mtlContent);

		// Step 2) Return the parsed result (already in correct format)
		return result;
	} catch (error) {
		console.error("Error during OBJ parsing:", error);
		throw error;
	}
}
// XYZ parser (space-delimited X Y Z format)
function parseXYZFile(content) {
	var lines = content.split("\n");
	var points = [];

	for (var i = 0; i < lines.length; i++) {
		var line = lines[i].trim();

		// Step 1) Skip empty lines and comments
		if (line === "" || line.startsWith("#") || line.startsWith("//")) {
			continue;
		}

		var parts = line.split(/\s+/);

		// Step 2) Parse X,Y,Z (required)
		if (parts.length >= 3) {
			var x = parseFloat(parts[0]);
			var y = parseFloat(parts[1]);
			var z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				var point = { x: x, y: y, z: z };

				// Step 3) Parse R,G,B if available (parts[3], parts[4], parts[5])
				if (parts.length >= 6) {
					var r = parseFloat(parts[3]);
					var g = parseFloat(parts[4]);
					var b = parseFloat(parts[5]);

					if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
						point.r = r;
						point.g = g;
						point.b = b;
					}
				}

				points.push(point);
			}
		}
	}

	return points;
}
// ASC parser (ASCII grid format, commonly used in GIS)
function parseASCFile(content) {
	const lines = content.split("\n");
	const points = [];

	// Parse header information
	let ncols, nrows, xllcorner, yllcorner, cellsize, nodata_value;
	let headerLines = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim().toLowerCase();
		if (line.startsWith("ncols")) {
			ncols = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nrows")) {
			nrows = parseInt(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("xllcorner") || line.startsWith("xllcenter")) {
			xllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("yllcorner") || line.startsWith("yllcenter")) {
			yllcorner = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("cellsize")) {
			cellsize = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.startsWith("nodata_value")) {
			nodata_value = parseFloat(line.split(/\s+/)[1]);
			headerLines++;
		} else if (line.length > 0 && !isNaN(parseFloat(line.split(/\s+/)[0]))) {
			break; // End of header, start of data
		}
	}

	// Parse elevation data
	for (let row = 0; row < nrows; row++) {
		const lineIndex = headerLines + row;
		if (lineIndex < lines.length) {
			const values = lines[lineIndex].trim().split(/\s+/);
			for (let col = 0; col < ncols && col < values.length; col++) {
				const z = parseFloat(values[col]);
				if (!isNaN(z) && z !== nodata_value) {
					const x = xllcorner + col * cellsize;
					const y = yllcorner + (nrows - 1 - row) * cellsize; // Flip Y coordinate
					points.push({
						x,
						y,
						z,
					});
				}
			}
		}
	}

	return points;
}
// PLY parser (ASCII format)
function parsePLYFile(content) {
	const lines = content.split("\n");
	const points = [];
	let inHeader = true;
	let vertexCount = 0;

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i].trim();

		if (inHeader) {
			if (line.startsWith("element vertex")) {
				vertexCount = parseInt(line.split(" ")[2]);
			} else if (line === "end_header") {
				inHeader = false;
			}
		} else if (vertexCount > 0) {
			const parts = line.split(/\s+/);
			if (parts.length >= 3) {
				const x = parseFloat(parts[0]);
				const y = parseFloat(parts[1]);
				const z = parseFloat(parts[2]);

				if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
					points.push({
						x,
						y,
						z,
					});
					vertexCount--;
				}
			}
		}
	}

	return points;
}
// PTS parser (point count + XYZ + intensity)
function parsePTSFile(content) {
	var lines = content.split("\n");
	var points = [];

	// Step 1) First line might be point count
	var startIndex = 0;
	if (lines[0] && !isNaN(parseInt(lines[0].trim()))) {
		startIndex = 1;
	}

	// Step 2) Parse each line
	for (var i = startIndex; i < lines.length; i++) {
		var line = lines[i].trim();

		// Skip empty lines and comments
		if (line === "" || line.startsWith("#") || line.startsWith("//")) {
			continue;
		}

		var parts = line.split(/\s+/);

		if (parts.length >= 3) {
			var x = parseFloat(parts[0]);
			var y = parseFloat(parts[1]);
			var z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				var point = { x: x, y: y, z: z };

				// Step 3) Parse R,G,B if available
				if (parts.length >= 6) {
					var r = parseFloat(parts[3]);
					var g = parseFloat(parts[4]);
					var b = parseFloat(parts[5]);

					if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
						point.r = r;
						point.g = g;
						point.b = b;
					}
				}

				points.push(point);
			}
		}
	}

	return points;
}
// TXT parser (flexible text format)
function parseTXTFile(content) {
	const lines = content.split("\n");
	const points = [];

	lines.forEach((line) => {
		// Skip comment lines and empty lines
		const trimmedLine = line.trim();
		if (trimmedLine.length === 0 || trimmedLine.startsWith("#") || trimmedLine.startsWith("//")) {
			return;
		}

		// Try different delimiters: space, tab, comma
		let parts = trimmedLine.split(/\s+/);
		if (parts.length < 3) {
			parts = trimmedLine.split("\t");
		}
		if (parts.length < 3) {
			parts = trimmedLine.split(",");
		}

		if (parts.length >= 3) {
			const x = parseFloat(parts[0]);
			const y = parseFloat(parts[1]);
			const z = parseFloat(parts[2]);

			if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
				points.push({
					x,
					y,
					z,
				});
			}
		}
	});

	return points;
}
// CSV parser specifically for point clouds
//=============================================================
// VERBOSE REMOVAL COMMENT - parseCSVPointCloud function extracted
//=============================================================
// Step 1) Function (32 lines, lines 36859-36890) was extracted to src/fileIO/PointCloudIO/PointCloudParser.js
// Step 2) Reason: Part of FileManager IO System modularization (Phase 2)
// Step 3) Date: 2026-01-03
// Step 4) The function is now exposed via FileManager.parse() with format "pointcloud-csv"
// Step 5) Handles CSV point clouds with optional header detection
// Step 6) Returns array of {x, y, z} points
// Step 7) Backward compatibility maintained via wrapper function below

function parseCSVPointCloud(content) {
	try {
		// Step 1) Use FileManager to parse point cloud CSV data
		var PointCloudParser = window.fileManager.parsers.get("pointcloud-csv");
		if (!PointCloudParser) {
			throw new Error("Point Cloud CSV parser not found in FileManager. Ensure init.js is loaded.");
		}

		var parser = new PointCloudParser();
		var result = parser.parseCSVData(content);

		// Step 2) Return the points array (backward compatible)
		return result;
	} catch (error) {
		console.error("Error during point cloud CSV parsing:", error);
		throw error;
	}
}
// Add this to track the current surface name
window.currentSurfaceName = null;

function createSurfaceFromPoints(points, surfaceName = null, autoSave = true) {
	const surfaceId = surfaceName || "surface_" + Date.now();

	// Create triangles in LOCAL variable (not global)
	const triangles = [];
	const coords = points.flatMap((p) => [p.x, p.y]);
	const delaunay = new Delaunator(coords);

	for (let i = 0; i < delaunay.triangles.length; i += 3) {
		const p1 = points[delaunay.triangles[i]];
		const p2 = points[delaunay.triangles[i + 1]];
		const p3 = points[delaunay.triangles[i + 2]];

		// ? Push to LOCAL triangles array
		triangles.push({
			vertices: [p1, p2, p3],
			minZ: Math.min(p1.z, p2.z, p3.z),
			maxZ: Math.max(p1.z, p2.z, p3.z),
		});
	}

	// ? Add complete surface to the Map
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: surfaceName || surfaceId,
		points: points,
		triangles: triangles,
		visible: true,
		gradient: "default",
	});

	updateCentroids();
	drawData(allBlastHoles, selectedHole);

	// Step #) Ensure TreeView reflects newly created surface from point cloud
	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}

	if (autoSave) {
		saveSurfaceToDB(surfaceId).catch((err) => console.error("Failed to save surface:", err));
	}
}

// NOTE: GeoTIFF export functions moved to src/helpers/GeoTIFFExporter.js
// - exportImagesAsGeoTIFF() - Exports cached surfaces and images as RGB GeoTIFF
// - exportSurfacesAsElevationGeoTIFF() - Exports surfaces as elevation GeoTIFF
// Surface rasterization helpers moved to src/helpers/SurfaceRasterizer.js
// - rasterizeSurfaceToElevationGrid() - Rasterizes triangle mesh to elevation grid
// - interpolateZFromTriangles() - Barycentric interpolation for elevation

// Point Cloud Import Dialog - Full-featured dialog with WGS84 detection and triangulation options
function showPointCloudImportDialog(points, fileName) {
	var pointCount = points.length;

	// Step 1) Detect if coordinates are likely WGS84
	var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
	for (var i = 0; i < Math.min(points.length, 1000); i++) {
		var pt = points[i];
		if (pt.x < minX) minX = pt.x;
		if (pt.x > maxX) maxX = pt.x;
		if (pt.y < minY) minY = pt.y;
		if (pt.y > maxY) maxY = pt.y;
	}
	var bbox = [minX, minY, maxX, maxY];
	var detectedWGS84 = isLikelyWGS84(bbox);

	// Step 2) Create dialog content HTML
	var contentHTML = '<div style="display: flex; flex-direction: column; gap: 15px; padding: 10px;">';

	// Step 3) File information
	contentHTML += '<div style="text-align: left;">';
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 10px 0;"><strong>File:</strong> ' + fileName + "</p>";
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 10px 0;">Points: <strong>' + pointCount.toLocaleString() + '</strong></p>';
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 10px 0;">Detected coordinate system: <strong>' + (detectedWGS84 ? "WGS84 (latitude/longitude)" : "Projected (UTM/local)") + "</strong></p>";
	contentHTML += "</div>";

	// Step 4) Import type selection
	contentHTML += '<div style="border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 10px; background: var(--dark-mode-bg);">';
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 8px 0; font-weight: bold;">Import As:</p>';

	contentHTML += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">';
	contentHTML += '<input type="radio" id="pc-import-pointcloud" name="pc-import-type" value="pointcloud" style="margin: 0;">';
	contentHTML += '<label for="pc-import-pointcloud" class="labelWhite15" style="margin: 0; cursor: pointer;">Point Cloud (KAD points)</label>';
	contentHTML += "</div>";

	contentHTML += '<div style="display: flex; align-items: center; gap: 8px;">';
	contentHTML += '<input type="radio" id="pc-import-surface" name="pc-import-type" value="surface" checked style="margin: 0;">';
	contentHTML += '<label for="pc-import-surface" class="labelWhite15" style="margin: 0; cursor: pointer;">Surface (triangulated mesh)</label>';
	contentHTML += "</div>";

	contentHTML += "</div>";

	// Step 5) Coordinate transformation options (only if WGS84 detected)
	if (detectedWGS84) {
		contentHTML += '<div style="border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 10px; background: var(--dark-mode-bg);">';
		contentHTML += '<p class="labelWhite15" style="margin: 0 0 8px 0; font-weight: bold;">Coordinate Transformation:</p>';

		contentHTML += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">';
		contentHTML += '<input type="radio" id="pc-keep-wgs84" name="pc-transform" value="keep" style="margin: 0;">';
		contentHTML += '<label for="pc-keep-wgs84" class="labelWhite15" style="margin: 0; cursor: pointer;">Keep as WGS84 (latitude/longitude)</label>';
		contentHTML += "</div>";

		contentHTML += '<div style="display: flex; align-items: center; gap: 8px;">';
		contentHTML += '<input type="radio" id="pc-transform-utm" name="pc-transform" value="transform" checked style="margin: 0;">';
		contentHTML += '<label for="pc-transform-utm" class="labelWhite15" style="margin: 0; cursor: pointer;">Transform to projected coordinates</label>';
		contentHTML += "</div>";

		// EPSG dropdown
		contentHTML += '<div id="pc-epsg-section" style="margin-top: 10px; display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: center;">';
		contentHTML += '<label class="labelWhite15">EPSG Code:</label>';
		contentHTML += '<select id="pc-import-epsg-code" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
		contentHTML += '<option value="">-- Select EPSG Code --</option>';

		// Add common EPSG codes (top100EPSGCodes from ProjectionDialog)
		var commonEPSG = [
			{ code: "32750", name: "WGS 84 / UTM zone 50S" },
			{ code: "32751", name: "WGS 84 / UTM zone 51S" },
			{ code: "32752", name: "WGS 84 / UTM zone 52S" },
			{ code: "32753", name: "WGS 84 / UTM zone 53S" },
			{ code: "32754", name: "WGS 84 / UTM zone 54S" },
			{ code: "32755", name: "WGS 84 / UTM zone 55S" },
			{ code: "32756", name: "WGS 84 / UTM zone 56S" },
			{ code: "28350", name: "GDA94 / MGA zone 50" },
			{ code: "28351", name: "GDA94 / MGA zone 51" },
			{ code: "28352", name: "GDA94 / MGA zone 52" },
			{ code: "28353", name: "GDA94 / MGA zone 53" },
			{ code: "28354", name: "GDA94 / MGA zone 54" },
			{ code: "28355", name: "GDA94 / MGA zone 55" },
			{ code: "28356", name: "GDA94 / MGA zone 56" },
			{ code: "7850", name: "GDA2020 / MGA zone 50" },
			{ code: "7851", name: "GDA2020 / MGA zone 51" },
			{ code: "7852", name: "GDA2020 / MGA zone 52" },
			{ code: "7853", name: "GDA2020 / MGA zone 53" },
			{ code: "7854", name: "GDA2020 / MGA zone 54" },
			{ code: "7855", name: "GDA2020 / MGA zone 55" },
			{ code: "7856", name: "GDA2020 / MGA zone 56" }
		];
		commonEPSG.forEach(function (item) {
			contentHTML += '<option value="' + item.code + '">' + item.code + " - " + item.name + "</option>";
		});
		contentHTML += "</select>";
		contentHTML += "</div>";

		// Custom Proj4
		contentHTML += '<div style="margin-top: 8px; display: grid; grid-template-columns: 100px 1fr; gap: 8px; align-items: start;">';
		contentHTML += '<label class="labelWhite15" style="padding-top: 4px;">Or Custom Proj4:</label>';
		contentHTML += '<textarea id="pc-import-custom-proj4" placeholder="+proj=utm +zone=50 +south +datum=WGS84 +units=m +no_defs" style="height: 50px; padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 11px; font-family: monospace; resize: vertical;"></textarea>';
		contentHTML += "</div>";

		contentHTML += "</div>";
	}

	// Step 6) Point Cloud options (shown for Point Cloud import)
	contentHTML += '<div id="pc-pointcloud-options" style="display: none; border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 10px; background: var(--dark-mode-bg);">';
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 8px 0; font-weight: bold;">Point Cloud Options:</p>';

	contentHTML += '<div style="display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center;">';
	contentHTML += '<label class="labelWhite15">Max Points:</label>';
	contentHTML += '<input type="number" id="pc-max-points" value="100000" min="1000" max="1000000" step="1000" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += "</div>";

	contentHTML += "</div>";

	// Step 7) Surface triangulation options (shown for Surface import)
	contentHTML += '<div id="pc-surface-options" style="border: 1px solid var(--light-mode-border); border-radius: 4px; padding: 10px; background: var(--dark-mode-bg);">';
	contentHTML += '<p class="labelWhite15" style="margin: 0 0 8px 0; font-weight: bold;">Surface Triangulation Options:</p>';

	// Surface Name
	contentHTML += '<div style="display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin-bottom: 6px;">';
	contentHTML += '<label class="labelWhite15">Surface Name:</label>';
	var defaultSurfaceName = fileName.replace(/\.[^/.]+$/, "") || "PointCloud_Surface";
	contentHTML += '<input type="text" id="pc-surface-name" value="' + defaultSurfaceName + '" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += "</div>";

	// Max Edge Length
	contentHTML += '<div style="display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin-bottom: 6px;">';
	contentHTML += '<label class="labelWhite15">Max Edge Length:</label>';
	contentHTML += '<input type="number" id="pc-max-edge-length" value="0" min="0" max="10000" step="1" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += '<p class="labelWhite15" style="font-size: 10px; opacity: 0.7; margin: 2px 0 0 0; grid-column: 2;">0 = disabled. Removes convex hull triangles with long edges.</p>';
	contentHTML += "</div>";

	// Consider 3D Edge Length
	contentHTML += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px; margin-left: 140px;">';
	contentHTML += '<input type="checkbox" id="pc-consider-3d-length" style="margin: 0;">';
	contentHTML += '<label for="pc-consider-3d-length" class="labelWhite15" style="margin: 0; cursor: pointer; font-size: 11px;">Consider 3D edge length (includes Z difference)</label>';
	contentHTML += "</div>";

	// Min Internal Angle
	contentHTML += '<div style="display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin-bottom: 6px;">';
	contentHTML += '<label class="labelWhite15">Min Internal Angle:</label>';
	contentHTML += '<input type="number" id="pc-min-angle" value="0" min="0" max="60" step="1" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += '<p class="labelWhite15" style="font-size: 10px; opacity: 0.7; margin: 2px 0 0 0; grid-column: 2;">0 = disabled. Removes skinny triangles (degrees).</p>';
	contentHTML += "</div>";

	// Consider 3D Angle
	contentHTML += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px; margin-left: 140px;">';
	contentHTML += '<input type="checkbox" id="pc-consider-3d-angle" style="margin: 0;">';
	contentHTML += '<label for="pc-consider-3d-angle" class="labelWhite15" style="margin: 0; cursor: pointer; font-size: 11px;">Consider 3D angle (includes Z in calculation)</label>';
	contentHTML += "</div>";

	// Surface Style (gradient)
	contentHTML += '<div style="display: grid; grid-template-columns: 140px 1fr; gap: 8px; align-items: center; margin-bottom: 6px;">';
	contentHTML += '<label class="labelWhite15">Surface Style:</label>';
	contentHTML += '<select id="pc-surface-style" style="padding: 4px 8px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--light-mode-border); border-radius: 3px; font-size: 12px;">';
	contentHTML += '<option value="default">Default (elevation)</option>';
	contentHTML += '<option value="hillshade">Hillshade</option>';
	contentHTML += '<option value="viridis">Viridis</option>';
	contentHTML += '<option value="turbo">Turbo</option>';
	contentHTML += '<option value="parula">Parula</option>';
	contentHTML += '<option value="cividis">Cividis</option>';
	contentHTML += '<option value="terrain">Terrain</option>';
	contentHTML += "</select>";
	contentHTML += "</div>";

	contentHTML += "</div>";

	// Error message
	contentHTML += '<div id="pc-import-error-message" style="display: none; margin-top: 8px; padding: 6px; background: #f44336; color: white; border-radius: 3px; font-size: 11px;"></div>';

	contentHTML += "</div>";

	// Step 8) Create dialog
	var dialog = new FloatingDialog({
		title: "Import Point Cloud",
		content: contentHTML,
		layoutType: "default",
		width: 650,
		height: detectedWGS84 ? 780 : 580,
		showConfirm: true,
		showCancel: true,
		confirmText: "Import",
		cancelText: "Cancel",
		onConfirm: async function () {
			try {
				// Step 9) Get form values
				var importType = document.querySelector('input[name="pc-import-type"]:checked').value;
				var errorDiv = document.getElementById("pc-import-error-message");
				var processedPoints = points.slice(); // Copy points array

				// Step 10) Handle coordinate transformation if WGS84
				if (detectedWGS84) {
					var transformRadio = document.querySelector('input[name="pc-transform"]:checked');
					if (transformRadio && transformRadio.value === "transform") {
						var epsgCode = document.getElementById("pc-import-epsg-code").value.trim();
						var customProj4 = document.getElementById("pc-import-custom-proj4").value.trim();

						if (!epsgCode && !customProj4) {
							errorDiv.textContent = "Please select an EPSG code or provide a custom Proj4 definition for transformation";
							errorDiv.style.display = "block";
							return;
						}

						// Load EPSG definition if needed
						if (epsgCode) {
							await window.loadEPSGCode(epsgCode);
						}

						// Transform coordinates
						var sourceDef = "+proj=longlat +datum=WGS84 +no_defs";
						var targetDef = customProj4 || "EPSG:" + epsgCode;

						console.log("Transforming point cloud from WGS84 to: " + targetDef);
						updateStatusMessage("Transforming coordinates...");

						for (var i = 0; i < processedPoints.length; i++) {
							var pt = processedPoints[i];
							var transformed = proj4(sourceDef, targetDef, [pt.x, pt.y]);
							processedPoints[i] = { x: transformed[0], y: transformed[1], z: pt.z };
							if (pt.r !== undefined) processedPoints[i].r = pt.r;
							if (pt.g !== undefined) processedPoints[i].g = pt.g;
							if (pt.b !== undefined) processedPoints[i].b = pt.b;
							if (pt.color) processedPoints[i].color = pt.color;
						}
						console.log("Transformed " + processedPoints.length + " points");
					}
				}

				// Step 11) Get ALL form values BEFORE closing dialog (elements removed on close)
				var maxPoints = 100000;
				var maxPointsEl = document.getElementById("pc-max-points");
				if (maxPointsEl) maxPoints = parseInt(maxPointsEl.value) || 100000;

				var surfaceNameEl = document.getElementById("pc-surface-name");
				var maxEdgeLengthEl = document.getElementById("pc-max-edge-length");
				var consider3DLengthEl = document.getElementById("pc-consider-3d-length");
				var minAngleEl = document.getElementById("pc-min-angle");
				var consider3DAngleEl = document.getElementById("pc-consider-3d-angle");
				var surfaceStyleEl = document.getElementById("pc-surface-style");

				var config = {
					surfaceName: surfaceNameEl ? surfaceNameEl.value : "PointCloud_Surface",
					maxEdgeLength: maxEdgeLengthEl ? parseFloat(maxEdgeLengthEl.value) || 0 : 0,
					consider3DLength: consider3DLengthEl ? consider3DLengthEl.checked : false,
					minAngle: minAngleEl ? parseFloat(minAngleEl.value) || 0 : 0,
					consider3DAngle: consider3DAngleEl ? consider3DAngleEl.checked : false,
					surfaceStyle: surfaceStyleEl ? surfaceStyleEl.value : "default"
				};

				// Step 12) NOW close the dialog
				dialog.close();

				// Step 13) Import based on type
				if (importType === "pointcloud") {
					// Point Cloud import
					var finalPoints = processedPoints;
					if (processedPoints.length > maxPoints) {
						finalPoints = decimatePointCloud(processedPoints, maxPoints);
						console.log("Decimated from " + processedPoints.length + " to " + finalPoints.length + " points");
					}
					createKADPointsFromPointCloud(finalPoints, fileName);
					updateStatusMessage("Imported " + finalPoints.length + " points as KAD entities");
				} else {
					// Surface import with triangulation options
					createSurfaceFromPointsWithOptions(processedPoints, config);
				}

			} catch (error) {
				var errorDiv = document.getElementById("pc-import-error-message");
				if (errorDiv) {
					errorDiv.textContent = "Import error: " + error.message;
					errorDiv.style.display = "block";
				}
				console.error("Point cloud import error:", error);
			}
		},
		onCancel: function () {
			console.log("Point cloud import cancelled");
		}
	});

	dialog.show();

	// Step 12) Toggle Point Cloud / Surface options visibility based on import type
	var importTypeRadios = document.querySelectorAll('input[name="pc-import-type"]');
	var pointcloudOptions = document.getElementById("pc-pointcloud-options");
	var surfaceOptions = document.getElementById("pc-surface-options");

	importTypeRadios.forEach(function (radio) {
		radio.addEventListener("change", function () {
			if (radio.value === "surface" && radio.checked) {
				pointcloudOptions.style.display = "none";
				surfaceOptions.style.display = "block";
			} else if (radio.value === "pointcloud" && radio.checked) {
				pointcloudOptions.style.display = "block";
				surfaceOptions.style.display = "none";
			}
		});
	});

	// Step 13) Toggle EPSG section visibility if WGS84 detected
	if (detectedWGS84) {
		var transformRadios = document.querySelectorAll('input[name="pc-transform"]');
		var epsgSection = document.getElementById("pc-epsg-section");

		transformRadios.forEach(function (radio) {
			radio.addEventListener("change", function () {
				if (radio.value === "transform") {
					epsgSection.style.display = "grid";
				} else {
					epsgSection.style.display = "none";
				}
			});
		});
	}
}

// Legacy function - redirect to new dialog
function showDecimationWarning(points, fileName) {
	showPointCloudImportDialog(points, fileName);
}

// Create Surface from Points with Triangulation Options (edge/angle culling)
function createSurfaceFromPointsWithOptions(points, config) {
	var surfaceName = config.surfaceName || "surface_" + Date.now();
	var maxEdgeLength = config.maxEdgeLength || 0;
	var consider3DLength = config.consider3DLength || false;
	var minAngle = config.minAngle || 0;
	var consider3DAngle = config.consider3DAngle || false;
	var surfaceStyle = config.surfaceStyle || "default";

	// Debug logging (only in developer mode)
	if (developerModeEnabled) {
		console.log("Creating surface: " + surfaceName);
		console.log("Options: maxEdgeLength=" + maxEdgeLength + ", minAngle=" + minAngle);
	}

	// Step 1) Create triangles using Delaunator
	var coords = points.flatMap(function (p) { return [p.x, p.y]; });
	var delaunay = new Delaunator(coords);

	// Step 2) Helper function to calculate distance
	function distanceSquared(p1, p2, use3D) {
		var dx = p2.x - p1.x;
		var dy = p2.y - p1.y;
		if (use3D) {
			var dz = p2.z - p1.z;
			return dx * dx + dy * dy + dz * dz;
		}
		return dx * dx + dy * dy;
	}

	// Step 3) Convert to triangles with culling
	var triangles = [];
	var culledByEdge = 0;
	var culledByAngle = 0;

	for (var i = 0; i < delaunay.triangles.length; i += 3) {
		var p1 = points[delaunay.triangles[i]];
		var p2 = points[delaunay.triangles[i + 1]];
		var p3 = points[delaunay.triangles[i + 2]];

		// Step 3a) Edge length culling
		if (maxEdgeLength > 0) {
			var edge1Sq = distanceSquared(p1, p2, consider3DLength);
			var edge2Sq = distanceSquared(p2, p3, consider3DLength);
			var edge3Sq = distanceSquared(p3, p1, consider3DLength);
			var maxEdgeSq = maxEdgeLength * maxEdgeLength;

			if (edge1Sq > maxEdgeSq || edge2Sq > maxEdgeSq || edge3Sq > maxEdgeSq) {
				culledByEdge++;
				continue;
			}
		}

		// Step 3b) Minimum angle culling
		if (minAngle > 0) {
			var edge1 = Math.sqrt(distanceSquared(p1, p2, consider3DAngle));
			var edge2 = Math.sqrt(distanceSquared(p2, p3, consider3DAngle));
			var edge3 = Math.sqrt(distanceSquared(p3, p1, consider3DAngle));

			// Calculate angles using law of cosines
			var angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2 * edge2 + edge3 * edge3 - edge1 * edge1) / (2 * edge2 * edge3)))) * (180 / Math.PI);
			var angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge3 * edge3 - edge2 * edge2) / (2 * edge1 * edge3)))) * (180 / Math.PI);
			var angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1 * edge1 + edge2 * edge2 - edge3 * edge3) / (2 * edge1 * edge2)))) * (180 / Math.PI);

			var minTriAngle = Math.min(angle1, angle2, angle3);

			if (minTriAngle < minAngle) {
				culledByAngle++;
				continue;
			}
		}

		// Step 3c) Add triangle
		triangles.push({
			vertices: [p1, p2, p3],
			minZ: Math.min(p1.z, p2.z, p3.z),
			maxZ: Math.max(p1.z, p2.z, p3.z)
		});
	}

	// Debug logging (only in developer mode)
	if (developerModeEnabled) {
		console.log("Generated " + triangles.length + " triangles");
		console.log("Culled: " + culledByEdge + " by edge length, " + culledByAngle + " by angle");
	}

	// Step 4) Create surface ID
	var surfaceId = surfaceName.replace(/\s+/g, "_");

	// Step 4a) Calculate meshBounds from points for centroid calculation
	// CRITICAL: Without meshBounds, centroid calculation cannot use this surface data
	var minX = Infinity, maxX = -Infinity;
	var minY = Infinity, maxY = -Infinity;
	var minZ = Infinity, maxZ = -Infinity;
	for (var bi = 0; bi < points.length; bi++) {
		var bp = points[bi];
		if (bp.x < minX) minX = bp.x;
		if (bp.x > maxX) maxX = bp.x;
		if (bp.y < minY) minY = bp.y;
		if (bp.y > maxY) maxY = bp.y;
		if (bp.z < minZ) minZ = bp.z;
		if (bp.z > maxZ) maxZ = bp.z;
	}
	var meshBounds = { minX: minX, maxX: maxX, minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ };

	// Step 5) Add surface to Map
	loadedSurfaces.set(surfaceId, {
		id: surfaceId,
		name: surfaceName,
		points: points,
		triangles: triangles,
		meshBounds: meshBounds, // CRITICAL: Add meshBounds for centroid calculation
		visible: true,
		gradient: surfaceStyle,
		metadata: {
			source: "pointcloud_import",
			pointCount: points.length,
			triangleCount: triangles.length,
			culledByEdge: culledByEdge,
			culledByAngle: culledByAngle,
			maxEdgeLength: maxEdgeLength,
			minAngle: minAngle
		}
	});

	// Step 6) Update display
	updateCentroids();
	drawData(allBlastHoles, selectedHole);

	// Step 7) Update TreeView
	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}

	// Step 8) Save to IndexedDB
	saveSurfaceToDB(surfaceId).catch(function (err) {
		console.error("Failed to save surface:", err);
	});

	updateStatusMessage("Created surface: " + surfaceName + " with " + triangles.length + " triangles");
}

function decimatePointCloud(points, targetCount) {
	if (points.length <= targetCount) return points;

	var step = Math.floor(points.length / targetCount);
	var decimatedPoints = [];

	for (var i = 0; i < points.length; i += step) {
		decimatedPoints.push(points[i]);
	}

	return decimatedPoints;
}

// Create KAD Points from Point Cloud with colors
function createKADPointsFromPointCloud(points, fileName) {
	// Step 1) Generate unique entity name
	var uid = Date.now();
	var entityName = "Cloud_" + uid;
	var entityType = "point";

	// Step 2) Create entity in allKADDrawingsMap if it doesn't exist
	if (!window.allKADDrawingsMap) {
		window.allKADDrawingsMap = new Map();
	}

	if (!allKADDrawingsMap.has(entityName)) {
		allKADDrawingsMap.set(entityName, {
			entityName: entityName,
			entityType: entityType,
			data: [],
			visible: true
		});
	}

	// Step 3) Convert point cloud points to KAD point format
	var kadPoints = [];
	var pointIDCounter = 1;

	for (var i = 0; i < points.length; i++) {
		var pt = points[i];

		// Step 4) Extract coordinates
		var x = pt.x || 0;
		var y = pt.y || 0;
		var z = pt.z || 0;

		// Step 5) Extract or generate color
		var color = "#808080"; // Default gray

		if (pt.r !== undefined && pt.g !== undefined && pt.b !== undefined) {
			// Step 6) Convert RGB to hex color
			var r = Math.max(0, Math.min(255, Math.floor(pt.r)));
			var g = Math.max(0, Math.min(255, Math.floor(pt.g)));
			var b = Math.max(0, Math.min(255, Math.floor(pt.b)));

			color = "#" +
				r.toString(16).padStart(2, "0") +
				g.toString(16).padStart(2, "0") +
				b.toString(16).padStart(2, "0");
		} else if (pt.color) {
			// Step 7) Use existing color if available
			color = pt.color;
		}

		// Step 8) Create KAD point object with proper structure
		var kadPoint = {
			entityName: entityName,
			entityType: entityType,
			pointID: pointIDCounter++,
			pointXLocation: x,
			pointYLocation: y,
			pointZLocation: z,
			lineWidth: 1,
			color: color,
			connected: false,
			closed: false,
			visible: true
		};

		kadPoints.push(kadPoint);
	}

	// Step 9) Add all points to the entity's data array
	var entity = allKADDrawingsMap.get(entityName);
	for (var i = 0; i < kadPoints.length; i++) {
		entity.data.push(kadPoints[i]);
	}

	// Step 10) Redraw canvas
	drawData(allBlastHoles, selectedHole);

	// Step 11) Update TreeView to show new entity
	if (typeof updateTreeView === "function") {
		updateTreeView();
	} else if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}

	// Step 12) Save to KAD file
	if (typeof debouncedSaveKAD === "function") {
		debouncedSaveKAD();
	}

	// Step 13) Show success message
	showModalMessage(
		"Point Cloud Imported",
		"Imported " + kadPoints.length + " points as KAD Points\n\nEntity: " + entityName,
		"success"
	);

	console.log("Imported " + kadPoints.length + " points as KAD Points to entity:", entityName);
}
// Add this simple canvasToWorld function (without snapping)
function canvasToWorld(canvasX, canvasY) {
	const worldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const worldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;
	return [worldX, worldY];
}

function drawSurface() {


	if (!surfacesGroupVisible) return; // ? ADD: Check surfaces group visibility
	if (loadedSurfaces.size === 0) return;

	loadedSurfaces.forEach((surface, surfaceId) => {


		if (!surface.visible) return;

		// Step 0a) Check if we should render 3D geometry
		// CRITICAL: Use ONLY onlyShowThreeJS flag - DO NOT check camera orbit angles
		// Checking isIn3DMode causes dual rendering (2D and 3D at same time)
		const should3DRender = threeInitialized && onlyShowThreeJS;

		// Step 0) Handle textured meshes (OBJ files) - only for texture gradient with actual textures
		if (surface.isTexturedMesh && surface.threeJSMesh) {
			var gradient = surface.gradient || "texture";

			// Step 0a) Check if mesh actually has textures
			var hasTexture = false;
			if (surface.threeJSMesh) {
				surface.threeJSMesh.traverse(function (child) {
					if (child.isMesh && child.material) {
						if (Array.isArray(child.material)) {
							hasTexture = child.material.some(function (mat) {
								return mat.map !== null && mat.map !== undefined;
							});
						} else {
							hasTexture = child.material.map !== null && child.material.map !== undefined;
						}
					}
				});
			}

			if (developerModeEnabled) {
				console.log("üé® drawSurface textured mesh: " + surfaceId + ", gradient: " + gradient + ", hasTexture: " + hasTexture + ", should3DRender: " + should3DRender + ", onlyShowThreeJS: " + onlyShowThreeJS);
			}

			// If gradient is "texture" AND mesh has textures, use textured mesh rendering (original JPG texture)
			if (gradient === "texture" && hasTexture) {
				// Use meshBounds for Z range
				let surfaceMinZ = surface.meshBounds ? surface.meshBounds.minZ : 0;
				let surfaceMaxZ = surface.meshBounds ? surface.meshBounds.maxZ : 100;

				// Draw in Three.js ONLY if in 3D rendering mode
				if (should3DRender) {
					// DEBUG: Disabled excessive logging on render
					// console.log("üé• Rendering textured mesh in 3D: " + surfaceId);
					drawSurfaceThreeJS(surfaceId, surface.triangles || [], surfaceMinZ, surfaceMaxZ, gradient, surface.transparency || 1.0, surface);
				} else {
					if (!surface._skipped3DLogShown) {
						console.log("üßπ Skipping 3D render (2D-only mode): " + surfaceId);
						surface._skipped3DLogShown = true;
					}
				}
				return; // Textured mesh with texture gradient doesn't have 2D triangle rendering
			}

			// For "default" and other gradients (hillshade, viridis, terrain, etc.), OR if no texture exists,
			// fall through to standard triangle rendering with elevation-based colors
			console.log("üîª Using color gradient for textured mesh: " + gradient + " (hasTexture: " + hasTexture + ")");
		}

		// Step 1) Standard surface - requires triangles
		if (!surface.triangles || surface.triangles.length === 0) return;
		if (!surface.points || surface.points.length === 0) return;

		// Calculate THIS surface's elevation range only
		let surfaceMinZ = Infinity;
		let surfaceMaxZ = -Infinity;

		surface.points.forEach((point) => {
			if (point.z < surfaceMinZ) surfaceMinZ = point.z;
			if (point.z > surfaceMaxZ) surfaceMaxZ = point.z;
		});

		// Step 2) Draw surface in Three.js ONLY if in 3D rendering mode
		if (should3DRender) {
			drawSurfaceThreeJS(surfaceId, surface.triangles, surfaceMinZ, surfaceMaxZ, surface.gradient || "default", surface.transparency || 1.0, surface);
		}

		// Step 3) Draw surface in 2D canvas (only when not in Three.js-only mode)
		if (!onlyShowThreeJS) {
			// Step 3a) Check if we can use cached surface image
			if (isSurfaceCacheValid(surfaceId, surface)) {
				// Step 3b) Use cached image - much faster!
				var cache = surface2DCache.get(surfaceId);
				if (drawCachedSurface(cache)) {
					return; // Successfully drew from cache, skip triangle rendering
				}
			}

			// Step 3c) Cache miss or invalid - render to cache first, then draw
			var cache = renderSurfaceToCache(surfaceId, surface, surfaceMinZ, surfaceMaxZ);
			if (cache && drawCachedSurface(cache)) {
				return; // Successfully rendered and drew from cache
			}

			// Step 3d) Fallback: Direct triangle rendering (if caching fails)
			// CRITICAL: Pass surface-specific min/max, transparency, AND gradient
			surface.triangles.forEach((triangle, i) => {
				// Fix line 20344 - Surface drawing function (added hillshadeColor parameter)
				drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, ctx, surface.transparency || 1.0, surface.gradient || "default", gradientMethod, lightBearing, lightElevation, surface.hillshadeColor || null, surface.minLimit, surface.maxLimit);
			});
		}
	});
}
// Step #) Surface legend - now uses CSS panel stacked with other legends
function drawSurfaceLegend() {
	// Step 1) Check if any surfaces are visible and have legend enabled
	if (!showSurfaceLegend || loadedSurfaces.size === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 2) Get all visible surfaces
	var visibleSurfaces = Array.from(loadedSurfaces.values()).filter(function (surface) {
		return surface.visible && surface.points && surface.points.length > 0;
	});

	if (visibleSurfaces.length === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 3) Build array of surface legend data (individual surfaces, not combined)
	var surfaceLegendData = [];

	for (var i = 0; i < visibleSurfaces.length; i++) {
		var surface = visibleSurfaces[i];

		// Step 3a) Calculate THIS surface's elevation range
		var surfaceMinZ = Infinity;
		var surfaceMaxZ = -Infinity;

		for (var j = 0; j < surface.points.length; j++) {
			var point = surface.points[j];
			if (point.z < surfaceMinZ) surfaceMinZ = point.z;
			if (point.z > surfaceMaxZ) surfaceMaxZ = point.z;
		}

		// Step 3b) Skip flat surfaces (no elevation variation)
		if (surfaceMaxZ - surfaceMinZ < 0.001) {
			continue;
		}

		// Step 3c) Determine display range (custom limits if set, otherwise actual range)
		var displayMinZ = surface.minLimit !== null ? surface.minLimit : surfaceMinZ;
		var displayMaxZ = surface.maxLimit !== null ? surface.maxLimit : surfaceMaxZ;

		// Step 3d) Add surface to legend data array
		surfaceLegendData.push({
			name: surface.name || "Surface " + (i + 1),
			actualMinZ: surfaceMinZ,
			actualMaxZ: surfaceMaxZ,
			displayMinZ: displayMinZ,
			displayMaxZ: displayMaxZ,
			hasCustomLimits: surface.minLimit !== null || surface.maxLimit !== null,
			gradient: surface.gradient || "default",
			hillshadeColor: surface.hillshadeColor || null
		});
	}

	// Step 4) Show legend if we have any valid surfaces
	if (surfaceLegendData.length === 0) {
		hideSurfaceElevationLegend();
		return;
	}

	// Step 5) Show CSS-based surface legend (stacked with individual surface entries)
	showSurfaceElevationLegend(surfaceLegendData);
}
// Color gradient functions
function getViridisColor(ratio) {
	const colors = [
		[68, 1, 84], // Dark purple
		[59, 82, 139], // Blue-purple
		[33, 144, 140], // Teal
		[92, 200, 99], // Green
		[253, 231, 37], // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getTurboColor(ratio) {
	const colors = [
		[48, 18, 59], // Dark purple
		[50, 136, 189], // Blue
		[94, 201, 98], // Green
		[253, 231, 37], // Yellow
		[240, 21, 22], // Red
	];
	return interpolateColors(colors, ratio);
}

function getParulaColor(ratio) {
	const colors = [
		[53, 42, 135], // Dark blue
		[15, 92, 221], // Blue
		[18, 125, 216], // Light blue
		[7, 156, 207], // Cyan
		[21, 177, 180], // Teal
		[89, 189, 140], // Green
		[170, 194, 97], // Yellow-green
		[249, 251, 14], // Yellow
	];
	return interpolateColors(colors, ratio);
}

function getCividisColor(ratio) {
	const colors = [
		[0, 32, 76], // Dark blue
		[0, 52, 102], // Blue
		[39, 90, 129], // Light blue
		[92, 125, 147], // Gray-blue
		[150, 159, 157], // Gray
		[206, 187, 158], // Beige
		[254, 230, 206], // Light yellow
	];
	return interpolateColors(colors, ratio);
}

function getTerrainColor(ratio) {
	const colors = [
		[0, 68, 27], // Dark green (low elevation)
		[35, 132, 67], // Green
		[65, 174, 118], // Light green
		[120, 198, 121], // Pale green
		[186, 228, 179], // Very pale green
		[120, 85, 45], // Brown (mid elevation)
		[160, 118, 74], // Light brown
		[200, 200, 200], // Gray (high elevation)
		[255, 255, 255], // White (peaks)
	];
	return interpolateColors(colors, ratio);
}

function interpolateColors(colors, ratio) {
	const scaledRatio = ratio * (colors.length - 1);
	const index = Math.floor(scaledRatio);
	const localRatio = scaledRatio - index;

	if (index >= colors.length - 1) {
		const [r, g, b] = colors[colors.length - 1];
		return `rgb(${r}, ${g}, ${b})`;
	}

	const [r1, g1, b1] = colors[index];
	const [r2, g2, b2] = colors[index + 1];

	const r = Math.round(r1 + (r2 - r1) * localRatio);
	const g = Math.round(g1 + (g2 - g1) * localRatio);
	const b = Math.round(b1 + (b2 - b1) * localRatio);

	return `rgb(${r}, ${g}, ${b})`;
}

// Updated elevationToColor function to accept gradient parameter and custom limits
function elevationToColor(z, minZ, maxZ, gradient = "default", minLimit = null, maxLimit = null) {
	// Use custom limits if provided, otherwise use actual surface range
	const effectiveMinZ = minLimit !== null ? minLimit : minZ;
	const effectiveMaxZ = maxLimit !== null ? maxLimit : maxZ;
	const effectiveRange = effectiveMaxZ - effectiveMinZ;

	// Check if the effective range is too small (flat surface)
	if (effectiveRange < 0.001) {
		// Very small tolerance for floating point comparison
		return "rgb(255, 165, 0)"; // Orange for flat surfaces
	}

	// Clamp z value to the effective range for coloring
	const clampedZ = Math.max(effectiveMinZ, Math.min(effectiveMaxZ, z));
	const ratio = (clampedZ - effectiveMinZ) / effectiveRange;

	// Apply selected gradient (now surface-specific)
	switch (gradient) {
		case "hillshade":
			// For hillshade, we'll handle coloring in drawTriangleWithGradient
			// This is just a fallback
			return "rgb(127, 127, 127)";
		case "viridis":
			return getViridisColor(ratio);
		case "turbo":
			return getTurboColor(ratio);
		case "parula":
			return getParulaColor(ratio);
		case "cividis":
			return getCividisColor(ratio);
		case "terrain":
			return getTerrainColor(ratio);
		default:
			// Original blue->cyan->green->yellow->red spectrum
			if (ratio < 0.25) {
				return `rgb(0, ${Math.floor(ratio * 4 * 255)}, 255)`;
			} else if (ratio < 0.5) {
				return `rgb(0, 255, ${Math.floor(255 - (ratio - 0.25) * 4 * 255)})`;
			} else if (ratio < 0.75) {
				return `rgb(${Math.floor((ratio - 0.5) * 4 * 255)}, 255, 0)`;
			} else {
				return `rgb(255, ${Math.floor(255 - (ratio - 0.75) * 4 * 255)}, 0)`;
			}
	}
}

// // Add new hillshading functions
// function getTriangleAspect(triangle) {
// 	const [p1, p2, p3] = triangle.vertices;

// 	// Calculate two edge vectors
// 	const v1X = p2.x - p1.x;
// 	const v1Y = p2.y - p1.y;
// 	const v1Z = p2.z - p1.z;

// 	const v2X = p3.x - p1.x;
// 	const v2Y = p3.y - p1.y;
// 	const v2Z = p3.z - p1.z;

// 	// Cross product to get surface normal
// 	const normalX = v1Y * v2Z - v1Z * v2Y;
// 	const normalY = v1Z * v2X - v1X * v2Z;
// 	const normalZ = v1X * v2Y - v1Y * v2X;

// 	// Handle flat triangles
// 	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
// 	if (horizontalMagnitude < 1e-6) {
// 		return {
// 			aspect: 0,
// 			slope: 0,
// 			isFlat: true
// 		};
// 	}

// 	// Calculate aspect (direction the slope faces)
// 	// 0? = North, 90? = East, 180? = South, 270? = West
// 	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

// 	// Calculate slope angle (steepness)
// 	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
// 	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

// 	return {
// 		aspect,
// 		slope,
// 		isFlat: false
// 	};
// }

// function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 90) {
// 	// Convert to radians
// 	const aspectRad = (aspect * Math.PI) / 180;
// 	const slopeRad = (slope * Math.PI) / 180;
// 	const lightBearingRad = (lightBearing * Math.PI) / 180;
// 	const lightElevationRad = (lightElevation * Math.PI) / 180;

// 	// Calculate illumination using standard hillshade formula
// 	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

// 	// Normalize to 0-1 range
// 	return Math.max(0, Math.min(1, illumination));
// }

// function getHillshadeColor(aspect, slope, isFlat = false) {
// 	if (isFlat) {
// 		// Flat triangles = 50% grey
// 		return "rgb(127, 127, 127)";
// 	}

// 	// Calculate illumination with light source from North (bearing 0?)
// 	const illumination = calculateHillshade(aspect, slope, 0, 45);

// 	// Your proposed color scheme:
// 	// 30% grey (dark) to 70% grey (light)
// 	const minGrey = 30; // 30% grey = rgb(76, 76, 76)
// 	const maxGrey = 70; // 70% grey = rgb(178, 178, 178)

// 	// Map illumination (0-1) to your grey range
// 	const greyPercent = minGrey + (maxGrey - minGrey) * illumination;
// 	const greyValue = Math.round((greyPercent * 255) / 100);

// 	return "rgb(" + greyValue + ", " + greyValue + ", " + greyValue + ")";
// }

// Step 1) Enhanced drawTriangleWithGradient function with unified gradient methods and hillshade controls

let gradientMethod = "radial"; // Step #) Changed to radial for better 2D surface visualization
let lightBearing = 135;
let lightElevation = 15;

// Step #) Add event listener for gradient style dropdown
document.getElementById("gradientStyle").addEventListener("change", function () {
	changeGradientStyle();
});

// Step #) Function to handle gradient style changes
function changeGradientStyle() {
	gradientMethod = document.getElementById("gradientStyle").value;
	if (developerModeEnabled) {
		console.log("Gradient style changed to: " + gradientMethod);
	}
	drawData(allBlastHoles, selectedHole);
}

// Step #) Add event listener for light bearing slider
document.getElementById("lightBearingSlider").addEventListener("input", function () {
	lightBearing = parseInt(document.getElementById("lightBearingSlider").value);
	// change the slider labelto u
	document.getElementById("lightBearingLabel").textContent = "Light Bearing (deg): " + lightBearing + "¬∞";
	if (developerModeEnabled) {
		console.log("Light bearing changed to: " + lightBearing);
	}
	// Invalidate all surface caches (hillshade depends on light direction)
	invalidateSurfaceCache(null);
	drawData(allBlastHoles, selectedHole);
});

// Step #) Add event listener for light elevation slider
document.getElementById("lightElevationSlider").addEventListener("input", function () {
	lightElevation = parseInt(document.getElementById("lightElevationSlider").value);
	// change the slider labelto use the new value
	document.getElementById("lightElevationLabel").textContent = "Light Elevation (deg): " + lightElevation + "¬∞";
	if (developerModeEnabled) {
		console.log("Light elevation changed to: " + lightElevation);
	}
	// Invalidate all surface caches (hillshade depends on light direction)
	invalidateSurfaceCache(null);
	drawData(allBlastHoles, selectedHole);
});

function drawTriangleWithGradient(triangle, surfaceMinZ, surfaceMaxZ, targetCtx = ctx, alpha = 1.0, gradient = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45, hillshadeColor = null, minLimit = null, maxLimit = null) {
	const showWireFrame = false;
	const [p1, p2, p3] = triangle.vertices;

	// Step 2) Convert to canvas coordinates - handle both object and array formats
	const [x1, y1] = worldToCanvas(p1.x !== undefined ? p1.x : p1[0], p1.y !== undefined ? p1.y : p1[1]);
	const [x2, y2] = worldToCanvas(p2.x !== undefined ? p2.x : p2[0], p2.y !== undefined ? p2.y : p2[1]);
	const [x3, y3] = worldToCanvas(p3.x !== undefined ? p3.x : p3[0], p3.y !== undefined ? p3.y : p3[1]);

	// Step 3) Get Z values for elevation calculations
	const z1 = p1.z !== undefined ? p1.z : p1[2];
	const z2 = p2.z !== undefined ? p2.z : p2[2];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 4) Save context state
	targetCtx.save();

	// Step 5) Set transparency for THIS surface only
	targetCtx.globalAlpha = alpha;

	// Step 6) Check if we have texture data (future enhancement)
	if (surfaceTextureData && surfaceTextureData.hasTextures) {
		// For now, use a different color scheme for textured surfaces
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();

		// Use elevation coloring but with different palette for textured surfaces
		const avgZ = (z1 + z2 + z3) / 3;
		targetCtx.fillStyle = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.051;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 7) Handle hillshade gradient specially with configurable lighting
	if (gradient === "hillshade") {
		const { aspect, slope, isFlat } = getTriangleAspect(triangle);
		const computedHillshadeColor = getHillshadeColor(aspect, slope, isFlat, lightBearing, lightElevation, hillshadeColor);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = computedHillshadeColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.16)";
			targetCtx.lineWidth = 0.05;
			targetCtx.stroke();
		}

		targetCtx.restore();
		return;
	}

	// Step 8) Check if THIS surface is flat (using surface-specific min/max)
	if (surfaceMaxZ - surfaceMinZ < 0.001) {
		// Flat surface - use solid orange color
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = "rgba(255, 165, 0, 0.7)"; // Semi-transparent orange
		targetCtx.fill();

		// Add wireframe edges
		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		targetCtx.restore();
		return;
	}

	// Step 9) Apply gradient method based on gradientMethod parameter
	switch (gradientMethod) {
		case "radial":
			drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
		case "barycentric":
			drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
		case "default":
		default:
			drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit, maxLimit);
			break;
	}

	// Step 10) Restore context state
	targetCtx.restore();
}

// Step 11) Linear gradient method (improved default)
function drawLinearGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 12) Find vertices with min and max Z values for better gradient orientation
	const vertices = [
		{ x: x1, y: y1, z: z1, index: 0 },
		{ x: x2, y: y2, z: z2, index: 1 },
		{ x: x3, y: y3, z: z3, index: 2 },
	];

	// Step 13) Sort vertices by elevation to find min and max Z points
	vertices.sort((a, b) => a.z - b.z);
	const minZVertex = vertices[0]; // Lowest elevation
	const maxZVertex = vertices[2]; // Highest elevation
	const midZVertex = vertices[1]; // Middle elevation

	// Step 14) Check if there's significant elevation difference
	const elevationDiff = maxZVertex.z - minZVertex.z;
	if (elevationDiff < 0.001) {
		// Essentially flat triangle - use average color
		const avgZ = (z1 + z2 + z3) / 3;
		const flatColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = flatColor;
		targetCtx.fill();
	} else {
		// Step 15) Create gradient from min elevation point to max elevation point
		const canvasGradient = targetCtx.createLinearGradient(minZVertex.x, minZVertex.y, maxZVertex.x, maxZVertex.y);

		// Step 16) Map Z values to colors using THIS surface's elevation range AND gradient
		const minColor = elevationToColor(minZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		const maxColor = elevationToColor(maxZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		// Step 17) Add color stops - more natural gradient flow
		canvasGradient.addColorStop(0, minColor);
		canvasGradient.addColorStop(1, maxColor);

		// Step 18) If middle vertex has significantly different elevation, add it as intermediate stop
		const midElevationRatio = (midZVertex.z - minZVertex.z) / elevationDiff;
		if (midElevationRatio > 0.1 && midElevationRatio < 0.9) {
			// Step 19) Calculate position of middle vertex along the gradient line
			const gradientLength = Math.sqrt(Math.pow(maxZVertex.x - minZVertex.x, 2) + Math.pow(maxZVertex.y - minZVertex.y, 2));

			if (gradientLength > 0) {
				// Project middle vertex onto gradient line
				const dx = maxZVertex.x - minZVertex.x;
				const dy = maxZVertex.y - minZVertex.y;
				const midDx = midZVertex.x - minZVertex.x;
				const midDy = midZVertex.y - minZVertex.y;

				// Calculate projection ratio
				const projectionRatio = (midDx * dx + midDy * dy) / (dx * dx + dy * dy);
				const clampedRatio = Math.max(0.1, Math.min(0.9, projectionRatio));

				const midColor = elevationToColor(midZVertex.z, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
				canvasGradient.addColorStop(clampedRatio, midColor);
			}
		}

		// Step 20) Draw triangle with improved gradient
		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = canvasGradient;
		targetCtx.fill();
	}

	// Step 21) Add wireframe edges if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 22) Radial gradient method for natural elevation flow
function drawRadialGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 23) Calculate triangle centroid
	const centerX = (x1 + x2 + x3) / 3;
	const centerY = (y1 + y2 + y3) / 3;
	const centerZ = (z1 + z2 + z3) / 3;

	// Step 24) Calculate triangle radius (distance to farthest vertex)
	const radius = Math.max(Math.sqrt(Math.pow(x1 - centerX, 2) + Math.pow(y1 - centerY, 2)), Math.sqrt(Math.pow(x2 - centerX, 2) + Math.pow(y2 - centerY, 2)), Math.sqrt(Math.pow(x3 - centerX, 2) + Math.pow(y3 - centerY, 2)));

	// Step 25) Create radial gradient from center
	const radialGradient = targetCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

	// Step 26) Determine inner and outer colors based on elevation variation
	const minZ = Math.min(z1, z2, z3);
	const maxZ = Math.max(z1, z2, z3);
	const elevationRange = maxZ - minZ;

	let innerColor, outerColor;

	if (elevationRange < 0.001) {
		// Flat triangle - use single color
		const flatColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		innerColor = flatColor;
		outerColor = flatColor;
	} else {
		// Step 27) Use center elevation for inner, highest elevation for outer (creates peak effect)
		const highestZ = Math.max(z1, z2, z3);
		innerColor = elevationToColor(centerZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
		outerColor = elevationToColor(highestZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	}

	radialGradient.addColorStop(0, innerColor);
	radialGradient.addColorStop(1, outerColor);

	// Step 28) Draw triangle with radial gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = radialGradient;
	targetCtx.fill();

	// Step 29) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 30) Barycentric gradient method for smooth color interpolation
function drawBarycentricGradientTriangle(targetCtx, x1, y1, z1, x2, y2, z2, x3, y3, z3, surfaceMinZ, surfaceMaxZ, gradient, showWireFrame, minLimit = null, maxLimit = null) {
	// Step 31) For small triangles or minimal elevation difference, use single color
	const elevationRange = Math.max(z1, z2, z3) - Math.min(z1, z2, z3);
	if (elevationRange < 0.001) {
		const avgZ = (z1 + z2 + z3) / 3;
		const solidColor = elevationToColor(avgZ, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

		targetCtx.beginPath();
		targetCtx.moveTo(x1, y1);
		targetCtx.lineTo(x2, y2);
		targetCtx.lineTo(x3, y3);
		targetCtx.closePath();
		targetCtx.fillStyle = solidColor;
		targetCtx.fill();

		if (showWireFrame) {
			targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
			targetCtx.lineWidth = 0.1;
			targetCtx.stroke();
		}
		return;
	}

	// Step 32) Create multiple gradient segments for smoother appearance
	// This approach creates overlapping gradients to simulate barycentric interpolation

	// Step 33) Calculate triangle bounds
	const minX = Math.min(x1, x2, x3);
	const maxX = Math.max(x1, x2, x3);
	const minY = Math.min(y1, y2, y3);
	const maxY = Math.max(y1, y2, y3);

	// Step 34) Create gradient across the triangle's bounding box oriented by elevation
	const vertices = [
		{ x: x1, y: y1, z: z1 },
		{ x: x2, y: y2, z: z2 },
		{ x: x3, y: y3, z: z3 },
	];

	// Step 35) Sort by elevation to determine gradient direction
	vertices.sort((a, b) => a.z - b.z);
	const lowVertex = vertices[0];
	const highVertex = vertices[2];

	const linearGradient = targetCtx.createLinearGradient(lowVertex.x, lowVertex.y, highVertex.x, highVertex.y);

	// Step 36) Sample colors at key points
	const color1 = elevationToColor(z1, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	const color2 = elevationToColor(z2, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);
	const color3 = elevationToColor(z3, surfaceMinZ, surfaceMaxZ, gradient, minLimit, maxLimit);

	// Step 37) Create blended gradient based on vertex positions and elevations
	const sortedByElevation = [
		{ z: z1, color: color1 },
		{ z: z2, color: color2 },
		{ z: z3, color: color3 },
	].sort((a, b) => a.z - b.z);

	linearGradient.addColorStop(0, sortedByElevation[0].color);
	linearGradient.addColorStop(0.5, sortedByElevation[1].color);
	linearGradient.addColorStop(1, sortedByElevation[2].color);

	// Step 38) Draw triangle with enhanced gradient
	targetCtx.beginPath();
	targetCtx.moveTo(x1, y1);
	targetCtx.lineTo(x2, y2);
	targetCtx.lineTo(x3, y3);
	targetCtx.closePath();
	targetCtx.fillStyle = linearGradient;
	targetCtx.fill();

	// Step 39) Add wireframe if enabled
	if (showWireFrame) {
		targetCtx.strokeStyle = "rgba(0, 0, 0, 0.1)";
		targetCtx.lineWidth = 0.1;
		targetCtx.stroke();
	}
}

// Step 40) Enhanced hillshade functions with configurable light source
function calculateHillshade(aspect, slope, lightBearing = 315, lightElevation = 45) {
	// Step 41) Convert to radians
	const aspectRad = (aspect * Math.PI) / 180;
	const slopeRad = (slope * Math.PI) / 180;
	const lightBearingRad = (lightBearing * Math.PI) / 180;
	const lightElevationRad = (lightElevation * Math.PI) / 180;

	// Step 42) Calculate illumination using standard hillshade formula
	const illumination = Math.sin(lightElevationRad) * Math.sin(slopeRad) + Math.cos(lightElevationRad) * Math.cos(slopeRad) * Math.cos(lightBearingRad - aspectRad);

	// Step 43) Normalize to 0-1 range and apply contrast enhancement
	return Math.max(0, Math.min(1, illumination));
}

// Step 44) Enhanced hillshade color function with configurable lighting
function getHillshadeColor(aspect, slope, isFlat = false, lightBearing = 315, lightElevation = 45, baseColor = null) {
	// Step 44a) Parse base color if provided (for tinted hillshade)
	var baseR = 128, baseG = 128, baseB = 128;
	if (baseColor && baseColor.charAt(0) === "#") {
		baseR = parseInt(baseColor.substring(1, 3), 16) || 128;
		baseG = parseInt(baseColor.substring(3, 5), 16) || 128;
		baseB = parseInt(baseColor.substring(5, 7), 16) || 128;
	}

	if (isFlat) {
		// Step 45) Flat triangles = base color at 50% intensity
		if (baseColor) {
			return "rgb(" + baseR + ", " + baseG + ", " + baseB + ")";
		}
		return "rgb(127, 127, 127)";
	}

	// Step 46) Calculate illumination with configurable light source
	var illumination = calculateHillshade(aspect, slope, lightBearing, lightElevation);

	// Step 47) Enhanced color range - from dark shadow to bright highlight
	var minBrightness = 0.2; // 20% brightness for deep shadows
	var maxBrightness = 1.2; // 120% brightness for bright highlights (clamped)

	// Step 48) Apply contrast curve for more dramatic shading
	var contrastIllumination = Math.pow(illumination, 0.8); // Gamma correction for better contrast

	// Step 49) Map illumination to brightness range
	var brightness = minBrightness + (maxBrightness - minBrightness) * contrastIllumination;

	// Step 49a) Apply brightness to base color
	var r = Math.min(255, Math.round(baseR * brightness));
	var g = Math.min(255, Math.round(baseG * brightness));
	var b = Math.min(255, Math.round(baseB * brightness));

	return "rgb(" + r + ", " + g + ", " + b + ")";
}

// Step 50) Enhanced triangle aspect calculation with improved normal computation
function getTriangleAspect(triangle) {
	const [p1, p2, p3] = triangle.vertices;

	// Step 51) Handle both object and array formats
	const x1 = p1.x !== undefined ? p1.x : p1[0];
	const y1 = p1.y !== undefined ? p1.y : p1[1];
	const z1 = p1.z !== undefined ? p1.z : p1[2];

	const x2 = p2.x !== undefined ? p2.x : p2[0];
	const y2 = p2.y !== undefined ? p2.y : p2[1];
	const z2 = p2.z !== undefined ? p2.z : p2[2];

	const x3 = p3.x !== undefined ? p3.x : p3[0];
	const y3 = p3.y !== undefined ? p3.y : p3[1];
	const z3 = p3.z !== undefined ? p3.z : p3[2];

	// Step 52) Calculate two edge vectors
	const v1X = x2 - x1;
	const v1Y = y2 - y1;
	const v1Z = z2 - z1;

	const v2X = x3 - x1;
	const v2Y = y3 - y1;
	const v2Z = z3 - z1;

	// Step 53) Cross product to get surface normal
	const normalX = v1Y * v2Z - v1Z * v2Y;
	const normalY = v1Z * v2X - v1X * v2Z;
	const normalZ = v1X * v2Y - v1Y * v2X;

	// Step 54) Handle flat triangles
	const horizontalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
	if (horizontalMagnitude < 1e-6) {
		return {
			aspect: 0,
			slope: 0,
			isFlat: true,
		};
	}

	// Step 55) Calculate aspect (direction the slope faces)
	// 0? = North, 90? = East, 180? = South, 270? = West
	const aspect = ((Math.atan2(normalX, normalY) * 180) / Math.PI + 360) % 360;

	// Step 56) Calculate slope angle (steepness)
	const totalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);
	const slope = (Math.acos(Math.abs(normalZ) / totalMagnitude) * 180) / Math.PI;

	return {
		aspect,
		slope,
		isFlat: false,
	};
}

// Step 57) Utility function to create surfaces with enhanced gradient options
function createSurfaceWithGradientOptions(surfaceName, gradientType = "hillshade", gradientMethod = "default", lightBearing = 315, lightElevation = 45) {
	// Example of how to create a surface with the new gradient options
	const surface = {
		name: surfaceName,
		gradient: gradientType,
		gradientMethod: gradientMethod,
		lightBearing: lightBearing,
		lightElevation: lightElevation,
		// ... other surface properties
	};

	console.log("Created surface with gradient options:");
	console.log("- Gradient Type: " + gradientType);
	console.log("- Gradient Method: " + gradientMethod);
	console.log("- Light Bearing: " + lightBearing + "¬∞");
	console.log("- Light Elevation: " + lightElevation + "¬∞");

	return surface;
}
// ADD: Global variable for texture data
let surfaceTextureData = null;
// Add this function near other surface-related functions
function getAllVisibleSurfaces() {
	const visibleSurfaces = [];
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				visibleSurfaces.push({
					id: surfaceId,
					name: surface.name || `Surface ${surfaceId}`,
				});
			}
		}
	}
	return visibleSurfaces;
}
// Helper function to assign holes to surface elevation (with proper geometry calculation)
// Step 26) Updated to support 5 modes: collar, grade, toe, grade_keep_toe, toe_keep_grade
function assignHoleToSurfaceElevation(hole, targetElevation, type) {
	if (!hole) return;

	var radAngle = hole.holeAngle * (Math.PI / 180);
	var cosAngle = Math.cos(radAngle);
	var sinAngle = Math.sin(radAngle);
	var radBearing = ((450 - hole.holeBearing) % 360) * (Math.PI / 180);

	if (type === "collar") {
		// Step 27) Keep TOE fixed, keep ANGLE and BEARING fixed
		// Move collar ALONG the existing hole vector to reach target Z elevation
		// This changes collar XYZ for angled holes, but preserves the hole direction

		// Step 27a) Save existing toe position and geometry
		var toeX = hole.endXLocation;
		var toeY = hole.endYLocation;
		var toeZ = hole.endZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 27b) Calculate angle components
		var radAngle = existingAngle * (Math.PI / 180);
		var cosAngle = Math.cos(radAngle);
		var sinAngle = Math.sin(radAngle);
		var radBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 27c) Check if hole is too horizontal (can't reach target Z)
		if (Math.abs(cosAngle) < 0.001) {
			console.warn("Cannot assign collar for near-horizontal hole (angle: " + existingAngle + "¬∞)");
			return;
		}

		// Step 27d) Calculate vertical distance from toe to new collar
		var verticalDistance = targetElevation - toeZ;

		// Step 27e) Calculate new hole length along the vector
		// Length = vertical distance / cos(angle)
		var newLength = verticalDistance / cosAngle;

		// Step 27f) Calculate horizontal distance along the vector
		var horizontalDistance = newLength * sinAngle;

		// Step 27g) Calculate new collar position (moving FROM toe TOWARD collar along vector)
		// The hole vector points from collar to toe, so we go opposite direction
		hole.startXLocation = toeX - horizontalDistance * Math.cos(radBearing);
		hole.startYLocation = toeY - horizontalDistance * Math.sin(radBearing);
		hole.startZLocation = targetElevation;

		// Step 27h) Update hole length (angle and bearing stay the same)
		hole.holeLengthCalculated = newLength;
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;

		// Step 27i) Toe stays fixed
		hole.endXLocation = toeX;
		hole.endYLocation = toeY;
		hole.endZLocation = toeZ;
		hole.subdrillAmount = existingSubdrill;

		// Step 27j) Recalculate grade position (subdrill distance from toe toward collar)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(angleRad);

		hole.gradeZLocation = toeZ + subdrillVertical;
		hole.gradeXLocation = toeX - subdrillHorizontal * Math.cos(radBearing);
		hole.gradeYLocation = toeY - subdrillHorizontal * Math.sin(radBearing);

		// Step 27k) Update bench height
		hole.benchHeight = hole.startZLocation - hole.gradeZLocation;

		console.log("Collar moved along vector to: (" + hole.startXLocation.toFixed(2) + ", " + hole.startYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Length: " + newLength.toFixed(2) + "m, Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles(); // Save changes to IndexedDB
	} else if (type === "grade") {
		// Step 28) Keep COLLAR fixed, keep ANGLE and BEARING fixed
		// Move GRADE along the hole vector to reach target Z, then calculate TOE from subdrill

		// Step 28a) Save existing geometry
		var collarX = hole.startXLocation;
		var collarY = hole.startYLocation;
		var collarZ = hole.startZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 28b) Calculate angle components
		var gradeRadAngle = existingAngle * (Math.PI / 180);
		var gradeCosAngle = Math.cos(gradeRadAngle);
		var gradeSinAngle = Math.sin(gradeRadAngle);
		var gradeRadBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 28c) Check if hole is too horizontal
		if (Math.abs(gradeCosAngle) < 0.001) {
			console.warn("Cannot assign grade for near-horizontal hole");
			return;
		}

		// Step 28d) Calculate vertical distance from collar to grade (bench height)
		var newBenchHeight = collarZ - targetElevation;
		hole.benchHeight = newBenchHeight;

		// Step 28e) Calculate distance from collar to grade along the hole vector
		var collarToGradeLength = newBenchHeight / gradeCosAngle;
		var collarToGradeHorizontal = collarToGradeLength * gradeSinAngle;

		// Step 28f) Calculate new grade position (sliding along vector from collar)
		hole.gradeXLocation = collarX + collarToGradeHorizontal * Math.cos(gradeRadBearing);
		hole.gradeYLocation = collarY + collarToGradeHorizontal * Math.sin(gradeRadBearing);
		hole.gradeZLocation = targetElevation;

		// Step 28g) Calculate toe position (subdrill distance beyond grade along vector)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(gradeRadAngle);

		hole.endXLocation = hole.gradeXLocation + subdrillHorizontal * Math.cos(gradeRadBearing);
		hole.endYLocation = hole.gradeYLocation + subdrillHorizontal * Math.sin(gradeRadBearing);
		hole.endZLocation = hole.gradeZLocation - subdrillVertical;

		// Step 28h) Calculate new hole length
		var newLength = collarToGradeLength + existingSubdrill;
		hole.holeLengthCalculated = newLength;

		// Step 28i) Angle and bearing stay the same
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;
		hole.subdrillAmount = existingSubdrill;

		console.log("Grade moved along vector to: (" + hole.gradeXLocation.toFixed(2) + ", " + hole.gradeYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles();

	} else if (type === "toe") {
		// Step 29) Keep COLLAR fixed, keep ANGLE and BEARING fixed
		// Move TOE along the hole vector to reach target Z, then calculate GRADE from subdrill

		// Step 29a) Save existing geometry
		var collarX = hole.startXLocation;
		var collarY = hole.startYLocation;
		var collarZ = hole.startZLocation;
		var existingSubdrill = hole.subdrillAmount;
		var existingAngle = hole.holeAngle;
		var existingBearing = hole.holeBearing;

		// Step 29b) Calculate angle components
		var toeRadAngle = existingAngle * (Math.PI / 180);
		var toeCosAngle = Math.cos(toeRadAngle);
		var toeSinAngle = Math.sin(toeRadAngle);
		var toeRadBearing = ((450 - existingBearing) % 360) * (Math.PI / 180);

		// Step 29c) Check if hole is too horizontal
		if (Math.abs(toeCosAngle) < 0.001) {
			console.warn("Cannot assign toe for near-horizontal hole");
			return;
		}

		// Step 29d) Calculate vertical distance from collar to toe
		var collarToToeVertical = collarZ - targetElevation;

		// Step 29e) Calculate new hole length (from collar to toe along vector)
		var newLength = collarToToeVertical / toeCosAngle;
		var collarToToeHorizontal = newLength * toeSinAngle;

		// Step 29f) Calculate new toe position (sliding along vector from collar)
		hole.endXLocation = collarX + collarToToeHorizontal * Math.cos(toeRadBearing);
		hole.endYLocation = collarY + collarToToeHorizontal * Math.sin(toeRadBearing);
		hole.endZLocation = targetElevation;

		// Step 29g) Calculate grade position (subdrill distance back from toe toward collar)
		// existingSubdrill is the VERTICAL distance (gradeZ - toeZ)
		var subdrillVertical = existingSubdrill;
		var subdrillHorizontal = existingSubdrill * Math.tan(toeRadAngle);

		hole.gradeXLocation = hole.endXLocation - subdrillHorizontal * Math.cos(toeRadBearing);
		hole.gradeYLocation = hole.endYLocation - subdrillHorizontal * Math.sin(toeRadBearing);
		hole.gradeZLocation = hole.endZLocation + subdrillVertical;

		// Step 29h) Update bench height and hole length
		hole.benchHeight = collarZ - hole.gradeZLocation;
		hole.holeLengthCalculated = newLength;

		// Step 29i) Angle and bearing stay the same
		hole.holeAngle = existingAngle;
		hole.holeBearing = existingBearing;
		hole.subdrillAmount = existingSubdrill;

		console.log("Toe moved along vector to: (" + hole.endXLocation.toFixed(2) + ", " + hole.endYLocation.toFixed(2) + ", " + targetElevation.toFixed(2) + "), Angle: " + existingAngle.toFixed(1) + "¬∞ (preserved)");
		debouncedSaveHoles();
	} else if (type === "grade_keep_toe") {
		// Step 30) Assign GRADE elevation - keep Toe fixed, calculate new Subdrill
		hole.gradeZLocation = targetElevation;

		// Calculate new bench height
		var newBenchHeight = hole.startZLocation - targetElevation;
		hole.benchHeight = newBenchHeight;

		// Calculate new subdrill from the vertical distance between grade and toe
		var verticalSubdrill = targetElevation - hole.endZLocation; // Grade is above Toe
		if (Math.abs(cosAngle) > 1e-9) {
			hole.subdrillAmount = Math.abs(verticalSubdrill) / cosAngle;
		} else {
			hole.subdrillAmount = Math.abs(verticalSubdrill);
		}

		// Ensure subdrill is non-negative
		if (hole.subdrillAmount < 0) hole.subdrillAmount = 0;

		// Recalculate GradeXY based on new grade position
		var benchDrillLength = newBenchHeight / (Math.abs(cosAngle) > 1e-9 ? cosAngle : 1);
		var horizontalToGrade = benchDrillLength * sinAngle;
		hole.gradeXLocation = hole.startXLocation + horizontalToGrade * Math.cos(radBearing);
		hole.gradeYLocation = hole.startYLocation + horizontalToGrade * Math.sin(radBearing);

		console.log("Grade assigned: " + targetElevation + "mZ, Toe kept at: " + hole.endZLocation.toFixed(2) + "mZ, New subdrill: " + hole.subdrillAmount.toFixed(2) + "m");
		debouncedSaveHoles();

	} else if (type === "toe_keep_grade") {
		// Step 31) Assign TOE elevation - keep Grade fixed, calculate new Subdrill

		// Calculate new subdrill from the vertical distance between grade and new toe
		var verticalSubdrill = hole.gradeZLocation - targetElevation; // Grade is above Toe
		if (Math.abs(cosAngle) > 1e-9) {
			hole.subdrillAmount = Math.abs(verticalSubdrill) / cosAngle;
		} else {
			hole.subdrillAmount = Math.abs(verticalSubdrill);
		}

		// Ensure subdrill is non-negative
		if (hole.subdrillAmount < 0) hole.subdrillAmount = 0;

		// Calculate new hole length: (benchHeight + new subdrill) / cos(angle)
		if (Math.abs(cosAngle) > 1e-9) {
			var newLength = (hole.benchHeight + hole.subdrillAmount) / cosAngle;
			hole.holeLengthCalculated = newLength;

			// Recalculate ToeXYZ
			var horizontalDist = newLength * sinAngle;
			hole.endXLocation = hole.startXLocation + horizontalDist * Math.cos(radBearing);
			hole.endYLocation = hole.startYLocation + horizontalDist * Math.sin(radBearing);
			hole.endZLocation = targetElevation;
		}

		console.log("Toe assigned: " + targetElevation + "mZ, Grade kept at: " + hole.gradeZLocation.toFixed(2) + "mZ, New subdrill: " + hole.subdrillAmount.toFixed(2) + "m");
		debouncedSaveHoles();
	}
}

// Updated surface assignment functions - CONVERTED TO FloatingDialog
// Step 1) Assign Surface Tool - Uses FloatingDialog instead of Swal2
assignSurfaceTool.addEventListener("change", function () {
	var toolCheckbox = this;

	// Step 1) Cancel handler to reset toolbar
	var cancelHandler = function () {
		toolCheckbox.checked = false;
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
	};

	if (this.checked) {
		resetFloatingToolbarButtons("assignSurfaceTool");

		// Step 2) Check if surface is available
		var visibleSurfaces = getAllVisibleSurfaces();
		if (visibleSurfaces.length === 0) {
			// Step 3) No surface available - show FloatingDialog for manual entry
			window.showAssignCollarDialog(
				function (elevation) {
					// Step 4) Apply elevation to selected holes
					window.assignHolesToFixedElevation(elevation, "collar");
					// Step 5) Deselect tool
					toolCheckbox.checked = false;
					resetFloatingToolbarButtons("none");
				},
				cancelHandler // onCancel callback
			);
			return;
		}

		// Step 6) Multiple surfaces available - ask which one to use
		if (visibleSurfaces.length > 1) {
			window.showSurfaceSelectDialog(
				visibleSurfaces,
				"Collar",
				function (selectedSurfaceId) {
					// Step 7) Surface is available - proceed with surface assignment
					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						var assignedCount = 0;
						for (var i = 0; i < selectedMultipleHoles.length; i++) {
							var hole = selectedMultipleHoles[i];
							var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								window.assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
								assignedCount++;
							}
						}

						// Step 8) Show success message
						var surface = loadedSurfaces.get(selectedSurfaceId);
						var surfaceName = surface ? surface.name || ("Surface " + selectedSurfaceId) : "selected surface";
						window.showAssignmentCompleteDialog(assignedCount, surfaceName, "collar");

						updateStatusMessage("Select next tool\n to continue");
					} else {
						updateStatusMessage("Click on holes to assign surface elevation.");
						canvas.addEventListener("click", handleAssignSurfaceClick);
						return; // Don't uncheck the tool yet
					}
					// Step 9) Deselect tool
					toolCheckbox.checked = false;
					resetFloatingToolbarButtons("none");
				},
				cancelHandler // onCancel callback
			);
			return;
		}

		// Step 10) Single surface available - proceed directly with first surface
		var surfaceId = visibleSurfaces[0].id;
		if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
			var assignedCount = 0;
			for (var i = 0; i < selectedMultipleHoles.length; i++) {
				var hole = selectedMultipleHoles[i];
				var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, surfaceId);
				if (surfaceZ !== null) {
					window.assignHoleToSurfaceElevation(hole, surfaceZ, "collar");
					assignedCount++;
				}
			}

			// Step 11) Show success message
			window.showAssignmentCompleteDialog(assignedCount, "surface", "collar");

			// Step 12) Deselect tool
			this.checked = false;
			resetFloatingToolbarButtons("none");
			updateStatusMessage("Select next tool\n to continue");
		} else {
			updateStatusMessage("Click on holes to assign surface elevation.");
			canvas.addEventListener("click", handleAssignSurfaceClick);
		}
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignSurfaceClick);
	}
});

// Step 13) Assign Grade Tool - ALWAYS shows Grade/Toe mode selector dialog
assignGradeTool.addEventListener("change", function () {
	var toolCheckbox = this;

	if (this.checked) {
		resetFloatingToolbarButtons("assignGradeTool");

		// Step 14) Get visible surfaces BEFORE showing dialog
		var visibleSurfaces = getAllVisibleSurfaces();
		console.log("Grade/Toe assignment - visibleSurfaces:", visibleSurfaces.length, visibleSurfaces);

		// Step 15) Show enhanced FloatingDialog with Grade/Toe mode selector and surface dropdown
		window.showAssignGradeDialog(
			visibleSurfaces,
			// onConfirm callback: (elevation, mode, selectedSurfaceId)
			function (elevation, mode, selectedSurfaceId) {
				// Step 16) If we have a surface selected, use surface elevation
				if (selectedSurfaceId) {
					var surface = loadedSurfaces.get(selectedSurfaceId);
					var surfaceName = surface ? (surface.name || ("Surface " + selectedSurfaceId)) : "surface";

					if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
						var assignedCount = 0;
						for (var i = 0; i < selectedMultipleHoles.length; i++) {
							var hole = selectedMultipleHoles[i];
							var surfaceZ = interpolateZFromSurface(hole.startXLocation, hole.startYLocation, selectedSurfaceId);
							if (surfaceZ !== null) {
								window.assignHoleToSurfaceElevation(hole, surfaceZ, mode);
								assignedCount++;
							}
						}
						// Step 17) Show success message
						window.showAssignmentCompleteDialog(assignedCount, surfaceName, mode);
						updateStatusMessage("Select next tool\n to continue");
					} else {
						// Step 18) No holes selected - enable click-to-assign mode
						updateStatusMessage("Click on holes to assign " + mode + " elevation to surface.");
						window._gradeAssignMode = mode;
						window._gradeAssignSurfaceId = selectedSurfaceId;
						canvas.addEventListener("click", handleAssignGradeClick);
						return; // Don't uncheck the tool yet
					}
				} else {
					// Step 19) No surface - use manual elevation
					console.log("No surface - using manual elevation:", elevation, "mode:", mode);
					window.assignHolesToFixedElevation(elevation, mode);
				}

				// Step 20) Deselect tool
				toolCheckbox.checked = false;
				resetFloatingToolbarButtons("none");
			},
			// onCancel callback
			function () {
				// Step 21) Cancel - reset toolbar and uncheck button
				toolCheckbox.checked = false;
				resetFloatingToolbarButtons("none");
				updateStatusMessage("Select next tool\n to continue");
			}
		);
	} else {
		resetFloatingToolbarButtons("none");
		updateStatusMessage("Select next tool\n to continue");
		canvas.removeEventListener("click", handleAssignGradeClick);
	}
});
// Step 22) Helper function to assign holes to a fixed elevation - CONVERTED TO FloatingDialog
// Note: This function now delegates to window.assignHolesToFixedElevation from SurfaceAssignmentDialogs.js
// Keeping local wrapper for backward compatibility with existing code
function assignHolesToFixedElevation(elevation, type) {
	// Step 23) Delegate to the new FloatingDialog-based function
	if (window.assignHolesToFixedElevation && window.assignHolesToFixedElevation !== assignHolesToFixedElevation) {
		return window.assignHolesToFixedElevation(elevation, type);
	}

	// Step 24) Fallback implementation if SurfaceAssignmentDialogs.js not loaded
	var assignedCount = 0;

	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		for (var i = 0; i < selectedMultipleHoles.length; i++) {
			assignHoleToSurfaceElevation(selectedMultipleHoles[i], elevation, type);
			assignedCount++;
		}

		debouncedSaveHoles(); // Save all changes to IndexedDB

		// Step 25) Show success message using FloatingDialog
		if (window.showAssignmentCompleteDialog) {
			window.showAssignmentCompleteDialog(assignedCount, elevation.toFixed(2) + "mZ", type);
		} else if (window.showModalMessage) {
			window.showModalMessage("Elevation Assignment Complete",
				"Successfully adjusted " + assignedCount + " holes to " + elevation.toFixed(2) + "mZ " + type + " elevation.",
				"success");
		}
	} else {
		updateStatusMessage("No holes selected for elevation assignment.");
	}

	drawData(allBlastHoles, selectedHole);
}

// Update click handlers - simplified version
function handleAssignSurfaceClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	const rect = canvas.getBoundingClientRect();
	const clickX = event.clientX - rect.left;
	const clickY = event.clientY - rect.top;

	// Find clicked hole using canvas coordinates
	const clickedHole = getClickedHole(clickX, clickY);
	if (clickedHole) {
		const surfaceZ = interpolateZFromSurface(clickedHole.startXLocation, clickedHole.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHole, surfaceZ, "collar");
			updateStatusMessage("Adjusted hole " + clickedHole.holeID + "\nCollar at " + surfaceZ.toFixed(2) + "m, length now " + clickedHole.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHole.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

function handleAssignGradeClick(event) {
	// Check if we have pre-selected holes (this shouldn't happen since we only add this listener when no holes are selected)
	if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		// This case is already handled in the main event listener
		return;
	}

	var rect = canvas.getBoundingClientRect();
	var clickX = event.clientX - rect.left;
	var clickY = event.clientY - rect.top;

	// Step 21) Get the stored mode (grade or toe) from the dialog selection
	var mode = window._gradeAssignMode || "grade";

	// Find clicked hole using canvas coordinates
	var clickedHoleLocal = getClickedHole(clickX, clickY);
	if (clickedHoleLocal) {
		var surfaceZ = interpolateZFromSurface(clickedHoleLocal.startXLocation, clickedHoleLocal.startYLocation);
		if (surfaceZ !== null) {
			assignHoleToSurfaceElevation(clickedHoleLocal, surfaceZ, mode);
			var typeLabel = mode === "grade" ? "Grade" : "Toe";
			updateStatusMessage("Adjusted hole " + clickedHoleLocal.holeID + "\n" + typeLabel + " at " + surfaceZ.toFixed(2) + "m, length now " + clickedHoleLocal.holeLengthCalculated.toFixed(2) + "m");
			drawData(allBlastHoles, selectedHole);
		} else {
			updateStatusMessage("Hole " + clickedHoleLocal.holeID + " is not on the surface.");
		}
	} else {
		updateStatusMessage("No hole found at click location.");
	}
}

// Fixed save function (around line 18158)
function saveViewControlsSliderValues() {
	// View control sliders
	localStorage.setItem("fontSize", fontSlider.value);
	localStorage.setItem("fontLock", fontLock.checked);
	localStorage.setItem("connSize", connSlider.value);
	localStorage.setItem("toeSize", toeSlider.value);
	localStorage.setItem("holeSize", holeSlider.value);
	localStorage.setItem("intervalSize", intervalSlider.value);
	localStorage.setItem("firstMovementSize", firstMovementSlider.value);

	// Connection controls
	localStorage.setItem("delay", connectorDelay.value);
	localStorage.setItem("connectorColor", connectorColor.jscolor.toHEXString());
	localStorage.setItem("connectSlider", connectSlider.value);
	localStorage.setItem("floatingDelay", floatingDelay.value);
	localStorage.setItem("floatingConnectorColor", floatingConnectorColor.jscolor.toHEXString());

	// Drawing controls
	localStorage.setItem("drawingColor", drawingColor.jscolor.toHEXString());
	localStorage.setItem("lineThickness", lineThickness.value);
	localStorage.setItem("drawingRadius", circleRadius.value);
	localStorage.setItem("drawingText", drawingText.value);
	localStorage.setItem("drawingPolygonRadius", polygonRadius.value);
	localStorage.setItem("radiiSteps", radiiSteps.value);
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);

	// Lightning and Gradient Controls
	localStorage.setItem("lightBearing", lightBearingSlider.value);
	localStorage.setItem("lightElevation", lightElevationSlider.value);
	localStorage.setItem("gradientStyle", gradientStyle.value);

	console.log("View controls saved to localStorage");
}

// Fixed load function with null checks
function loadViewControlsSliderValues() {
	// View control sliders with defaults
	if (localStorage.getItem("fontSize")) fontSlider.value = localStorage.getItem("fontSize");
	if (localStorage.getItem("fontLock")) fontLock.checked = localStorage.getItem("fontLock");
	if (localStorage.getItem("connSize")) connSlider.value = localStorage.getItem("connSize");
	if (localStorage.getItem("toeSize")) toeSlider.value = localStorage.getItem("toeSize");
	if (localStorage.getItem("holeSize")) holeSlider.value = localStorage.getItem("holeSize");
	if (localStorage.getItem("intervalSize")) intervalSlider.value = localStorage.getItem("intervalSize");
	if (localStorage.getItem("firstMovementSize")) firstMovementSlider.value = localStorage.getItem("firstMovementSize");
	if (localStorage.getItem("snapRadiusPixels")) snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
	// Connection controls
	if (localStorage.getItem("delay")) connectorDelay.value = localStorage.getItem("delay");
	if (localStorage.getItem("connectorColor")) connectorColor.jscolor.fromString(localStorage.getItem("connectorColor"));
	if (localStorage.getItem("connectSlider")) connectSlider.value = localStorage.getItem("connectSlider");
	if (localStorage.getItem("floatingDelay")) floatingDelay.value = localStorage.getItem("floatingDelay");
	if (localStorage.getItem("floatingConnectorColor")) floatingConnectorColor.jscolor.fromString(localStorage.getItem("floatingConnectorColor"));
	// Drawing controls
	if (localStorage.getItem("drawingColor")) {
		drawingColor.jscolor.fromString(localStorage.getItem("drawingColor"));
		// Step #) Also sync floatingKADColor to the saved drawingColor
		var floatingKADColorEl = document.getElementById("floatingKADColor");
		if (floatingKADColorEl && floatingKADColorEl.jscolor) {
			floatingKADColorEl.jscolor.fromString(localStorage.getItem("drawingColor"));
		}
	}
	if (localStorage.getItem("drawingRadius")) circleRadius.value = localStorage.getItem("drawingRadius");
	if (localStorage.getItem("drawingText")) drawingText.value = localStorage.getItem("drawingText");
	if (localStorage.getItem("drawingPolygonRadius")) polygonRadius.value = localStorage.getItem("drawingPolygonRadius");
	if (localStorage.getItem("radiiSteps")) radiiSteps.value = localStorage.getItem("radiiSteps");
	if (localStorage.getItem("lineThickness")) lineThickness.value = localStorage.getItem("lineThickness");
	// Lightning and Gradient Controls
	if (localStorage.getItem("lightBearing")) lightBearingSlider.value = localStorage.getItem("lightBearing");
	if (localStorage.getItem("lightElevation")) lightElevationSlider.value = localStorage.getItem("lightElevation");
	if (localStorage.getItem("gradientStyle")) gradientStyle.value = localStorage.getItem("gradientStyle");

	console.log("View controls loaded from localStorage");
}
// Auto-save when any control changes (add after the load function)
function setupAutoSavePreferences() {
	// View control sliders
	fontSlider.addEventListener("input", saveViewControlsSliderValues);
	connSlider.addEventListener("input", saveViewControlsSliderValues);
	toeSlider.addEventListener("input", saveViewControlsSliderValues);
	holeSlider.addEventListener("input", saveViewControlsSliderValues);
	intervalSlider.addEventListener("input", saveViewControlsSliderValues);
	firstMovementSlider.addEventListener("input", saveViewControlsSliderValues);
	snapToleranceSlider.addEventListener("input", saveViewControlsSliderValues);
	// Connection controls
	connectorDelay.addEventListener("input", saveViewControlsSliderValues);
	connectSlider.addEventListener("input", saveViewControlsSliderValues);
	floatingConnectorColor.addEventListener("input", saveViewControlsSliderValues);
	floatingDelay.addEventListener("input", saveViewControlsSliderValues);

	// Drawing controls
	circleRadius.addEventListener("input", saveViewControlsSliderValues);
	drawingText.addEventListener("input", saveViewControlsSliderValues);
	polygonRadius.addEventListener("input", saveViewControlsSliderValues);
	radiiSteps.addEventListener("input", saveViewControlsSliderValues);

	// Color pickers (these need special handling)
	connectorColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	drawingColor.addEventListener("input", function () {
		setTimeout(saveViewControlsSliderValues, 100); // Small delay for jscolor
	});
	// Step #) Also save when floatingKADColor changes
	var floatingKADColorEl = document.getElementById("floatingKADColor");
	if (floatingKADColorEl) {
		floatingKADColorEl.addEventListener("input", function () {
			setTimeout(saveViewControlsSliderValues, 100);
		});
	}
	lineThickness.addEventListener("input", saveViewControlsSliderValues);
}

//--------------------GLOBAL SNAPPING SNAP SELECT ------------------------//
// Global snapping configuration
let snapRadiusPixels = 10; // Default value in pixels
let snapEnabled = true; // Global snap toggle
let snapHighlight = null; // Store the current snap target for visual feedback

// Initialize snap radius from localStorage
if (localStorage.getItem("snapRadiusPixels")) {
	snapRadiusPixels = parseFloat(localStorage.getItem("snapRadiusPixels"));
} else if (localStorage.getItem("snapRadius") || localStorage.getItem("snapTolerance")) {
	// Migrate old meter-based snap to pixel-based (convert 1m to ~10 pixels as default)
	snapRadiusPixels = 10;
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
}

// Update slider to match loaded value
if (document.getElementById("snapToleranceSlider")) {
	document.getElementById("snapToleranceSlider").min = 2; // Minimum 2 pixels
	document.getElementById("snapToleranceSlider").max = 50; // Maximum 50 pixels
	document.getElementById("snapToleranceSlider").step = 1; // 1 pixel increments
	document.getElementById("snapToleranceSlider").value = snapRadiusPixels;
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";
}

// Single event listener for snap tolerance
document.getElementById("snapToleranceSlider")?.addEventListener("input", function () {
	snapRadiusPixels = parseFloat(this.value);
	// console.log("Snap Tolerance updated: " + snapRadiusPixels + "px");
	updateStatusMessage("Snap Tolerance: " + snapRadiusPixels + "px");
	setTimeout(() => updateStatusMessage(""), 1500);

	// Update all labels consistently
	document.getElementById("snapToleranceLabel").textContent = "Snap Tolerance: " + snapRadiusPixels + "px";

	// Save to localStorage
	localStorage.setItem("snapRadiusPixels", snapRadiusPixels);
});

// Helper function to convert pixel tolerance to world coordinates for current zoom
function getSnapToleranceInWorldUnits() {
	return snapRadiusPixels / currentScale;
}

// All possible snap targets and their priorities
const SNAP_PRIORITIES = {
	HOLE_COLLAR: 1, // Highest priority
	HOLE_GRADE: 2,
	HOLE_TOE: 3,
	KAD_POINT: 4,
	KAD_LINE_VERTEX: 5,
	KAD_POLYGON_VERTEX: 6,
	KAD_SEGMENT_INTERSECT_XY: 7, // XY intersection of segments (ignoring Z)
	KAD_CIRCLE_CENTER: 8,
	KAD_TEXT_POSITION: 9,
	KAD_LINE_SEGMENT: 10, // Segments get lower priority
	KAD_POLYGON_SEGMENT: 11, // Segments get lower priority
	SURFACE_POINT: 12,
	SURFACE_FACE: 13, // Lowest priority
};

// Step 1) Snap priorities for Move Tool (holes moving - excludes hole snap targets)
const MOVE_SNAP_PRIORITIES = {
	KAD_POINT: 1, // Highest priority
	KAD_LINE_VERTEX: 2,
	KAD_POLYGON_VERTEX: 3,
	KAD_SEGMENT_INTERSECT_XY: 4, // XY intersection of segments (ignoring Z)
	KAD_CIRCLE_CENTER: 5,
	KAD_TEXT_POSITION: 6,
	KAD_LINE_SEGMENT: 7, // Segments lower priority
	KAD_POLYGON_SEGMENT: 8,
	SURFACE_POINT: 9,
	SURFACE_FACE: 10, // Lowest priority (with interpolation)
};

// Step 2) Snap function for Move Tool - excludes holes (holes cannot snap to other holes)
function snapToNearestPointExcludingHoles(rawWorldX, rawWorldY, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || (document.getElementById("drawingElevation") ? document.getElementById("drawingElevation").value : 0),
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets (excluding holes)
	const snapCandidates = [];

	// 1) Search KAD Objects (all vertices and segments)
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach(function (entity, entityName) {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// Check vertices
			entity.data.forEach(function (dataPoint) {
				// Step 1a) Skip hidden elements - hidden items not snappable from canvas
				if (dataPoint.visible === false) return;
				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = MOVE_SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = MOVE_SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = MOVE_SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = MOVE_SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			});

			// Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Step 1b) Skip segments where either endpoint is hidden
						if (p1.visible === false || p2.visible === false) continue;

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = MOVE_SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: entity.entityType + " segment " + (i + 1),
							});
						}
					}
				}
			}
		});
	}

	// 2) Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach(function (surfacePoint, index) {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}

			// 3) Search Surface Faces (triangulated mesh) with Z interpolation
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				surface.triangles.forEach(function (triangle, triIndex) {
					if (!triangle.vertices || triangle.vertices.length !== 3) return;

					const v1 = triangle.vertices[0];
					const v2 = triangle.vertices[1];
					const v3 = triangle.vertices[2];

					// Project point onto triangle plane
					const projected = projectPointOntoTriangle(rawWorldX, rawWorldY, v1, v2, v3);

					if (projected && projected.isInside && projected.distance <= searchRadius) {
						snapCandidates.push({
							distance: projected.distance,
							point: {
								x: projected.x,
								y: projected.y,
								z: projected.z,
							},
							type: "SURFACE_FACE",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_FACE,
							description: surface.name + " face " + triIndex,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort(function (a, b) {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingZValue || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || (document.getElementById("drawingElevation") ? document.getElementById("drawingElevation").value : 0),
		snapped: false,
		snapTarget: null,
	};
}

// Helper function: Project point onto triangle and check if inside
function projectPointOntoTriangle(px, py, v1, v2, v3) {
	// Calculate barycentric coordinates
	const v0x = v3.x - v1.x;
	const v0y = v3.y - v1.y;
	const v1x = v2.x - v1.x;
	const v1y = v2.y - v1.y;
	const v2x = px - v1.x;
	const v2y = py - v1.y;

	const dot00 = v0x * v0x + v0y * v0y;
	const dot01 = v0x * v1x + v0y * v1y;
	const dot02 = v0x * v2x + v0y * v2y;
	const dot11 = v1x * v1x + v1y * v1y;
	const dot12 = v1x * v2x + v1y * v2y;

	const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
	const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

	// Check if point is inside triangle
	const isInside = u >= 0 && v >= 0 && u + v <= 1;

	if (!isInside) {
		return null;
	}

	// Interpolate Z using barycentric coordinates
	const w = 1 - u - v;
	const z = w * v1.z + u * v3.z + v * v2.z;

	// Calculate distance from original point to projected point (2D distance)
	const distance = Math.sqrt(Math.pow(px - px, 2) + Math.pow(py - py, 2)); // Always 0 since we're on the triangle

	return {
		x: px,
		y: py,
		z: z,
		isInside: true,
		distance: 0, // Point is projected onto triangle, so 2D distance is 0
	};
}

// Step 3) 3D variant: Snap function for Move Tool with ray-based snapping (cylindrical snap)
// Excludes holes - for moving holes in 3D mode
function snapToNearestPointExcludingHolesWithRay(rayOrigin, rayDirection, snapRadiusPixels, mouseScreenX, mouseScreenY) {
	if (!snapEnabled) {
		return {
			snapped: false,
			snapTarget: null,
		};
	}

	// Convert pixel radius to world units for point snapping (ray-based fat ray)
	// Use actual camera scale to convert screen pixels to world units
	const camera = tr ? tr.camera : null;
	const canvas = tr ? tr.getCanvas() : null;
	let snapRadiusWorld = snapRadiusPixels; // Fallback

	if (camera && camera.isOrthographicCamera && canvas) {
		// For orthographic camera: screen pixels to world units conversion
		// Camera frustum width in world units = (right - left) / zoom
		// Screen width in pixels = canvas.width
		// Therefore: 1 pixel = frustumWidth / canvasWidth world units
		const rect = canvas.getBoundingClientRect();
		const frustumWidth = (camera.right - camera.left) / camera.zoom;
		const pixelsToWorld = frustumWidth / rect.width;
		snapRadiusWorld = snapRadiusPixels * pixelsToWorld;
	}

	const snapCandidates = [];

	// Step 3a) Helper functions for coordinate conversion
	const worldToLocal = function (worldX, worldY, worldZ) {
		if (typeof window.worldToThreeLocal === "function") {
			const local = window.worldToThreeLocal(worldX, worldY);
			return { x: local.x, y: local.y, z: worldZ || 0 };
		}
		return { x: worldX, y: worldY, z: worldZ || 0 };
	};

	// Step 3b) Search KAD Objects (vertices and segments) - convert to local coords for ray comparison
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach(function (entity, entityName) {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// Check vertices
			entity.data.forEach(function (dataPoint) {
				// Step 3b.1) Skip hidden elements - hidden items not snappable from canvas
				if (dataPoint.visible === false) return;
				// Convert world coords to local for ray comparison
				const pointLocal = worldToLocal(dataPoint.pointXLocation, dataPoint.pointYLocation, dataPoint.pointZLocation || 0);
				const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

				if (pointResult.distance <= snapRadiusWorld && pointResult.rayT > 0) {
					// Determine type and priority
					let snapType = "KAD_POINT";
					let priority = MOVE_SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = MOVE_SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = MOVE_SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = MOVE_SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = MOVE_SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					// Return actual object world coordinates
					snapCandidates.push({
						distance: pointResult.distance,
						rayT: pointResult.rayT,
						point: { x: dataPoint.pointXLocation, y: dataPoint.pointYLocation, z: dataPoint.pointZLocation || 0 },
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			});

			// Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length];

						// Step 3b.2) Skip segments where either endpoint is hidden
						if (p1.visible === false || p2.visible === false) continue;

						// SCREEN-SPACE SNAP: Project segment to screen and measure pixel distance
						const screen1 = worldToScreen(p1.pointXLocation, p1.pointYLocation, p1.pointZLocation || window.dataCentroidZ || 0);
						const screen2 = worldToScreen(p2.pointXLocation, p2.pointYLocation, p2.pointZLocation || window.dataCentroidZ || 0);

						// Calculate 2D screen distance from mouse to segment (in pixels)
						const A = mouseScreenX - screen1.x;
						const B = mouseScreenY - screen1.y;
						const C = screen2.x - screen1.x;
						const D = screen2.y - screen1.y;
						const dot = A * C + B * D;
						const lenSq = C * C + D * D;
						let screenDist;
						if (lenSq === 0) {
							screenDist = Math.sqrt(A * A + B * B);
						} else {
							let t = dot / lenSq;
							t = Math.max(0, Math.min(1, t));
							const projX = screen1.x + t * C;
							const projY = screen1.y + t * D;
							const dx = mouseScreenX - projX;
							const dy = mouseScreenY - projY;
							screenDist = Math.sqrt(dx * dx + dy * dy);
						}

						if (screenDist <= snapRadiusPixels) {
							// Find the parameter t along the segment in SCREEN space
							const dx = screen2.x - screen1.x;
							const dy = screen2.y - screen1.y;
							const lengthSq = dx * dx + dy * dy;
							let segmentT = 0;
							if (lengthSq > 1e-10) {
								const px = mouseScreenX - screen1.x;
								const py = mouseScreenY - screen1.y;
								const dot = px * dx + py * dy;
								segmentT = Math.max(0, Math.min(1, dot / lengthSq));
							}

							// Calculate the snap point in world coordinates using the segment parameter
							const snapPointWorld = {
								x: p1.pointXLocation + segmentT * (p2.pointXLocation - p1.pointXLocation),
								y: p1.pointYLocation + segmentT * (p2.pointYLocation - p1.pointYLocation),
								z: (p1.pointZLocation || 0) + segmentT * ((p2.pointZLocation || 0) - (p1.pointZLocation || 0)),
							};

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = MOVE_SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: screenDist, // Screen pixel distance for sorting
								rayT: 100, // Arbitrary depth for segments
								point: snapPointWorld,
								type: segmentType,
								priority: priority,
								description: entity.entityType + " segment " + (i + 1),
							});
						}
					}
				}
			}
		});
	}

	// Step 3c) Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach(function (surfacePoint, index) {
					// Convert world coords to local for ray comparison
					const pointLocal = worldToLocal(surfacePoint.x, surfacePoint.y, surfacePoint.z || 0);
					const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

					if (pointResult.distance <= snapRadiusWorld && pointResult.rayT > 0) {
						// Return actual object world coordinates
						snapCandidates.push({
							distance: pointResult.distance,
							rayT: pointResult.rayT,
							point: { x: surfacePoint.x, y: surfacePoint.y, z: surfacePoint.z || 0 },
							type: "SURFACE_POINT",
							priority: MOVE_SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}

			// Step 3d) Search Surface Faces (triangulated mesh) with ray intersection and Z interpolation
			if (surface.visible && surface.triangles && surface.triangles.length > 0) {
				surface.triangles.forEach(function (triangle, triIndex) {
					if (!triangle.vertices || triangle.vertices.length !== 3) return;

					const v1 = triangle.vertices[0];
					const v2 = triangle.vertices[1];
					const v3 = triangle.vertices[2];

					// Convert triangle vertices to local coords for ray comparison
					const v1Local = worldToLocal(v1.x, v1.y, v1.z || 0);
					const v2Local = worldToLocal(v2.x, v2.y, v2.z || 0);
					const v3Local = worldToLocal(v3.x, v3.y, v3.z || 0);

					// Perform ray-triangle intersection
					const intersection = rayTriangleIntersection(rayOrigin, rayDirection, v1Local, v2Local, v3Local);

					if (intersection && intersection.t > 0) {
						// Calculate perpendicular distance from ray to intersection point
						const dist = 0; // Ray intersects triangle, so distance is 0

						if (dist <= snapRadius) {
							// Convert intersection point back to world coordinates
							// Use barycentric coordinates to interpolate world position
							const u = intersection.u;
							const v = intersection.v;
							const w = 1 - u - v;

							const worldX = w * v1.x + u * v2.x + v * v3.x;
							const worldY = w * v1.y + u * v2.y + v * v3.y;
							const worldZ = w * v1.z + u * v2.z + v * v3.z;

							snapCandidates.push({
								distance: dist,
								rayT: intersection.t,
								point: { x: worldX, y: worldY, z: worldZ },
								type: "SURFACE_FACE",
								priority: MOVE_SNAP_PRIORITIES.SURFACE_FACE,
								description: surface.name + " face " + triIndex,
							});
						}
					}
				});
			}
		}
	}

	// Step 3e) Find the best snap candidate
	// Sort by: 1) Priority (lower number = higher priority), 2) Distance along ray (closer to camera)
	if (snapCandidates.length > 0) {
		snapCandidates.sort(function (a, b) {
			if (a.priority !== b.priority) {
				return a.priority - b.priority; // Lower priority number wins
			}
			return a.rayT - b.rayT; // Closer to camera wins
		});

		const bestCandidate = snapCandidates[0];


		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found
	return {
		snapped: false,
		snapTarget: null,
	};
}

// Helper function: Ray-triangle intersection using M?ller-Trumbore algorithm
function rayTriangleIntersection(rayOrigin, rayDir, v0, v1, v2) {
	const EPSILON = 0.0000001;

	// Edge vectors
	const edge1 = {
		x: v1.x - v0.x,
		y: v1.y - v0.y,
		z: v1.z - v0.z,
	};
	const edge2 = {
		x: v2.x - v0.x,
		y: v2.y - v0.y,
		z: v2.z - v0.z,
	};

	// Begin calculating determinant - also used to calculate u parameter
	const h = {
		x: rayDir.y * edge2.z - rayDir.z * edge2.y,
		y: rayDir.z * edge2.x - rayDir.x * edge2.z,
		z: rayDir.x * edge2.y - rayDir.y * edge2.x,
	};

	// If determinant is near zero, ray lies in plane of triangle
	const a = edge1.x * h.x + edge1.y * h.y + edge1.z * h.z;
	if (a > -EPSILON && a < EPSILON) {
		return null; // Ray is parallel to triangle
	}

	const f = 1.0 / a;
	const s = {
		x: rayOrigin.x - v0.x,
		y: rayOrigin.y - v0.y,
		z: rayOrigin.z - v0.z,
	};

	const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);
	if (u < 0.0 || u > 1.0) {
		return null;
	}

	const q = {
		x: s.y * edge1.z - s.z * edge1.y,
		y: s.z * edge1.x - s.x * edge1.z,
		z: s.x * edge1.y - s.y * edge1.x,
	};

	const v = f * (rayDir.x * q.x + rayDir.y * q.y + rayDir.z * q.z);
	if (v < 0.0 || u + v > 1.0) {
		return null;
	}

	// At this stage we can compute t to find out where the intersection point is on the line
	const t = f * (edge2.x * q.x + edge2.y * q.y + edge2.z * q.z);

	if (t > EPSILON) {
		// Ray intersection
		return { t: t, u: u, v: v };
	}

	return null; // Line intersection but not a ray intersection
}
// Add this new function before snapToNearestPoint
// Add this new function before snapToNearestPoint
function snapToNearestPointExcludingKAD(rawWorldX, rawWorldY, excludeEntityName, excludeElementIndex, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation,
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation,
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation,
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// 2. Search KAD Objects but exclude the moving point and its segments
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip if this is the entity being moved
			const isMovingEntity = entityName === excludeEntityName;

			// Check vertices
			entity.data.forEach((dataPoint, index) => {
				// Skip the actual point being moved
				if (isMovingEntity && index === excludeElementIndex) {
					return;
				}

				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`,
					});
				}
			});

			// Check segments but exclude adjacent ones
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						// Skip segments adjacent to the moving point
						if (isMovingEntity) {
							const nextIndex = (i + 1) % points.length;
							if (i === excludeElementIndex || nextIndex === excludeElementIndex) {
								continue; // Skip this segment
							}
						}

						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t,
								},
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null,
	};
}

// Convert pixel radius to world radius for 3D snapping
// This ensures snap radius is always N pixels on screen regardless of zoom
function getSnapRadiusInWorldUnits3D(pixelRadius) {
	if (!threeRenderer || !threeRenderer.camera || !threeRenderer.renderer) {
		// Fallback to 2D calculation
		return pixelRadius / (currentScale || 1.0);
	}

	const camera = threeRenderer.camera;
	const canvas = threeRenderer.renderer.domElement;

	if (camera.isOrthographicCamera) {
		// Orthographic: World units per pixel is constant across the view
		// CRITICAL: With camera.zoom, effective frustum = base frustum / zoom
		// frustumWidth / screenWidth / zoom = world units per pixel
		const frustumWidth = camera.right - camera.left;
		const frustumHeight = camera.top - camera.bottom;

		// CRITICAL: canvas.width/height include devicePixelRatio, but we need CSS pixels
		// Use clientWidth/clientHeight for actual screen pixels
		const canvasWidth = canvas.clientWidth || canvas.width;
		const canvasHeight = canvas.clientHeight || canvas.height;
		const zoom = camera.zoom || 1.0;

		// Use the smaller dimension to ensure radius works in both X and Y
		const worldUnitsPerPixelX = frustumWidth / canvasWidth / zoom;
		const worldUnitsPerPixelY = frustumHeight / canvasHeight / zoom;
		const worldUnitsPerPixel = Math.min(worldUnitsPerPixelX, worldUnitsPerPixelY);

		return pixelRadius * worldUnitsPerPixel;
	} else if (camera.isPerspectiveCamera) {
		// Perspective: World units per pixel depends on distance from camera
		// This is more complex - for now, fall back to a reasonable estimate
		// based on the camera distance to the orbit center
		const distance = camera.position.length() || 1000;
		const fov = (camera.fov * Math.PI) / 180; // Convert to radians
		const canvasHeight = canvas.height;

		// At the focal distance, world size = 2 * distance * tan(fov/2)
		const worldHeight = 2 * distance * Math.tan(fov / 2);
		const worldUnitsPerPixel = worldHeight / canvasHeight;

		return pixelRadius * worldUnitsPerPixel;
	} else {
		// Unknown camera type, fallback
		return pixelRadius / (currentScale || 1.0);
	}
}

// Expose for canvas3DDrawing.js module
window.getSnapRadiusInWorldUnits3D = getSnapRadiusInWorldUnits3D;

// Helper function: Calculate perpendicular distance from a point to a ray (infinite line)
function distanceFromPointToRay(point, rayOrigin, rayDirection) {
	// Vector from ray origin to point
	const v = {
		x: point.x - rayOrigin.x,
		y: point.y - rayOrigin.y,
		z: point.z - rayOrigin.z,
	};

	// Project v onto ray direction to get distance along ray (t parameter)
	const t = v.x * rayDirection.x + v.y * rayDirection.y + v.z * rayDirection.z;

	// Point on ray closest to target point
	const closestPoint = {
		x: rayOrigin.x + t * rayDirection.x,
		y: rayOrigin.y + t * rayDirection.y,
		z: rayOrigin.z + t * rayDirection.z,
	};

	// Perpendicular distance from point to ray
	const distance = Math.sqrt(Math.pow(point.x - closestPoint.x, 2) + Math.pow(point.y - closestPoint.y, 2) + Math.pow(point.z - closestPoint.z, 2));

	return {
		distance: distance, // Perpendicular distance to ray (for snap radius check)
		rayT: t, // Distance along ray (for depth sorting)
		closestPoint: closestPoint, // Actual 3D snap point
	};
}

// Helper: Calculate closest distance and point between a ray and a line segment
function distanceFromRayToLineSegment(rayOrigin, rayDirection, segmentStart, segmentEnd) {
	// Line segment direction
	const segDir = {
		x: segmentEnd.x - segmentStart.x,
		y: segmentEnd.y - segmentStart.y,
		z: segmentEnd.z - segmentStart.z
	};

	// Vector from segment start to ray origin
	const w0 = {
		x: rayOrigin.x - segmentStart.x,
		y: rayOrigin.y - segmentStart.y,
		z: rayOrigin.z - segmentStart.z
	};

	const a = segDir.x * segDir.x + segDir.y * segDir.y + segDir.z * segDir.z; // |segDir|^2
	const b = segDir.x * rayDirection.x + segDir.y * rayDirection.y + segDir.z * rayDirection.z;
	const c = rayDirection.x * rayDirection.x + rayDirection.y * rayDirection.y + rayDirection.z * rayDirection.z; // Should be 1 if normalized
	const d = segDir.x * w0.x + segDir.y * w0.y + segDir.z * w0.z;
	const e = rayDirection.x * w0.x + rayDirection.y * w0.y + rayDirection.z * w0.z;

	const denom = a * c - b * b;

	let sc, tc; // Parameters along segment and ray

	if (Math.abs(denom) < 1e-10) {
		// Lines are parallel
		sc = 0.0;
		tc = (b > c ? d / b : e / c);
	} else {
		sc = (b * e - c * d) / denom;
		tc = (a * e - b * d) / denom;
	}

	// Clamp sc to [0, 1] to stay on segment
	sc = Math.max(0, Math.min(1, sc));

	// Recalculate tc after clamping sc to find the closest point on the ray to the clamped segment point
	const closestOnSegment = {
		x: segmentStart.x + sc * segDir.x,
		y: segmentStart.y + sc * segDir.y,
		z: segmentStart.z + sc * segDir.z
	};

	// Vector from ray origin to closest point on segment
	const wc = {
		x: closestOnSegment.x - rayOrigin.x,
		y: closestOnSegment.y - rayOrigin.y,
		z: closestOnSegment.z - rayOrigin.z
	};

	// Project this vector onto the ray direction to find tc
	tc = rayDirection.x * wc.x + rayDirection.y * wc.y + rayDirection.z * wc.z;

	const closestOnRay = {
		x: rayOrigin.x + tc * rayDirection.x,
		y: rayOrigin.y + tc * rayDirection.y,
		z: rayOrigin.z + tc * rayDirection.z
	};

	// Distance between closest points
	const dx = closestOnRay.x - closestOnSegment.x;
	const dy = closestOnRay.y - closestOnSegment.y;
	const dz = closestOnRay.z - closestOnSegment.z;
	const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

	return {
		distance: distance,
		rayT: tc,
		segmentT: sc,
		closestOnSegment: closestOnSegment,
		closestOnRay: closestOnRay
	};
}

// Helper: Find XY intersections between line/polygon segments (ignoring Z)
function findSegmentIntersectionsXY() {
	const intersections = [];

	if (!allKADDrawingsMap || allKADDrawingsMap.size === 0) return intersections;

	// Collect all segments from all KAD entities
	const allSegments = [];

	allKADDrawingsMap.forEach((entity, entityName) => {
		if (!isEntityVisible(entityName)) return;

		if (entity.entityType === "line" || entity.entityType === "poly" || entity.entityType === "polygon") {
			const points = entity.data;
			if (points.length >= 2) {
				const numSegments = (entity.entityType === "poly" || entity.entityType === "polygon") ? points.length : points.length - 1;

				for (let i = 0; i < numSegments; i++) {
					const p1 = points[i];
					const p2 = points[(i + 1) % points.length];

					allSegments.push({
						entityName: entityName,
						entityType: entity.entityType,
						segmentIndex: i,
						p1: p1,
						p2: p2
					});
				}
			}
		}
	});

	// Find intersections between all pairs of segments (XY only)
	for (let i = 0; i < allSegments.length; i++) {
		for (let j = i + 1; j < allSegments.length; j++) {
			const seg1 = allSegments[i];
			const seg2 = allSegments[j];

			// Skip if same entity
			if (seg1.entityName === seg2.entityName) continue;

			// Calculate 2D intersection in XY plane
			const intersection = findLineIntersection(
				seg1.p1.pointXLocation, seg1.p1.pointYLocation,
				seg1.p2.pointXLocation, seg1.p2.pointYLocation,
				seg2.p1.pointXLocation, seg2.p1.pointYLocation,
				seg2.p2.pointXLocation, seg2.p2.pointYLocation
			);

			if (intersection) {
				// Interpolate Z value from both segments and average them
				const t1 = calculateTValue(seg1.p1, seg1.p2, intersection);
				const t2 = calculateTValue(seg2.p1, seg2.p2, intersection);

				const z1 = (seg1.p1.pointZLocation || 0) + t1 * ((seg1.p2.pointZLocation || 0) - (seg1.p1.pointZLocation || 0));
				const z2 = (seg2.p1.pointZLocation || 0) + t2 * ((seg2.p2.pointZLocation || 0) - (seg2.p1.pointZLocation || 0));
				const avgZ = (z1 + z2) / 2;

				intersections.push({
					x: intersection.x,
					y: intersection.y,
					z: avgZ,
					segment1: seg1.entityName + " seg " + (seg1.segmentIndex + 1),
					segment2: seg2.entityName + " seg " + (seg2.segmentIndex + 1),
				});
			}
		}
	}

	return intersections;
}

// Helper: Calculate t value (0-1) for point on line segment
function calculateTValue(p1, p2, point) {
	const dx = p2.pointXLocation - p1.pointXLocation;
	const dy = p2.pointYLocation - p1.pointYLocation;
	const length = Math.sqrt(dx * dx + dy * dy);

	if (length < 1e-10) return 0;

	const px = point.x - p1.pointXLocation;
	const py = point.y - p1.pointYLocation;
	const dot = px * dx + py * dy;

	return Math.max(0, Math.min(1, dot / (length * length)));
}

// 3D Cylindrical Snap: Snap to anything in the "shadow" along the view ray
// Uses screen-space distance for segments (pixels), ray distance for points
// CRITICAL: Segments use 2D screen projection, points use 3D ray distance
// PERFORMANCE: Limited to prevent freeze with large DXFs
// worldToScreen() is VERY expensive (creates Vector3 + projects for EACH point)
// With 500 entities √ó 100 points = 50,000 projections PER MOUSE MOVE = FREEZE
var lastSnapTime = 0;
var SNAP_THROTTLE_MS = 50; // 20fps max for snap calculations (was 16ms, too fast)
var MAX_SNAP_ENTITIES = 500; // Max KAD entities checked for snap (raycaster pre-filters to visible only)
var MAX_SNAP_POINTS_PER_ENTITY = 200; // Max points per entity checked (raycaster pre-filters to visible only)
var MAX_SNAP_SEGMENTS_PER_ENTITY = 20; // NEW: Max segments per entity checked

function snapToNearestPointWithRay(rayOrigin, rayDirection, snapRadiusPixels, mouseScreenX, mouseScreenY) {
	if (!snapEnabled) {
		return {
			snapped: false,
			snapTarget: null,
		};
	}

	// Step 0) Throttle snap calculations to prevent freeze on fast mouse moves
	var now = performance.now();
	if (now - lastSnapTime < SNAP_THROTTLE_MS) {
		// Return cached result or empty result
		return window.lastSnapResult || { snapped: false, snapTarget: null };
	}
	lastSnapTime = now;

	const snapCandidates = [];

	// Step 0.5) PERFORMANCE OPTIMIZATION: Use Three.js GPU-accelerated raycaster to get visible objects first
	// This dramatically reduces the number of entities we need to check (same approach as click handler)
	// The raycaster automatically handles frustum culling and only returns visible objects
	var visibleEntityNames = new Set();
	var visibleHoleIDs = new Set();

	// Step 0.5a) Get interactionManager and threeRenderer (try window globals if not in scope)
	var im = interactionManager || window.interactionManager;
	var tr = threeRenderer || window.threeRenderer;

	// Convert pixel radius to world units for point snapping (ray-based fat ray)
	// Use actual camera scale to convert screen pixels to world units
	const camera = tr ? tr.camera : null;
	const canvas = tr ? tr.getCanvas() : null;
	let snapRadiusWorld = snapRadiusPixels; // Fallback

	if (camera && camera.isOrthographicCamera && canvas) {
		// For orthographic camera: screen pixels to world units conversion
		// Camera frustum width in world units = (right - left) / zoom
		// Screen width in pixels = canvas.width
		// Therefore: 1 pixel = frustumWidth / canvasWidth world units
		const rect = canvas.getBoundingClientRect();
		const frustumWidth = (camera.right - camera.left) / camera.zoom;
		const pixelsToWorld = frustumWidth / rect.width;
		snapRadiusWorld = snapRadiusPixels * pixelsToWorld;
	}

	// Step 0.5b) Use InteractionManager's raycast method (same as click handler) - GPU-accelerated!
	// This method handles mouse position, camera setup, and returns only visible intersecting objects
	if (im && typeof im.raycast === "function" && tr && tr.camera && tr.scene) {
		try {
			const intersects = im.raycast();

			// Step 0.5c) Extract entity names and hole IDs from raycast results
			// These are the objects that Three.js says are visible and intersecting the ray
			intersects.forEach(function (intersect) {
				var object = intersect.object;
				var depth = 0;
				// Traverse up the object hierarchy to find KAD entities or holes
				while (object && depth < 10) {
					if (object.userData) {
						// Check for KAD entities
						if (object.userData.kadId) {
							visibleEntityNames.add(object.userData.kadId);
						}
						// Check for holes
						if (object.userData.holeID) {
							visibleHoleIDs.add(object.userData.holeID);
						}
					}
					object = object.parent;
					depth++;
				}
			});
		} catch (e) {
			// Fallback if raycast fails - will use frustum culling instead
			if (developerModeEnabled) {
				console.log("‚ö†Ô∏è [3D SNAP] Raycast failed, using frustum culling:", e);
			}
		}
	}

	// Step 0.6) PERFORMANCE OPTIMIZATION: Screen-space frustum check helper
	// Only check objects that are within screen bounds (with padding for snap radius)
	// Note: canvas and camera already declared at top of function
	const isPointInFrustum = function (worldX, worldY, worldZ) {
		if (!camera || !canvas) return true; // If no camera, check everything (fallback)

		// Convert world to screen coordinates
		const screenPos = worldToScreen(worldX, worldY, worldZ);
		if (!screenPos) return true; // Fallback if conversion fails

		// Check if point is within screen bounds (with padding for snap radius)
		const padding = snapRadiusPixels * 2; // Extra padding for objects near screen edge
		const rect = canvas.getBoundingClientRect();
		return screenPos.x >= -padding &&
			screenPos.x <= rect.width + padding &&
			screenPos.y >= -padding &&
			screenPos.y <= rect.height + padding;
	};

	// Step 1) Convert helper function: World coordinates to Three.js local coordinates
	const worldToLocal = function (worldX, worldY, worldZ) {
		if (typeof window.worldToThreeLocal === "function") {
			const local = window.worldToThreeLocal(worldX, worldY);
			return { x: local.x, y: local.y, z: worldZ || 0 };
		}
		// Fallback: No conversion if function not available
		return { x: worldX, y: worldY, z: worldZ || 0 };
	};

	// Step 2) Convert helper function: Three.js local coordinates back to world coordinates
	const localToWorld = function (localX, localY, localZ) {
		if (typeof window.threeLocalToWorld === "function") {
			const world = window.threeLocalToWorld(localX, localY);
			return { x: world.x, y: world.y, z: localZ || 0 };
		}
		// Fallback: No conversion if function not available
		return { x: localX, y: localY, z: localZ || 0 };
	};

	// Step 3) Search holes (collar, grade, toe) - OPTIMIZED: Only check visible holes or holes in frustum
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// PERFORMANCE: Skip holes not in frustum (unless they were hit by raycast)
			const holeInFrustum = isPointInFrustum(hole.startXLocation, hole.startYLocation, hole.startZLocation || 0) ||
				isPointInFrustum(hole.gradeXLocation, hole.gradeYLocation, hole.gradeZLocation || 0) ||
				isPointInFrustum(hole.endXLocation, hole.endYLocation, hole.endZLocation || 0);
			const holeVisible = visibleHoleIDs.has(hole.holeID);

			// Only check if hole is visible via raycast OR in frustum
			if (!holeVisible && !holeInFrustum) return;

			// FAT RAY snapping for holes: Cast cylinder from camera through mouse
			// Check cylindrical distance from ray (zoom-aware conversion at top of function)

			// Hole collar (start) - FAT RAY: check cylindrical distance from ray
			const collarLocal = worldToLocal(hole.startXLocation, hole.startYLocation, hole.startZLocation || 0);
			const collarResult = distanceFromPointToRay(collarLocal, rayOrigin, rayDirection);
			if (collarResult.distance <= snapRadiusWorld && collarResult.rayT > 0) {
				snapCandidates.push({
					distance: collarResult.distance,
					rayT: collarResult.rayT,
					point: { x: hole.startXLocation, y: hole.startYLocation, z: hole.startZLocation || 0 },
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade - FAT RAY: check cylindrical distance from ray
			const gradeLocal = worldToLocal(hole.gradeXLocation, hole.gradeYLocation, hole.gradeZLocation || 0);
			const gradeResult = distanceFromPointToRay(gradeLocal, rayOrigin, rayDirection);
			if (gradeResult.distance <= snapRadiusWorld && gradeResult.rayT > 0) {
				snapCandidates.push({
					distance: gradeResult.distance,
					rayT: gradeResult.rayT,
					point: { x: hole.gradeXLocation, y: hole.gradeYLocation, z: hole.gradeZLocation || 0 },
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end) - FAT RAY: check cylindrical distance from ray
			const toeLocal = worldToLocal(hole.endXLocation, hole.endYLocation, hole.endZLocation || 0);
			const toeResult = distanceFromPointToRay(toeLocal, rayOrigin, rayDirection);
			if (toeResult.distance <= snapRadiusWorld && toeResult.rayT > 0) {
				snapCandidates.push({
					distance: toeResult.distance,
					rayT: toeResult.rayT,
					point: { x: hole.endXLocation, y: hole.endYLocation, z: hole.endZLocation || 0 },
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// Step 4) Search KAD Objects - OPTIMIZED: Only check visible entities or entities in frustum
	// PERFORMANCE: Limited to MAX_SNAP_ENTITIES to prevent freeze with large DXFs
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		var entityCount = 0;
		for (var [entityName, entity] of allKADDrawingsMap) {
			// Performance limit - skip remaining entities if we've checked enough
			if (entityCount >= MAX_SNAP_ENTITIES) break;

			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) continue;

			// PERFORMANCE: Skip entities not visible via raycast AND not in frustum
			const entityVisible = visibleEntityNames.has(entityName);
			// Smart frustum check: for lines/polygons, check more points or all points if entity is small
			var entityInFrustum = false;
			if (!entityVisible && entity.data && entity.data.length > 0) {
				// For lines and polygons, check more points since they can cross the screen
				const pointsToCheck = (entity.entityType === "line" || entity.entityType === "poly" || entity.entityType === "polygon")
					? Math.min(10, entity.data.length)  // Check up to 10 points for lines/polys
					: Math.min(3, entity.data.length);   // Only 3 points for other types

				for (var i = 0; i < pointsToCheck; i++) {
					var point = entity.data[i];
					if (isPointInFrustum(point.pointXLocation, point.pointYLocation, point.pointZLocation || window.dataCentroidZ || 0)) {
						entityInFrustum = true;
						break;
					}
				}
			}

			// Only check if entity is visible via raycast OR in frustum
			if (!entityVisible && !entityInFrustum) continue;

			entityCount++;

			// Check vertices (points, line endpoints, polygon vertices, etc.)
			// PERFORMANCE: Limit points per entity
			var pointCount = 0;
			for (var dataPoint of entity.data) {
				if (pointCount >= MAX_SNAP_POINTS_PER_ENTITY) break;

				// Step 4a) Skip hidden elements - hidden items not snappable from canvas
				if (dataPoint.visible === false) continue;

				// Use SCREEN-SPACE distance for vertices (same as segments)
				const screenPos = worldToScreen(dataPoint.pointXLocation, dataPoint.pointYLocation, dataPoint.pointZLocation || window.dataCentroidZ || 0);
				if (!screenPos) continue; // Skip if worldToScreen fails

				// PERFORMANCE: Skip points far outside screen (but keep a generous margin for snap radius)
				const margin = snapRadiusPixels * 3; // Generous margin
				const canvas = tr ? tr.getCanvas() : null;
				if (canvas) {
					const rect = canvas.getBoundingClientRect();
					if (screenPos.x < -margin || screenPos.x > rect.width + margin ||
						screenPos.y < -margin || screenPos.y > rect.height + margin) {
						continue;
					}
				}

				pointCount++;
				const dx = mouseScreenX - screenPos.x;
				const dy = mouseScreenY - screenPos.y;
				const screenDist = Math.sqrt(dx * dx + dy * dy);

				if (screenDist <= snapRadiusPixels) {
					// Determine type and priority based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "line") {
						snapType = "KAD_LINE_VERTEX";
						priority = SNAP_PRIORITIES.KAD_LINE_VERTEX;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					// IMPORTANT: Return the ACTUAL object world coordinates
					snapCandidates.push({
						distance: screenDist, // Screen pixel distance for consistent sorting
						rayT: 50, // Arbitrary depth for vertices (vertices have higher priority anyway)
						point: { x: dataPoint.pointXLocation, y: dataPoint.pointYLocation, z: dataPoint.pointZLocation || 0 },
						type: snapType,
						priority: priority,
						description: entity.entityType + " " + (dataPoint.pointID || "item"),
					});
				}
			}

			// Check segments for lines and polygons
			// PERFORMANCE: Limit segments checked per entity
			if (entity.entityType === "line" || entity.entityType === "poly" || entity.entityType === "polygon") {
				const points = entity.data;
				if (points.length >= 2) {
					var numSegments = (entity.entityType === "poly" || entity.entityType === "polygon") ? points.length : points.length - 1;
					// Limit segments per entity for performance
					if (numSegments > MAX_SNAP_POINTS_PER_ENTITY) numSegments = MAX_SNAP_POINTS_PER_ENTITY;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length];

						// Step 4b) Skip segments where either endpoint is hidden
						if (p1.visible === false || p2.visible === false) continue;

						// SCREEN-SPACE SNAP: Project segment to screen and measure pixel distance
						// This matches the selection behavior and avoids coordinate system issues
						const screen1 = worldToScreen(p1.pointXLocation, p1.pointYLocation, p1.pointZLocation || window.dataCentroidZ || 0);
						const screen2 = worldToScreen(p2.pointXLocation, p2.pointYLocation, p2.pointZLocation || window.dataCentroidZ || 0);

						// Skip if projection fails
						if (!screen1 || !screen2) continue;

						// PERFORMANCE: Skip segments where both endpoints are far outside screen
						const margin = snapRadiusPixels * 3; // Generous margin
						const canvas = tr ? tr.getCanvas() : null;
						if (canvas) {
							const rect = canvas.getBoundingClientRect();
							const p1OutOfBounds = screen1.x < -margin || screen1.x > rect.width + margin ||
								screen1.y < -margin || screen1.y > rect.height + margin;
							const p2OutOfBounds = screen2.x < -margin || screen2.x > rect.width + margin ||
								screen2.y < -margin || screen2.y > rect.height + margin;
							if (p1OutOfBounds && p2OutOfBounds) continue;
						}

						// Calculate 2D screen distance from mouse to segment (in pixels)
						// Inline helper - same as used in selection code
						const A = mouseScreenX - screen1.x;
						const B = mouseScreenY - screen1.y;
						const C = screen2.x - screen1.x;
						const D = screen2.y - screen1.y;
						const dot = A * C + B * D;
						const lenSq = C * C + D * D;
						let screenDist;
						if (lenSq === 0) {
							screenDist = Math.sqrt(A * A + B * B);
						} else {
							let t = dot / lenSq;
							t = Math.max(0, Math.min(1, t));
							const projX = screen1.x + t * C;
							const projY = screen1.y + t * D;
							const dx = mouseScreenX - projX;
							const dy = mouseScreenY - projY;
							screenDist = Math.sqrt(dx * dx + dy * dy);
						}

						if (screenDist <= snapRadiusPixels) {
							// Find the parameter t along the segment in SCREEN space
							const dx = screen2.x - screen1.x;
							const dy = screen2.y - screen1.y;
							const lengthSq = dx * dx + dy * dy;
							let segmentT = 0;
							if (lengthSq > 1e-10) {
								const px = mouseScreenX - screen1.x;
								const py = mouseScreenY - screen1.y;
								const dot = px * dx + py * dy;
								segmentT = Math.max(0, Math.min(1, dot / lengthSq));
							}

							// Calculate the snap point in world coordinates using the segment parameter
							const snapPointWorld = {
								x: p1.pointXLocation + segmentT * (p2.pointXLocation - p1.pointXLocation),
								y: p1.pointYLocation + segmentT * (p2.pointYLocation - p1.pointYLocation),
								z: (p1.pointZLocation || 0) + segmentT * ((p2.pointZLocation || 0) - (p1.pointZLocation || 0)),
							};

							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : "KAD_POLYGON_SEGMENT";
							const priority = SNAP_PRIORITIES[segmentType];

							snapCandidates.push({
								distance: screenDist, // Screen pixel distance for sorting
								rayT: 100, // Arbitrary depth for segments (segments have lower priority anyway)
								point: snapPointWorld,
								type: segmentType,
								priority: priority,
								description: entity.entityName + " segment " + (i + 1),
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									interpolationT: segmentT,
								},
							});
						}
					}
				}
			}
		}
	}

	// Step 4.5) Search KAD segment intersections in XY plane (ignoring Z)
	// PERFORMANCE: Only check intersections if we have visible entities or small dataset
	if (visibleEntityNames.size > 0 || (allKADDrawingsMap && allKADDrawingsMap.size < 100)) {
		const intersections = findSegmentIntersectionsXY();
		intersections.forEach((intersection) => {
			// PERFORMANCE: Skip intersections not in frustum
			if (!isPointInFrustum(intersection.x, intersection.y, intersection.z)) return;

			// Convert world coords to local for ray comparison
			const intersectionLocal = worldToLocal(intersection.x, intersection.y, intersection.z);
			const intersectionResult = distanceFromPointToRay(intersectionLocal, rayOrigin, rayDirection);

			if (intersectionResult.distance <= snapRadiusWorld && intersectionResult.rayT > 0) {
				snapCandidates.push({
					distance: intersectionResult.distance,
					rayT: intersectionResult.rayT,
					point: { x: intersection.x, y: intersection.y, z: intersection.z },
					type: "KAD_SEGMENT_INTERSECT_XY",
					priority: SNAP_PRIORITIES.KAD_SEGMENT_INTERSECT_XY,
					description: "Intersection of " + intersection.entity1 + " and " + intersection.entity2,
				});
			}
		});
	}

	// Step 5) Search Surface Points (if surfaces are loaded) - OPTIMIZED: Only check visible surfaces
	// CRITICAL FIX: Use mouse world position as search hint instead of checking first N points
	// This ensures we search for surface vertices near where the user is actually pointing
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		// Step 5a) Get approximate mouse world position for spatial filtering
		// Use view plane intersection to find where the mouse is pointing in world space
		var mouseHintX = null, mouseHintY = null;
		if (im && typeof im.getMouseWorldPositionOnViewPlane === "function") {
			var viewPlanePos = im.getMouseWorldPositionOnViewPlane();
			if (viewPlanePos && isFinite(viewPlanePos.x) && isFinite(viewPlanePos.y)) {
				mouseHintX = viewPlanePos.x;
				mouseHintY = viewPlanePos.y;
			}
		}
		// Fallback: use current centroid if view plane intersection fails
		if (mouseHintX === null) {
			mouseHintX = window.centroidX || 0;
			mouseHintY = window.centroidY || 0;
		}

		// Step 5b) Calculate search radius in world units (generous to catch nearby vertices)
		// Use 5x the snap radius to ensure we find vertices within snap distance
		var surfaceSearchRadius = snapRadiusWorld * 5;
		var surfaceSearchRadiusSq = surfaceSearchRadius * surfaceSearchRadius;

		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				// Step 5c) PERFORMANCE: Pre-filter points by XY distance from mouse hint
				// This is O(n) but with simple distance check, much faster than ray math
				var nearbyPoints = [];
				var MAX_NEARBY_POINTS = 200; // Max points to collect near mouse

				for (var pi = 0; pi < surface.points.length && nearbyPoints.length < MAX_NEARBY_POINTS; pi++) {
					var sp = surface.points[pi];
					var dxHint = sp.x - mouseHintX;
					var dyHint = sp.y - mouseHintY;
					var distSqFromHint = dxHint * dxHint + dyHint * dyHint;

					// Only consider points within search radius of mouse hint
					if (distSqFromHint <= surfaceSearchRadiusSq) {
						nearbyPoints.push({ point: sp, index: pi });
					}
				}

				// Step 5d) Now do detailed snap check on just the nearby points
				nearbyPoints.forEach(function (item) {
					var surfacePoint = item.point;
					var index = item.index;

					// PERFORMANCE: Skip surface points not in frustum
					if (!isPointInFrustum(surfacePoint.x, surfacePoint.y, surfacePoint.z || 0)) return;

					// Convert world coords to local for ray comparison
					const pointLocal = worldToLocal(surfacePoint.x, surfacePoint.y, surfacePoint.z || 0);
					const pointResult = distanceFromPointToRay(pointLocal, rayOrigin, rayDirection);

					if (pointResult.distance <= snapRadiusWorld && pointResult.rayT > 0) {
						// IMPORTANT: Return the ACTUAL object world coordinates, NOT the ray projection point
						snapCandidates.push({
							distance: pointResult.distance,
							rayT: pointResult.rayT,
							point: { x: surfacePoint.x, y: surfacePoint.y, z: surfacePoint.z || 0 },
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Step 6) Find the best snap candidate
	// Sort by: 1) Priority (lower number = higher priority), 2) Distance along ray (closer to camera)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority; // Lower priority number wins
			}
			return a.rayT - b.rayT; // Closer to camera wins
		});

		const bestCandidate = snapCandidates[0];

		// Debug: Log snap success
		if (developerModeEnabled) { console.log("üß≤ [3D SNAP] Snapped to:", bestCandidate.type, "(" + bestCandidate.description + ") | Priority:", bestCandidate.priority, "| Distance:", bestCandidate.distance.toFixed(2)); }

		var result = {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z,
			snapped: true,
			snapTarget: bestCandidate,
		};
		window.lastSnapResult = result; // Cache result for throttled calls
		return result;
	}

	// No snap target found
	var noSnapResult = {
		snapped: false,
		snapTarget: null,
	};
	window.lastSnapResult = noSnapResult; // Cache result for throttled calls
	return noSnapResult;
}

// Enhanced global snapping function with segment support
function snapToNearestPoint(rawWorldX, rawWorldY, searchRadius = getSnapToleranceInWorldUnits()) {
	if (!snapEnabled) {
		return {
			worldX: rawWorldX,
			worldY: rawWorldY,
			worldZ: drawingZValue || document.getElementById("drawingElevation")?.value || 0,
			snapped: false,
			snapTarget: null,
		};
	}

	// Search all possible snap targets
	const snapCandidates = [];

	// 1. Search holes (collar, grade, toe)
	if (allBlastHoles && allBlastHoles.length > 0) {
		allBlastHoles.forEach((hole) => {
			// Skip hidden holes - check both group visibility and individual hole visibility
			if (!isHoleVisible(hole)) return;

			// Hole collar (start)
			const collarDist = Math.sqrt(Math.pow(hole.startXLocation - rawWorldX, 2) + Math.pow(hole.startYLocation - rawWorldY, 2));
			if (collarDist <= searchRadius) {
				snapCandidates.push({
					distance: collarDist,
					point: {
						x: hole.startXLocation,
						y: hole.startYLocation,
						z: hole.startZLocation,
					},
					type: "HOLE_COLLAR",
					priority: SNAP_PRIORITIES.HOLE_COLLAR,
					description: "Hole " + hole.holeID + " collar",
				});
			}

			// Hole grade
			const gradeDist = Math.sqrt(Math.pow(hole.gradeXLocation - rawWorldX, 2) + Math.pow(hole.gradeYLocation - rawWorldY, 2));
			if (gradeDist <= searchRadius) {
				snapCandidates.push({
					distance: gradeDist,
					point: {
						x: hole.gradeXLocation,
						y: hole.gradeYLocation,
						z: hole.gradeZLocation,
					},
					type: "HOLE_GRADE",
					priority: SNAP_PRIORITIES.HOLE_GRADE,
					description: "Hole " + hole.holeID + " grade",
				});
			}

			// Hole toe (end)
			const toeDist = Math.sqrt(Math.pow(hole.endXLocation - rawWorldX, 2) + Math.pow(hole.endYLocation - rawWorldY, 2));
			if (toeDist <= searchRadius) {
				snapCandidates.push({
					distance: toeDist,
					point: {
						x: hole.endXLocation,
						y: hole.endYLocation,
						z: hole.endZLocation,
					},
					type: "HOLE_TOE",
					priority: SNAP_PRIORITIES.HOLE_TOE,
					description: "Hole " + hole.holeID + " toe",
				});
			}
		});
	}

	// 2. Search ALL KAD Objects in unified map
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach((entity, entityName) => {
			// Skip hidden KAD entities
			if (!isEntityVisible(entityName)) return;

			// First, check vertices (existing behavior)
			entity.data.forEach((dataPoint) => {
				// Step 2a) Skip hidden elements - hidden items not snappable from canvas
				if (dataPoint.visible === false) return;
				const dist = Math.sqrt(Math.pow(dataPoint.pointXLocation - rawWorldX, 2) + Math.pow(dataPoint.pointYLocation - rawWorldY, 2));
				if (dist <= searchRadius) {
					// Determine type based on entity type
					let snapType = "KAD_POINT";
					let priority = SNAP_PRIORITIES.KAD_POINT;

					if (entity.entityType === "point") {
						snapType = "KAD_POINT";
						priority = SNAP_PRIORITIES.KAD_POINT;
					} else if (entity.entityType === "poly") {
						snapType = "KAD_POLYGON_VERTEX";
						priority = SNAP_PRIORITIES.KAD_POLYGON_VERTEX;
					} else if (entity.entityType === "circle") {
						snapType = "KAD_CIRCLE_CENTER";
						priority = SNAP_PRIORITIES.KAD_CIRCLE_CENTER;
					} else if (entity.entityType === "text") {
						snapType = "KAD_TEXT_POSITION";
						priority = SNAP_PRIORITIES.KAD_TEXT_POSITION;
					}

					snapCandidates.push({
						distance: dist,
						point: {
							x: dataPoint.pointXLocation,
							y: dataPoint.pointYLocation,
							z: dataPoint.pointZLocation,
						},
						type: snapType,
						priority: priority,
						description: `${entity.entityType} ${dataPoint.pointID || "item"}`,
					});
				}
			});

			// NEW: Check segments for lines and polygons
			if (entity.entityType === "line" || entity.entityType === "poly") {
				const points = entity.data;
				if (points.length >= 2) {
					const numSegments = entity.entityType === "poly" ? points.length : points.length - 1;

					for (let i = 0; i < numSegments; i++) {
						const p1 = points[i];
						const p2 = points[(i + 1) % points.length]; // Wrap for polygons

						// Step 2b) Skip segments where either endpoint is hidden
						if (p1.visible === false || p2.visible === false) continue;

						// Calculate distance from point to line segment
						const segmentDistance = pointToLineSegmentDistance(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

						if (segmentDistance <= searchRadius) {
							// Find the closest point on the segment
							const closestPoint = getClosestPointOnLineSegment(rawWorldX, rawWorldY, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);

							// Interpolate Z value between endpoints
							const t = getInterpolationParameter(closestPoint.x, closestPoint.y, p1.pointXLocation, p1.pointYLocation, p2.pointXLocation, p2.pointYLocation);
							const interpolatedZ = p1.pointZLocation + t * (p2.pointZLocation - p1.pointZLocation);

							// OLD CODE (problematic):
							// const priority = entity.entityType === "line" ? SNAP_PRIORITIES.KAD_LINE_VERTEX - 0.5 : SNAP_PRIORITIES.KAD_POLYGON_VERTEX - 0.5;

							// NEW CODE (fixed):
							const segmentType = entity.entityType === "line" ? "KAD_LINE_SEGMENT" : entity.entityType === "poly" ? "KAD_POLYGON_SEGMENT" : "KAD_LINE_SEGMENT"; // fallback
							const priority = SNAP_PRIORITIES[segmentType]; // Use explicit segment priorities

							snapCandidates.push({
								distance: segmentDistance,
								point: {
									x: closestPoint.x,
									y: closestPoint.y,
									z: interpolatedZ,
								},
								type: segmentType,
								priority: priority,
								description: `${entity.entityType} segment ${i + 1}`,
								segmentInfo: {
									entityName: entity.entityName,
									segmentIndex: i,
									startPoint: p1,
									endPoint: p2,
									interpolationT: t,
								},
							});
						}
					}
				}
			}
		});
	}

	// 7. Search Surface Points (from all loaded surfaces)
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		for (const [surfaceId, surface] of loadedSurfaces.entries()) {
			if (surface.visible && surface.points && surface.points.length > 0) {
				surface.points.forEach((surfacePoint, index) => {
					const dist = Math.sqrt(Math.pow(surfacePoint.x - rawWorldX, 2) + Math.pow(surfacePoint.y - rawWorldY, 2));
					if (dist <= searchRadius) {
						snapCandidates.push({
							distance: dist,
							point: {
								x: surfacePoint.x,
								y: surfacePoint.y,
								z: surfacePoint.z,
							},
							type: "SURFACE_POINT",
							priority: SNAP_PRIORITIES.SURFACE_POINT,
							description: surface.name + " point " + index,
						});
					}
				});
			}
		}
	}

	// Find the best snap candidate (highest priority, then closest 2D distance)
	if (snapCandidates.length > 0) {
		snapCandidates.sort((a, b) => {
			if (a.priority !== b.priority) {
				return a.priority - b.priority;
			}
			return a.distance - b.distance;
		});

		const bestCandidate = snapCandidates[0];

		return {
			worldX: bestCandidate.point.x,
			worldY: bestCandidate.point.y,
			worldZ: bestCandidate.point.z || drawingElevation || 0,
			snapped: true,
			snapTarget: bestCandidate,
		};
	}

	// No snap target found - use raw coordinates or the elevation value
	return {
		worldX: rawWorldX,
		worldY: rawWorldY,
		worldZ: drawingZValue || document.getElementById("drawingElevation").value || 0,
		snapped: false,
		snapTarget: null,
	};
}

// Convert canvas coordinates to world coordinates with snapping
function canvasToWorldWithSnap(canvasX, canvasY) {
	// Convert to raw world coordinates first
	const rawWorldX = (canvasX - canvas.width / 2) / currentScale + centroidX;
	const rawWorldY = -(canvasY - canvas.height / 2) / currentScale + centroidY;

	// Apply snapping
	return snapToNearestPoint(rawWorldX, rawWorldY);
}

// Enhanced mouse move handler with snap preview
function handleMouseMoveWithSnap(event) {
	const rect = canvas.getBoundingClientRect();
	const mouseX = event.clientX - rect.left;
	const mouseY = event.clientY - rect.top;
	const mouseZ = drawingZValue || document.getElementById("drawingElevation").value || 0;

	// Update global mouse tracking
	currentMouseCanvasX = mouseX;
	currentMouseCanvasY = mouseY;
	currentMouseCanvasZ = mouseZ;

	// Get snapped coordinates for preview
	const snapResult = canvasToWorldWithSnap(mouseX, mouseY, mouseZ);
	currentMouseWorldX = snapResult.worldX;
	currentMouseWorldY = snapResult.worldY;
	// Step #) Validate Z to prevent extreme values (2D canvas KAD drawing path)
	currentMouseWorldZ = validateWorldZ(snapResult.worldZ, dataCentroidZ);

	// Store snap target for visual feedback
	snapHighlight = snapResult.snapped ? snapResult.snapTarget : null;
	// Update elevation field when snapping to a Z value
	if (snapResult.snapped && snapResult.worldZ !== undefined) {
		var validatedSnapZ = validateWorldZ(snapResult.worldZ, dataCentroidZ);
		document.getElementById("drawingElevation").value = validatedSnapZ;
		drawingZValue = validatedSnapZ;
		currentMouseWorldZ = validatedSnapZ;
	}
	// Existing mouse move logic...
	if (isDragging && !isDraggingBearing && !isDraggingHole) {
		deltaX = mouseX - lastMouseX;
		deltaY = mouseY - lastMouseY;
		centroidX -= deltaX / currentScale;
		centroidY += deltaY / currentScale;
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	} else {
		lastMouseX = mouseX;
		lastMouseY = mouseY;
	}

	// ... rest of existing mouse move logic ...
	drawData(allBlastHoles, selectedHole);
}

// Visual feedback for snap highlights
//TODO Need to call this in the DrawData() function.
//TODO got fix this
function drawSnapHighlight() {
	if (!snapHighlight || !snapEnabled) return;

	// Convert world coordinates to canvas
	const [snapX, snapY] = worldToCanvas(snapHighlight.point.x, snapHighlight.point.y);

	// Draw snap indicator
	ctx.save();
	ctx.strokeStyle = "#00ff00"; // Bright green
	ctx.lineWidth = 2;
	ctx.fillStyle = "rgba(0, 255, 0, 0.3)";

	// Draw crosshair
	const size = 8;
	ctx.beginPath();
	ctx.moveTo(snapX - size, snapY);
	ctx.lineTo(snapX + size, snapY);
	ctx.moveTo(snapX, snapY - size);
	ctx.lineTo(snapX, snapY + size);
	ctx.stroke();

	// Draw circle
	ctx.beginPath();
	ctx.arc(snapX, snapY, size * 0.7, 0, 2 * Math.PI);
	ctx.stroke();

	// Enhanced tooltip with Z value
	ctx.font = "10px Arial";
	ctx.fillStyle = "#00ff00";
	const zText = snapHighlight.point.z ? " (" + snapHighlight.point.z.toFixed(2) + "m RL)" : "";
	ctx.fillText(snapHighlight.description + zText, snapX + 12, snapY - 8);

	ctx.restore();
}

// Settings for snap configuration
function addSnapSettings() {
	// Add to the UI settings panel
	const snapSettings = `
        <div class="setting-group">
            <label class="labelWhite12">Snap Settings:</label>
            <div class="setting-row">
                <label class="labelWhite10">Enable Snapping:</label>
                <input type="checkbox" id="snapEnabled" ${snapEnabled ? "checked" : ""}>
            </div>
            <div class="setting-row">
                <label class="labelWhite10">Snap Radius:</label>
                <input type="number" id="snapRadius" value="${snapRadius}" min="1" max="50" step="0.5">
                <label class="labelWhite10">meters</label>
            </div>
        </div>
    `;

	// Add event listeners for snap settings
	document.getElementById("snapEnabled")?.addEventListener("change", (e) => {
		snapEnabled = e.target.checked;
		localStorage.setItem("snapEnabled", snapEnabled);
	});

	document.getElementById("snapRadius")?.addEventListener("change", (e) => {
		snapRadius = parseFloat(e.target.value);
		localStorage.setItem("snapRadius", snapRadius);
	});
}

///------------  GEOTIFF STUFF GOES HERE ------------///
// ‚úÖ VERBOSE REMOVAL COMMENT - GeoTIFF code moved to ImageIO parsers/writers
// Step 1) Functions extracted to src/fileIO/ImageIO/IMGParser.js and IMGWriter.js
// Step 2) Reason: Modernize to use FileManager architecture with parser/writer pattern
// Step 3) Date: 2026-01-09
// Step 4) Functions moved:
//        - interpolateZFromRaster() - Moved to IMGParser.js as static method (line 135)
//        - loadGeoTIFF() - Replaced by IMGParser.parse() method
//        - processGeoTIFF() - Integrated into IMGParser.parse() logic
//        - createElevationSurface() - Replaced by createElevationSurfaceFromParser() (kirra.js line 11607)
//        - createImageSurface() - Replaced by createImageSurfaceFromParser() (kirra.js line 11571)
// Step 5) New usage pattern:
//        var parser = window.fileManager.getParser("geotiff");
//        var result = await parser.parse(file);
//        // Then use createImageSurfaceFromParser() or createElevationSurfaceFromParser()
// Step 6) Coordinate projection dialog uses ProjectionDialog.js (imported at line 88)
// Step 7) Export functionality added in IMGWriter.js (PNG+world file, XYZ point cloud)
//
// *** OLD GEOTIFF PARSING CODE REMOVED (211 lines) ***
// Functions still in kirra.js (below):
//   - updateCentroidsWithBBox() - Still used for centering view on imported extents
//   - loadedImages Map - Still used for storing multiple background images
//   - drawBackgroundImage() - Still used for rendering images on canvas
//   - isPointInBackgroundImage() - Still used for mouse hit testing

// Add this new helper function
function updateCentroidsWithBBox(bbox) {
	// Call regular updateCentroids first
	updateCentroids();

	// If there's no data yet, use the bbox directly
	if (centroidX === 0 && centroidY === 0) {
		centroidX = (bbox[0] + bbox[2]) / 2;
		centroidY = (bbox[1] + bbox[3]) / 2;
		// console.log("Centering view on GeoTIFF extent:", { centroidX, centroidY });
	}
}

// NEW: Background image support
// WITH this multi-image system:
let loadedImages = new Map(); // Map<imageId, {id, name, canvas, bbox, type, visible, transparency}>

function drawBackgroundImage() {
	if (!imagesGroupVisible) return; // ? ADD: Check images group visibility
	if (loadedImages.size === 0) return;

	loadedImages.forEach((image) => {
		if (!image.visible || !image.canvas) return;

		// Draw this image
		const bbox = image.bbox;
		if (bbox && bbox.length >= 4) {
			// Convert world coordinates to canvas coordinates
			const [x1, y1] = worldToCanvas(bbox[0], bbox[3]); // Top-left
			const [x2, y2] = worldToCanvas(bbox[2], bbox[1]); // Bottom-right

			ctx.save();
			// Fix line 21643 in drawBackgroundImage function
			ctx.globalAlpha = image.transparency !== undefined && image.transparency !== null ? image.transparency : 1.0;

			ctx.drawImage(image.canvas, x1, y1, x2 - x1, y2 - y1);
			ctx.restore();
			// Debug rectangle - FIX: Use canvas.width and canvas.height
			ctx.strokeStyle = "red";
			ctx.lineWidth = 1;
			ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));

			ctx.restore();
		}
	});
}

// Step 1) Image Context Menu using FloatingDialog for consistent styling
// MOVED TO ImagesContextMenu.js - This function is now loaded from external module
// END OF MOVED FUNCTION - showImageContextMenu now loaded from ImagesContextMenu.js

// REPLACE this function to accept image parameter:
function isPointInBackgroundImage(canvasX, canvasY, image = null) {
	// If no specific image provided, check all visible images
	if (!image) {
		return Array.from(loadedImages.values()).some((img) => img.visible && isPointInBackgroundImage(canvasX, canvasY, img));
	}

	if (!image || !image.canvas || !image.visible) return false;

	const bbox = image.bbox;
	if (!bbox || bbox.length < 4) return false;

	// Convert canvas coordinates to world coordinates
	const [worldX, worldY] = canvasToWorld(canvasX, canvasY);

	// Check if point is within image bounds
	return worldX >= bbox[0] && worldX <= bbox[2] && worldY >= bbox[1] && worldY <= bbox[3];
}

///------------  GEOTIFF STUFF ENDS HERE ------------///

///------------ PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///
// ‚úÖ VERBOSE REMOVAL COMMENT - Projection dialog moved to ProjectionDialog.js
// Step 1) Functions extracted to src/dialog/popups/generic/ProjectionDialog.js
// Step 2) Reason: Modernize to use FloatingDialog instead of SweetAlert
// Step 3) Date: 2026-01-08
// Step 4) Functions moved:
//        - loadEPSGCode() - Load EPSG definition from epsg.io
//        - isLikelyWGS84() - Detect WGS84 coordinates
//        - promptForProjection() - Show coordinate conversion dialog
//        - top100EPSGCodes[] - EPSG code list (100 entries)
// Step 5) All functions are imported in kirra.js line 88
// Step 6) Dialog now uses FloatingDialog with modern UI and File System Access API

// Placeholder for legacy code reference
const top100EPSGCodes_MOVED = []; // Old EPSG codes array moved to ProjectionDialog.js

// *** OLD PROJECTION CODE REMOVED (580 lines) ***
// The following was moved to src/dialog/popups/generic/ProjectionDialog.js:
//   - top100EPSGCodes[] array (100 EPSG codes: WGS84, MGA, GDA94, GDA2020, UTM zones, etc.)
//   - getTop100EPSGCodesFromWeb() function  
//   - isLikelyWGS84() function
//   - promptForProjection() function (converted from Swal to FloatingDialog)
// These functions now use FloatingDialog instead of SweetAlert and are imported at line 88

///------------ END OF PROJECTION COORDINATES USING PROJ4 GOES HERE ----------------///

//----REPLACEMENT OPTION FOR PRINTING----///
// Print functions have been moved to ./print/PrintSystem.js, ./print/PrintRendering.js, and ./print/PrintStats.js

//===========================
// End of the STATS SECTION
//===========================

//=============================================================
// TREE VIEW SYSTEM - NOW IMPORTED FROM MODULE
//=============================================================
// TreeView class has been moved to src/dialog/tree/TreeView.js
// This includes ~1,600 lines of code extracted for better modularity
// The TreeView is now imported at the top of this file and 
// initialized via initializeTreeView() function

// JS COLOR PICKER FOR INSTANT COLOUR CHANGES
function openColorPickerForElement(swatchElement, entityName, pointID) {
	console.log("üéØ openColorPickerForElement called with:", {
		swatchElement,
		entityName,
		pointID,
	});

	// Get the entity data
	const entity = allKADDrawingsMap.get(entityName);
	console.log("üìä Entity found:", entity);

	if (!entity) {
		console.log("‚ùå Entity not found:", entityName);
		return;
	}

	// Debug: Show all pointIDs in the entity
	console.log(
		"üîò All pointIDs in entity:",
		entity.data.map((el) => ({
			pointID: el.pointID,
			type: typeof el.pointID,
		}))
	);

	// ? FIX: Use 'let' instead of 'const' so we can reassign
	let element = entity.data.find((el) => el.pointID === pointID);
	console.log("üîé Element found:", element);

	if (!element) {
		console.log("‚ùå Element not found with pointID:", pointID);
		// Try converting to string
		element = entity.data.find((el) => el.pointID === pointID.toString());
		console.log("üîª Trying as string:", element);
		if (!element) {
			// Try converting pointID to string and compare
			element = entity.data.find((el) => el.pointID.toString() === pointID.toString());
			console.log("üîª Trying both as strings:", element);
		}
		if (!element) {
			console.log("‚ùå Element still not found after all attempts");
			return;
		}
	}

	// Check if JSColor is already installed and remove it
	if (swatchElement.jscolor) {
		try {
			swatchElement.jscolor.destroy();
		} catch (e) {
			// Ignore errors during cleanup
		}
	}

	// Create JSColor picker directly
	const picker = new JSColor(swatchElement, {
		value: element.color || getJSColorHexDrawing(),
		format: "hex",
		mode: "HSV",
		position: "right",
		onChange: function () {
			// ? FIX: Use toHEXString() instead of toString() to avoid double hash
			const newColor = this.toHEXString(); // This already includes the #
			element.color = newColor;

			// Update the original swatch element (might be orphaned after tree rebuild)
			swatchElement.style.backgroundColor = newColor;

			// Redraw the canvas
			drawData(allBlastHoles, selectedHole);

			// Update tree (rebuilds HTML with new color)
			debouncedUpdateTreeView();

			// CRITICAL: After tree updates, find and update the NEW swatch element in the DOM
			// The tree rebuild creates new elements, so we need to update the new swatch too
			setTimeout(function () {
				const newSwatchElement = document.querySelector(
					'.color-swatch[data-entity-name="' + entityName + '"][data-point-id="' + pointID + '"]'
				);
				if (newSwatchElement) {
					newSwatchElement.style.backgroundColor = newColor;
					console.log("üîª Updated NEW swatch element after tree rebuild");
				}
			}, 150); // Wait for debounced tree update (100ms) + render time

			console.log("‚úÖ Updated " + entityName + " point " + pointID + " color to:", newColor);
		},
	});

	// Show the picker
	picker.show();
}
// Initialize tree view
let treeView;
// Add this debounced version
let updateTreeViewTimeout;

// Step 1) Function to sync canvas selections to TreeView
function syncCanvasToTreeView() {
	if (!treeView) return;

	const nodeIds = [];

	// Step 2) Convert hole selections to node IDs
	if (selectedHole) {
		const nodeId = "hole‚£ø" + selectedHole.entityName + "‚£ø" + selectedHole.holeID;
		nodeIds.push(nodeId);
	} else if (selectedMultipleHoles && selectedMultipleHoles.length > 0) {
		selectedMultipleHoles.forEach(function (hole) {
			const nodeId = "hole‚£ø" + hole.entityName + "‚£ø" + hole.holeID;
			nodeIds.push(nodeId);
		});
	}

	// Step 3) Convert KAD selections to node IDs
	if (selectedKADObject) {
		// Check if vertex-level selection
		if (selectedPoint) {
			// Individual vertex
			const nodeId = selectedKADObject.entityType + "‚£ø" + selectedKADObject.entityName + "‚£øelement‚£ø" + selectedPoint.pointID;
			nodeIds.push(nodeId);
		} else {
			// Entity-level selection
			const entityType = selectedKADObject.entityType === "point" ? "points" : selectedKADObject.entityType;
			const nodeId = entityType + "‚£ø" + selectedKADObject.entityName;
			nodeIds.push(nodeId);
		}
	} else if (selectedMultipleKADObjects && selectedMultipleKADObjects.length > 0) {
		selectedMultipleKADObjects.forEach(function (kadObj) {
			if (kadObj.selectionType === "vertex") {
				// Vertex selection
				const entity = allKADDrawingsMap.get(kadObj.entityName);
				if (entity && entity.data[kadObj.elementIndex]) {
					const pointID = entity.data[kadObj.elementIndex].pointID;
					const nodeId = kadObj.entityType + "‚£ø" + kadObj.entityName + "‚£øelement‚£ø" + pointID;
					nodeIds.push(nodeId);
				}
			} else {
				// Entity selection
				const entityType = kadObj.entityType === "point" ? "points" : kadObj.entityType;
				const nodeId = entityType + "‚£ø" + kadObj.entityName;
				nodeIds.push(nodeId);
			}
		});
	}

	// Step 4) Highlight nodes in TreeView
	if (nodeIds.length > 0) {
		treeView.highlightNodes(nodeIds);
	} else {
		treeView.clearSelection();
	}
}


// Assign the actual implementation to the forward-declared variable
// PERFORMANCE FIX 2025-12-28: Smart tree updates - skip if hidden, use idle callback
debouncedUpdateTreeView = function (delay = 250) {  // Increased default delay
	if (updateTreeViewTimeout) {
		clearTimeout(updateTreeViewTimeout);
	}

	// Initialize TreeView in background if not already created
	if (!treeView) {
		console.log("üå≥ [Background] Creating TreeView for background caching...");
		treeView = new TreeView("treePanel");
	}

	// ALWAYS update tree data in background for caching (even when hidden)
	updateTreeViewTimeout = setTimeout(function () {
		// Use requestIdleCallback if available for non-blocking update
		if (typeof requestIdleCallback === "function") {
			requestIdleCallback(function () {
				updateTreeView();
			}, { timeout: 500 });  // Max wait 500ms
		} else {
			updateTreeView();
		}
	}, delay);
};
// ? Function to update TreeView visual states based on actual visibility
function updateTreeViewVisibilityStates() {
	if (!treeView) return;

	// Update group visibility states
	const groupNodes = [
		{
			nodeId: "blast",
			visible: blastGroupVisible,
		},
		{
			nodeId: "drawings",
			visible: drawingsGroupVisible,
		},
		{
			nodeId: "surfaces",
			visible: surfacesGroupVisible,
		},
		{
			nodeId: "images",
			visible: imagesGroupVisible,
		},
		{
			nodeId: "drawings?points",
			visible: pointsGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?lines",
			visible: linesGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?polygons",
			visible: polygonsGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?circles",
			visible: circlesGroupVisible && drawingsGroupVisible,
		},
		{
			nodeId: "drawings?texts",
			visible: textsGroupVisible && drawingsGroupVisible,
		},
	];

	groupNodes.forEach(({ nodeId, visible }) => {
		const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
		if (element) {
			if (visible) {
				element.style.opacity = "1";
				element.classList.remove("hidden-node");
			} else {
				element.style.opacity = "0.5";
				element.classList.add("hidden-node");
			}
		}
	});

	// ? FIX: Update entity visibility states (inherit from parent group)
	if (typeof allKADDrawingsMap !== "undefined" && allKADDrawingsMap) {
		for (const [entityName, entity] of allKADDrawingsMap.entries()) {
			const nodeId = entity.entityType + "?" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check both entity visibility AND parent group visibility
				let isVisible = entity.visible !== false && drawingsGroupVisible;

				// ? FIX: Also check specific subgroup visibility with correct entity types
				if (entity.entityType === "point") isVisible = isVisible && pointsGroupVisible;
				else if (entity.entityType === "line") isVisible = isVisible && linesGroupVisible;
				else if (entity.entityType === "poly") isVisible = isVisible && polygonsGroupVisible;
				else if (entity.entityType === "circle") isVisible = isVisible && circlesGroupVisible;
				else if (entity.entityType === "text") isVisible = isVisible && textsGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}

			// ? ADD: Update individual element visibility states
			entity.data.forEach((elementData, index) => {
				const elementNodeId = entity.entityType + "‚£ø" + entityName + "‚£øelement‚£ø" + (elementData.pointID || index + 1);
				const elementElement = treeView.container.querySelector('[data-node-id="' + elementNodeId + '"]');
				if (elementElement) {
					// Element inherits from entity and group visibility
					let isElementVisible = entity.visible !== false && drawingsGroupVisible;

					// Check specific subgroup visibility
					if (entity.entityType === "point") isElementVisible = isElementVisible && pointsGroupVisible;
					else if (entity.entityType === "line") isElementVisible = isElementVisible && linesGroupVisible;
					else if (entity.entityType === "poly") isElementVisible = isElementVisible && polygonsGroupVisible;
					else if (entity.entityType === "circle") isElementVisible = isElementVisible && circlesGroupVisible;
					else if (entity.entityType === "text") isElementVisible = isElementVisible && textsGroupVisible;

					// Check individual element visibility
					if (elementData.visible === false) isElementVisible = false;

					if (isElementVisible) {
						elementElement.style.opacity = "1";
						elementElement.classList.remove("hidden-node");
					} else {
						elementElement.style.opacity = "0.5";
						elementElement.classList.add("hidden-node");
					}
				}
			});
		}
	}

	// ? FIX: Update hole visibility states with correct node ID pattern
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const nodeId = "hole‚£ø" + hole.holeID; // ? FIX: Correct node ID pattern
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				const isVisible = hole.visible !== false && blastGroupVisible;
				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}

	// ? ADD: Update entity (blast) group visibility
	const entityGroups = {};
	if (typeof allBlastHoles !== "undefined" && allBlastHoles) {
		allBlastHoles.forEach((hole) => {
			const entityName = hole.entityName || "Unknown";
			if (!entityGroups[entityName]) {
				entityGroups[entityName] = [];
			}
			entityGroups[entityName].push(hole);
		});

		Object.keys(entityGroups).forEach((entityName) => {
			const nodeId = "entity‚£ø" + entityName;
			const element = treeView.container.querySelector('[data-node-id="' + nodeId + '"]');
			if (element) {
				// Check if any holes in this entity are visible and blast group is visible
				const entityHoles = entityGroups[entityName];
				const hasVisibleHoles = entityHoles.some((hole) => hole.visible !== false);
				const isVisible = hasVisibleHoles && blastGroupVisible;

				if (isVisible) {
					element.style.opacity = "1";
					element.classList.remove("hidden-node");
				} else {
					element.style.opacity = "0.5";
					element.classList.add("hidden-node");
				}
			}
		});
	}
}

// Update tree when data changes
function updateTreeView() {
	if (treeView) {
		// ? Update tree visibility states first
		updateTreeViewVisibilityStates();

		treeView.updateTreeData();
	}
}

//=============================================================
// TREE VIEW DELEGATION FUNCTIONS
//=============================================================
// These functions are called by the TreeView module to handle operations
// that require access to global application state

// Step 1) Handle TreeView delete operations
window.handleTreeViewDelete = function (nodeIds, treeViewInstance) {
	console.log("üéÑ [TreeView] Delete requested for:", nodeIds.length, "items");

	// Determine what's being deleted
	const hasHoles = nodeIds.some(function (id) { return id.startsWith("hole‚£ø"); });
	const hasEntities = nodeIds.some(function (id) { return id.startsWith("entity‚£ø"); });
	const hasSurfaces = nodeIds.some(function (id) { return id.startsWith("surface‚£ø"); });
	const hasImages = nodeIds.some(function (id) { return id.startsWith("image‚£ø"); });
	const hasKADElements = nodeIds.some(function (id) { return id.includes("‚£øelement‚£ø"); });
	const hasKADEntities = nodeIds.some(function (id) {
		const parts = id.split("‚£ø");
		return (parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2;
	});
	// Step 14) Check for layer nodes - Added 2026-01-16
	const hasDrawingLayers = nodeIds.some(function (id) {
		return id.startsWith("layer-drawing‚£ø") && id.split("‚£ø").length === 2;
	});
	const hasSurfaceLayers = nodeIds.some(function (id) {
		return id.startsWith("layer-surface‚£ø") && id.split("‚£ø").length === 2;
	});

	// Step 14a) Handle layer deletion with confirmation
	if (hasDrawingLayers || hasSurfaceLayers) {
		var layerIds = nodeIds.filter(function (id) {
			return id.startsWith("layer-drawing‚£ø") || id.startsWith("layer-surface‚£ø");
		}).map(function (id) {
			return {
				type: id.startsWith("layer-drawing‚£ø") ? "drawing" : "surface",
				layerId: id.split("‚£ø")[1]
			};
		});

		// Step 14a-fix) Use FloatingDialog with 3 buttons for delete layer options
		var dialogContent = '<div style="padding: 16px; text-align: center;">' +
			'<p style="font-size: 14px; margin-bottom: 16px;">Delete ' + layerIds.length + ' layer(s)?</p>' +
			'<p style="font-size: 12px; color: #888;">Choose how to handle entities inside:</p>' +
			'</div>';

		var deleteDialog = new FloatingDialog({
			title: "Delete Layer(s)",
			content: dialogContent,
			width: 400,
			height: "auto",
			showConfirm: true,
			showCancel: true,
			showOption1: true,
			confirmText: "Delete All",
			cancelText: "Cancel",
			option1Text: "Keep Entities",
			draggable: true,
			onConfirm: function () {
				// Delete layer AND all entities inside
				layerIds.forEach(function (layerInfo) {
					deleteLayer(layerInfo.type, layerInfo.layerId, true);
				});
				treeViewInstance.updateTreeData();
				deleteDialog.close();
			},
			onCancel: function () {
				// Cancelled
				deleteDialog.close();
			},
			onOption1: function () {
				// Delete layer, move entities to Default Layer
				layerIds.forEach(function (layerInfo) {
					deleteLayer(layerInfo.type, layerInfo.layerId, false);
				});
				treeViewInstance.updateTreeData();
				deleteDialog.close();
			}
		});
		deleteDialog.show();
		return;
	}

	// Delegate to existing deletion logic
	if (hasKADElements) {
		// Delete KAD elements (vertices/points)
		const entitiesToRenumber = new Set();

		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length >= 4 && parts[2] === "element") {
				const entityName = parts[1];
				const elementId = parts[3];

				const entity = allKADDrawingsMap.get(entityName);
				if (entity && entity.data) {
					const elementIndex = entity.data.findIndex(function (el) { return el.pointID == elementId; });
					if (elementIndex !== -1) {
						entity.data.splice(elementIndex, 1);
						entitiesToRenumber.add(entityName);

						if (entity.data.length === 0) {
							allKADDrawingsMap.delete(entityName);
							entitiesToRenumber.delete(entityName);
						}
					}
				}
			}
		});

		// Renumber affected entities
		entitiesToRenumber.forEach(function (entityName) {
			const entity = allKADDrawingsMap.get(entityName);
			if (entity && typeof renumberEntityPoints === "function") {
				renumberEntityPoints(entity);
			}
		});

		if (typeof debouncedSaveKAD === "function") {
			debouncedSaveKAD();
		}

		treeViewInstance.updateTreeData();
		// Step #) Trigger 3D rebuild when KAD elements are deleted via TreeView
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	} else if (hasKADEntities) {
		// Delete entire KAD entities
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2) {
				const entityName = parts[1];
				if (allKADDrawingsMap.has(entityName)) {
					allKADDrawingsMap.delete(entityName);
				}
			}
		});

		if (typeof debouncedSaveKAD === "function") {
			debouncedSaveKAD();
		}

		treeViewInstance.updateTreeData();
		// Step #) Trigger 3D rebuild when KAD entities are deleted via TreeView
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	} else if (hasSurfaces) {
		// Delete surfaces
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2 && parts[0] === "surface") {
				const surfaceId = parts[1];
				if (window.loadedSurfaces && window.loadedSurfaces.has(surfaceId)) {
					window.loadedSurfaces.delete(surfaceId);
					// Delete from IndexedDB
					if (typeof window.deleteSurfaceFromDB === "function") {
						window.deleteSurfaceFromDB(surfaceId);
					}
					console.log("‚úÖ Surface " + surfaceId + " deleted");
				}
			}
		});

		treeViewInstance.updateTreeData();
		// Step #) Trigger 3D rebuild when surfaces are deleted via TreeView
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	} else if (hasImages) {
		// Delete images
		nodeIds.forEach(function (nodeId) {
			const parts = nodeId.split("‚£ø");
			if (parts.length === 2 && parts[0] === "image") {
				const imageId = parts[1];
				if (window.loadedImages && window.loadedImages.has(imageId)) {
					window.loadedImages.delete(imageId);
					// Delete from IndexedDB
					if (typeof window.deleteImageFromDB === "function") {
						window.deleteImageFromDB(imageId);
					}
					console.log("‚úÖ Image " + imageId + " deleted");
				}
			}
		});

		treeViewInstance.updateTreeData();
		// Step #) Trigger 3D rebuild when images are deleted via TreeView
		window.threeDataNeedsRebuild = true;
		drawData(allBlastHoles, selectedHole);
	} else if (hasHoles || hasEntities) {
		// Step 2a) Delete holes and/or entire blast entities with renumber confirmation (USE FACTORY CODE)

		// Step 2a.1) Ask if user wants to renumber after deletion (USE FACTORY CODE)
		window.showConfirmationDialog(
			"Renumber Holes?",
			"Do you want to renumber holes after deletion?",
			"Yes",
			"No",
			function () {
				// Step 2a.2) Yes - Ask for starting number (USE FACTORY CODE)
				window.showConfirmationDialogWithInput(
					"Renumber Starting Value",
					"Enter the starting number for renumbering:",
					"Start From",
					"text",
					"1",
					"OK",
					"Cancel",
					function (startNumber) {
						// Step 2a.3) Delete and renumber with starting value
						const entitiesToRenumber = new Set();

						if (hasEntities) {
							// Delete entire blast entities (all holes in that entity)
							nodeIds.forEach(function (nodeId) {
								const parts = nodeId.split("‚£ø");
								if (parts[0] === "entity" && parts.length === 2) {
									const entityName = parts[1];

									// Remove all holes with this entityName
									const holesRemoved = allBlastHoles.filter(function (hole) { return hole.entityName === entityName; }).length;
									allBlastHoles = allBlastHoles.filter(function (hole) { return hole.entityName !== entityName; });

									console.log("‚ùå Deleted entity: " + entityName + " (" + holesRemoved + " holes)");
								}
							});
						}

						if (hasHoles) {
							// Delete individual holes
							nodeIds.forEach(function (nodeId) {
								const parts = nodeId.split("‚£ø");
								if (parts[0] === "hole" && parts.length === 3) {
									const entityName = parts[1];
									const holeID = parts[2];

									// Find and remove the specific hole
									const index = allBlastHoles.findIndex(function (h) { return h.entityName === entityName && h.holeID === holeID; });
									if (index !== -1) {
										allBlastHoles.splice(index, 1);
										entitiesToRenumber.add(entityName);
										console.log("‚ùå Deleted hole: " + entityName + ":" + holeID);
									}
								}
							});
						}

						// Renumber affected entities with starting number (USE FACTORY CODE)
						entitiesToRenumber.forEach(function (entityName) {
							if (typeof renumberHolesFunction === "function") {
								renumberHolesFunction(startNumber, entityName);
							}
						});

						// Save and update (USE FACTORY CODE)
						if (typeof debouncedSaveHoles === "function") {
							debouncedSaveHoles();
						}

						treeViewInstance.updateTreeData();
						// Step #) Trigger 3D rebuild when holes are deleted via TreeView
						window.threeDataNeedsRebuild = true;
						drawData(allBlastHoles, selectedHole);
						updateStatusMessage("Deleted holes and renumbered from " + startNumber);
						setTimeout(function () { updateStatusMessage(""); }, 2000);
					},
					function () {
						// Step 2a.4) User cancelled starting number input
						updateStatusMessage("Delete cancelled");
						setTimeout(function () { updateStatusMessage(""); }, 2000);
					}
				);
			},
			function () {
				// Step 2a.5) No - Delete without renumbering
				if (hasEntities) {
					// Delete entire blast entities (all holes in that entity)
					nodeIds.forEach(function (nodeId) {
						const parts = nodeId.split("‚£ø");
						if (parts[0] === "entity" && parts.length === 2) {
							const entityName = parts[1];

							// Remove all holes with this entityName
							const holesRemoved = allBlastHoles.filter(function (hole) { return hole.entityName === entityName; }).length;
							allBlastHoles = allBlastHoles.filter(function (hole) { return hole.entityName !== entityName; });

							console.log("‚ùå Deleted entity: " + entityName + " (" + holesRemoved + " holes)");
						}
					});
				}

				if (hasHoles) {
					// Delete individual holes
					nodeIds.forEach(function (nodeId) {
						const parts = nodeId.split("‚£ø");
						if (parts[0] === "hole" && parts.length === 3) {
							const entityName = parts[1];
							const holeID = parts[2];

							// Find and remove the specific hole
							const index = allBlastHoles.findIndex(function (h) { return h.entityName === entityName && h.holeID === holeID; });
							if (index !== -1) {
								allBlastHoles.splice(index, 1);
								console.log("‚ùå Deleted hole: " + entityName + ":" + holeID);
							}
						}
					});
				}

				// Step 6) CRITICAL FIX: Save to IndexedDB after deletion without renumbering
				if (typeof debouncedSaveHoles === "function") {
					debouncedSaveHoles();
				}

				// Clear selections
				selectedHole = null;
				selectedMultipleHoles = [];
				// Use refreshPoints() for complete update
				refreshPoints();
				updateStatusMessage("Deleted holes without renumbering");
				setTimeout(function () { updateStatusMessage(""); }, 2000);
			}
		);
	}
};

// Step 2) Handle TreeView visibility toggle
window.handleTreeViewVisibility = function (nodeId, type, itemId, isVisible) {
	console.log("üéÑ [TreeView] Visibility toggle:", nodeId, "‚Üí", isVisible);

	// Main group visibility
	if (nodeId === "blast") {
		setBlastGroupVisibility(isVisible);
	} else if (nodeId === "drawings") {
		setDrawingsGroupVisibility(isVisible);
	} else if (nodeId === "surfaces") {
		setSurfacesGroupVisibility(isVisible);
	} else if (nodeId === "images") {
		setImagesGroupVisibility(isVisible);
	}
	// Drawing subgroup visibility
	else if (nodeId === "drawings?points") {
		setPointsGroupVisibility(isVisible);
	} else if (nodeId === "drawings?lines") {
		setLinesGroupVisibility(isVisible);
	} else if (nodeId === "drawings?polygons") {
		setPolygonsGroupVisibility(isVisible);
	} else if (nodeId === "drawings?circles") {
		setCirclesGroupVisibility(isVisible);
	} else if (nodeId === "drawings?texts") {
		setTextsGroupVisibility(isVisible);
	}
	// Individual item visibility
	else if (type === "surface") {
		setSurfaceVisibility(itemId, isVisible);
	} else if (type === "image") {
		setImageVisibility(itemId, isVisible);
	} else if (type === "hole") {
		// Step 4) FIX: Parse hole node ID correctly - format is "hole‚£øentityName‚£øholeID"
		// itemId contains "entityName‚£øholeID", we need just the holeID
		const parts = nodeId.split("‚£ø");
		if (parts.length === 3) {
			const holeID = parts[2]; // Extract just the holeID
			console.log("üîß [TreeView] Parsed hole visibility: entityName=" + parts[1] + ", holeID=" + holeID);
			setHoleVisibility(holeID, isVisible);
		} else {
			// Fallback for old format (shouldn't happen but be safe)
			setHoleVisibility(itemId, isVisible);
		}
	} else if (type === "entity") {
		setEntityVisibility(itemId, isVisible);
	} else if (type === "points" || type === "line" || type === "poly" || type === "circle" || type === "text") {
		setKADEntityVisibility(itemId, isVisible);
	} else if (nodeId.includes("‚£øelement‚£ø")) {
		const parts = nodeId.split("‚£ø");
		if (parts.length >= 4 && parts[2] === "element") {
			const entityName = parts[1];
			const elementId = parts[3];
			setKADElementVisibility(entityName, elementId, isVisible);
		}
	}

	// Note: Individual visibility setters already call drawData() and updateTreeViewVisibilityStates()
};

// ================================================================================
// Step 12) Layer System Functions - Added 2026-01-16
// ================================================================================

// Step 12a) Create a new layer via dialog
window.createLayerDialog = function (layerType) {
	console.log("üéÑ [Layer] Creating " + layerType + " layer dialog");

	var dialogTitle = layerType === "drawing" ? "Create New Drawing Layer" : "Create New Surface Layer";
	var dialog = new FloatingDialog({
		title: dialogTitle,
		width: 400,
		height: "auto",
		content: '<div style="padding: 16px;">' +
			'<label style="display: block; margin-bottom: 8px; font-weight: bold;">Layer Name:</label>' +
			'<input type="text" id="newLayerNameInput" placeholder="Enter layer name..." ' +
			'style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;" />' +
			'</div>',
		showConfirm: true,
		confirmText: "Create",
		cancelText: "Cancel",
		onConfirm: function () {
			var nameInput = document.getElementById("newLayerNameInput");
			var layerName = nameInput ? nameInput.value.trim() : "";

			if (!layerName) {
				showModalMessage("Error", "Layer name cannot be empty", "error");
				return;
			}

			// Step 12b) Create the layer
			var result = createLayer(layerType, layerName);
			if (result.success) {
				console.log("‚úÖ [Layer] Created layer:", layerName, "with ID:", result.layerId);

				// Step 29) Automatically make the new layer active
				setActiveLayer(layerType, result.layerId);
				console.log("‚úÖ [Layer] Set new layer as active:", result.layerId);

				debouncedUpdateTreeView();
				debouncedSaveLayers();
			} else {
				showModalMessage("Error", result.message || "Failed to create layer", "error");
			}

			dialog.close();
		}
	});
	dialog.show();

	// Focus the input
	setTimeout(function () {
		var nameInput = document.getElementById("newLayerNameInput");
		if (nameInput) nameInput.focus();
	}, 100);
};

// Step 12c) Create a layer programmatically
function createLayer(layerType, layerName, sourceFile) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var timestamp = Date.now();
	var layerId = "layer_" + layerName.replace(/[^a-zA-Z0-9]/g, "_") + "_" + timestamp;

	// Check for duplicate names
	var nameExists = false;
	layersMap.forEach(function (layer) {
		if (layer.layerName === layerName) {
			nameExists = true;
		}
	});

	if (nameExists) {
		return { success: false, message: "A layer with this name already exists" };
	}

	var newLayer = {
		layerId: layerId,
		layerName: layerName,
		visible: true,
		sourceFile: sourceFile || null,
		importDate: new Date().toISOString(),
		entities: new Set()
	};

	layersMap.set(layerId, newLayer);
	console.log("‚úÖ [Layer] Created " + layerType + " layer:", layerName, "ID:", layerId);

	return { success: true, layerId: layerId, layer: newLayer };
}

// Step 12d) Delete a layer and optionally its entities
function deleteLayer(layerType, layerId, deleteEntities) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var layer = layersMap.get(layerId);

	if (!layer) {
		console.warn("‚ö†Ô∏è [Layer] Layer not found:", layerId);
		return { success: false, message: "Layer not found" };
	}

	// Step 12d-1) If deleteEntities is true, remove all entities in the layer
	if (deleteEntities) {
		if (layerType === "drawing") {
			// Delete entities from layer.entities Set
			layer.entities.forEach(function (entityName) {
				if (allKADDrawingsMap.has(entityName)) {
					allKADDrawingsMap.delete(entityName);
				}
			});
			// Also delete any entities with matching layerId
			var entitiesToDelete = [];
			allKADDrawingsMap.forEach(function (entity, entityName) {
				if (entity.layerId === layerId) {
					entitiesToDelete.push(entityName);
				}
			});
			entitiesToDelete.forEach(function (entityName) {
				allKADDrawingsMap.delete(entityName);
			});
			debouncedSaveKAD();
		} else if (layerType === "surface") {
			// Delete surfaces from layer.entities Set
			layer.entities.forEach(function (surfaceId) {
				if (loadedSurfaces && loadedSurfaces.has(surfaceId)) {
					loadedSurfaces.delete(surfaceId);
					// Also delete from IndexedDB
					if (typeof deleteSurfaceFromDB === "function") {
						deleteSurfaceFromDB(surfaceId);
					}
				}
			});
			// Also delete any surfaces with matching layerId
			var surfacesToDelete = [];
			if (loadedSurfaces) {
				loadedSurfaces.forEach(function (surface, surfaceId) {
					if (surface.layerId === layerId) {
						surfacesToDelete.push(surfaceId);
					}
				});
			}
			surfacesToDelete.forEach(function (surfaceId) {
				loadedSurfaces.delete(surfaceId);
				if (typeof deleteSurfaceFromDB === "function") {
					deleteSurfaceFromDB(surfaceId);
				}
			});
		}
	} else {
		// Step 12d-2) Move entities to default layer
		var defaultLayerId = layerType === "drawing" ? DEFAULT_DRAWING_LAYER_ID : DEFAULT_SURFACE_LAYER_ID;
		var defaultLayer = layersMap.get(defaultLayerId);

		if (!defaultLayer) {
			// Create default layer if it doesn't exist
			defaultLayer = {
				layerId: defaultLayerId,
				layerName: "Default Layer",
				visible: true,
				sourceFile: null,
				importDate: new Date().toISOString(),
				entities: new Set()
			};
			layersMap.set(defaultLayerId, defaultLayer);
		}

		// Move entities to default layer
		if (layerType === "drawing") {
			layer.entities.forEach(function (entityName) {
				var entity = allKADDrawingsMap.get(entityName);
				if (entity) {
					entity.layerId = defaultLayerId;
					defaultLayer.entities.add(entityName);
				}
			});
			// Also update any entities with matching layerId
			allKADDrawingsMap.forEach(function (entity, entityName) {
				if (entity.layerId === layerId) {
					entity.layerId = defaultLayerId;
					defaultLayer.entities.add(entityName);
				}
			});
			debouncedSaveKAD();
		} else if (layerType === "surface") {
			// Move surfaces from layer.entities Set
			layer.entities.forEach(function (surfaceId) {
				var surface = loadedSurfaces ? loadedSurfaces.get(surfaceId) : null;
				if (surface) {
					surface.layerId = defaultLayerId;
					defaultLayer.entities.add(surfaceId);
				}
			});
			// Also update any surfaces with matching layerId
			if (loadedSurfaces) {
				loadedSurfaces.forEach(function (surface, surfaceId) {
					if (surface.layerId === layerId) {
						surface.layerId = defaultLayerId;
						defaultLayer.entities.add(surfaceId);
					}
				});
			}
		}
	}

	// Remove the layer
	layersMap.delete(layerId);
	console.log("‚úÖ [Layer] Deleted " + layerType + " layer:", layer.layerName);

	debouncedSaveLayers();
	debouncedUpdateTreeView();
	// Step #) Trigger 3D rebuild when layer is deleted
	window.threeDataNeedsRebuild = true;
	drawData(allBlastHoles, selectedHole);

	return { success: true };
}

// Step 12e) Rename a layer
function renameLayer(layerType, layerId, newName) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var layer = layersMap.get(layerId);

	if (!layer) {
		return { success: false, message: "Layer not found" };
	}

	// Check for duplicate names
	var nameExists = false;
	layersMap.forEach(function (l, lid) {
		if (l.layerName === newName && lid !== layerId) {
			nameExists = true;
		}
	});

	if (nameExists) {
		return { success: false, message: "A layer with this name already exists" };
	}

	layer.layerName = newName;
	console.log("‚úÖ [Layer] Renamed layer to:", newName);

	debouncedSaveLayers();
	debouncedUpdateTreeView();

	return { success: true };
}

// Step 12f) Set visibility for all entities in a layer
window.setLayerVisibility = function (layerId, layerType, isVisible) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var layer = layersMap.get(layerId);

	if (!layer) {
		console.warn("‚ö†Ô∏è [Layer] Layer not found:", layerId);
		return;
	}

	layer.visible = isVisible;

	// Step 12f-1) Set visibility for all entities in the layer
	if (layerType === "drawing") {
		// Method 1: Use layer.entities if populated
		if (layer.entities && layer.entities.size > 0) {
			layer.entities.forEach(function (entityName) {
				var entity = allKADDrawingsMap.get(entityName);
				if (entity) {
					entity.visible = isVisible;
				}
			});
		}
		// Method 2: Also iterate all entities to catch any with matching layerId
		if (allKADDrawingsMap) {
			allKADDrawingsMap.forEach(function (entity, entityName) {
				if (entity.layerId === layerId) {
					entity.visible = isVisible;
				}
			});
		}
		debouncedSaveKAD();
	} else if (layerType === "surface") {
		// Method 1: Use layer.entities if populated
		if (layer.entities && layer.entities.size > 0) {
			layer.entities.forEach(function (surfaceId) {
				if (loadedSurfaces && loadedSurfaces.has(surfaceId)) {
					var surface = loadedSurfaces.get(surfaceId);
					surface.visible = isVisible;
				}
			});
		}
		// Method 2: Also iterate all surfaces to catch any with matching layerId
		if (loadedSurfaces) {
			loadedSurfaces.forEach(function (surface, surfaceId) {
				if (surface.layerId === layerId) {
					surface.visible = isVisible;
				}
			});
		}
	}

	console.log("‚úÖ [Layer] Set visibility for layer", layer.layerName, "to", isVisible);
	debouncedSaveLayers();
	drawData(allBlastHoles, selectedHole);
};

// Step 12f-2) Set visibility for all entities of a specific type within a layer
window.setLayerEntityTypeVisibility = function (layerId, entityTypeFolder, isVisible) {
	var layer = allDrawingLayers.get(layerId);

	if (!layer) {
		console.warn("‚ö†Ô∏è [Layer] Layer not found for entity type visibility:", layerId);
		return;
	}

	// Map folder name to entity type
	var entityTypeMap = {
		"points": "point",
		"lines": "line",
		"polygons": "poly",
		"circles": "circle",
		"texts": "text"
	};
	var targetType = entityTypeMap[entityTypeFolder];

	if (!targetType) {
		console.warn("‚ö†Ô∏è [Layer] Unknown entity type folder:", entityTypeFolder);
		return;
	}

	// Set visibility for all entities of this type in the layer
	layer.entities.forEach(function (entityName) {
		var entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.entityType === targetType) {
			entity.visible = isVisible;
		}
	});

	console.log("‚úÖ [Layer] Set visibility for", entityTypeFolder, "in layer", layer.layerName, "to", isVisible);
	debouncedSaveKAD();
	drawData(allBlastHoles, selectedHole);
};

// Step 12g) Get or create a layer for import (synchronous, for backward compatibility)
function getOrCreateLayerForImport(layerType, fileName) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;

	// Check if a layer with this sourceFile already exists
	var existingLayer = null;
	layersMap.forEach(function (layer) {
		if (layer.sourceFile === fileName || layer.layerName === fileName) {
			existingLayer = layer;
		}
	});

	// Step 16) Name collision handling - if layer exists, create with unique name
	if (existingLayer) {
		// For auto-import, just add a numeric suffix
		var counter = 2;
		var newLayerName = fileName + "_" + counter;
		while (layerNameExists(layersMap, newLayerName)) {
			counter++;
			newLayerName = fileName + "_" + counter;
		}
		console.log("‚ö†Ô∏è [Layer] Name collision: '" + fileName + "' already exists. Creating as '" + newLayerName + "'");
		var result = createLayer(layerType, newLayerName, fileName);
		if (result.success) {
			return result.layer;
		}
		return null;
	}

	// Create a new layer
	var result = createLayer(layerType, fileName, fileName);
	if (result.success) {
		return result.layer;
	}

	return null;
}

// Step 16a) Helper to check if a layer name exists
function layerNameExists(layersMap, layerName) {
	var exists = false;
	layersMap.forEach(function (layer) {
		if (layer.layerName === layerName) {
			exists = true;
		}
	});
	return exists;
}

// Step 16b) Async version with dialog for name collision
async function getOrCreateLayerForImportAsync(layerType, fileName) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;

	// Check if a layer with this sourceFile already exists
	var existingLayer = null;
	layersMap.forEach(function (layer) {
		if (layer.sourceFile === fileName || layer.layerName === fileName) {
			existingLayer = layer;
		}
	});

	if (existingLayer) {
		// Show collision dialog
		return new Promise(function (resolve) {
			showLayerCollisionDialog(layerType, fileName, existingLayer, function (action, newName) {
				if (action === "rename") {
					var result = createLayer(layerType, newName, fileName);
					resolve(result.success ? result.layer : null);
				} else if (action === "replace") {
					// Delete existing layer and create new one
					deleteLayer(layerType, existingLayer.layerId, true);
					var result = createLayer(layerType, fileName, fileName);
					resolve(result.success ? result.layer : null);
				} else {
					// Cancel
					resolve(null);
				}
			});
		});
	}

	// Create a new layer
	var result = createLayer(layerType, fileName, fileName);
	if (result.success) {
		return result.layer;
	}

	return null;
}

// Step 16c) Show dialog for layer name collision
function showLayerCollisionDialog(layerType, fileName, existingLayer, callback) {
	var counter = 2;
	var suggestedName = fileName + "_" + counter;
	while (layerNameExists(layerType === "drawing" ? allDrawingLayers : allSurfaceLayers, suggestedName)) {
		counter++;
		suggestedName = fileName + "_" + counter;
	}

	var dialogContent = '<div style="padding: 16px;">' +
		'<p style="margin-bottom: 16px;">A layer named <strong>"' + fileName + '"</strong> already exists.</p>' +
		'<p style="margin-bottom: 16px;">What would you like to do?</p>' +
		'<div style="margin-bottom: 12px;">' +
		'<input type="radio" name="collisionAction" id="actionRename" value="rename" checked>' +
		'<label for="actionRename"> Import as new layer with name:</label>' +
		'</div>' +
		'<input type="text" id="newLayerNameInput" value="' + suggestedName + '" ' +
		'style="width: calc(100% - 20px); margin-left: 20px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 12px;" />' +
		'<div style="margin-bottom: 12px;">' +
		'<input type="radio" name="collisionAction" id="actionReplace" value="replace">' +
		'<label for="actionReplace"> Replace existing layer (delete old entities)</label>' +
		'</div>' +
		'</div>';

	var dialog = new FloatingDialog({
		title: "Layer Name Collision",
		width: 450,
		height: "auto",
		content: dialogContent,
		showConfirm: true,
		confirmText: "Import",
		cancelText: "Cancel",
		onConfirm: function () {
			var renameRadio = document.getElementById("actionRename");
			var nameInput = document.getElementById("newLayerNameInput");

			if (renameRadio && renameRadio.checked) {
				var newName = nameInput ? nameInput.value.trim() : suggestedName;
				callback("rename", newName);
			} else {
				callback("replace", null);
			}
			dialog.close();
		},
		onCancel: function () {
			callback("cancel", null);
			dialog.close();
		}
	});
	dialog.show();
}

// Expose collision functions
window.getOrCreateLayerForImportAsync = getOrCreateLayerForImportAsync;
window.showLayerCollisionDialog = showLayerCollisionDialog;

// ================================================================================
// Step 17) Migration Logic - Migrate existing entities without layerId
// ================================================================================

function migrateEntitiesWithoutLayerId() {
	console.log("üîÑ [Migration] Checking for entities without layerId...");

	var migratedDrawings = 0;
	var migratedSurfaces = 0;

	// Step 17a) Ensure default drawing layer exists
	var defaultDrawingLayerId = DEFAULT_DRAWING_LAYER_ID;
	if (!allDrawingLayers.has(defaultDrawingLayerId)) {
		allDrawingLayers.set(defaultDrawingLayerId, {
			layerId: defaultDrawingLayerId,
			layerName: "Default Layer",
			visible: true,
			sourceFile: null,
			importDate: new Date().toISOString(),
			entities: new Set()
		});
		console.log("‚úÖ [Migration] Created default drawing layer");
	}
	var defaultDrawingLayer = allDrawingLayers.get(defaultDrawingLayerId);

	// Step 17b) Migrate KAD entities without layerId
	if (allKADDrawingsMap && allKADDrawingsMap.size > 0) {
		allKADDrawingsMap.forEach(function (entity, entityName) {
			if (!entity.layerId) {
				entity.layerId = defaultDrawingLayerId;
				defaultDrawingLayer.entities.add(entityName);
				migratedDrawings++;
			} else {
				// Step 17c) Ensure entity is in its layer's entities set
				var layer = allDrawingLayers.get(entity.layerId);
				if (layer && !layer.entities.has(entityName)) {
					layer.entities.add(entityName);
				}
			}
		});
	}

	// Step 17d) Ensure default surface layer exists
	var defaultSurfaceLayerId = DEFAULT_SURFACE_LAYER_ID;
	if (!allSurfaceLayers.has(defaultSurfaceLayerId)) {
		allSurfaceLayers.set(defaultSurfaceLayerId, {
			layerId: defaultSurfaceLayerId,
			layerName: "Default Layer",
			visible: true,
			sourceFile: null,
			importDate: new Date().toISOString(),
			entities: new Set()
		});
		console.log("‚úÖ [Migration] Created default surface layer");
	}
	var defaultSurfaceLayer = allSurfaceLayers.get(defaultSurfaceLayerId);

	// Step 17e) Migrate surfaces without layerId
	if (loadedSurfaces && loadedSurfaces.size > 0) {
		loadedSurfaces.forEach(function (surface, surfaceId) {
			if (!surface.layerId) {
				surface.layerId = defaultSurfaceLayerId;
				defaultSurfaceLayer.entities.add(surfaceId);
				migratedSurfaces++;
			} else {
				// Step 17f) Ensure surface is in its layer's entities set
				var layer = allSurfaceLayers.get(surface.layerId);
				if (layer && !layer.entities.has(surfaceId)) {
					layer.entities.add(surfaceId);
				}
			}
		});
	}

	if (migratedDrawings > 0 || migratedSurfaces > 0) {
		console.log("‚úÖ [Migration] Migrated " + migratedDrawings + " drawing entities and " + migratedSurfaces + " surfaces to default layers");
		debouncedSaveLayers();
	} else {
		console.log("‚úÖ [Migration] No migration needed - all entities have layerId");
	}
}

// Expose migration function
window.migrateEntitiesWithoutLayerId = migrateEntitiesWithoutLayerId;

// Step 12h) Add entity to a layer
function addEntityToLayer(layerType, layerId, entityName) {
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var layer = layersMap.get(layerId);

	if (!layer) {
		console.warn("‚ö†Ô∏è [Layer] Cannot add entity - layer not found:", layerId);
		return false;
	}

	layer.entities.add(entityName);
	return true;
}

// Step 18b) Set active layer
function setActiveLayer(layerType, layerId) {
	if (layerType === "drawing") {
		activeDrawingLayerId = layerId;
		window.activeDrawingLayerId = layerId;
		console.log("‚úÖ [Layer] Active drawing layer set to:", layerId);
	} else if (layerType === "surface") {
		activeSurfaceLayerId = layerId;
		window.activeSurfaceLayerId = layerId;
		console.log("‚úÖ [Layer] Active surface layer set to:", layerId);
	}

	// Update TreeView to show active layer indicator
	if (typeof debouncedUpdateTreeView === "function") {
		debouncedUpdateTreeView();
	}

	// Show user notification
	var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
	var layer = layersMap.get(layerId);
	if (layer) {
		updateStatusMessage("Active layer: " + layer.layerName);
		setTimeout(function () { updateStatusMessage(""); }, 3000);
	}
}

// Step 18c) Get active layer ID
function getActiveLayerId(layerType) {
	if (layerType === "drawing") {
		return activeDrawingLayerId || DEFAULT_DRAWING_LAYER_ID;
	} else if (layerType === "surface") {
		return activeSurfaceLayerId || DEFAULT_SURFACE_LAYER_ID;
	}
	return null;
}

// Expose functions to window
window.createLayer = createLayer;
window.deleteLayer = deleteLayer;
window.renameLayer = renameLayer;
window.getOrCreateLayerForImport = getOrCreateLayerForImport;
window.addEntityToLayer = addEntityToLayer;
window.setActiveLayer = setActiveLayer;
window.getActiveLayerId = getActiveLayerId;

// ================================================================================
// End Layer System Functions
// ================================================================================

// Step 3) Handle TreeView rename operations
window.handleTreeViewRename = function (nodeId, treeViewInstance) {
	console.log("üéÑ [TreeView] Rename requested for:", nodeId);

	const parts = nodeId.split("‚£ø");

	// Blast entity rename
	if (parts[0] === "entity" && parts.length === 2) {
		const entityName = parts[1];
		const firstHole = allBlastHoles.find(function (h) { return h.entityName === entityName; });
		if (firstHole && typeof window.editBlastNamePopup === "function") {
			// editBlastNamePopup now returns a promise
			window.editBlastNamePopup(firstHole).then(function (result) {
				if (result && result.isConfirmed) {
					// Update TreeView after successful rename
					if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
						treeViewInstance.updateTreeData();
					}
				}
			});
		}
		return;
	}

	// KAD entity rename
	if ((parts[0] === "points" || parts[0] === "line" || parts[0] === "poly" || parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
		const oldEntityName = parts[1];
		const entity = allKADDrawingsMap.get(oldEntityName);
		if (!entity) {
			console.log("[BAD] [TreeView] Entity not found:", oldEntityName);
			return;
		}

		if (typeof window.renameEntityDialog === "function") {
			window.renameEntityDialog(parts[0], oldEntityName).then(function (result) {
				if (result.isConfirmed) {
					const newEntityName = result.value.trim();
					if (!newEntityName || newEntityName === oldEntityName) return;

					if (allKADDrawingsMap.has(newEntityName)) {
						showModalMessage("Name Error", "Name already exists!", "error");
						return;
					}

					// Rename entity
					allKADDrawingsMap.set(newEntityName, {
						...entity,
						entityName: newEntityName,
						data: entity.data.map(function (el) {
							return { ...el, entityName: newEntityName };
						})
					});
					allKADDrawingsMap.delete(oldEntityName);

					if (typeof debouncedSaveKAD === "function") {
						debouncedSaveKAD();
					}

					treeViewInstance.updateTreeData();
					drawData(allBlastHoles, selectedHole);
				}
			});
		} else {
			console.error("[BAD] [TreeView] window.renameEntityDialog is not a function! Type:", typeof window.renameEntityDialog);
		}
		return;
	}

	// Surface rename
	if (parts[0] === "surface" && parts.length === 2) {
		const surfaceId = parts[1];
		const surface = window.loadedSurfaces ? window.loadedSurfaces.get(surfaceId) : null;
		if (surface) {
			// Create a simple input dialog for renaming
			window.showConfirmationDialogWithInput(
				"Rename Surface",
				"Enter new name for surface:",
				"New Name",
				"text",
				surface.name || "Surface " + surfaceId,
				"OK",
				"Cancel",
				function (newName) {
					if (newName && newName.trim() && newName.trim() !== surface.name) {
						const trimmedName = newName.trim();
						surface.name = trimmedName;

						// Save to IndexedDB if function exists
						if (typeof window.saveSurfaceToDB === "function") {
							window.saveSurfaceToDB(surfaceId, surface);
						}

						// Update TreeView
						if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
							treeViewInstance.updateTreeData();
						}

						console.log("‚úÖ Surface renamed:", surfaceId, "->", trimmedName);
					}
				},
				function () {
					// Cancelled
				}
			);
		}
		return;
	}

	// Image rename
	if (parts[0] === "image" && parts.length === 2) {
		const imageId = parts[1];
		const image = window.loadedImages ? window.loadedImages.get(imageId) : null;
		if (image) {
			// Create a simple input dialog for renaming
			window.showConfirmationDialogWithInput(
				"Rename Image",
				"Enter new name for image:",
				"New Name",
				"text",
				image.name || "Image " + imageId,
				"OK",
				"Cancel",
				function (newName) {
					if (newName && newName.trim() && newName.trim() !== image.name) {
						const trimmedName = newName.trim();
						image.name = trimmedName;

						// Save to IndexedDB if function exists
						if (typeof window.saveImageToDB === "function") {
							window.saveImageToDB(imageId, image);
						}

						// Update TreeView
						if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
							treeViewInstance.updateTreeData();
						}

						console.log("‚úÖ Image renamed:", imageId, "->", trimmedName);
					}
				},
				function () {
					// Cancelled
				}
			);
		}
		return;
	}

	// Step 13) Layer rename - Added 2026-01-16
	// Node ID format: "layer-drawing‚£ølayerId" or "layer-surface‚£ølayerId"
	if ((parts[0] === "layer-drawing" || parts[0] === "layer-surface") && parts.length === 2) {
		var layerType = parts[0] === "layer-drawing" ? "drawing" : "surface";
		var layerId = parts[1];
		var layersMap = layerType === "drawing" ? allDrawingLayers : allSurfaceLayers;
		var layer = layersMap.get(layerId);

		if (!layer) {
			console.log("üö´ [TreeView] Layer not found:", layerId);
			return;
		}

		window.showConfirmationDialogWithInput(
			"Rename Layer",
			"Enter new name for layer:",
			"New Name",
			"text",
			layer.layerName || "Layer",
			"OK",
			"Cancel",
			function (newName) {
				if (newName && newName.trim() && newName.trim() !== layer.layerName) {
					var trimmedName = newName.trim();
					var result = renameLayer(layerType, layerId, trimmedName);

					if (result.success) {
						console.log("‚úÖ Layer renamed:", layer.layerName, "->", trimmedName);

						// Update TreeView
						if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
							treeViewInstance.updateTreeData();
						}
					} else {
						showModalMessage("Rename Error", result.message || "Failed to rename layer", "error");
					}
				}
			},
			function () {
				// Cancelled
			}
		);
		return;
	}

	// Step 3b) Single hole HoleID rename
	// Node ID format: "hole‚£øentityName‚£øholeID"
	if (parts[0] === "hole" && parts.length === 3) {
		const entityName = parts[1];
		const oldHoleID = parts[2];
		const hole = allBlastHoles.find(function (h) {
			return h.entityName === entityName && h.holeID === oldHoleID;
		});

		if (!hole) {
			console.log("üö´ [TreeView] Hole not found:", entityName, oldHoleID);
			return;
		}

		// Step 3b.1) Generate unique code suffix for suggestion
		var generateUniqueCode = function () {
			var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
			var code = "";
			for (var i = 0; i < 4; i++) {
				code += chars.charAt(Math.floor(Math.random() * chars.length));
			}
			return code;
		};

		// Step 3b.2) Check if HoleID already exists in the same blast
		var holeIDExists = function (blastName, holeID) {
			return allBlastHoles.some(function (h) {
				return h.entityName === blastName && h.holeID === holeID;
			});
		};

		window.showConfirmationDialogWithInput(
			"Rename Hole ID",
			"Enter new Hole ID for " + oldHoleID + " in " + entityName + ":<br><small>Note: Must be unique within the blast pattern.</small>",
			"New Hole ID",
			"text",
			oldHoleID + "_" + generateUniqueCode(),
			"OK",
			"Cancel",
			function (newHoleID) {
				if (newHoleID && newHoleID.trim() && newHoleID.trim() !== oldHoleID) {
					var trimmedID = newHoleID.trim();

					// Step 3b.3) Check for duplicate HoleID in the same blast
					if (holeIDExists(entityName, trimmedID)) {
						showModalMessage("Duplicate ID", "A hole with ID '" + trimmedID + "' already exists in " + entityName + ". Please choose a different ID.", "error");
						return;
					}

					// Step 3b.4) Update the hole ID
					hole.holeID = trimmedID;

					// Step 3b.5) Save to IndexedDB
					if (typeof debouncedSaveBlastHoles === "function") {
						debouncedSaveBlastHoles();
					}

					// Step 3b.6) Update TreeView
					if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
						treeViewInstance.updateTreeData();
					}

					drawData(allBlastHoles, selectedHole);
					console.log("‚úÖ Hole ID renamed:", oldHoleID, "->", trimmedID, "in", entityName);
				}
			},
			function () {
				// Cancelled
			}
		);
		return;
	}
};

// Step 4) Handle multiple hole BlastName reassignment
window.handleTreeViewRenameMultipleHoles = function (nodeIds, treeViewInstance) {
	console.log("üéÑ [TreeView] BlastName reassignment requested for", nodeIds.length, "holes");

	// Step 4a) Extract all selected holes
	var selectedHolesList = [];
	nodeIds.forEach(function (nodeId) {
		var parts = nodeId.split("‚£ø");
		if (parts[0] === "hole" && parts.length === 3) {
			var entityName = parts[1];
			var holeID = parts[2];
			var hole = allBlastHoles.find(function (h) {
				return h.entityName === entityName && h.holeID === holeID;
			});
			if (hole) {
				selectedHolesList.push(hole);
			}
		}
	});

	if (selectedHolesList.length === 0) {
		console.log("üö´ [TreeView] No holes found for reassignment");
		return;
	}

	// Step 4b) Get list of existing blast names for selection
	var existingBlastNames = new Set();
	allBlastHoles.forEach(function (h) {
		if (h.entityName) {
			existingBlastNames.add(h.entityName);
		}
	});
	var blastNameOptions = Array.from(existingBlastNames).sort();

	// Step 4c) Build select options HTML
	var optionsHtml = blastNameOptions.map(function (name) {
		return "<option value=\"" + name + "\">" + name + "</option>";
	}).join("");

	// Step 4d) Create dialog content with select dropdown and new name input
	var dialogContent = document.createElement("div");
	dialogContent.innerHTML =
		"<p style=\"margin-bottom:10px;\">Reassign " + selectedHolesList.length + " hole(s) to a different blast pattern:</p>" +
		"<div style=\"margin-bottom:10px;\">" +
		"<label style=\"display:block;margin-bottom:5px;\">Select existing blast:</label>" +
		"<select id=\"blastNameSelect\" style=\"width:100%;padding:5px;\">" +
		"<option value=\"\">-- Select a blast --</option>" +
		optionsHtml +
		"<option value=\"__NEW__\">+ Create New Blast...</option>" +
		"</select>" +
		"</div>" +
		"<div id=\"newBlastNameDiv\" style=\"display:none;margin-bottom:10px;\">" +
		"<label style=\"display:block;margin-bottom:5px;\">New blast name:</label>" +
		"<input type=\"text\" id=\"newBlastNameInput\" style=\"width:100%;padding:5px;\" placeholder=\"Enter new blast name\">" +
		"</div>";

	// Step 4e) Create dialog
	var dialog = new FloatingDialog({
		title: "Reassign Holes to Blast",
		content: dialogContent,
		layoutType: "default",
		width: 400,
		height: 280,
		showConfirm: true,
		showCancel: true,
		confirmText: "Reassign",
		cancelText: "Cancel",
		onConfirm: function () {
			var selectEl = document.getElementById("blastNameSelect");
			var newNameInput = document.getElementById("newBlastNameInput");
			var targetBlastName = "";

			if (selectEl.value === "__NEW__") {
				targetBlastName = newNameInput.value.trim();
				if (!targetBlastName) {
					showModalMessage("Invalid Name", "Please enter a valid blast name.", "error");
					return;
				}
			} else if (selectEl.value) {
				targetBlastName = selectEl.value;
			} else {
				showModalMessage("No Selection", "Please select a blast pattern.", "error");
				return;
			}

			// Step 4f) Handle HoleID conflicts when moving to new blast
			// Generate unique suffix for conflicting IDs
			var generateUniqueCode = function () {
				var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
				var code = "";
				for (var i = 0; i < 4; i++) {
					code += chars.charAt(Math.floor(Math.random() * chars.length));
				}
				return code;
			};

			var existingHoleIDs = new Set();
			allBlastHoles.forEach(function (h) {
				if (h.entityName === targetBlastName) {
					existingHoleIDs.add(h.holeID);
				}
			});

			// Step 4g) Reassign holes with conflict resolution
			var renamedCount = 0;
			selectedHolesList.forEach(function (hole) {
				if (hole.entityName !== targetBlastName) {
					var newHoleID = hole.holeID;

					// Check for conflict and generate unique ID
					while (existingHoleIDs.has(newHoleID)) {
						newHoleID = hole.holeID + "_" + generateUniqueCode();
					}

					hole.entityName = targetBlastName;
					hole.holeID = newHoleID;
					existingHoleIDs.add(newHoleID);
					renamedCount++;
				}
			});

			// Step 4h) Save and update
			if (typeof debouncedSaveBlastHoles === "function") {
				debouncedSaveBlastHoles();
			}

			if (treeViewInstance && typeof treeViewInstance.updateTreeData === "function") {
				treeViewInstance.updateTreeData();
				treeViewInstance.clearSelection();
			}

			drawData(allBlastHoles, selectedHole);
			console.log("‚úÖ Reassigned", renamedCount, "holes to", targetBlastName);
			updateStatusMessage("Reassigned " + renamedCount + " holes to " + targetBlastName);
			setTimeout(function () { updateStatusMessage(""); }, 3000);
		},
		onCancel: function () {
			// Cancelled
		}
	});

	dialog.show();

	// Step 4i) Show/hide new blast name input based on selection
	setTimeout(function () {
		var selectEl = document.getElementById("blastNameSelect");
		var newBlastDiv = document.getElementById("newBlastNameDiv");
		if (selectEl && newBlastDiv) {
			selectEl.addEventListener("change", function () {
				newBlastDiv.style.display = selectEl.value === "__NEW__" ? "block" : "none";
			});
		}
	}, 100);
};

// Step 5) Handle TreeView show properties
window.handleTreeViewShowProperties = function (nodeId, type) {
	console.log("üéÑ [TreeView] Show properties for:", nodeId);

	const parts = nodeId.split("‚£ø");

	// KAD element properties
	if (parts.length >= 4 && parts[2] === "element") {
		const entityName = parts[1];
		const elementId = parts[3];

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data) {
			const element = entity.data.find(function (el) { return el.pointID == elementId; });
			if (element) {
				const kadObject = {
					...element,
					entityName: entityName,
					entityType: entity.entityType,
					elementIndex: entity.data.indexOf(element)
				};
				if (typeof window.showKADPropertyEditorPopup === "function") {
					window.showKADPropertyEditorPopup(kadObject);
				}
			}
		}
	}
	// KAD chunk properties (show first point in chunk range)
	else if (parts.length === 4 && parts[2] === "chunk") {
		const entityType = parts[0];
		const entityName = parts[1];
		const rangeStr = parts[3]; // e.g., "1-50"
		const rangeParts = rangeStr.split("-");
		const startIndex = parseInt(rangeParts[0]) - 1; // Convert to 0-based index

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data && entity.data[startIndex]) {
			const element = entity.data[startIndex];
			const kadObject = {
				...element,
				entityName: entityName,
				entityType: entity.entityType,
				elementIndex: startIndex
			};
			if (typeof window.showKADPropertyEditorPopup === "function") {
				window.showKADPropertyEditorPopup(kadObject);
			}
		}
	}
	// KAD entity properties (show first point in entity)
	else if ((parts[0] === "line" || parts[0] === "poly" || parts[0] === "points" ||
		parts[0] === "circle" || parts[0] === "text") && parts.length === 2) {
		const entityType = parts[0];
		const entityName = parts[1];

		const entity = allKADDrawingsMap.get(entityName);
		if (entity && entity.data && entity.data.length > 0) {
			const element = entity.data[0]; // Show first point
			const kadObject = {
				...element,
				entityName: entityName,
				entityType: entity.entityType,
				elementIndex: 0
			};
			if (typeof window.showKADPropertyEditorPopup === "function") {
				window.showKADPropertyEditorPopup(kadObject);
			}
		}
	}
	// Hole properties
	else if (parts[0] === "hole") {
		const entityName = parts[1];
		const holeID = parts[2];
		const hole = allBlastHoles.find(function (h) { return h.entityName === entityName && h.holeID === holeID; });
		if (hole && typeof showHolePropertyEditor === "function") {
			showHolePropertyEditor(hole);
		}
	}
	// Entity properties
	else if (parts[0] === "entity") {
		const entityName = parts.slice(1).join("‚£ø");
		const firstHole = allBlastHoles.find(function (h) { return h.entityName === entityName; });
		if (firstHole && typeof showHolePropertyEditor === "function") {
			showHolePropertyEditor(firstHole);
		}
	}
	// Surface properties
	else if (parts[0] === "surface") {
		const surfaceId = parts.slice(1).join("‚£ø");
		if (typeof window.showSurfaceContextMenu === "function") {
			// Use center of viewport as default position for TreeView-launched dialogs
			const centerX = window.innerWidth / 2;
			const centerY = window.innerHeight / 2;
			window.showSurfaceContextMenu(centerX, centerY, surfaceId);
		}
	}
	// Image properties  
	else if (parts[0] === "image") {
		const imageId = parts.slice(1).join("‚£ø");
		if (typeof window.showImageContextMenu === "function") {
			// Use center of viewport as default position for TreeView-launched dialogs
			const centerX = window.innerWidth / 2;
			const centerY = window.innerHeight / 2;
			window.showImageContextMenu(centerX, centerY, imageId);
		}
	}
};

// Step 5) Handle TreeView reset connections
window.handleTreeViewResetConnections = function (holeNodeIds) {
	console.log("üéÑ [TreeView] Reset connections for:", holeNodeIds.length, "holes");

	const holesToReset = [];
	holeNodeIds.forEach(function (nodeId) {
		const parts = nodeId.split("‚£ø");
		if (parts[0] === "hole" && parts.length === 3) {
			const entityName = parts[1];
			const holeID = parts[2];
			const hole = allBlastHoles.find(function (h) { return h.entityName === entityName && h.holeID === holeID; });
			if (hole) {
				holesToReset.push(hole);
			}
		}
	});

	if (holesToReset.length === 0) return;

	// Reset connections
	holesToReset.forEach(function (hole) {
		hole.fromHoleID = hole.entityName + ":::" + hole.holeID;
	});

	// Recalculate timing
	if (typeof calculateTimes === "function") {
		holeTimes = calculateTimes(allBlastHoles);
	}
	if (typeof recalculateContours === "function") {
		const result = recalculateContours(allBlastHoles, 0, 0);
		if (result) {
			contourLinesArray = result.contourLinesArray;
			directionArrows = result.directionArrows;
		}
	}

	drawData(allBlastHoles, selectedHole);
};

//=============================================================
// FLOATING DIALOG SYSTEM - NOW IMPORTED FROM MODULE
//=============================================================
// BUG FIX 6: Removed duplicate FloatingDialog code (736 lines)
// The FloatingDialog class is now imported from src/dialog/FloatingDialog.js
// This removes code duplication and ensures a single source of truth

// NOTE: FloatingDialog, createFormContent, createEnhancedFormContent,
// and showConfirmationDialog are all imported from the module
// Step 1) Create utility function for confirmation dialogs with 3 buttons
// Step 14) Load 3D settings from localStorage
function load3DSettings() {
	const defaultSettings = {
		dampingFactor: 0.05,
		cursorZoom: true,
		cursorOpacity: 0.2,
		lightBearing: 135,
		lightElevation: 15,
		ambientLightIntensity: 0.8,
		directionalLightIntensity: 2.5,
		shadowIntensity: 0.5,
		// Step 14a) Grid and Clipping Plane settings removed - not working properly
		// Keeping defaults for backward compatibility but not used in dialog
		clippingNear: -50000,
		clippingFar: 50000,
		showClippingPlane: false,
		previewClippingPlane: false,
		showGrid: false,
		gridSize: 10,
		gridOpacity: 0.3,
		gridPlane: "XY",
		gizmoDisplay: "only_when_orbit_or_rotate", // "always", "only_when_orbit_or_rotate", "never"
		axisLock: "none", // "none", "pitch", "roll", "yaw"
		textBillboarding: "off", // "off", "holes", "kad", "all" - which text types should billboard
	};

	const saved = localStorage.getItem("kirra3DSettings");
	if (saved) {
		try {
			const parsed = JSON.parse(saved);
			return { ...defaultSettings, ...parsed };
		} catch (e) {
			console.warn("Failed to parse 3D settings from localStorage:", e);
			return defaultSettings;
		}
	}

	return defaultSettings;
}

// Step 15) Save 3D settings to localStorage
function save3DSettings(settings) {
	try {
		localStorage.setItem("kirra3DSettings", JSON.stringify(settings));
		console.log("üíæ 3D settings saved to localStorage");
	} catch (e) {
		console.error("‚ùå Failed to save 3D settings to localStorage:", e);
	}
}

// Step 15a) Expose 3D settings functions on window for ThreeDSettingsDialog module
window.load3DSettings = load3DSettings;
window.save3DSettings = save3DSettings;

// Step 16) Show 3D Scene, Camera and Lighting Settings dialog
// Step 16a) Moved to separate module: src/dialog/popups/ThreeDSettingsDialog.js
// Step 16b) Function is now available via window.show3DSettingsDialog

// Step 17) Apply 3D settings
function apply3DSettings(settings) {
	// Step 17a) Update unified camera controls settings
	if (cameraControls) {
		const cameraSettings = {
			gizmoDisplay: settings.gizmoDisplay,
			axisLock: settings.axisLock,
			dampingFactor: settings.dampingFactor,
		};
		cameraControls.updateSettings(cameraSettings);

		// Step 17a.1) Update gizmo display immediately
		if (settings.gizmoDisplay !== undefined) {
			updateGizmoDisplay();
		}
	}

	// Step 17b) Update cursor opacity
	if (settings.cursorOpacity !== undefined) {
		window.cursorOpacity3D = settings.cursorOpacity;
	}

	// Step 17c) Update lighting
	if (threeRenderer) {
		if (settings.lightBearing !== undefined && settings.lightElevation !== undefined) {
			threeRenderer.updateLighting(settings.lightBearing, settings.lightElevation);
		}
		if (settings.ambientLightIntensity !== undefined) {
			threeRenderer.updateAmbientLightIntensity(settings.ambientLightIntensity);
		}
		if (settings.directionalLightIntensity !== undefined) {
			threeRenderer.updateDirectionalLightIntensity(settings.directionalLightIntensity);
		}
		if (settings.shadowIntensity !== undefined && typeof threeRenderer.updateShadowIntensity === "function") {
			threeRenderer.updateShadowIntensity(settings.shadowIntensity);
		}
	}

	// Step 17d) Update orbit center (needed for camera controls, removed grid-specific code)
	if (threeRenderer) {
		const centroid = calculateDataCentroid();
		if (typeof threeRenderer.setOrbitCenter === "function") {
			threeRenderer.setOrbitCenter(centroid.x, centroid.y, centroid.z);
		}
	}

	// Step 17e) Request re-render to apply changes
	if (threeRenderer) {
		threeRenderer.requestRender();
	}
}

// Step 17f) Expose apply3DSettings on window for ThreeDSettingsDialog module
window.apply3DSettings = apply3DSettings;

// Step 17g) Update gizmo display based on current mode and state
function updateGizmoDisplay() {
	if (!cameraControls || !threeRenderer) return;

	const gizmoMode = cameraControls.gizmoDisplayMode || "only_when_orbit_or_rotate";
	const isOrbiting = cameraControls.isOrbiting || false;
	const isRotating = cameraControls.isRotating || false;

	if (gizmoMode === "always") {
		// Step 17g1) Always show gizmo
		const currentState = cameraControls.getCameraState();
		threeRenderer.showAxisHelper(true, currentState.centroidX, currentState.centroidY, currentState.scale);
	} else if (gizmoMode === "only_when_orbit_or_rotate") {
		// Step 17g2) Show only when orbiting or rotating
		if (isOrbiting || isRotating) {
			const currentState = cameraControls.getCameraState();
			threeRenderer.showAxisHelper(true, currentState.centroidX, currentState.centroidY, currentState.scale);
		} else {
			threeRenderer.showAxisHelper(false);
		}
	} else if (gizmoMode === "never") {
		// Step 17g3) Never show gizmo
		threeRenderer.showAxisHelper(false);
	}
}

// NOTE: showConfirmationThreeDialog and showModalMessage are imported from FloatingDialog.js module

//CONTEXT DIALOG FOR HOLE MODIFICATION
// MOVED TO HolesContextMenu.js - These functions are now loaded from external module
// showHolePropertyEditor, processHolePropertyUpdates
// END OF MOVED FUNCTIONS - Holes functions now loaded from HolesContextMenu.js

//For Kad entities
// Step 1) Hole Property Dialogs - Removed 717 lines (41311-42027)
// Step 2) All 7 property dialog functions now in HolePropertyDialogs.js
// Step 3) Functions: renameEntityDialog, editBlastNamePopup, editHoleTypePopup, editHoleLengthPopup, measuredLengthPopup, measuredMassPopup, measuredCommentPopup
// Step 4) Loaded via <script> tag in kirra.html, exposed globally via window object

//===========================================
// FLOATING DIALOG END
//===========================================

//===========================================
// MINIMAL SAFE OVERLAY FOR THE APP
//===========================================
// Around line 39636, replace the problematic section with this clean version:

// Step 1) Initialize overlay system variables
// Note: contourOverlayCanvas and contourOverlayCtx are forward-declared earlier in the file
let useContourOverlay = false;

// Step 2) Create overlay canvas with proper positioning
function createContourOverlay() {
	if (contourOverlayCanvas) return;

	const mainCanvas = canvas;
	const container = mainCanvas.parentElement;

	contourOverlayCanvas = document.createElement("canvas");
	contourOverlayCtx = contourOverlayCanvas.getContext("2d");

	contourOverlayCanvas.width = mainCanvas.width;
	contourOverlayCanvas.height = mainCanvas.height;
	contourOverlayCanvas.style.position = "absolute";
	contourOverlayCanvas.style.left = "0";
	contourOverlayCanvas.style.top = "0";
	contourOverlayCanvas.style.zIndex = "10";
	contourOverlayCanvas.style.pointerEvents = "none";
	contourOverlayCanvas.style.width = mainCanvas.style.width;
	contourOverlayCanvas.style.height = mainCanvas.style.height;

	container.appendChild(contourOverlayCanvas);
	console.log("Contour overlay " + "created");
}

// Step 5) Synchronize overlay with main canvas dimensions
function syncOverlayWithMainCanvas() {
	if (!contourOverlayCanvas || !canvas) return;

	contourOverlayCanvas.width = canvas.width;
	contourOverlayCanvas.height = canvas.height;

	contourOverlayCanvas.style.width = canvas.style.width || canvas.width + "px";
	contourOverlayCanvas.style.height = canvas.style.height || canvas.height + "px";

	contourOverlayCanvas.style.left = canvas.offsetLeft + "px";
	contourOverlayCanvas.style.top = canvas.offsetTop + "px";
}

// Step 6) Draw contours on overlay with proper coordinate transformation
function drawContoursOnOverlayFixed() {
	if (!contourOverlayCanvas || !useContourOverlay) return;

	// Step 6.1) Don't draw 2D contour overlay when in 3D-only mode
	if (onlyShowThreeJS) {
		contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
		return;
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (!displayContours.checked || !contourLinesArray) {
		console.log("Contours disabled " + "or no data");
		return;
	}

	//console.log("Drawing overlay contours - " + "levels: " + contourLinesArray.length);
	drawBrightContoursFixed();
}

// Step 7) Draw bright contours with theme-aware colors
function drawBrightContoursFixed() {
	if (!contourLinesArray || contourLinesArray.length === 0) return;

	// Step 3a: Calculate interval
	const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
	let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
	if (typeof intervalAmount !== "undefined") {
		interval = parseInt(intervalAmount);
	}

	// Step 3b: Set up theme-aware contour colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	//console.log("Drawing with interval: " + interval + " (Dark mode: " + darkModeEnabled + ")");

	// Step 3c: Process each contour level
	for (let level = 0; level < contourLinesArray.length; level++) {
		const contourLevel = contourLinesArray[level];
		if (!contourLevel || contourLevel.length === 0) continue;

		const contourTime = level * interval;
		const color = colors[level % colors.length];

		//console.log("Level " + level + " (" + contourTime + "ms): " + contourLevel.length + " lines in " + color);

		// Step 3d: Remove line style settings (handled in drawAlternatingDashLine)
		let linesDrawn = 0;

		// Step 3e: Draw each line segment in this level
		for (let i = 0; i < contourLevel.length; i++) {
			const line = contourLevel[i];
			if (!line || !line[0] || !line[1]) continue;

			// Step 3f: Extract coordinates using your structure (line[0].x, line[0].y, line[1].x, line[1].y)
			const startWorldX = line[0].x;
			const startWorldY = line[0].y;
			const endWorldX = line[1].x;
			const endWorldY = line[1].y;

			// Step 3g: Transform to screen coordinates
			const startScreenX = (startWorldX - centroidX) * currentScale + canvas.width / 2;
			const startScreenY = (-startWorldY + centroidY) * currentScale + canvas.height / 2;
			const endScreenX = (endWorldX - centroidX) * currentScale + canvas.width / 2;
			const endScreenY = (-endWorldY + centroidY) * currentScale + canvas.height / 2;

			// Step 3h: Draw alternating colored dashes
			drawAlternatingDashLine(startScreenX, startScreenY, endScreenX, endScreenY);

			linesDrawn++;

			// Step 3i: Add time labels at 1/3 and 2/3 marks
			const totalLines = contourLevel.length;
			const oneThirdMark = Math.floor(totalLines / 3);
			const twoThirdsMark = Math.floor((totalLines * 2) / 3);

			if (i === oneThirdMark || i === twoThirdsMark) {
				const midX = (startScreenX + endScreenX) / 2;
				const midY = (startScreenY + endScreenY) / 2;
				drawTimeLabelFixed(midX, midY, contourTime + "ms", "#" + "FFFFFF");
			}
		}

		//console.log("Drew " + linesDrawn + " line segments for level " + level);
	}

	//console.log("Bright contours " + "drawn on overlay");
}

// Step 13) Draw alternating colored dash lines
function drawAlternatingDashLine(x1, y1, x2, y2) {
	// Step 4a: Calculate line properties
	const totalLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	const angle = Math.atan2(y2 - y1, x2 - x1);
	const dashLength = 10; // 10px dashes

	// Step 4b: Theme-aware dash colors
	const colors = darkModeEnabled
		? ["#FFFF00", "#FF00FF"] // Bright yellow & cyan for dark mode
		: ["#FF00FF", "#FFFF00"]; // Orange & magenta for light mode

	contourOverlayCtx.lineWidth = 3;
	contourOverlayCtx.lineCap = "butt";

	let currentDistance = 0;
	let colorIndex = 0;

	// Step 4b: Draw alternating colored segments
	while (currentDistance < totalLength) {
		const segmentStart = currentDistance;
		const segmentEnd = Math.min(currentDistance + dashLength, totalLength);

		// Step 4c: Calculate segment coordinates
		const startX = x1 + Math.cos(angle) * segmentStart;
		const startY = y1 + Math.sin(angle) * segmentStart;
		const endX = x1 + Math.cos(angle) * segmentEnd;
		const endY = y1 + Math.sin(angle) * segmentEnd;

		// Step 4d: Draw segment with alternating color
		contourOverlayCtx.strokeStyle = colors[colorIndex % colors.length];
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(startX, startY);
		contourOverlayCtx.lineTo(endX, endY);
		contourOverlayCtx.stroke();

		currentDistance += dashLength;
		colorIndex++;
	}
}

// Step 14) Draw time labels with theme-aware styling
function drawTimeLabelFixed(x, y, text, color) {
	// Step 5a: Use theme-aware background color
	const backgroundColor = darkModeEnabled ? "rgba(0, 0, 0,0.6)" : "rgba(255, 255, 255,0.6)";

	contourOverlayCtx.fillStyle = backgroundColor;
	contourOverlayCtx.font = "bold " + "16px Arial";
	const metrics = contourOverlayCtx.measureText(text);
	const padding = 6;
	// Step 5a1: Draw rounded rectangle background
	const rectX = x - metrics.width / 2 - padding;
	const rectY = y - 8 - padding;
	const rectWidth = metrics.width + padding * 2;
	const rectHeight = 16 + padding * 2;
	const radius = 4;

	contourOverlayCtx.beginPath();
	contourOverlayCtx.moveTo(rectX + radius, rectY);
	contourOverlayCtx.lineTo(rectX + rectWidth - radius, rectY);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + radius);
	contourOverlayCtx.lineTo(rectX + rectWidth, rectY + rectHeight - radius);
	contourOverlayCtx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - radius, rectY + rectHeight);
	contourOverlayCtx.lineTo(rectX + radius, rectY + rectHeight);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - radius);
	contourOverlayCtx.lineTo(rectX, rectY + radius);
	contourOverlayCtx.quadraticCurveTo(rectX, rectY, rectX + radius, rectY);
	contourOverlayCtx.closePath();
	contourOverlayCtx.fill();

	// Step 5b: Use standard text color from your theme system
	contourOverlayCtx.fillStyle = textFillColor; // Uses your global theme variable
	contourOverlayCtx.textAlign = "center";
	contourOverlayCtx.textBaseline = "middle";
	contourOverlayCtx.fillText(text, x, y);
}
// Step 5X: Toggle overlay on/off
function toggleContourOverlayFixed() {
	useContourOverlay = !useContourOverlay;

	if (useContourOverlay) {
		// Step 5a: Create overlay canvas
		createContourOverlay();

		// Step 5b: Enable contours if needed
		if (!displayContours.checked) {
			displayContours.checked = true;
			drawData(allBlastHoles, selectedHole);
		}

		// Step 5c: Draw contours on overlay
		setTimeout(() => {
			drawContoursOnOverlayFixed();
		}, 100);
	} else {
		// Step 5d: Clear overlay when disabled
		if (contourOverlayCanvas) {
			contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);
		}
	}
}

// Step 6: Update overlay colors when dark mode changes
function updateOverlayColorsForTheme() {
	if (useContourOverlay) {
		drawContoursOnOverlayFixed(); // Redraw with new colors?
	}
}

// Step 7: Hook into your existing dark mode system
function hookOverlayIntoThemeSystem() {
	// Step 7a: Hook into your updateColorsForDarkMode function
	const originalUpdateColors = window.updateColorsForDarkMode;
	if (typeof originalUpdateColors === "function") {
		window.updateColorsForDarkMode = function () {
			const result = originalUpdateColors.apply(this, arguments);
			updateOverlayColorsForTheme(); // Update overlay when theme changes
			return result;
		};
		console.log("üé® Overlay hooked into theme system");
	}

	// Step 7b: Hook into dark mode toggle
	const darkModeToggle = document.getElementById("darkModeToggle");
	if (darkModeToggle) {
		darkModeToggle.addEventListener("change", function () {
			setTimeout(() => {
				updateOverlayColorsForTheme(); // Update overlay after theme change
			}, 50);
		});
	}
}

function debugCorrectVariables() {
	console.log("=== USING YOUR EXACT VARIABLES ===");
	console.log("displayContours.checked: " + (typeof displayContours !== "undefined" ? displayContours.checked : "undefined"));
	console.log("contourLinesArray: " + (typeof contourLinesArray !== "undefined" ? contourLinesArray?.length + " levels" : "undefined"));
	console.log("centroidX: " + (typeof centroidX !== "undefined" ? centroidX : "undefined"));
	console.log("centroidY: " + (typeof centroidY !== "undefined" ? centroidY : "undefined"));
	console.log("currentScale: " + (typeof currentScale !== "undefined" ? currentScale : "undefined"));
	console.log("canvas size: " + (typeof canvas !== "undefined" ? canvas.width + "x" + canvas.height : "undefined"));
}

function testDrawOnOverlay() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	// Step 7a: Draw bright test rectangle
	contourOverlayCtx.fillStyle = "#FF0000";
	contourOverlayCtx.fillRect(100, 100, 200, 200);

	// Step 7b: Draw bright test text
	contourOverlayCtx.fillStyle = "#FFFF00";
	contourOverlayCtx.font = "bold " + "32px Arial";
	contourOverlayCtx.fillText("OVERLAY TEST", 150, 150);

	console.log("Drew test rectangle " + "and text on overlay");
}

function drawTestContourLine() {
	if (!contourOverlayCanvas) {
		createContourOverlay();
	}

	contourOverlayCtx.clearRect(0, 0, contourOverlayCanvas.width, contourOverlayCanvas.height);

	if (allBlastHoles && allBlastHoles.length >= 2) {
		const hole1 = allBlastHoles[0];
		const hole2 = allBlastHoles[1];

		// Step 7c: Use same coordinate transformation as contours
		const x1 = (hole1.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y1 = (-hole1.startYLocation + centroidY) * currentScale + canvas.height / 2;
		const x2 = (hole2.startXLocation - centroidX) * currentScale + canvas.width / 2;
		const y2 = (-hole2.startYLocation + centroidY) * currentScale + canvas.height / 2;

		console.log("Drawing test line from " + x1 + "," + y1 + " to " + x2 + "," + y2);

		// Step 7d: Draw bright test line
		contourOverlayCtx.strokeStyle = "#00FF00";
		contourOverlayCtx.lineWidth = 5;
		contourOverlayCtx.setLineDash([]);
		contourOverlayCtx.beginPath();
		contourOverlayCtx.moveTo(x1, y1);
		contourOverlayCtx.lineTo(x2, y2);
		contourOverlayCtx.stroke();

		// Step 7e: Add markers at endpoints
		contourOverlayCtx.fillStyle = "#" + "FF0000";
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x1, y1, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();
		contourOverlayCtx.beginPath();
		contourOverlayCtx.arc(x2, y2, 10, 0, 2 * Math.PI);
		contourOverlayCtx.fill();

		console.log("Drew test line between " + "first two blast holes");
	}
}

// Step 8: Auto-update hooks - Add these to integrate with your existing code
function hookOverlayIntoExistingFunctions() {
	// Step 8a: Hook into drawData function
	if (typeof window.drawData === "function") {
		const originalDrawData = window.drawData;
		window.drawData = function () {
			const result = originalDrawData.apply(this, arguments);
			updateOverlayColorsForTheme(); // Auto-update overlay
			return result;
		};
		console.log("Hooked into drawData");
	}

	// Step 8b: Hook into recalculateContours function
	if (typeof window.recalculateContours === "function") {
		const originalRecalculateContours = window.recalculateContours;
		window.recalculateContours = function () {
			const result = originalRecalculateContours.apply(this, arguments);
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 50); // Small delay for data to update
			}
			return result;
		};
		console.log("Hooked into recalculateContours");
	}

	// Step 8c: Hook into pan/zoom events if canvas has event listeners
	const originalAddEventListener = canvas.addEventListener;
	canvas.addEventListener = function (event, handler) {
		if (event === "wheel" || event === "mousemove") {
			const wrappedHandler = function () {
				const result = handler.apply(this, arguments);
				if (useContourOverlay) {
					updateOverlayColorsForTheme();
				}
				return result;
			};
			return originalAddEventListener.call(this, event, wrappedHandler);
		}
		return originalAddEventListener.call(this, event, handler);
	};

	// Step 8d: Hook into contour checkbox changes
	const contourCheckbox = displayContours;
	if (contourCheckbox && contourCheckbox.addEventListener) {
		contourCheckbox.addEventListener("change", function () {
			if (useContourOverlay) {
				setTimeout(() => updateOverlayColorsForTheme(), 100);
			}
		});
		console.log("Hooked into contour checkbox");
	}
}

// Step 19) Hook into resize events
function hookOverlayIntoResize() {
	window.addEventListener("resize", function () {
		if (contourOverlayCanvas && useContourOverlay) {
			// Resize overlay to match main canvas
			contourOverlayCanvas.width = canvas.width;
			contourOverlayCanvas.height = canvas.height;
			contourOverlayCanvas.style.width = canvas.style.width;
			contourOverlayCanvas.style.height = canvas.style.height;

			// Redraw with new size - contour overlay updates on next drawData call
		}
	});
	console.log("Hooked into window resize");
}

// Step 21) Enable auto-update system
function enableAutoUpdate() {
	hookOverlayIntoExistingFunctions();
	hookOverlayIntoThemeSystem();
	hookOverlayIntoResize(); // Add this line
	console.log("Auto-update enabled - overlay will update automatically");
}

// Step 10: Usage instructions with auto-update
console.log("Complete overlay system ready:");
console.log("1. debugContourStructure() - Check your contour data structure");
console.log("2. debugCorrectVariables() - Check variable availability");
console.log("3. testDrawOnOverlay() - Test overlay with simple shapes");
console.log("4. drawTestContourLine() - Test with blast hole coordinates");
console.log("5. toggleContourOverlayFixed() - Enable bright contour overlay");
console.log("6. enableAutoUpdate() - Enable automatic updates (RECOMMENDED)");
console.log("7. updateOverlayColorsForTheme() - Manual update if needed");
console.log("Theme-aware overlay system ready:");
console.log("- Colors automatically adapt to light/dark mode");
console.log("- Text uses standard theme colors (textFillColor)");
console.log("- Backgrounds use theme-appropriate opacity");
console.log("- Updates automatically when theme changes");

// Auto-enable the hooks when overlay system loads
console.log("Setting up auto-update hooks...");
if (typeof window.drawData === "function") {
	enableAutoUpdate();
}

//===========================================
// END OF MINIMAL SAFE OVERLAY FOR THE APP
//===========================================

//===========================================
// Step 1) Inline Contour Calculation (moved from webworker)
//===========================================

// Step 2) Interpolation function - essential for contour crossing points
function interpolateContourPoint(p1, p2, contourLevel) {
	const t = (contourLevel - p1.z) / (p2.z - p1.z);
	return {
		x: p1.x + t * (p2.x - p1.x),
		y: p1.y + t * (p2.y - p1.y),
	};
}

// Step 3) Main contour calculation function - now runs in main thread
function calculateContoursSync(contourData, contourLevels, maxEdgeLength, displayOptions) {
	const { displayContours, displayFirstMovements, displayRelief, firstMovementSize = 2 } = displayOptions;

	// Step 4) Early return if no display options enabled
	if (!displayContours && !displayFirstMovements && !displayRelief) {
		return {
			contourLinesArray: [],
			directionArrows: [],
		};
	}

	if (!contourData || !Array.isArray(contourData) || contourData.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	const factor = 1.6;
	const minAngleThreshold = 5;
	const surfaceAreaThreshold = 0.1;

	// Step 5) Filter out holes where holeTime is null
	const filteredContourData = contourData.filter((hole) => hole.holeTime !== null);

	if (filteredContourData.length < 3) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	// Step 6) Helper function for distance calculation
	function getLocalAverageDistance(targetPoint, allPoints, neighborCount = 6) {
		const distances = [];

		for (let i = 0; i < allPoints.length; i++) {
			if (allPoints[i] === targetPoint) continue;

			const dx = targetPoint.x - allPoints[i].x;
			const dy = targetPoint.y - allPoints[i].y;
			const distance = Math.sqrt(dx * dx + dy * dy);
			distances.push(distance);
		}

		distances.sort((a, b) => a - b);
		const nearestDistances = distances.slice(0, Math.min(neighborCount, distances.length));

		return nearestDistances.length > 0 ? nearestDistances.reduce((sum, dist) => sum + dist, 0) / nearestDistances.length : maxEdgeLength;
	}

	// Step 7) Cache for performance
	const localAverageCache = new Map();
	function getCachedLocalAverage(point) {
		if (!localAverageCache.has(point)) {
			localAverageCache.set(point, getLocalAverageDistance(point, filteredContourData, 6));
		}
		return localAverageCache.get(point);
	}

	// Step 8) Compute Delaunay triangulation
	const delaunay = Delaunay.from(filteredContourData.map((hole) => [hole.x, hole.y]));
	const triangles = delaunay.triangles;

	if (!triangles || triangles.length === 0) {
		return { contourLinesArray: [], directionArrows: [] };
	}

	const contourLinesArray = [];
	const directionArrows = [];

	// Step 9) Process each contour level
	for (let levelIndex = 0; levelIndex < contourLevels.length; levelIndex++) {
		const contourLevel = contourLevels[levelIndex];
		const contourLines = [];

		// Step 10) Process triangles for this contour level
		for (let i = 0; i < triangles.length; i += 3) {
			const contourLine = [];

			const p1 = contourData[triangles[i]];
			const p2 = contourData[triangles[i + 1]];
			const p3 = contourData[triangles[i + 2]];

			// Step 11) Get cached local average distances for adaptive filtering
			const p1LocalAvg = getCachedLocalAverage(p1);
			const p2LocalAvg = getCachedLocalAverage(p2);
			const p3LocalAvg = getCachedLocalAverage(p3);

			const triangleLocalAverage = (p1LocalAvg + p2LocalAvg + p3LocalAvg) / 3;
			const adaptiveMaxEdgeLength = Math.min(maxEdgeLength, triangleLocalAverage * factor);

			// Step 12) Calculate triangle properties for direction arrows
			const centroidX = (p1.x + p2.x + p3.x) / 3;
			const centroidY = (p1.y + p2.y + p3.y) / 3;

			// Step 13) Calculate edge lengths and check filtering
			const edge1Length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
			const edge2Length = Math.sqrt(Math.pow(p3.x - p2.x, 2) + Math.pow(p3.y - p2.y, 2));
			const edge3Length = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));

			let trianglePassesFilter = true;
			if (edge1Length > adaptiveMaxEdgeLength || edge2Length > adaptiveMaxEdgeLength || edge3Length > adaptiveMaxEdgeLength) {
				trianglePassesFilter = false;
			}

			// Step 14) Check triangle angles to reject acute triangles
			if (trianglePassesFilter) {
				const edge1Squared = edge1Length * edge1Length;
				const edge2Squared = edge2Length * edge2Length;
				const edge3Squared = edge3Length * edge3Length;

				const angle1 = Math.acos(Math.max(-1, Math.min(1, (edge2Squared + edge3Squared - edge1Squared) / (2 * edge2Length * edge3Length)))) * (180 / Math.PI);
				const angle2 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge3Squared - edge2Squared) / (2 * edge1Length * edge3Length)))) * (180 / Math.PI);
				const angle3 = Math.acos(Math.max(-1, Math.min(1, (edge1Squared + edge2Squared - edge3Squared) / (2 * edge1Length * edge2Length)))) * (180 / Math.PI);

				const minAngle = Math.min(angle1, angle2, angle3);
				if (minAngle < minAngleThreshold) {
					trianglePassesFilter = false;
				}
			}

			// Step 15) Only process triangles that pass filtering
			if (trianglePassesFilter) {
				// Step 16) Create direction arrows for first movement
				if (levelIndex === 0 && displayFirstMovements) {
					const surfaceArea = Math.abs((p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2);

					if (surfaceArea > surfaceAreaThreshold) {
						const v1X = p2.x - p1.x;
						const v1Y = p2.y - p1.y;
						const v1Z = p2.z - p1.z;

						const v2X = p3.x - p1.x;
						const v2Y = p3.y - p1.y;
						const v2Z = p3.z - p1.z;

						const slopeX = v1Y * v2Z - v1Z * v2Y;
						const slopeY = v1Z * v2X - v1X * v2Z;
						const slopeLength = Math.sqrt(slopeX * slopeX + slopeY * slopeY);

						if (slopeLength > 0) {
							const normSlopeX = slopeX / slopeLength;
							const normSlopeY = slopeY / slopeLength;

							const arrowEndX = centroidX - normSlopeX * firstMovementSize;
							const arrowEndY = centroidY - normSlopeY * firstMovementSize;

							directionArrows.push([centroidX, centroidY, arrowEndX, arrowEndY, "goldenrod", firstMovementSize]);
						}
					}
				}

				// Step 17) Check each edge for contour level crossings
				for (let j = 0; j < 3; j++) {
					const edgeP1 = contourData[triangles[i + j]];
					const edgeP2 = contourData[triangles[i + ((j + 1) % 3)]];

					// Step 18) Calculate distance between edge points
					const distance = Math.sqrt(Math.pow(edgeP2.x - edgeP1.x, 2) + Math.pow(edgeP2.y - edgeP1.y, 2));

					// Step 19) CRITICAL: Only create contour point if level crosses the edge
					if (distance <= adaptiveMaxEdgeLength && ((edgeP1.z < contourLevel && edgeP2.z >= contourLevel) || (edgeP1.z >= contourLevel && edgeP2.z < contourLevel))) {
						// Step 20) Interpolate to find exact crossing point
						const point = interpolateContourPoint(edgeP1, edgeP2, contourLevel);
						contourLine.push(point);
					}
				}

				// Step 21) Only add contour line if it has exactly 2 points (proper line segment)
				if (contourLine.length === 2) {
					contourLines.push(contourLine);
				}
			}
		}

		// Step 22) Add this level's contour lines to the array
		contourLinesArray.push(contourLines);
	}

	// Step 23) Filter direction arrows
	const interval = 1;
	const filteredArrows = directionArrows.filter((arrow, index) => index % interval === 0);

	return {
		contourLinesArray,
		directionArrows: filteredArrows,
	};
}

// Step 24) Delaunay contours - now calls synchronous version
function delaunayContours(contourData, contourLevel, maxEdgeLength) {
	// Step 25) Calculate all contour levels
	const maxHoleTime = Math.max(...allBlastHoles.map((hole) => hole.holeTime || 0).filter((t) => t > 0));
	let interval = maxHoleTime < 350 ? 25 : maxHoleTime < 700 ? 100 : 250;
	if (typeof intervalAmount !== "undefined") {
		interval = parseInt(intervalAmount);
	}

	const numLevels = Math.ceil(maxHoleTime / interval) || 13;
	const contourLevels = [];
	for (let level = 0; level < numLevels; level++) {
		contourLevels.push(level * interval);
	}

	// Step 26) Prepare contour data
	const processedData = contourData.map((hole) => ({
		x: hole.x,
		y: hole.y,
		z: hole.z || hole.holeTime || 0,
		holeTime: hole.holeTime,
	}));

	// Step 27) Call synchronous calculation
	const displayOptions = {
		displayContours: displayContours ? displayContours.checked : false,
		displayFirstMovements: displayFirstMovements ? displayFirstMovements.checked : false,
		displayRelief: displayRelief ? displayRelief.checked : false,
		firstMovementSize: firstMovementSize || 2,
	};

	return calculateContoursSync(processedData, contourLevels, maxEdgeLength, displayOptions);
}

console.log("‚úÖ Contour calculations now run in main thread (synchronous)");

//===========================================
// END OF Inline Contour Calculation
//===========================================

document.addEventListener("DOMContentLoaded", function () {
	console.log("üöÄ Starting application initialization...");

	// Add click handlers for all file import icon buttons
	const fileImportButtons = document.querySelectorAll(".file-import-btn");

	fileImportButtons.forEach((button) => {
		button.addEventListener("click", function () {
			const targetId = this.getAttribute("data-target");
			const fileInput = document.getElementById(targetId);
			if (fileInput) {
				fileInput.click();
			}
		});
	});

	// Just hide the panel
	const treePanel = document.getElementById("treePanel");
	if (treePanel) {
		treePanel.style.display = "none";
	}

	// Toggle TreeView panel visibility (TreeView is now created in background automatically)
	document.getElementById("showTreeBtn").addEventListener("click", function () {
		// Ensure TreeView exists (should already be created in background)
		if (!treeView) {
			console.log("üå≥ Creating TreeView on demand (should have been created in background)...");
			treeView = new TreeView("treePanel");
			updateTreeView();
		}

		// Toggle panel visibility
		const treePanel = document.getElementById("treePanel");
		if (treePanel) {
			if (treePanel.style.display === "none" || !treePanel.style.display) {
				treePanel.style.display = "flex";
				// FIX: Populate tree immediately when opened (use cached data if available)
				if (treeView && treeView._cachedTreeData) {
					var tree = [
						{ id: "blast", type: "blast", label: "Blast", expanded: true, children: treeView._cachedTreeData.blastData },
						{ id: "drawings", type: "drawing", label: "Drawings", expanded: true, children: treeView._cachedTreeData.drawingData },
						{ id: "surfaces", type: "surface", label: "Surfaces", expanded: true, children: treeView._cachedTreeData.surfaceData || [] },
						{ id: "images", type: "image", label: "Images", expanded: true, children: treeView._cachedTreeData.imageData || [] }
					];
					var html = treeView.renderTree(tree);
					var treeViewElement = document.getElementById("treeView");
					if (treeViewElement) {
						treeViewElement.innerHTML = html;
					}
				} else {
					// No cached data, trigger update
					treeView.updateTreeData();
				}
			} else {
				treePanel.style.display = "none";
			}
		}
	});

	addPlaySpeedMarkers();
	updateConnectDistance(); // Set initial value based on current slider position
	addConnectDistanceMarkers(); // Add visual scale markers

	// ? CRITICAL: Add handleMouseMove and handleTouchMove listeners ONLY ONCE here
	// These are for general mouse tracking and crosshairs, and should always be active.
	// Ensure 'canvas' is defined globally or accessible here.
	if (typeof canvas !== "undefined" && canvas !== null) {
		// Add a check for 'canvas' existence
		canvas.addEventListener("mousemove", handleMouseMove);
		canvas.addEventListener("touchmove", handleTouchMove);
	}
	// Also add to document if you need tracking outside the canvas area.
	document.addEventListener("mousemove", handleMouseMove);
	document.addEventListener("touchmove", handleTouchMove);
	// Initialize overlay system automatically
	setTimeout(() => {
		if (typeof debugCorrectVariables === "function") {
			debugCorrectVariables(); // Check variables are ready
			enableAutoUpdate(); // Set up automatic hooks
			console.log("Overlay system initialized and ready");
		}
	}, 1000); // Small delay to ensure all your variables are loaded
	// The rest of your initialization code...
	setTimeout(function () {
		getDarkModeSettings();
		// updatePopup(); // remove and call from the initDB function
		initializeVoronoiControls();

		// Longer delay for jscolor
		setTimeout(function () {
			initializePreferences();
		}, 200);

		console.log("‚úÖ Application initialization complete");
		debugPreferences();
	}, 50);
});

