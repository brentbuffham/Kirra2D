// src/fileIO/EpirocIO/IREDESWriter.js
//=============================================================
// IREDES (EPIROC) XML WRITER
//=============================================================
// Step 1) Export blast hole data to Epiroc IREDES XML format
// Step 2) Supports drill plan XML with CRC32 checksum validation
// Step 3) Migrated from ExportDialogs.js to FileManager system
// Step 4) Created: 2026-01-07

import BaseWriter from "../BaseWriter.js";

export default class IREDESWriter extends BaseWriter {
	constructor(options = {}) {
		super(options);
		this.options = options;
	}

	// Step 5) Main write entry point
	async write(data) {
		// Step 6) Validate input data
		if (!data || !data.holes || !Array.isArray(data.holes)) {
			throw new Error("IREDESWriter requires holes array");
		}

		// Step 7) Extract parameters from data object
		var holes = data.holes;
		var filename = data.filename || "DrillPlan_XML";
		var planID = data.planID || "PLAN001";
		var siteID = data.siteID || "SiteName";
		var notes = data.notes || "Notes";
		var holeOptions = data.holeOptions !== undefined ? data.holeOptions : true;
		var mwd = data.mwd !== undefined ? data.mwd : true;
		var chksumType = data.chksumType || "CRC32-DECIMAL";
		var holeTypeHandling = data.holeTypeHandling || "Undefined";

		// Step 8) Process notes - limit to 200 characters and remove line breaks
		var processedNotes = notes.replace(/[\r\n]/g, " ").substring(0, 200);

		// Step 9) Generate IREDES XML content
		var xmlContent = this.generateIREDESXML(holes, filename, planID, siteID, holeOptions, mwd, chksumType, processedNotes, holeTypeHandling);

		// Step 10) Create Blob for download
		var blob = this.createBlob(xmlContent, "text/xml;charset=utf-8");

		return blob;
	}

	// Step 11) Core IREDES XML generation logic (extracted from ExportDialogs.js)
	generateIREDESXML(allBlastHoles, filename, planID, siteID, holeOptions, mwd, chksumType, notes, holeTypeHandling) {
		// Step 12) Validate holes array
		if (!allBlastHoles || !Array.isArray(allBlastHoles) || allBlastHoles.length === 0) {
			console.warn("IREDESWriter: No holes to export");
			return "";
		}

		// Step 13) Get current date and convert to computer time zone
		var now = new Date();
		now.setMinutes(now.getMinutes() - now.getTimezoneOffset());

		var iredesPoints = [];

		// Step 14) Process hole types based on the selected handling option
		var holeTypeMapping = {};

		if (holeTypeHandling === "convert") {
			// Step 15) Group holes by type and assign integers 1-15
			var uniqueTypes = [];
			for (var i = 0; i < allBlastHoles.length; i++) {
				var type = allBlastHoles[i].holeType || "Production";
				if (uniqueTypes.indexOf(type) === -1) {
					uniqueTypes.push(type);
				}
			}

			for (var i = 0; i < uniqueTypes.length && i < 15; i++) {
				holeTypeMapping[uniqueTypes[i]] = (i + 1).toString();
			}
		} else if (holeTypeHandling === "Undefined") {
			// Step 16) Set all hole types to "Undefined"
			for (var i = 0; i < allBlastHoles.length; i++) {
				var type = allBlastHoles[i].holeType || "Production";
				holeTypeMapping[type] = "Undefined";
			}
		}

		// Step 17) Build iredesPoints array with processed hole types
		for (var i = 0; i < allBlastHoles.length; i++) {
			var hole = allBlastHoles[i];
			var processedHoleType = hole.holeType || "Production";

			// Step 18) Apply hole type processing based on the selected option
			if (holeTypeHandling === "convert" && holeTypeMapping[processedHoleType]) {
				processedHoleType = holeTypeMapping[processedHoleType];
			} else if (holeTypeHandling === "Undefined") {
				processedHoleType = "Undefined";
			}

			iredesPoints.push({
				holeID: hole.holeID,
				startXLocation: hole.startXLocation,
				startYLocation: hole.startYLocation,
				startZLocation: hole.startZLocation,
				endXLocation: hole.endXLocation,
				endYLocation: hole.endYLocation,
				endZLocation: hole.endZLocation,
				holeDiameter: hole.holeDiameter,
				holeType: processedHoleType,
				measuredLength: hole.measuredLength
			});
		}

		// Step 19) Sort holes by ID
		iredesPoints.sort(function(a, b) {
			return a.holeID.localeCompare(b.holeID);
		});

		// Step 20) Format the date as YYYY-MM-DDTHH:mm:ss
		var formattedDate = now.toISOString().slice(0, 19);

		// Step 21) Use the provided notes or default
		var processedNotes = notes || "Notes";

		// Step 22) Build XML header
		var xmlHeader = '<?xml version="1.0" encoding="UTF-8"?>\r\n<!-- Generated by Kirra - https://blastingapps.com/kirra.html -->\r\n';
		var xml = "" + xmlHeader + '<DRPPlan xmlns:IR="http://www.iredes.org/xml" IRVersion="V 1.0" IRDownwCompat="V 1.0" DRPPlanDownwCompat="V 1.0" DRPPlanVersion="V 1.0" xmlns="http://www.iredes.org/xml/DrillRig">\r\n';

		// Step 23) General Header
		xml += "  <IR:GenHead>\r\n";
		xml += "    <IR:FileCreateDate>" + formattedDate + "</IR:FileCreateDate>\r\n";
		xml += '      <IR:IRversion DownwCompat="V 1.0">V 1.0</IR:IRversion>\r\n';
		xml += "    </IR:GenHead>\r\n";
		xml += "    <IR:PlanId>" + planID + "</IR:PlanId>\r\n";
		xml += "    <IR:PlanName>" + planID + "</IR:PlanName>\r\n";
		xml += "    <IR:Comment>" + processedNotes + "</IR:Comment>\r\n";
		xml += "    <IR:Project>" + siteID + "(Site)</IR:Project>\r\n";
		xml += "    <IR:WorkOrder>" + siteID + "(WorkOrder)</IR:WorkOrder>\r\n";

		// Step 24) Drill Position Plan
		xml += '  <DrillPosPlan IRVersion="V 1.0" IRDownwCompat="V 1.0">\r\n';
		xml += "    <IR:GenHead>\r\n";
		xml += "      <IR:FileCreateDate>" + formattedDate + "</IR:FileCreateDate>\r\n";
		xml += '      <IR:IRversion DownwCompat="V 1.0">V 1.0</IR:IRversion>\r\n';
		xml += "    </IR:GenHead>\r\n";
		xml += "    <IR:PlanId>" + planID + "</IR:PlanId>\r\n";
		xml += "    <IR:PlanName>" + planID + "</IR:PlanName>\r\n";
		xml += "    <IR:Comment>" + processedNotes + "</IR:Comment>\r\n";
		xml += "    <IR:Project>" + siteID + "(Site)</IR:Project>\r\n";
		xml += "    <IR:WorkOrder>" + siteID + "(WorkOrder)</IR:WorkOrder>\r\n";

		// Step 25) Position Data
		xml += "    <PositionData>\r\n";
		xml += "      <Coordsystem>\r\n";
		xml += "        <IR:CoordSysName>local</IR:CoordSysName>\r\n";
		xml += "        <IR:TMatrix>\r\n";
		xml += "          <IR:Col>\r\n";
		xml += "            <IR:x>1.000</IR:x>\r\n";
		xml += "            <IR:y>0.000</IR:y>\r\n";
		xml += "            <IR:z>0.000</IR:z>\r\n";
		xml += "            <IR:w>0.000</IR:w>\r\n";
		xml += "          </IR:Col>\r\n";
		xml += "          <IR:Col>\r\n";
		xml += "            <IR:x>0.000</IR:x>\r\n";
		xml += "            <IR:y>1.000</IR:y>\r\n";
		xml += "            <IR:z>0.000</IR:z>\r\n";
		xml += "            <IR:w>0.000</IR:w>\r\n";
		xml += "          </IR:Col>\r\n";
		xml += "          <IR:Col>\r\n";
		xml += "            <IR:x>0.000</IR:x>\r\n";
		xml += "            <IR:y>0.000</IR:y>\r\n";
		xml += "            <IR:z>1.000</IR:z>\r\n";
		xml += "            <IR:w>0.000</IR:w>\r\n";
		xml += "          </IR:Col>\r\n";
		xml += "          <IR:Col>\r\n";
		xml += "            <IR:x>0.000</IR:x>\r\n";
		xml += "            <IR:y>0.000</IR:y>\r\n";
		xml += "            <IR:z>0.000</IR:z>\r\n";
		xml += "            <IR:w>1.000</IR:w>\r\n";
		xml += "          </IR:Col>\r\n";
		xml += "        </IR:TMatrix>\r\n";
		xml += "        <IR:CsysType>L</IR:CsysType>\r\n";
		xml += "      </Coordsystem>\r\n";
		xml += "      <PlanIdRef />\r\n";
		xml += "      <Bearing>0.000</Bearing>\r\n";
		xml += "    </PositionData>\r\n";
		xml += "  </DrillPosPlan>\r\n";

		// Step 26) DrillPlan
		xml += "  <DrillPlan>\r\n";
		xml += "  <NumberOfHoles>" + iredesPoints.length + "</NumberOfHoles>\r\n";

		// Step 27) Holes - CRITICAL: IREDES uses Y,X order (Northing, Easting)
		for (var i = 0; i < iredesPoints.length; i++) {
			var iredesPoint = iredesPoints[i];
			xml += "    <Hole>\r\n";
			xml += "      <HoleId>" + iredesPoint.holeID.trim() + "</HoleId>\r\n";
			xml += "      <HoleName>" + iredesPoint.holeID.trim() + "</HoleName>\r\n";
			xml += "      <StartPoint>\r\n";
			xml += "        <IR:PointX>" + iredesPoint.startYLocation.toFixed(3) + "</IR:PointX>\r\n";
			xml += "        <IR:PointY>" + iredesPoint.startXLocation.toFixed(3) + "</IR:PointY>\r\n";
			xml += "        <IR:PointZ>" + iredesPoint.startZLocation.toFixed(3) + "</IR:PointZ>\r\n";
			xml += "      </StartPoint>\r\n";
			xml += "      <EndPoint>\r\n";
			xml += "        <IR:PointX>" + iredesPoint.endYLocation.toFixed(3) + "</IR:PointX>\r\n";
			xml += "        <IR:PointY>" + iredesPoint.endXLocation.toFixed(3) + "</IR:PointY>\r\n";
			xml += "        <IR:PointZ>" + iredesPoint.endZLocation.toFixed(3) + "</IR:PointZ>\r\n";
			xml += "      </EndPoint>\r\n";
			xml += "      <TypeOfHole>" + iredesPoint.holeType.trim() + "</TypeOfHole>\r\n";
			xml += "      <DrillBitDia>" + iredesPoint.holeDiameter + "</DrillBitDia>\r\n";
			xml += "      <MwdOn>" + (mwd ? "1" : "0") + "</MwdOn>\r\n";
			xml += '      <HoleOptions xmlns:opt="opt">\r\n';
			xml += "        <opt:HoleData>\r\n";
			xml += "          <ExtendedHoleStatus>" + (iredesPoint.measuredLength ? "Drilled" : "Undrilled") + "</ExtendedHoleStatus>\r\n";
			xml += "        </opt:HoleData>\r\n";
			xml += "      </HoleOptions>\r\n";
			xml += "    </Hole>\r\n";
		}

		// Step 28) Placeholder for the checksum with the string "0"
		var checksumPlaceholder = "0";

		// Step 29) Closing the XML
		xml += '    <EquipmentData xmlns="">\r\n';
		xml += "      <IR:OptionData />\r\n";
		xml += "    </EquipmentData>\r\n";
		xml += "  </DrillPlan>\r\n";
		xml += "  <IR:GenTrailer>\r\n";
		xml += "    <IR:FileCloseDate>" + formattedDate + "</IR:FileCloseDate>\r\n";
		xml += "    <IR:ChkSum>" + checksumPlaceholder + "</IR:ChkSum>\r\n";
		xml += "  </IR:GenTrailer>\r\n";
		xml += "</DRPPlan>";

		// Step 30) Calculate CRC32 of the ENTIRE XML (including the "0")
		var checksum = this.calculateCRC32(xml, chksumType);

		// Step 31) Replace the "0" with the calculated checksum
		if (chksumType === "CRC32-DECIMAL") {
			xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, "<IR:ChkSum>" + checksum + "</IR:ChkSum>");
		} else if (chksumType === "CRC32-HEXBINARY") {
			xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, "<IR:ChkSum>" + checksum + "</IR:ChkSum>");
		} else if (chksumType === "NONE") {
			xml = xml.replace(/<IR:ChkSum>0<\/IR:ChkSum>/, "<IR:ChkSum> </IR:ChkSum>");
		}

		return xml;
	}

	// Step 32) Calculate the CRC32 checksum of a string
	calculateCRC32(str, chksumType) {
		// Step 33) Build CRC32 lookup table
		var table = new Uint32Array(256);
		for (var i = 256; i--; ) {
			var tmp = i;
			for (var k = 8; k--; ) {
				tmp = tmp & 1 ? 3988292384 ^ (tmp >>> 1) : tmp >>> 1;
			}
			table[i] = tmp;
		}

		// Step 34) Calculate CRC32
		var crc = 0xffffffff;
		for (var i = 0, l = str.length; i < l; i++) {
			crc = (crc >>> 8) ^ table[(crc ^ str.charCodeAt(i)) & 255];
		}

		crc = crc >>> 0; // Ensure unsigned

		// Step 35) Format depending on chksumType
		if (chksumType === "CRC32-HEXBINARY") {
			return crc.toString(16).toUpperCase();
		} else {
			return crc;
		}
	}
}
