// src/fileIO/ThreeJSMeshIO/OBJWriter.js
//=============================================================
// OBJ WRITER - WAVEFRONT OBJ FORMAT
//=============================================================
// Step 1) Exports mesh data to Wavefront OBJ format
// Step 2) Supports vertices, faces, normals, UVs, materials
// Step 3) Created: 2026-01-04

import BaseWriter from "../BaseWriter.js";

// Step 4) OBJWriter class
class OBJWriter extends BaseWriter {
	constructor(options = {}) {
		super(options);

		// Step 5) Writer options
		this.includeNormals = options.includeNormals !== false; // Default true
		this.includeUVs = options.includeUVs !== false; // Default true
		this.includeColors = options.includeColors || false; // Default false (OBJ doesn't natively support vertex colors)
		this.objectName = options.objectName || "Mesh";
		this.decimalPlaces = options.decimalPlaces || 6;
	}

	// Step 6) Main write method
	async write(data) {
		// Step 7) Validate input data
		if (!data || !data.vertices || !Array.isArray(data.vertices)) {
			throw new Error("Invalid data: vertices array required");
		}

		if (data.vertices.length === 0) {
			throw new Error("No vertices to export");
		}

		// Step 8) Generate OBJ content
		var obj = this.generateOBJ(data);

		// Step 9) Create and return blob
		return this.createBlob(obj, "text/plain");
	}

	// Step 10) Generate OBJ file content
	generateOBJ(data) {
		var obj = "";

		// Step 11) Add header comment
		obj += "# Wavefront OBJ file\n";
		obj += "# Generated by Kirra FileManager\n";
		obj += "# Vertices: " + data.vertices.length + "\n";
		if (data.faces) {
			obj += "# Faces: " + data.faces.length + "\n";
		}
		obj += "\n";

		// Step 12) Add object name
		obj += "o " + this.objectName + "\n\n";

		// Step 13) Write vertices
		obj += "# Vertices\n";
		for (var i = 0; i < data.vertices.length; i++) {
			var v = data.vertices[i];
			var x = this.formatCoordinate(v.x || 0);
			var y = this.formatCoordinate(v.y || 0);
			var z = this.formatCoordinate(v.z || 0);

			// Step 14) Vertex format: v x y z [r g b]
			obj += "v " + x + " " + y + " " + z;

			// Step 15) Add vertex colors if available (non-standard OBJ extension)
			if (this.includeColors && data.colors && data.colors[i]) {
				var c = data.colors[i];
				var r = this.normalizeColorValue(c.r);
				var g = this.normalizeColorValue(c.g);
				var b = this.normalizeColorValue(c.b);
				obj += " " + r + " " + g + " " + b;
			}

			obj += "\n";
		}
		obj += "\n";

		// Step 16) Write texture coordinates if available
		if (this.includeUVs && data.uvs && data.uvs.length > 0) {
			obj += "# Texture coordinates\n";
			for (var i = 0; i < data.uvs.length; i++) {
				var uv = data.uvs[i];
				var u = this.formatCoordinate(uv.u || 0);
				var v = this.formatCoordinate(uv.v || 0);
				obj += "vt " + u + " " + v + "\n";
			}
			obj += "\n";
		}

		// Step 17) Write normals if available
		if (this.includeNormals && data.normals && data.normals.length > 0) {
			obj += "# Normals\n";
			for (var i = 0; i < data.normals.length; i++) {
				var n = data.normals[i];
				var x = this.formatCoordinate(n.x || 0);
				var y = this.formatCoordinate(n.y || 0);
				var z = this.formatCoordinate(n.z || 0);
				obj += "vn " + x + " " + y + " " + z + "\n";
			}
			obj += "\n";
		}

	// Step 18) Write faces if available
	if (data.faces && data.faces.length > 0) {
		obj += "# Faces\n";
		for (var i = 0; i < data.faces.length; i++) {
			var face = data.faces[i];
			
			// Face should have indices array
			if (!face.indices || !Array.isArray(face.indices)) {
				console.warn("OBJWriter: Face " + i + " has no indices array, skipping");
				continue;
			}

			// Step 19) Face format: f v1//vn1 v2//vn2 v3//vn3 (using face normals)
			obj += "f";

			// Check if face has a single normal for all vertices (flat shading)
			var hasNormal = face.normalIndex !== undefined && data.normals && data.normals.length > 0;

			for (var j = 0; j < face.indices.length; j++) {
				var vertexIndex = face.indices[j] + 1; // OBJ indices are 1-based

				obj += " " + vertexIndex;

				// Step 20) Add normal index (same normal for all vertices in flat shading)
				if (hasNormal) {
					obj += "//" + (face.normalIndex + 1); // OBJ indices are 1-based
				}
			}

			obj += "\n";
		}
		obj += "\n";
	}

		// Step 22) Add end comment
		obj += "# End of file\n";

		return obj;
	}

	// Step 23) Format coordinate to specified decimal places
	formatCoordinate(value) {
		return parseFloat(value).toFixed(this.decimalPlaces);
	}

	// Step 24) Normalize color value to 0-1 range for OBJ
	normalizeColorValue(value) {
		// Step 25) If value is 0-255, convert to 0-1
		if (value > 1) {
			return (value / 255).toFixed(this.decimalPlaces);
		}
		// Step 26) If value is already 0-1, use as-is
		return parseFloat(value).toFixed(this.decimalPlaces);
	}
}

export default OBJWriter;
