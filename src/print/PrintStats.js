///------------------ PRINT STATISTICS FUNCTIONS ------------------///

import { getBlastStatisticsPerEntity } from "../helpers/BlastStatistics.js";
import { printCanvas } from "./PrintSystem.js";
import * as SVG from "./SVGBuilder.js";

export { printCtx } from "./PrintSystem.js";

/**
 * @deprecated Use printHeaderSVG() for vector PDF generation
 */
export function printHeader(printCtx, x, y, width, height, context) {
    const { allBlastHoles } = context;
    printCtx.save();

    printCtx.fillStyle = "black";
    printCtx.font = "bold 30px Arial";
    printCtx.textAlign = "left";
    printCtx.textBaseline = "top";

    // Title
    const title = "Kirra";
    printCtx.fillText(title, x, y + 10);

    //QR code from icons/ folder "icons/kirra2d-qr-code.png"
    const qrCode = new Image();
    qrCode.onload = function () {
        printCtx.drawImage(qrCode, x, y + 35, 110, 110);
        // If this is the last thing to draw, you can now continue with PDF generation
    };
    qrCode.src = "icons/kirra2d-qr-code.png";

    printCtx.fillStyle = "black";
    printCtx.font = "18px Arial";
    printCtx.textAlign = "left";
    printCtx.textBaseline = "top";
    const url = "https://blastingapps.com/kirra.html";
    printCtx.fillText(url, x, y + 155);

    // Statistics
    if (allBlastHoles && allBlastHoles.length > 0) {
        printCtx.textAlign = "left";
        printCtx.font = "18px Arial";
        let statsX = x + 10;
        let statsY = y + 175;

        printBlastStats(printCtx, statsX, statsY, context);
    }

    printCtx.restore();
}

/**
 * @deprecated Use printFooterSVG() for vector PDF generation
 */
export function printFooter(printCtx, x, y, width, height, context) {
    printCtx.save();
    printCtx.fillStyle = "black";
    printCtx.font = "12px Arial";
    printCtx.textAlign = "center";
    printCtx.textBaseline = "middle";

    printCtx.fillText("Generated by KIRRA Blast Design Software", x + width / 2, y + height / 2);

    printCtx.restore();
}

/**
 * @deprecated Use printBlastStatsSVG() for vector PDF generation
 */
export function printBlastStats(printCtx, xPos, yPos, context) {
    const { allBlastHoles } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles);
    xPos = xPos || 10;
    yPos = yPos || 150;

    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        let line = 0;

        // --- Print main blast stats ---
        printCtx.fillText("Blast Entity: " + entity, xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Common Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Common Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
        line++;

        // --- Setup for delays table ---
        const tableX = xPos;
        const tableY = yPos + line * 20 + 20; // Position table below stats
        const rowHeight = 24;
        const col1Width = 80; // Delay label column width
        const col2Width = 50; // Count column width

        // --- Draw table header ---
        printCtx.save();
        printCtx.font = "bold 16px Arial";
        printCtx.fillStyle = "#fff";
        printCtx.fillRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header background
        printCtx.strokeRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header border
        printCtx.fillStyle = "#000";
        printCtx.fillText("Delays:", tableX + 5, tableY + 4); // Header text
        printCtx.restore();

        // --- Draw each delay group as a table row ---
        let row = 1;
        Object.keys(s.delayGroups)
            .sort((a, b) => {
                // Sort numerically, unknown last
                if (a === "Unknown") return 1;
                if (b === "Unknown") return -1;
                return parseFloat(a) - parseFloat(b);
            })
            .forEach((delay) => {
                const group = s.delayGroups[delay];
                const count = group.count;
                const color = group.color || (delay === "Unknown" ? "#000" : "#fff");

                printCtx.save();

                // --- Draw background for delay label cell ---
                printCtx.fillStyle = color;
                printCtx.fillRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);

                // --- Draw cell borders ---
                printCtx.strokeRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);
                printCtx.strokeRect(tableX + col1Width, tableY + row * rowHeight, col2Width, rowHeight);

                // --- Determine text color for delay label (white on dark, black on light) ---
                let labelTextColor = "#000";
                let countTextColor = "#000";
                function hexToRgb(hex) {
                    hex = hex.replace("#", "");
                    if (hex.length === 3) {
                        hex = hex
                            .split("")
                            .map((x) => x + x)
                            .join("");
                    }
                    const num = parseInt(hex, 16);
                    return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                }
                function getLuminance(hex) {
                    const [r, g, b] = hexToRgb(hex);
                    return 0.299 * r + 0.587 * g + 0.114 * b;
                }
                // For the label cell
                if (color.startsWith("#") && getLuminance(color) < 128) {
                    labelTextColor = "#fff";
                }
                if (color.toLowerCase() === "black" || color === "#000" || color === "#222" || color === "#2d2d2d") {
                    labelTextColor = "#fff";
                }
                // For the count cell, always check against white background
                countTextColor = "#000"; // Always black for count cell (white cell background)

                // --- Draw delay label (left cell) ---
                printCtx.fillStyle = labelTextColor;
                printCtx.font = "16px Arial";
                printCtx.fillText((delay === "Unknown" ? "Unknown" : delay + "ms") + ":", tableX + 5, tableY + row * rowHeight + 4);

                // --- Draw count (right cell) ---
                printCtx.fillStyle = countTextColor;
                printCtx.fillText(count, tableX + col1Width + 10, tableY + row * rowHeight + 4);

                printCtx.restore();
                row++;
            });
    });
}

/**
 * @deprecated Use printBlastStatsSimpleSVG() for vector PDF generation
 */
export function printBlastStatsSimple(printCtx, xPos, yPos, context) {
    const { allBlastHoles } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles);
    xPos = xPos || 10;
    yPos = yPos || 150;
    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        printCtx.fillText("Entity: " + entity, xPos, yPos);
        printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + 20);
        printCtx.fillText("Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + 40);
        printCtx.fillText("Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + 60);
        printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + 80);
        printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + 100);
        printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + 120);
        printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + 140);
        printCtx.fillText("Delays: " + JSON.stringify(s.delayGroups), xPos, yPos + 160);
        printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + 180);
        printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + 200);
        yPos += 240; // Space between entities
    });
}

// ==================== SVG RENDERING FUNCTIONS ====================

export function printHeaderSVG(x, y, width, height, context) {
    const { allBlastHoles } = context;
    let svg = "";
    
    // Title
    svg += SVG.createSVGText(x, y + 10, "Kirra", "black", "30", "Arial", "bold", "start", "top");
    
    // QR code is handled separately as raster image in PrintSystem.js
    // No SVG image element needed here
    
    // URL
    svg += SVG.createSVGText(x, y + 155, "https://blastingapps.com/kirra.html", "black", "18", "Arial", "normal", "start", "top");
    
    // Statistics
    if (allBlastHoles && allBlastHoles.length > 0) {
        svg += printBlastStatsSVG(x + 10, y + 175, context);
    }
    
    return svg;
}

export function printFooterSVG(x, y, width, height, context) {
    return SVG.createSVGText(x + width / 2, y + height / 2, "Generated by KIRRA Blast Design Software", "black", "12", "Arial", "normal", "middle", "middle");
}

export function printBlastStatsSVG(xPos, yPos, context) {
    const { allBlastHoles } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles);
    xPos = xPos || 10;
    yPos = yPos || 150;
    
    let svg = "";
    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        let line = 0;
        
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Blast Entity: " + entity, "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Holes: " + s.holeCount, "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Common Burden: " + s.burden.toFixed(2) + "m", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Common Spacing: " + s.spacing.toFixed(2) + "m", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Drill Metres: " + s.drillMetres.toFixed(1) + "m", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Exp. Mass: " + s.expMass.toFixed(1) + "kg", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Volume: " + s.volume.toFixed(1) + "m³", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Surface Area: " + s.surfaceArea.toFixed(1) + "m²", "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), "black", "18", "Arial", "normal", "start", "auto");
        line++;
        svg += SVG.createSVGText(xPos, yPos + line * 20, "Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), "black", "18", "Arial", "normal", "start", "auto");
        line++;
        
        // Delays table
        const tableX = xPos;
        const tableY = yPos + line * 20 + 20;
        const rowHeight = 24;
        const col1Width = 80;
        const col2Width = 50;
        
        // Table header
        svg += SVG.createSVGRect(tableX, tableY, col1Width + col2Width, rowHeight, "#fff", "black", 1);
        svg += SVG.createSVGText(tableX + 5, tableY + 4, "Delays:", "black", "16", "Arial", "bold", "start", "auto");
        
        // Table rows
        let row = 1;
        Object.keys(s.delayGroups)
            .sort((a, b) => {
                if (a === "Unknown") return 1;
                if (b === "Unknown") return -1;
                return parseFloat(a) - parseFloat(b);
            })
            .forEach((delay) => {
                const group = s.delayGroups[delay];
                const count = group.count;
                const color = group.color || (delay === "Unknown" ? "#000" : "#fff");
                
                // Background for delay label cell
                svg += SVG.createSVGRect(tableX, tableY + row * rowHeight, col1Width, rowHeight, color, "black", 1);
                svg += SVG.createSVGRect(tableX + col1Width, tableY + row * rowHeight, col2Width, rowHeight, "#fff", "black", 1);
                
                // Text color determination (simplified)
                const labelTextColor = (color === "black" || color === "#000" || color === "#222" || color === "#2d2d2d") ? "#fff" : "#000";
                
                svg += SVG.createSVGText(tableX + 5, tableY + row * rowHeight + 4, (delay === "Unknown" ? "Unknown" : delay + "ms") + ":", labelTextColor, "16", "Arial", "normal", "start", "auto");
                svg += SVG.createSVGText(tableX + col1Width + 10, tableY + row * rowHeight + 4, count, "#000", "16", "Arial", "normal", "start", "auto");
                
                row++;
            });
    });
    
    return svg;
}

export function printBlastStatsSimpleSVG(xPos, yPos, context) {
    const { allBlastHoles } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles);
    xPos = xPos || 10;
    yPos = yPos || 150;
    
    let svg = "";
    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        svg += SVG.createSVGText(xPos, yPos, "Entity: " + entity, "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 20, "Holes: " + s.holeCount, "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 40, "Burden: " + s.burden.toFixed(2) + "m", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 60, "Spacing: " + s.spacing.toFixed(2) + "m", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 80, "Drill Metres: " + s.drillMetres.toFixed(1) + "m", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 100, "Exp. Mass: " + s.expMass.toFixed(1) + "kg", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 120, "Volume: " + s.volume.toFixed(1) + "m³", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 140, "Surface Area: " + s.surfaceArea.toFixed(1) + "m²", "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 160, "Delays: " + JSON.stringify(s.delayGroups), "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 180, "Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), "black", "18", "Arial", "normal", "start", "auto");
        svg += SVG.createSVGText(xPos, yPos + 200, "Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), "black", "18", "Arial", "normal", "start", "auto");
        yPos += 240;
    });
    
    return svg;
}

