///------------------ PRINT STATISTICS FUNCTIONS ------------------///

import { getBlastStatisticsPerEntity } from "../helpers/BlastStatistics.js";
import { printCanvas } from "./PrintSystem.js";

export { printCtx } from "./PrintSystem.js";

export function printHeader(printCtx, x, y, width, height, context) {
    const { allBlastHoles } = context;
    printCtx.save();

    printCtx.fillStyle = "black";
    printCtx.font = "bold 30px Arial";
    printCtx.textAlign = "left";
    printCtx.textBaseline = "top";

    // Title
    const title = "Kirra 2D";
    printCtx.fillText(title, x, y + 10);

    //QR code from icons/ folder "icons/kirra2d-qr-code.png"
    const qrCode = new Image();
    qrCode.onload = function () {
        printCtx.drawImage(qrCode, x, y + 35, 110, 110);
        // If this is the last thing to draw, you can now continue with PDF generation
    };
    qrCode.src = "icons/kirra2d-qr-code.png";

    printCtx.fillStyle = "black";
    printCtx.font = "18px Arial";
    printCtx.textAlign = "left";
    printCtx.textBaseline = "top";
    const url = "https://blastingapps.com/kirra.html";
    printCtx.fillText(url, x, y + 155);

    // Statistics
    if (allBlastHoles && allBlastHoles.length > 0) {
        printCtx.textAlign = "left";
        printCtx.font = "18px Arial";
        let statsX = x + 10;
        let statsY = y + 175;

        printBlastStats(printCtx, statsX, statsY, context);
    }

    printCtx.restore();
}

export function printFooter(printCtx, x, y, width, height, context) {
    printCtx.save();
    printCtx.fillStyle = "black";
    printCtx.font = "12px Arial";
    printCtx.textAlign = "center";
    printCtx.textBaseline = "middle";

    printCtx.fillText("Generated by KIRRA Blast Design Software", x + width / 2, y + height / 2);

    printCtx.restore();
}

export function printBlastStats(printCtx, xPos, yPos, context) {
    const { allBlastHoles, getVoronoiMetrics } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles, getVoronoiMetrics);
    xPos = xPos || 10;
    yPos = yPos || 150;

    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        let line = 0;

        // --- Print main blast stats ---
        printCtx.fillText("Blast Entity: " + entity, xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Common Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Common Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
        line++;
        printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + line * 20);
        line++;

        // --- Setup for delays table ---
        const tableX = xPos;
        const tableY = yPos + line * 20 + 20; // Position table below stats
        const rowHeight = 24;
        const col1Width = 80; // Delay label column width
        const col2Width = 50; // Count column width

        // --- Draw table header ---
        printCtx.save();
        printCtx.font = "bold 16px Arial";
        printCtx.fillStyle = "#fff";
        printCtx.fillRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header background
        printCtx.strokeRect(tableX, tableY, col1Width + col2Width, rowHeight); // Header border
        printCtx.fillStyle = "#000";
        printCtx.fillText("Delays:", tableX + 5, tableY + 4); // Header text
        printCtx.restore();

        // --- Draw each delay group as a table row ---
        let row = 1;
        Object.keys(s.delayGroups)
            .sort((a, b) => {
                // Sort numerically, unknown last
                if (a === "Unknown") return 1;
                if (b === "Unknown") return -1;
                return parseFloat(a) - parseFloat(b);
            })
            .forEach((delay) => {
                const group = s.delayGroups[delay];
                const count = group.count;
                const color = group.color || (delay === "Unknown" ? "#000" : "#fff");

                printCtx.save();

                // --- Draw background for delay label cell ---
                printCtx.fillStyle = color;
                printCtx.fillRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);

                // --- Draw cell borders ---
                printCtx.strokeRect(tableX, tableY + row * rowHeight, col1Width, rowHeight);
                printCtx.strokeRect(tableX + col1Width, tableY + row * rowHeight, col2Width, rowHeight);

                // --- Determine text color for delay label (white on dark, black on light) ---
                let labelTextColor = "#000";
                let countTextColor = "#000";
                function hexToRgb(hex) {
                    hex = hex.replace("#", "");
                    if (hex.length === 3) {
                        hex = hex
                            .split("")
                            .map((x) => x + x)
                            .join("");
                    }
                    const num = parseInt(hex, 16);
                    return [num >> 16, (num >> 8) & 0xff, num & 0xff];
                }
                function getLuminance(hex) {
                    const [r, g, b] = hexToRgb(hex);
                    return 0.299 * r + 0.587 * g + 0.114 * b;
                }
                // For the label cell
                if (color.startsWith("#") && getLuminance(color) < 128) {
                    labelTextColor = "#fff";
                }
                if (color.toLowerCase() === "black" || color === "#000" || color === "#222" || color === "#2d2d2d") {
                    labelTextColor = "#fff";
                }
                // For the count cell, always check against white background
                countTextColor = "#000"; // Always black for count cell (white cell background)

                // --- Draw delay label (left cell) ---
                printCtx.fillStyle = labelTextColor;
                printCtx.font = "16px Arial";
                printCtx.fillText((delay === "Unknown" ? "Unknown" : delay + "ms") + ":", tableX + 5, tableY + row * rowHeight + 4);

                // --- Draw count (right cell) ---
                printCtx.fillStyle = countTextColor;
                printCtx.fillText(count, tableX + col1Width + 10, tableY + row * rowHeight + 4);

                printCtx.restore();
                row++;
            });
    });
}

export function printBlastStatsSimple(printCtx, xPos, yPos, context) {
    const { allBlastHoles, getVoronoiMetrics } = context;
    const stats = getBlastStatisticsPerEntity(allBlastHoles, getVoronoiMetrics);
    xPos = xPos || 10;
    yPos = yPos || 150;
    Object.keys(stats).forEach((entity) => {
        const s = stats[entity];
        printCtx.fillText("Entity: " + entity, xPos, yPos);
        printCtx.fillText("Holes: " + s.holeCount, xPos, yPos + 20);
        printCtx.fillText("Burden: " + s.burden.toFixed(2) + "m", xPos, yPos + 40);
        printCtx.fillText("Spacing: " + s.spacing.toFixed(2) + "m", xPos, yPos + 60);
        printCtx.fillText("Drill Metres: " + s.drillMetres.toFixed(1) + "m", xPos, yPos + 80);
        printCtx.fillText("Exp. Mass: " + s.expMass.toFixed(1) + "kg", xPos, yPos + 100);
        printCtx.fillText("Volume: " + s.volume.toFixed(1) + "m³", xPos, yPos + 120);
        printCtx.fillText("Surface Area: " + s.surfaceArea.toFixed(1) + "m²", xPos, yPos + 140);
        printCtx.fillText("Delays: " + JSON.stringify(s.delayGroups), xPos, yPos + 160);
        printCtx.fillText("Min Firing: " + (s.minFiringTime !== null ? s.minFiringTime + "ms" : "N/A"), xPos, yPos + 180);
        printCtx.fillText("Max Firing: " + (s.maxFiringTime !== null ? s.maxFiringTime + "ms" : "N/A"), xPos, yPos + 200);
        yPos += 240; // Space between entities
    });
}

