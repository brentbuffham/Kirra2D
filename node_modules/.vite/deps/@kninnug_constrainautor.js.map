{
  "version": 3,
  "sources": ["../../@kninnug/constrainautor/lib/Constrainautor.mjs"],
  "sourcesContent": ["import { incircle, orient2d } from 'robust-predicates';\n\n/**\n * A set of numbers, stored as bits in a typed array. The amount of numbers /\n * the maximum number that can be stored is limited by the length, which is\n * fixed at construction time.\n */\nclass BitSet {\n    constructor(W, bs) {\n        this.W = W;\n        this.bs = bs;\n    }\n    /**\n     * Add a number to the set.\n     *\n     * @param idx The number to add. Must be 0 <= idx < len.\n     * @return this.\n     */\n    add(idx) {\n        const W = this.W, byte = (idx / W) | 0, bit = idx % W;\n        this.bs[byte] |= 1 << bit;\n        return this;\n    }\n    /**\n     * Delete a number from the set.\n     *\n     * @param idx The number to delete. Must be 0 <= idx < len.\n     * @return this.\n     */\n    delete(idx) {\n        const W = this.W, byte = (idx / W) | 0, bit = idx % W;\n        this.bs[byte] &= ~(1 << bit);\n        return this;\n    }\n    /**\n     * Add or delete a number in the set, depending on the second argument.\n     *\n     * @param idx The number to add or delete. Must be 0 <= idx < len.\n     * @param val If true, add the number, otherwise delete.\n     * @return val.\n     */\n    set(idx, val) {\n        const W = this.W, byte = (idx / W) | 0, bit = idx % W, m = 1 << bit;\n        //this.bs[byte] = set ? this.bs[byte] | m : this.bs[byte] & ~m;\n        this.bs[byte] ^= (-val ^ this.bs[byte]) & m; // -set == set * 255\n        return val;\n    }\n    /**\n     * Whether the number is in the set.\n     *\n     * @param idx The number to test. Must be 0 <= idx < len.\n     * @return True if the number is in the set.\n     */\n    has(idx) {\n        const W = this.W, byte = (idx / W) | 0, bit = idx % W;\n        return !!(this.bs[byte] & (1 << bit));\n    }\n    /**\n     * Iterate over the numbers that are in the set. The callback is invoked\n     * with each number that is set. It is allowed to change the BitSet during\n     * iteration. If it deletes a number that has not been iterated over, that\n     * number will not show up in a later call. If it adds a number during\n     * iteration, that number may or may not show up in a later call.\n     *\n     * @param fn The function to call for each number.\n     * @return this.\n     */\n    forEach(fn) {\n        const W = this.W, bs = this.bs, len = bs.length;\n        for (let byte = 0; byte < len; byte++) {\n            let bit = 0;\n            // bs[byte] may change during iteration\n            while (bs[byte] && bit < W) {\n                if (bs[byte] & (1 << bit)) {\n                    fn(byte * W + bit);\n                }\n                bit++;\n            }\n        }\n        return this;\n    }\n}\n/**\n * A bit set using 8 bits per cell.\n */\nclass BitSet8 extends BitSet {\n    /**\n     * Create a bit set.\n     *\n     * @param len The length of the bit set, limiting the maximum value that\n     *        can be stored in it to len - 1.\n     */\n    constructor(len) {\n        const W = 8, bs = new Uint8Array(Math.ceil(len / W)).fill(0);\n        super(W, bs);\n    }\n}\n\nfunction nextEdge(e) { return (e % 3 === 2) ? e - 2 : e + 1; }\nfunction prevEdge(e) { return (e % 3 === 0) ? e + 2 : e - 1; }\n/**\n * Constrain a triangulation from Delaunator, using (parts of) the algorithm\n * in \"A fast algorithm for generating constrained Delaunay triangulations\" by\n * S. W. Sloan.\n */\nclass Constrainautor {\n    /**\n     * Make a Constrainautor.\n     *\n     * @param del The triangulation output from Delaunator.\n     * @param edges If provided, constrain these edges as by constrainAll.\n     */\n    constructor(del, edges) {\n        if (!del || typeof del !== 'object' || !del.triangles || !del.halfedges || !del.coords) {\n            throw new Error(\"Expected an object with Delaunator output\");\n        }\n        if (del.triangles.length % 3 || del.halfedges.length !== del.triangles.length || del.coords.length % 2) {\n            throw new Error(\"Delaunator output appears inconsistent\");\n        }\n        if (del.triangles.length < 3) {\n            throw new Error(\"No edges in triangulation\");\n        }\n        this.del = del;\n        const U32NIL = 2 ** 32 - 1, // Max value of a Uint32Array: use as a sentinel for not yet defined \n        numPoints = del.coords.length >> 1, numEdges = del.triangles.length;\n        // Map every vertex id to the right-most edge that points to that vertex.\n        this.vertMap = new Uint32Array(numPoints).fill(U32NIL);\n        // Keep track of edges flipped while constraining\n        this.flips = new BitSet8(numEdges);\n        // Keep track of constrained edges\n        this.consd = new BitSet8(numEdges);\n        for (let e = 0; e < numEdges; e++) {\n            const v = del.triangles[e];\n            if (this.vertMap[v] === U32NIL) {\n                this.updateVert(e);\n            }\n        }\n        if (edges) {\n            this.constrainAll(edges);\n        }\n    }\n    /**\n     * Constrain the triangulation such that there is an edge between p1 and p2.\n     *\n     * @param segP1 The index of one segment end-point in the coords array.\n     * @param segP2 The index of the other segment end-point in the coords array.\n     * @return The id of the edge that points from p1 to p2. If the\n     *         constrained edge lies on the hull and points in the opposite\n     *         direction (p2 to p1), the negative of its id is returned.\n     */\n    constrainOne(segP1, segP2) {\n        const { triangles, halfedges } = this.del, vm = this.vertMap, consd = this.consd, start = vm[segP1];\n        // Loop over the edges touching segP1\n        let edg = start;\n        do {\n            // edg points toward segP1, so its start-point is opposite it\n            const p4 = triangles[edg], nxt = nextEdge(edg);\n            // already constrained, but in reverse order\n            if (p4 === segP2) {\n                return this.protect(edg);\n            }\n            // The edge opposite segP1\n            const opp = prevEdge(edg), p3 = triangles[opp];\n            // already constrained\n            if (p3 === segP2) {\n                this.protect(nxt);\n                return nxt;\n            }\n            // edge opposite segP1 intersects constraint\n            if (this.intersectSegments(segP1, segP2, p3, p4)) {\n                edg = opp;\n                break;\n            }\n            const adj = halfedges[nxt];\n            // The next edge pointing to segP1\n            edg = adj;\n        } while (edg !== -1 && edg !== start);\n        let conEdge = edg;\n        // Walk through the triangulation looking for further intersecting\n        // edges and flip them. If an intersecting edge cannot be flipped,\n        // assign its id to `rescan` and restart from there, until there are\n        // no more intersects.\n        let rescan = -1;\n        while (edg !== -1) {\n            // edg is the intersecting half-edge in the triangle we came from\n            // adj is now the opposite half-edge in the adjacent triangle, which\n            // is away from segP1.\n            const adj = halfedges[edg], \n            // cross diagonal\n            bot = prevEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj);\n            if (adj === -1) {\n                throw new Error(\"Constraining edge exited the hull\");\n            }\n            if (consd.has(edg)) { // || consd.has(adj) // assume consd is consistent\n                throw new Error(\"Edge intersects already constrained edge\");\n            }\n            if (this.isCollinear(segP1, segP2, triangles[edg]) ||\n                this.isCollinear(segP1, segP2, triangles[adj])) {\n                throw new Error(\"Constraining edge intersects point\");\n            }\n            const convex = this.intersectSegments(triangles[edg], triangles[adj], triangles[bot], triangles[top]);\n            // The quadrilateral formed by the two triangles adjoing edg is not\n            // convex, so the edge can't be flipped. Continue looking for the\n            // next intersecting edge and restart at this one later.\n            if (!convex) {\n                if (rescan === -1) {\n                    rescan = edg;\n                }\n                if (triangles[top] === segP2) {\n                    if (edg === rescan) {\n                        throw new Error(\"Infinite loop: non-convex quadrilateral\");\n                    }\n                    edg = rescan;\n                    rescan = -1;\n                    continue;\n                }\n                // Look for the next intersect\n                if (this.intersectSegments(segP1, segP2, triangles[top], triangles[adj])) {\n                    edg = top;\n                }\n                else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {\n                    edg = rgt;\n                }\n                else if (rescan === edg) {\n                    throw new Error(\"Infinite loop: no further intersect after non-convex\");\n                }\n                continue;\n            }\n            this.flipDiagonal(edg);\n            // The new edge might still intersect, which will be fixed in the\n            // next rescan.\n            if (this.intersectSegments(segP1, segP2, triangles[bot], triangles[top])) {\n                if (rescan === -1) {\n                    rescan = bot;\n                }\n                if (rescan === bot) {\n                    throw new Error(\"Infinite loop: flipped diagonal still intersects\");\n                }\n            }\n            // Reached the other segment end-point? Start the rescan.\n            if (triangles[top] === segP2) {\n                conEdge = top;\n                edg = rescan;\n                rescan = -1;\n                // Otherwise, for the next edge that intersects. Because we just\n                // flipped, it's either edg again, or rgt.\n            }\n            else if (this.intersectSegments(segP1, segP2, triangles[rgt], triangles[top])) {\n                edg = rgt;\n            }\n        }\n        const flips = this.flips;\n        this.protect(conEdge);\n        do {\n            // need to use var to scope it outside the loop, but re-initialize\n            // to 0 each iteration\n            var flipped = 0;\n            flips.forEach(edg => {\n                flips.delete(edg);\n                const adj = halfedges[edg];\n                if (adj === -1) {\n                    return;\n                }\n                flips.delete(adj);\n                if (!this.isDelaunay(edg)) {\n                    this.flipDiagonal(edg);\n                    flipped++;\n                }\n            });\n        } while (flipped > 0);\n        return this.findEdge(segP1, segP2);\n    }\n    /**\n     * Fix the Delaunay condition. It is no longer necessary to call this\n     * method after constraining (many) edges, since constrainOne will do it\n     * after each.\n     *\n     * @param deep If true, keep checking & flipping edges until all\n     *        edges are Delaunay, otherwise only check the edges once.\n     * @return The triangulation object.\n     */\n    delaunify(deep = false) {\n        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd, len = halfedges.length;\n        do {\n            var flipped = 0;\n            for (let edg = 0; edg < len; edg++) {\n                if (consd.has(edg)) {\n                    continue;\n                }\n                flips.delete(edg);\n                const adj = halfedges[edg];\n                if (adj === -1) {\n                    continue;\n                }\n                flips.delete(adj);\n                if (!this.isDelaunay(edg)) {\n                    this.flipDiagonal(edg);\n                    flipped++;\n                }\n            }\n        } while (deep && flipped > 0);\n        return this;\n    }\n    /**\n     * Call constrainOne on each edge, and delaunify afterwards.\n     *\n     * @param edges The edges to constrain: each element is an array with\n     *        [p1, p2] which are indices into the points array originally\n     *        supplied to Delaunator.\n     * @return The triangulation object.\n     */\n    constrainAll(edges) {\n        const len = edges.length;\n        for (let i = 0; i < len; i++) {\n            const e = edges[i];\n            this.constrainOne(e[0], e[1]);\n        }\n        return this;\n    }\n    /**\n     * Whether an edge is a constrained edge.\n     *\n     * @param edg The edge id.\n     * @return True if the edge is constrained.\n     */\n    isConstrained(edg) {\n        return this.consd.has(edg);\n    }\n    /**\n     * Find the edge that points from p1 -> p2. If there is only an edge from\n     * p2 -> p1 (i.e. it is on the hull), returns the negative id of it.\n     *\n     * @param p1 The index of the first point into the points array.\n     * @param p2 The index of the second point into the points array.\n     * @return The id of the edge that points from p1 -> p2, or the negative\n     *         id of the edge that goes from p2 -> p1, or Infinity if there is\n     *         no edge between p1 and p2.\n     */\n    findEdge(p1, p2) {\n        const start1 = this.vertMap[p2], { triangles, halfedges } = this.del;\n        let edg = start1, prv = -1;\n        // Walk around p2, iterating over the edges pointing to it\n        do {\n            if (triangles[edg] === p1) {\n                return edg;\n            }\n            prv = nextEdge(edg);\n            edg = halfedges[prv];\n        } while (edg !== -1 && edg !== start1);\n        // Did not find p1 -> p2, the only option is that it is on the hull on\n        // the 'left-hand' side, pointing p2 -> p1 (or there is no edge)\n        if (triangles[nextEdge(prv)] === p1) {\n            return -prv;\n        }\n        return Infinity;\n    }\n    /**\n     * Mark an edge as constrained, i.e. should not be touched by `delaunify`.\n     *\n     * @private\n     * @param edg The edge id.\n     * @return If edg has an adjacent, returns that, otherwise -edg.\n     */\n    protect(edg) {\n        const adj = this.del.halfedges[edg], flips = this.flips, consd = this.consd;\n        flips.delete(edg);\n        consd.add(edg);\n        if (adj !== -1) {\n            flips.delete(adj);\n            consd.add(adj);\n            return adj;\n        }\n        return -edg;\n    }\n    /**\n     * Mark an edge as flipped, unless it is already marked as constrained.\n     *\n     * @private\n     * @param edg The edge id.\n     * @return True if edg was not constrained.\n     */\n    markFlip(edg) {\n        const halfedges = this.del.halfedges, flips = this.flips, consd = this.consd;\n        if (consd.has(edg)) {\n            return false;\n        }\n        const adj = halfedges[edg];\n        if (adj !== -1) {\n            flips.add(edg);\n            flips.add(adj);\n        }\n        return true;\n    }\n    /**\n     * Flip the edge shared by two triangles.\n     *\n     * @private\n     * @param edg The edge shared by the two triangles, must have an\n     *        adjacent half-edge.\n     * @return The new diagonal.\n     */\n    flipDiagonal(edg) {\n        // Flip a diagonal\n        //                top                     edg\n        //          o  <----- o            o <------  o \n        //         | ^ \\      ^           |       ^ / ^\n        //      lft|  \\ \\     |        lft|      / /  |\n        //         |   \\ \\adj |           |  bot/ /   |\n        //         | edg\\ \\   |           |    / /top |\n        //         |     \\ \\  |rgt        |   / /     |rgt\n        //         v      \\ v |           v  / v      |\n        //         o ----->  o            o   ------> o \n        //           bot                     adj\n        const { triangles, halfedges } = this.del, flips = this.flips, consd = this.consd, adj = halfedges[edg], bot = prevEdge(edg), lft = nextEdge(edg), top = prevEdge(adj), rgt = nextEdge(adj), adjBot = halfedges[bot], adjTop = halfedges[top];\n        if (consd.has(edg)) { // || consd.has(adj) // assume consd is consistent\n            throw new Error(\"Trying to flip a constrained edge\");\n        }\n        // move *edg to *top\n        triangles[edg] = triangles[top];\n        halfedges[edg] = adjTop;\n        if (!flips.set(edg, flips.has(top))) {\n            consd.set(edg, consd.has(top));\n        }\n        if (adjTop !== -1) {\n            halfedges[adjTop] = edg;\n        }\n        halfedges[bot] = top;\n        // move *adj to *bot\n        triangles[adj] = triangles[bot];\n        halfedges[adj] = adjBot;\n        if (!flips.set(adj, flips.has(bot))) {\n            consd.set(adj, consd.has(bot));\n        }\n        if (adjBot !== -1) {\n            halfedges[adjBot] = adj;\n        }\n        halfedges[top] = bot;\n        this.markFlip(edg);\n        this.markFlip(lft);\n        this.markFlip(adj);\n        this.markFlip(rgt);\n        // mark flips unconditionally\n        flips.add(bot);\n        consd.delete(bot);\n        flips.add(top);\n        consd.delete(top);\n        this.updateVert(edg);\n        this.updateVert(lft);\n        this.updateVert(adj);\n        this.updateVert(rgt);\n        return bot;\n    }\n    /**\n     * Whether the two triangles sharing edg conform to the Delaunay condition.\n     * As a shortcut, if the given edge has no adjacent (is on the hull), it is\n     * certainly Delaunay.\n     *\n     * @private\n     * @param edg The edge shared by the triangles to test.\n     * @return True if they are Delaunay.\n     */\n    isDelaunay(edg) {\n        const { triangles, halfedges } = this.del, adj = halfedges[edg];\n        if (adj === -1) {\n            return true;\n        }\n        const p1 = triangles[prevEdge(edg)], p2 = triangles[edg], p3 = triangles[nextEdge(edg)], px = triangles[prevEdge(adj)];\n        return !this.inCircle(p1, p2, p3, px);\n    }\n    /**\n     * Update the vertex -> incoming edge map.\n     *\n     * @private\n     * @param start The id of an *outgoing* edge.\n     * @return The id of the right-most incoming edge.\n     */\n    updateVert(start) {\n        const { triangles, halfedges } = this.del, vm = this.vertMap, v = triangles[start];\n        // When iterating over incoming edges around a vertex, we do so in\n        // clockwise order ('going left'). If the vertex lies on the hull, two\n        // of the edges will have no opposite, leaving a gap. If the starting\n        // incoming edge is not the right-most, we will miss edges between it\n        // and the gap. So walk counter-clockwise until we find an edge on the\n        // hull, or get back to where we started.\n        let inc = prevEdge(start), adj = halfedges[inc];\n        while (adj !== -1 && adj !== start) {\n            inc = prevEdge(adj);\n            adj = halfedges[inc];\n        }\n        vm[v] = inc;\n        return inc;\n    }\n    /**\n     * Whether the segment between [p1, p2] intersects with [p3, p4]. When the\n     * segments share an end-point (e.g. p1 == p3 etc.), they are not considered\n     * intersecting.\n     *\n     * @private\n     * @param p1 The index of point 1 into this.del.coords.\n     * @param p2 The index of point 2 into this.del.coords.\n     * @param p3 The index of point 3 into this.del.coords.\n     * @param p4 The index of point 4 into this.del.coords.\n     * @return True if the segments intersect.\n     */\n    intersectSegments(p1, p2, p3, p4) {\n        const pts = this.del.coords;\n        // If the segments share one of the end-points, they cannot intersect\n        // (provided the input is properly segmented, and the triangulation is\n        // correct), but intersectSegments will say that they do. We can catch\n        // it here already.\n        if (p1 === p3 || p1 === p4 || p2 === p3 || p2 === p4) {\n            return false;\n        }\n        return intersectSegments(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[p4 * 2], pts[p4 * 2 + 1]);\n    }\n    /**\n     * Whether point px is in the circumcircle of the triangle formed by p1, p2,\n     * and p3 (which are in counter-clockwise order).\n     *\n     * @param p1 The index of point 1 into this.del.coords.\n     * @param p2 The index of point 2 into this.del.coords.\n     * @param p3 The index of point 3 into this.del.coords.\n     * @param px The index of point x into this.del.coords.\n     * @return True if (px, py) is in the circumcircle.\n     */\n    inCircle(p1, p2, p3, px) {\n        const pts = this.del.coords;\n        return incircle(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p3 * 2], pts[p3 * 2 + 1], pts[px * 2], pts[px * 2 + 1]) < 0.0;\n    }\n    /**\n     * Whether point p1, p2, and p are collinear.\n     *\n     * @private\n     * @param p1 The index of segment point 1 into this.del.coords.\n     * @param p2 The index of segment point 2 into this.del.coords.\n     * @param p The index of the point p into this.del.coords.\n     * @return True if the points are collinear.\n     */\n    isCollinear(p1, p2, p) {\n        const pts = this.del.coords;\n        return orient2d(pts[p1 * 2], pts[p1 * 2 + 1], pts[p2 * 2], pts[p2 * 2 + 1], pts[p * 2], pts[p * 2 + 1]) === 0.0;\n    }\n}\nConstrainautor.intersectSegments = intersectSegments;\n/**\n * Compute if two line segments [p1, p2] and [p3, p4] intersect.\n *\n * @name Constrainautor.intersectSegments\n * @source https://github.com/mikolalysenko/robust-segment-intersect\n * @param p1x The x coordinate of point 1 of the first segment.\n * @param p1y The y coordinate of point 1 of the first segment.\n * @param p2x The x coordinate of point 2 of the first segment.\n * @param p2y The y coordinate of point 2 of the first segment.\n * @param p3x The x coordinate of point 1 of the second segment.\n * @param p3y The y coordinate of point 1 of the second segment.\n * @param p4x The x coordinate of point 2 of the second segment.\n * @param p4y The y coordinate of point 2 of the second segment.\n * @return True if the line segments intersect.\n */\nfunction intersectSegments(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n    const x0 = orient2d(p1x, p1y, p3x, p3y, p4x, p4y), y0 = orient2d(p2x, p2y, p3x, p3y, p4x, p4y);\n    if ((x0 > 0 && y0 > 0) || (x0 < 0 && y0 < 0)) {\n        return false;\n    }\n    const x1 = orient2d(p3x, p3y, p1x, p1y, p2x, p2y), y1 = orient2d(p4x, p4y, p1x, p1y, p2x, p2y);\n    if ((x1 > 0 && y1 > 0) || (x1 < 0 && y1 < 0)) {\n        return false;\n    }\n    //Check for degenerate collinear case\n    if (x0 === 0 && y0 === 0 && x1 === 0 && y1 === 0) {\n        return !(Math.max(p3x, p4x) < Math.min(p1x, p2x) ||\n            Math.max(p1x, p2x) < Math.min(p3x, p4x) ||\n            Math.max(p3y, p4y) < Math.min(p1y, p2y) ||\n            Math.max(p1y, p2y) < Math.min(p3y, p4y));\n    }\n    return true;\n}\n\nexport { Constrainautor as default };\n"],
  "mappings": "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",
  "names": ["edg"]
}
