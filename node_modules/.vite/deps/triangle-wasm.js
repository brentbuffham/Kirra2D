import {
  require_fs
} from "./chunk-UVQV3GRF.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/triangle-wasm/triangle.out.js
var require_triangle_out = __commonJS({
  "node_modules/triangle-wasm/triangle.out.js"(exports, module) {
    var Module = (function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return (function(Module2) {
        Module2 = Module2 || {};
        var Module2 = typeof Module2 !== "undefined" ? Module2 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module2["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module2) {
          if (Module2.hasOwnProperty(key)) {
            moduleOverrides[key] = Module2[key];
          }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = false;
        var ENVIRONMENT_IS_WORKER = false;
        var ENVIRONMENT_IS_NODE = false;
        var ENVIRONMENT_IS_SHELL = false;
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module2["locateFile"]) {
            return Module2["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary, setWindowTitle;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = require_path().dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS) nodeFS = require_fs();
            if (!nodePath) nodePath = require_path();
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          arguments_ = process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status) {
            process["exit"](status);
          };
          Module2["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_SHELL) {
          if (typeof read != "undefined") {
            read_ = function shell_read(f) {
              return read(f);
            };
          }
          readBinary = function readBinary2(f) {
            var data;
            if (typeof readbuffer === "function") {
              return new Uint8Array(readbuffer(f));
            }
            data = read(f, "binary");
            assert(typeof data === "object");
            return data;
          };
          if (typeof scriptArgs != "undefined") {
            arguments_ = scriptArgs;
          } else if (typeof arguments != "undefined") {
            arguments_ = arguments;
          }
          if (typeof quit === "function") {
            quit_ = function(status) {
              quit(status);
            };
          }
          if (typeof print !== "undefined") {
            if (typeof console === "undefined") console = {};
            console.log = print;
            console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
          }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = function shell_read(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function readBinary2(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function readAsync2(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function xhr_onload() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
          setWindowTitle = function(title) {
            document.title = title;
          };
        } else {
        }
        var out = Module2["print"] || console.log.bind(console);
        var err = Module2["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module2[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module2["arguments"]) arguments_ = Module2["arguments"];
        if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
        if (Module2["quit"]) quit_ = Module2["quit"];
        var wasmBinary;
        if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];
        var noExitRuntime;
        if (Module2["noExitRuntime"]) noExitRuntime = Module2["noExitRuntime"];
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var wasmTable;
        var ABORT = false;
        var EXITSTATUS = 0;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx, endPtr));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0)) return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) break;
              heap[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++] = 192 | u >> 6;
              heap[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++] = 224 | u >> 12;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++] = 240 | u >> 18;
              heap[outIdx++] = 128 | u >> 12 & 63;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127) ++len;
            else if (u <= 2047) len += 2;
            else if (u <= 65535) len += 3;
            else len += 4;
          }
          return len;
        }
        var WASM_PAGE_SIZE = 65536;
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module2["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module2["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module2["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module2["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module2["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module2["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module2["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module2["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_INITIAL_MEMORY = Module2["INITIAL_MEMORY"] || 16777216;
        if (Module2["wasmMemory"]) {
          wasmMemory = Module2["wasmMemory"];
        } else {
          wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE, "maximum": INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE });
        }
        if (wasmMemory) {
          buffer = wasmMemory.buffer;
        }
        INITIAL_INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeExited = false;
        function preRun() {
          if (Module2["preRun"]) {
            if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
            while (Module2["preRun"].length) {
              addOnPreRun(Module2["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function exitRuntime() {
          runtimeExited = true;
        }
        function postRun() {
          if (Module2["postRun"]) {
            if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
            while (Module2["postRun"].length) {
              addOnPostRun(Module2["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
          runDependencies++;
          if (Module2["monitorRunDependencies"]) {
            Module2["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module2["monitorRunDependencies"]) {
            Module2["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module2["preloadedImages"] = {};
        Module2["preloadedAudios"] = {};
        function abort(what) {
          if (Module2["onAbort"]) {
            Module2["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        function hasPrefix(str, prefix) {
          return String.prototype.startsWith ? str.startsWith(prefix) : str.indexOf(prefix) === 0;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return hasPrefix(filename, dataURIPrefix);
        }
        var fileURIPrefix = "file://";
        function isFileURI(filename) {
          return hasPrefix(filename, fileURIPrefix);
        }
        var wasmBinaryFile = "triangle.out.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary() {
          try {
            if (wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(wasmBinaryFile);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(function() {
              return getBinary();
            });
          }
          return Promise.resolve().then(getBinary);
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module2["asm"] = exports3;
            wasmTable = Module2["asm"]["g"];
            removeRunDependency("wasm-instantiate");
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiatedSource(output) {
            receiveInstance(output["instance"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              return WebAssembly.instantiate(binary, info);
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiatedSource, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiatedSource);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiatedSource);
            }
          }
          if (Module2["instantiateWasm"]) {
            try {
              var exports2 = Module2["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync();
          return {};
        }
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module2);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest, src, src + num);
        }
        function abortOnCannotGrowMemory(requestedSize) {
          abort("OOM");
        }
        function _emscripten_resize_heap(requestedSize) {
          requestedSize = requestedSize >>> 0;
          abortOnCannotGrowMemory(requestedSize);
        }
        function _exit(status) {
          exit(status);
        }
        var SYSCALLS = { mappings: {}, buffers: [null, [], []], printChar: function(stream, curr) {
          var buffer2 = SYSCALLS.buffers[stream];
          if (curr === 0 || curr === 10) {
            (stream === 1 ? out : err)(UTF8ArrayToString(buffer2, 0));
            buffer2.length = 0;
          } else {
            buffer2.push(curr);
          }
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, get64: function(low, high) {
          return low;
        } };
        function _fd_write(fd, iov, iovcnt, pnum) {
          var num = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >> 2];
            var len = HEAP32[iov + (i * 8 + 4) >> 2];
            for (var j = 0; j < len; j++) {
              SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
            }
            num += len;
          }
          HEAP32[pnum >> 2] = num;
          return 0;
        }
        function _gettimeofday(ptr) {
          var now = Date.now();
          HEAP32[ptr >> 2] = now / 1e3 | 0;
          HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0;
          return 0;
        }
        __ATINIT__.push({ func: function() {
          ___wasm_call_ctors();
        } });
        var asmLibraryArg = { "d": _emscripten_memcpy_big, "e": _emscripten_resize_heap, "f": _exit, "c": _fd_write, "b": _gettimeofday, "a": wasmMemory };
        var asm = createWasm();
        var ___wasm_call_ctors = Module2["___wasm_call_ctors"] = function() {
          return (___wasm_call_ctors = Module2["___wasm_call_ctors"] = Module2["asm"]["h"]).apply(null, arguments);
        };
        var _malloc = Module2["_malloc"] = function() {
          return (_malloc = Module2["_malloc"] = Module2["asm"]["i"]).apply(null, arguments);
        };
        var _free = Module2["_free"] = function() {
          return (_free = Module2["_free"] = Module2["asm"]["j"]).apply(null, arguments);
        };
        var _triangulate = Module2["_triangulate"] = function() {
          return (_triangulate = Module2["_triangulate"] = Module2["asm"]["k"]).apply(null, arguments);
        };
        Module2["stringToUTF8"] = stringToUTF8;
        Module2["lengthBytesUTF8"] = lengthBytesUTF8;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        };
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) return;
          function doRun() {
            if (calledRun) return;
            calledRun = true;
            Module2["calledRun"] = true;
            if (ABORT) return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module2);
            if (Module2["onRuntimeInitialized"]) Module2["onRuntimeInitialized"]();
            postRun();
          }
          if (Module2["setStatus"]) {
            Module2["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module2["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module2["run"] = run;
        function exit(status, implicit) {
          if (implicit && noExitRuntime && status === 0) {
            return;
          }
          if (noExitRuntime) {
          } else {
            EXITSTATUS = status;
            exitRuntime();
            if (Module2["onExit"]) Module2["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module2["preInit"]) {
          if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
          while (Module2["preInit"].length > 0) {
            Module2["preInit"].pop()();
          }
        }
        noExitRuntime = true;
        run();
        return Module2.ready;
      });
    })();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = Module;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return Module;
      });
    else if (typeof exports === "object")
      exports["Module"] = Module;
  }
});

// node_modules/triangle-wasm/index.js
var require_triangle_wasm = __commonJS({
  "node_modules/triangle-wasm/index.js"(exports, module) {
    var createModule = require_triangle_out();
    var Module = {};
    var stringToHeap = (str) => {
      const length = Module.lengthBytesUTF8(str) + 1;
      const ptr = Module._malloc(length);
      Module.stringToUTF8(str, ptr, length);
      return ptr;
    };
    var arrayToHeap = (arr, type = Int32Array) => {
      if (!arr || !arr.length) return null;
      const typedArray = getTypedArray(arr, type);
      const ptr = Module._malloc(typedArray.length * typedArray.BYTES_PER_ELEMENT);
      const pos = ptr / typedArray.BYTES_PER_ELEMENT;
      const heap = getHeapStr(type);
      const heapArray = Module[heap].subarray(pos, pos + typedArray.length);
      heapArray.set(typedArray);
      return ptr;
    };
    var heapToArray = (ptr, length, type = Int32Array) => {
      if (!ptr) return null;
      const pos = ptr / type.BYTES_PER_ELEMENT;
      const heap = getHeapStr(type);
      return Module[heap].subarray(pos, pos + length);
    };
    var getHeapStr = (type) => {
      switch (type) {
        case Float64Array:
          return "HEAPF64";
        case Int32Array:
          return "HEAP32";
        default:
          return "HEAP8";
      }
    };
    var getTypedArray = (arr, type) => {
      if (arr.constructor == type) return arr;
      return new type(arr);
    };
    var getSwitchesStr = (obj, input, vorout = null) => {
      if (typeof obj === "string") return obj;
      if (typeof obj !== "object" || !obj) obj = {};
      let str = "";
      if (obj.pslg !== false) str = `${str}p`;
      str = `${str}z`;
      if (vorout !== null) str = `${str}v`;
      if (obj.quiet !== false) str = `${str}Q`;
      if (obj.refine === true) str = `${str}r`;
      if (obj.regionAttr === true) str = `${str}A`;
      if (obj.convexHull === true) str = `${str}c`;
      if (obj.ccdt === true) str = `${str}D`;
      if (obj.jettison === true) str = `${str}j`;
      if (obj.edges === true) str = `${str}e`;
      if (obj.neighbors === true) str = `${str}n`;
      if (obj.quadratic === true) str = `${str}o2`;
      if (obj.bndMarkers === false) str = `${str}B`;
      if (obj.holes === false) str = `${str}O`;
      if (typeof obj.steiner === "number") str = `${str}S${obj.steiner}`;
      if (typeof obj.quality === "number") str = `${str}q${obj.quality}`;
      else if (obj.quality === true) str = `${str}q`;
      if (typeof obj.area === "number") str = `${str}a${obj.area}`;
      else if (obj.area === true) str = `${str}a`;
      if (obj.quiet === false) console.log("Switches:", str);
      return str;
    };
    var TriangulateIO = class _TriangulateIO {
      static get LENGTH() {
        return 23;
      }
      constructor(props = {}) {
        this.ptr = Module._malloc(_TriangulateIO.LENGTH * Int32Array.BYTES_PER_ELEMENT);
        this.arr = heapToArray(this.ptr, _TriangulateIO.LENGTH);
        this.arr.set(new Int32Array(_TriangulateIO.LENGTH));
        for (const prop in props) {
          if (prop in this) this[prop] = props[prop];
        }
      }
      destroy(all) {
        Module._free(this.arr[0]);
        Module._free(this.arr[1]);
        Module._free(this.arr[2]);
        Module._free(this.arr[5]);
        Module._free(this.arr[6]);
        Module._free(this.arr[7]);
        Module._free(this.arr[8]);
        Module._free(this.arr[12]);
        Module._free(this.arr[13]);
        Module._free(this.arr[19]);
        Module._free(this.arr[20]);
        Module._free(this.arr[21]);
        Module._free(this.ptr);
        if (all) {
          Module._free(this.arr[15]);
          Module._free(this.arr[17]);
        }
      }
      // --------------------------------------------
      // SETTERS
      // --------------------------------------------
      set pointlist(value) {
        this.arr[0] = arrayToHeap(value, Float64Array);
        this.arr[3] = value ? ~~(value.length * 0.5) : 0;
      }
      set pointattributelist(value) {
        this.arr[1] = arrayToHeap(value, Float64Array);
        this.arr[4] = value ? ~~(value.length / this.numberofpoints) : 0;
      }
      set pointmarkerlist(value) {
        this.arr[2] = arrayToHeap(value);
      }
      set numberofpoints(value) {
      }
      set numberofpointattributes(value) {
      }
      set trianglelist(value) {
        this.arr[5] = arrayToHeap(value);
        this.arr[9] = value ? ~~(value.length / 3) : 0;
      }
      set triangleattributelist(value) {
        this.arr[6] = arrayToHeap(value, Float64Array);
        this.arr[11] = value ? ~~(value.length / this.numberoftriangles) : 0;
      }
      set trianglearealist(value) {
        this.arr[7] = arrayToHeap(value, Float64Array);
      }
      set neighborlist(value) {
        this.arr[8] = arrayToHeap(value);
      }
      set numberoftriangles(value) {
      }
      set numberofcorners(value) {
      }
      set numberoftriangleattributes(value) {
      }
      set segmentlist(value) {
        this.arr[12] = arrayToHeap(value);
        this.arr[14] = value ? ~~(value.length * 0.5) : 0;
      }
      set segmentmarkerlist(value) {
        this.arr[13] = arrayToHeap(value);
      }
      set numberofsegments(value) {
      }
      set holelist(value) {
        this.arr[15] = arrayToHeap(value, Float64Array);
        this.arr[16] = value ? ~~(value.length * 0.5) : 0;
      }
      set numberofholes(value) {
      }
      set regionlist(value) {
        this.arr[17] = arrayToHeap(value, Float64Array);
        this.arr[18] = value ? ~~(value.length * 0.25) : 0;
      }
      set numberofregions(value) {
      }
      set edgelist(value) {
        this.arr[19] = arrayToHeap(value);
        this.arr[22] = value ? ~~(value.length * 0.5) : 0;
      }
      set edgemarkerlist(value) {
        this.arr[20] = arrayToHeap(value);
      }
      set normlist(value) {
        this.arr[21] = arrayToHeap(value, Float64Array);
      }
      set numberofedges(value) {
      }
      // --------------------------------------------
      // GETTERS
      // --------------------------------------------
      get pointlist() {
        return heapToArray(this.arr[0], this.numberofpoints * 2, Float64Array);
      }
      get pointattributelist() {
        return heapToArray(this.arr[1], this.numberofpointattributes * this.numberofpoints, Float64Array);
      }
      get pointmarkerlist() {
        return heapToArray(this.arr[2], this.numberofpoints);
      }
      get numberofpoints() {
        return this.arr[3];
      }
      get numberofpointattributes() {
        return this.arr[4];
      }
      get trianglelist() {
        return heapToArray(this.arr[5], this.numberoftriangles * this.numberofcorners);
      }
      get triangleattributelist() {
        return heapToArray(this.arr[6], this.numberoftriangleattributes * this.numberoftriangles, Float64Array);
      }
      get trianglearealist() {
        return heapToArray(this.arr[7], this.numberoftriangles, Float64Array);
      }
      get neighborlist() {
        return heapToArray(this.arr[8], this.numberoftriangles * 3);
      }
      get numberoftriangles() {
        return this.arr[9];
      }
      get numberofcorners() {
        return this.arr[10];
      }
      get numberoftriangleattributes() {
        return this.arr[11];
      }
      get segmentlist() {
        return heapToArray(this.arr[12], this.numberofsegments * 2);
      }
      get segmentmarkerlist() {
        return heapToArray(this.arr[13], this.numberofsegments);
      }
      get numberofsegments() {
        return this.arr[14];
      }
      get holelist() {
        return heapToArray(this.arr[15], this.numberofholes * 2, Float64Array);
      }
      get numberofholes() {
        return this.arr[16];
      }
      get regionlist() {
        return heapToArray(this.arr[17], this.numberofregions * 4, Float64Array);
      }
      get numberofregions() {
        return this.arr[18];
      }
      get edgelist() {
        return heapToArray(this.arr[19], this.numberofedges * 2);
      }
      get edgemarkerlist() {
        return heapToArray(this.arr[20], this.numberofedges);
      }
      get normlist() {
        return heapToArray(this.arr[21], this.numberofedges * 2, Float64Array);
      }
      get numberofedges() {
        return this.arr[22];
      }
    };
    var init = (path) => {
      return new Promise((resolve, reject) => {
        createModule({
          locateFile: (_f, _p) => path || _p + _f
        }).then((m) => {
          Module = m;
          resolve();
        });
      });
    };
    var triangulate = (switches, input, output, vorout = null) => {
      const s_str = getSwitchesStr(switches, input, vorout);
      const s_ptr = stringToHeap(s_str);
      const v_ptr = vorout ? vorout.ptr : null;
      Module._triangulate(s_ptr, input.ptr, output.ptr, v_ptr);
      Module._free(s_ptr);
    };
    var makeIO = (data) => {
      return new TriangulateIO(data);
    };
    var freeIO = (io, all) => {
      io.destroy(all);
    };
    module.exports = {
      init,
      triangulate,
      makeIO,
      freeIO,
      getSwitchesStr
    };
  }
});
export default require_triangle_wasm();
//# sourceMappingURL=triangle-wasm.js.map
