import DxfArrayScanner from './DxfArrayScanner';
import AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';
import { sortBy, forEach, findIndex, isEqual, ceil, replace } from 'lodash';
import Face from './entities/3dface';
import Arc from './entities/arc';
import AttDef from './entities/attdef';
import Circle from './entities/circle';
import Dimension from './entities/dimension';
import Ellipse from './entities/ellipse';
import Insert from './entities/insert';
import Line from './entities/line';
import LWPolyline from './entities/lwpolyline';
import MText from './entities/mtext';
import Point from './entities/point';
import Polyline from './entities/polyline';
import Solid from './entities/solid';
import Spline from './entities/spline';
import Text from './entities/text';
import Multileader from './entities/multileader';
//import Vertex from './entities/';
import log from 'loglevel';
//log.setLevel('trace');
//log.setLevel('debug');
//log.setLevel('info');
// log.setLevel('warn');
log.setLevel('error');
function registerDefaultEntityHandlers(dxfParser) {
    // Supported entities here (some entity code is still being refactored into this flow)
    dxfParser.registerEntityHandler(Face);
    dxfParser.registerEntityHandler(Arc);
    dxfParser.registerEntityHandler(AttDef);
    dxfParser.registerEntityHandler(Circle);
    dxfParser.registerEntityHandler(Dimension);
    dxfParser.registerEntityHandler(Ellipse);
    dxfParser.registerEntityHandler(Insert);
    dxfParser.registerEntityHandler(Line);
    dxfParser.registerEntityHandler(LWPolyline);
    dxfParser.registerEntityHandler(MText);
    dxfParser.registerEntityHandler(Point);
    dxfParser.registerEntityHandler(Polyline);
    dxfParser.registerEntityHandler(Solid);
    dxfParser.registerEntityHandler(Spline);
    dxfParser.registerEntityHandler(Text);
    dxfParser.registerEntityHandler(Multileader);
    //dxfParser.registerEntityHandler(require('./entities/vertex'));
}
export default class DxfParser {
    _entityHandlers = {};
    constructor() {
        registerDefaultEntityHandlers(this);
    }
    parse(source) {
        if (typeof source === 'string') {
            return this._parse(source);
        }
        else {
            console.error('Cannot read dxf source of type `' + typeof (source));
            return null;
        }
    }
    registerEntityHandler(handlerType) {
        const instance = new handlerType();
        this._entityHandlers[instance.ForEntityName] = instance;
    }
    parseSync(source) {
        return this.parse(source);
    }
    parseStream(stream) {
        let dxfString = "";
        const self = this;
        return new Promise((res, rej) => {
            stream.on('data', (chunk) => {
                dxfString += chunk;
            });
            stream.on('end', () => {
                try {
                    res(self._parse(dxfString));
                }
                catch (err) {
                    rej(err);
                }
            });
            stream.on('error', (err) => {
                rej(err);
            });
        });
    }
    getEntities(source, entitiesIds) {
        let sourceJSON = null;
        let idsJSON = null;
        try {
            idsJSON = JSON.parse(entitiesIds);
        }
        catch (error) {
            console.log(error);
            idsJSON = entitiesIds;
        }
        try {
            sourceJSON = JSON.parse(source);
        }
        catch (error) {
            console.log(error);
            sourceJSON = source;
        }
        let objects = [];
        idsJSON.data.objects.forEach((model) => {
            model.objects.forEach((itemBlock) => {
                itemBlock.objects.forEach((item) => {
                    if (item.objects && item.objects.length > 0) {
                        item.objects.forEach((item2) => {
                            objects.push({ ...item2, type: itemBlock.name });
                        });
                    }
                    else {
                        objects.push({ ...item, type: itemBlock.name });
                    }
                });
            });
        });
        let retValue = sourceJSON.entities;
        let entities = retValue.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        let dimension = retValue.filter((item) => item.type == 'DIMENSION');
        dimension = dimension.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        return {
            entities: entities.filter((item) => item.dbId),
            dimension: dimension
        };
    }
    getDXFDiff(source, source2, entitiesIds) {
        let sourceJSON = {};
        let source2JSON = {};
        let idsJSON = [];
        try {
            idsJSON = JSON.parse(entitiesIds);
        }
        catch (error) {
            console.log(error);
            idsJSON = entitiesIds;
        }
        try {
            sourceJSON = JSON.parse(source);
        }
        catch (error) {
            console.log(error);
            sourceJSON = source;
        }
        try {
            source2JSON = JSON.parse(source2);
        }
        catch (error) {
            console.log(error);
            source2JSON = source2;
        }
        let objects = [];
        idsJSON.data.objects.forEach((model) => {
            model.objects.forEach((itemBlock) => {
                itemBlock.objects.forEach((item) => {
                    if (item.objects && item.objects.length > 0) {
                        item.objects.forEach((item2) => {
                            objects.push({ ...item2, type: itemBlock.name });
                        });
                    }
                    else {
                        objects.push({ ...item, type: itemBlock.name });
                    }
                });
            });
        });
        let sortedJSON = sortBy(sourceJSON.entities.filter((item) => item.name), ['handle', 'name']);
        let sorted2JSON = sortBy(source2JSON.entities.filter((item) => item.name), ['handle', 'name']);
        let dimensionJSON = sortBy(sourceJSON.entities.filter((item) => item.type == 'DIMENSION'), ['handle']);
        let dimension2JSON = sortBy(source2JSON.entities.filter((item) => item.type == 'DIMENSION'), ['handle']);
        let changePoint1Dimension = [];
        let changePoint2Dimension = [];
        let changeMeasurementDimension = [];
        let newDimension = [];
        let removedDimension = [];
        dimensionJSON = dimensionJSON.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            let angularEntity = objects.find(itemVal => itemVal.name == `Angular [${item.handle}]`);
            if (angularEntity) {
                return { ...item, entity_name: 'angular', dbId: angularEntity.objectid, blockType: angularEntity.type };
            }
            return item;
        });
        dimension2JSON = dimension2JSON.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            let angularEntity = objects.find(itemVal => itemVal.name == `Angular [${item.handle}]`);
            if (angularEntity) {
                return { ...item, entity_name: 'angular', dbId: angularEntity.objectid, blockType: angularEntity.type };
            }
            return item;
        });
        forEach(dimension2JSON, dimentionNew => {
            if (findIndex(dimensionJSON, { handle: dimentionNew.handle }) == -1) {
                newDimension.push(dimentionNew);
            }
        });
        forEach(dimensionJSON, dimentionOriginal => {
            let index = findIndex(dimension2JSON, (item) => item.handle == dimentionOriginal.handle);
            if (index >= 0) {
                if (!isEqual(dimentionOriginal.linearOrAngularPoint1, dimension2JSON[index].linearOrAngularPoint1)) {
                    let oldPosition = {
                        x: ceil(dimentionOriginal.linearOrAngularPoint1.x, 10),
                        y: ceil(dimentionOriginal.linearOrAngularPoint1.y, 10)
                    };
                    let newPosition = {
                        x: ceil(dimension2JSON[index].linearOrAngularPoint1.x, 10),
                        y: ceil(dimension2JSON[index].linearOrAngularPoint1.y, 10)
                    };
                    if (!isEqual(oldPosition, newPosition)) {
                        changePoint1Dimension.push({ ...dimentionOriginal, newPoint1: dimension2JSON[index].linearOrAngularPoint1 });
                    }
                }
                if (!isEqual(dimentionOriginal.linearOrAngularPoint2, dimension2JSON[index].linearOrAngularPoint2)) {
                    let oldPosition = {
                        x: ceil(dimentionOriginal.linearOrAngularPoint2.x, 10),
                        y: ceil(dimentionOriginal.linearOrAngularPoint2.y, 10)
                    };
                    let newPosition = {
                        x: ceil(dimension2JSON[index].linearOrAngularPoint2.x, 10),
                        y: ceil(dimension2JSON[index].linearOrAngularPoint2.y, 10)
                    };
                    if (!isEqual(oldPosition, newPosition)) {
                        changePoint2Dimension.push({ ...dimentionOriginal, newPoint2: dimension2JSON[index].linearOrAngularPoint2 });
                    }
                }
                if (!isEqual(dimentionOriginal.actualMeasurement, dimension2JSON[index].actualMeasurement)) {
                    let oldMeasuremnt = ceil(dimentionOriginal.actualMeasurement, 10);
                    let newMeasuremnt = ceil(dimension2JSON[index].actualMeasurement, 10);
                    if (!isEqual(oldMeasuremnt, newMeasuremnt)) {
                        changeMeasurementDimension.push({ ...dimentionOriginal, newMeasuremnt: dimension2JSON[index].actualMeasurement });
                    }
                }
            }
            else {
                removedDimension.push(dimentionOriginal);
            }
        });
        let removedEntity = [];
        let newEntity = [];
        let changePositionEntity = [];
        let changeRotationEntity = [];
        forEach(sortedJSON, entityOriginal => {
            let index = findIndex(sorted2JSON, { handle: entityOriginal.handle });
            if (index >= 0) {
                if (!isEqual(entityOriginal.position, sorted2JSON[index].position)) {
                    let oldPosition = {
                        x: ceil(entityOriginal.position.x, 10),
                        y: ceil(entityOriginal.position.y, 10)
                    };
                    let newPosition = {
                        x: ceil(sorted2JSON[index].position.x, 10),
                        y: ceil(sorted2JSON[index].position.y, 10)
                    };
                    if (!isEqual(oldPosition, newPosition)) {
                        changePositionEntity.push({ ...entityOriginal, newPosition: sorted2JSON[index].position });
                    }
                }
                if (entityOriginal.rotation !== sorted2JSON[index].rotation) {
                    changeRotationEntity.push({ entityOriginal, newRotation: sorted2JSON[index].rotation });
                }
            }
            else {
                removedEntity.push(entityOriginal);
            }
        });
        forEach(sorted2JSON, entityNew => {
            if (findIndex(sortedJSON, { handle: entityNew.handle }) == -1) {
                newEntity.push(entityNew);
            }
        });
        removedEntity = removedEntity.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        newEntity = newEntity.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        changeRotationEntity = changeRotationEntity.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        changePositionEntity = changePositionEntity.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        return {
            entities: {
                removedEntity: removedEntity.filter((item) => item.dbId),
                newEntity: newEntity.filter((item) => item.dbId),
                changeRotationEntity: changeRotationEntity.filter((item) => item.dbId),
                changePositionEntity: changePositionEntity.filter((item) => item.dbId),
                changePoint1Dimension: changePoint1Dimension.filter((item) => item.dbId),
                changePoint2Dimension: changePoint2Dimension.filter((item) => item.dbId),
                changeMeasurementDimension: changeMeasurementDimension.filter((item) => item.dbId),
                newDimension: newDimension.filter((item) => item.dbId),
                removedDimension: removedDimension.filter((item) => item.dbId),
            }
        };
    }
    _parse(dxfString) {
        const dxf = {};
        let lastHandle = 0;
        const dxfLinesArray = dxfString.split(/\r\n|\r|\n/g);
        const scanner = new DxfArrayScanner(dxfLinesArray);
        if (!scanner.hasNext())
            throw Error('Empty file');
        const self = this;
        let curr;
        function parseAll() {
            curr = scanner.next();
            while (!scanner.isEOF()) {
                if (curr.code === 0 && curr.value === 'SECTION') {
                    curr = scanner.next();
                    // // Be sure we are reading a section code
                    if (curr.code !== 2) {
                        console.error('Unexpected code %s after 0:SECTION', debugCode(curr));
                        curr = scanner.next();
                        continue;
                    }
                    if (curr.value === 'HEADER') {
                        log.debug('> HEADER');
                        dxf.header = parseHeader();
                        log.debug('<');
                    }
                    else if (curr.value === 'BLOCKS') {
                        log.debug('> BLOCKS');
                        const parseBlock = parseBlocks();
                        dxf.blocks = parseBlock.blocks;
                        dxf.fullblocks = parseBlock.fullblocks;
                        log.debug('<');
                    }
                    else if (curr.value === 'ENTITIES') {
                        log.debug('> ENTITIES');
                        dxf.entities = parseEntities(false);
                        log.debug('<');
                    }
                    else if (curr.value === 'TABLES') {
                        log.debug('> TABLES');
                        dxf.tables = parseTables();
                        log.debug('<');
                    }
                    else if (curr.value === 'OBJECTS') {
                        log.debug('EOF');
                        dxf.objects = parseLayerStates();
                    }
                    else if (curr.value === 'EOF') {
                        log.debug('EOF');
                    }
                    else {
                        log.warn('Skipping section \'%s\'', curr.value);
                    }
                }
                else {
                    curr = scanner.next();
                }
                // If is a new section
            }
        }
        function parseLayerStates() {
            curr = scanner.next();
            let layersStates = [];
            let layersStatesValue = {};
            let item = {};
            while (true) {
                if (groupIs(curr, 0, 'ENDSEC')) {
                    break;
                }
                else {
                    if (curr.code == 5) {
                        item.name = curr.value;
                        item.isLayer = false;
                    }
                    else {
                        if (item.name == "18F") {
                            if (curr.code == 3) {
                                item.key = curr.value;
                            }
                            if (curr.code == 350) {
                                item.value = curr.value;
                                layersStates = [...layersStates, { key: item.key, value: item.value }];
                            }
                        }
                        if (curr.code == 330 && curr.value == "18F") {
                            item.isLayer = true;
                        }
                        if (item.isLayer) {
                            if (curr.code == 8) {
                                item.currentLayer = curr.value;
                            }
                            else {
                                if (!layersStatesValue[item.name]) {
                                    layersStatesValue[item.name] = {};
                                }
                                if (!layersStatesValue[item.name][item.currentLayer] && item.currentLayer && item.currentLayer !== "0") {
                                    layersStatesValue[item.name][item.currentLayer] = {};
                                }
                                if (item.currentLayer && item.currentLayer !== "0") {
                                    switch (curr.code) {
                                        case 62: // color, visibility
                                            let visible = curr.value >= 0;
                                            let colorIndex = Math.abs(curr.value);
                                            let color = getAcadColor(colorIndex);
                                            layersStatesValue[item.name][item.currentLayer]["colorIndex"] = colorIndex;
                                            layersStatesValue[item.name][item.currentLayer]["visible"] = visible;
                                            layersStatesValue[item.name][item.currentLayer]["color"] = color;
                                            break;
                                        case 70: // frozen layer
                                            let frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);
                                            layersStatesValue[item.name][item.currentLayer]["frozen"] = frozen;
                                            break;
                                        default:
                                            layersStatesValue[item.name][item.currentLayer][curr.code] = curr.value;
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    // log.warn('OBJECT VALUE \'%s\'', curr);
                    // layersStates.push(curr)
                }
                curr = scanner.next();
            }
            return { layersStates: layersStates, layersStatesValue };
        }
        /**
         *
         * @return {object} header
         */
        function parseHeader() {
            // interesting variables:
            //  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE
            // http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm
            // Also see VPORT table entries
            let currVarName = null;
            let currVarValue = null;
            const header = {};
            // loop through header variables
            curr = scanner.next();
            while (true) {
                if (groupIs(curr, 0, 'ENDSEC')) {
                    if (currVarName)
                        header[currVarName] = currVarValue;
                    break;
                }
                else if (curr.code === 9) {
                    if (currVarName)
                        header[currVarName] = currVarValue;
                    currVarName = curr.value;
                    // Filter here for particular variables we are interested in
                }
                else {
                    if (curr.code === 10) {
                        currVarValue = { x: curr.value };
                    }
                    else if (curr.code === 20) {
                        currVarValue.y = curr.value;
                    }
                    else if (curr.code === 30) {
                        currVarValue.z = curr.value;
                    }
                    else {
                        currVarValue = curr.value;
                    }
                }
                curr = scanner.next();
            }
            // console.log(util.inspect(header, { colors: true, depth: null }));
            curr = scanner.next(); // swallow up ENDSEC
            return header;
        }
        /**
         *
         */
        function parseBlocks() {
            const blocks = {};
            const fullblocks = {};
            curr = scanner.next();
            while (curr.value !== 'EOF') {
                if (groupIs(curr, 0, 'ENDSEC')) {
                    break;
                }
                if (groupIs(curr, 0, 'BLOCK')) {
                    log.debug('block {');
                    const block = parseBlock();
                    log.debug('}');
                    ensureHandle(block);
                    if (!block.name)
                        log.error('block with handle "' + block.handle + '" is missing a name.');
                    else {
                        if (block.type >= 2) {
                            blocks[block.name] = block;
                        }
                        if (block.type == 3) {
                            fullblocks[block.name] = block;
                        }
                    }
                }
                else {
                    logUnhandledGroup(curr);
                    curr = scanner.next();
                }
            }
            return { blocks: blocks, fullblocks: fullblocks };
        }
        function parseBlock() {
            const block = {};
            curr = scanner.next();
            while (curr.value !== 'EOF') {
                switch (curr.code) {
                    case 1:
                        block.xrefPath = curr.value;
                        curr = scanner.next();
                        break;
                    case 2:
                        block.name = curr.value;
                        curr = scanner.next();
                        break;
                    case 3:
                        block.name2 = curr.value;
                        curr = scanner.next();
                        break;
                    case 5:
                        block.handle = curr.value;
                        curr = scanner.next();
                        break;
                    case 8:
                        block.layer = curr.value;
                        curr = scanner.next();
                        break;
                    case 10:
                        block.position = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 67:
                        block.paperSpace = (curr.value && curr.value == 1) ? true : false;
                        curr = scanner.next();
                        break;
                    case 70:
                        if (curr.value != 0) {
                            //if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');
                            //if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');
                            //if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');
                            //if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');
                            //if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');
                            //if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');
                            //if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');
                            block.type = curr.value;
                        }
                        curr = scanner.next();
                        break;
                    case 100:
                        // ignore class markers
                        curr = scanner.next();
                        break;
                    case 330:
                        block.ownerHandle = curr.value;
                        curr = scanner.next();
                        break;
                    case 0:
                        if (curr.value == 'ENDBLK')
                            break;
                        block.entities = parseEntities(true);
                        break;
                    default:
                        logUnhandledGroup(curr);
                        curr = scanner.next();
                }
                if (groupIs(curr, 0, 'ENDBLK')) {
                    curr = scanner.next();
                    break;
                }
            }
            return block;
        }
        /**
         * parseTables
         * @return {Object} Object representing tables
         */
        function parseTables() {
            const tables = {};
            curr = scanner.next();
            while (curr.value !== 'EOF') {
                if (groupIs(curr, 0, 'ENDSEC'))
                    break;
                if (groupIs(curr, 0, 'TABLE')) {
                    curr = scanner.next();
                    const tableDefinition = tableDefinitions[curr.value];
                    if (tableDefinition) {
                        log.debug(curr.value + ' Table {');
                        tables[tableDefinitions[curr.value].tableName] = parseTable(curr);
                        log.debug('}');
                    }
                    else {
                        log.debug('Unhandled Table ' + curr.value);
                    }
                }
                else {
                    // else ignored
                    curr = scanner.next();
                }
            }
            curr = scanner.next();
            return tables;
        }
        const END_OF_TABLE_VALUE = 'ENDTAB';
        function parseTable(group) {
            const tableDefinition = tableDefinitions[group.value];
            const table = {};
            let expectedCount = 0;
            curr = scanner.next();
            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {
                switch (curr.code) {
                    case 5:
                        table.handle = curr.value;
                        curr = scanner.next();
                        break;
                    case 330:
                        table.ownerHandle = curr.value;
                        curr = scanner.next();
                        break;
                    case 100:
                        if (curr.value === 'AcDbSymbolTable') {
                            // ignore
                            curr = scanner.next();
                        }
                        else {
                            logUnhandledGroup(curr);
                            curr = scanner.next();
                        }
                        break;
                    case 70:
                        expectedCount = curr.value;
                        curr = scanner.next();
                        break;
                    case 0:
                        if (curr.value === tableDefinition.dxfSymbolName) {
                            table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();
                        }
                        else {
                            logUnhandledGroup(curr);
                            curr = scanner.next();
                        }
                        break;
                    default:
                        logUnhandledGroup(curr);
                        console.log(curr);
                        curr = scanner.next();
                }
            }
            const tableRecords = table[tableDefinition.tableRecordsProperty];
            if (tableRecords) {
                let actualCount = (() => {
                    if (tableRecords.constructor === Array) {
                        return tableRecords.length;
                    }
                    else if (typeof (tableRecords) === 'object') {
                        return Object.keys(tableRecords).length;
                    }
                    return undefined;
                })();
                if (expectedCount !== actualCount)
                    console.log('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\'s but expected ' + expectedCount);
            }
            curr = scanner.next();
            return table;
        }
        function parseViewPortRecords() {
            const viewPorts = []; // Multiple table entries may have the same name indicating a multiple viewport configuration
            let viewPort = {};
            log.debug('ViewPort {');
            curr = scanner.next();
            while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {
                switch (curr.code) {
                    case 2: // layer name
                        viewPort.name = curr.value;
                        curr = scanner.next();
                        break;
                    case 10:
                        viewPort.lowerLeftCorner = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 11:
                        viewPort.upperRightCorner = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 12:
                        viewPort.center = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 13:
                        viewPort.snapBasePoint = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 14:
                        viewPort.snapSpacing = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 15:
                        viewPort.gridSpacing = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 16:
                        viewPort.viewDirectionFromTarget = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 17:
                        viewPort.viewTarget = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 42:
                        viewPort.lensLength = curr.value;
                        curr = scanner.next();
                        break;
                    case 43:
                        viewPort.frontClippingPlane = curr.value;
                        curr = scanner.next();
                        break;
                    case 44:
                        viewPort.backClippingPlane = curr.value;
                        curr = scanner.next();
                        break;
                    case 45:
                        viewPort.viewHeight = curr.value;
                        curr = scanner.next();
                        break;
                    case 50:
                        viewPort.snapRotationAngle = curr.value;
                        curr = scanner.next();
                        break;
                    case 51:
                        viewPort.viewTwistAngle = curr.value;
                        curr = scanner.next();
                        break;
                    case 79:
                        viewPort.orthographicType = curr.value;
                        curr = scanner.next();
                        break;
                    case 110:
                        viewPort.ucsOrigin = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 111:
                        viewPort.ucsXAxis = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 112:
                        viewPort.ucsYAxis = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 110:
                        viewPort.ucsOrigin = parsePoint(curr);
                        curr = scanner.next();
                        break;
                    case 281:
                        viewPort.renderMode = curr.value;
                        curr = scanner.next();
                        break;
                    case 281:
                        // 0 is one distant light, 1 is two distant lights
                        viewPort.defaultLightingType = curr.value;
                        curr = scanner.next();
                        break;
                    case 292:
                        viewPort.defaultLightingOn = curr.value;
                        curr = scanner.next();
                        break;
                    case 330:
                        viewPort.ownerHandle = curr.value;
                        curr = scanner.next();
                        break;
                    case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.
                    case 421:
                    case 431:
                        viewPort.ambientColor = curr.value;
                        curr = scanner.next();
                        break;
                    case 0:
                        // New ViewPort
                        if (curr.value === 'VPORT') {
                            log.debug('}');
                            viewPorts.push(viewPort);
                            log.debug('ViewPort {');
                            viewPort = {};
                            curr = scanner.next();
                        }
                        break;
                    default:
                        logUnhandledGroup(curr);
                        curr = scanner.next();
                        break;
                }
            }
            // Note: do not call scanner.next() here,
            //  parseTable() needs the current group
            log.debug('}');
            viewPorts.push(viewPort);
            return viewPorts;
        }
        function parseLineTypes() {
            const ltypes = {};
            let ltype = {};
            let length = 0;
            let ltypeName;
            log.debug('LType {');
            curr = scanner.next();
            while (!groupIs(curr, 0, 'ENDTAB')) {
                switch (curr.code) {
                    case 2:
                        ltype.name = curr.value;
                        ltypeName = curr.value;
                        curr = scanner.next();
                        break;
                    case 3:
                        ltype.description = curr.value;
                        curr = scanner.next();
                        break;
                    case 73: // Number of elements for this line type (dots, dashes, spaces);
                        length = curr.value;
                        if (length > 0)
                            ltype.pattern = [];
                        curr = scanner.next();
                        break;
                    case 40: // total pattern length
                        ltype.patternLength = curr.value;
                        curr = scanner.next();
                        break;
                    case 49:
                        ltype.pattern.push(curr.value);
                        curr = scanner.next();
                        break;
                    case 0:
                        log.debug('}');
                        if (length > 0 && length !== ltype.pattern.length)
                            log.warn('lengths do not match on LTYPE pattern');
                        ltypes[ltypeName] = ltype;
                        ltype = {};
                        log.debug('LType {');
                        curr = scanner.next();
                        break;
                    default:
                        curr = scanner.next();
                }
            }
            log.debug('}');
            ltypes[ltypeName] = ltype;
            return ltypes;
        }
        function parseLayers() {
            const layers = {};
            let layer = {};
            let layerName;
            log.debug('Layer {');
            curr = scanner.next();
            while (!groupIs(curr, 0, 'ENDTAB')) {
                switch (curr.code) {
                    case 2: // layer name
                        layer.name = curr.value;
                        layerName = curr.value;
                        curr = scanner.next();
                        break;
                    case 62: // color, visibility
                        layer.visible = curr.value >= 0;
                        // TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.
                        layer.colorIndex = Math.abs(curr.value);
                        layer.color = getAcadColor(layer.colorIndex);
                        curr = scanner.next();
                        break;
                    case 70: // frozen layer
                        layer.frozen = ((curr.value & 1) != 0 || (curr.value & 2) != 0);
                        curr = scanner.next();
                        break;
                    case 0:
                        // New Layer
                        if (curr.value === 'LAYER') {
                            log.debug('}');
                            layers[layerName] = layer;
                            log.debug('Layer {');
                            layer = {};
                            layerName = undefined;
                            curr = scanner.next();
                        }
                        break;
                    default:
                        logUnhandledGroup(curr);
                        curr = scanner.next();
                        break;
                }
            }
            // Note: do not call scanner.next() here,
            //  parseLayerTable() needs the current group
            log.debug('}');
            layers[layerName] = layer;
            return layers;
        }
        const tableDefinitions = {
            VPORT: {
                tableRecordsProperty: 'viewPorts',
                tableName: 'viewPort',
                dxfSymbolName: 'VPORT',
                parseTableRecords: parseViewPortRecords
            },
            LTYPE: {
                tableRecordsProperty: 'lineTypes',
                tableName: 'lineType',
                dxfSymbolName: 'LTYPE',
                parseTableRecords: parseLineTypes
            },
            LAYER: {
                tableRecordsProperty: 'layers',
                tableName: 'layer',
                dxfSymbolName: 'LAYER',
                parseTableRecords: parseLayers
            }
        };
        /**
         * Is called after the parser first reads the 0:ENTITIES group. The scanner
         * should be on the start of the first entity already.
         * @return {Array} the resulting entities
         */
        function parseEntities(forBlock) {
            const entities = [];
            const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';
            if (!forBlock) {
                curr = scanner.next();
            }
            while (true) {
                if (curr.code === 0) {
                    if (curr.value === endingOnValue) {
                        break;
                    }
                    const handler = self._entityHandlers[curr.value];
                    if (handler != null) {
                        log.debug(curr.value + ' {');
                        const entity = handler.parseEntity(scanner, curr);
                        curr = scanner.lastReadGroup;
                        log.debug('}');
                        ensureHandle(entity);
                        //Only fetch the Attributes Def
                        if (forBlock && entity.type == "ATTDEF") {
                            entities.push(entity);
                        }
                        if (!forBlock) {
                            entities.push(entity);
                        }
                    }
                    else {
                        // log.warn('Unhandled entity ' + curr.value);
                        curr = scanner.next();
                        continue;
                    }
                }
                else {
                    // ignored lines from unsupported entity
                    curr = scanner.next();
                }
            }
            if (endingOnValue == 'ENDSEC')
                curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK
            return entities;
        }
        /**
         * Parses a 2D or 3D point, returning it as an object with x, y, and
         * (sometimes) z property if it is 3D. It is assumed the current group
         * is x of the point being read in, and scanner.next() will return the
         * y. The parser will determine if there is a z point automatically.
         * @return {Object} The 2D or 3D point as an object with x, y[, z]
         */
        function parsePoint(curr) {
            const point = {};
            let code = curr.code;
            point.x = curr.value;
            code += 10;
            curr = scanner.next();
            if (curr.code != code)
                throw new Error('Expected code for point value to be ' + code +
                    ' but got ' + curr.code + '.');
            point.y = curr.value;
            code += 10;
            curr = scanner.next();
            if (curr.code != code) {
                scanner.rewind();
                return point;
            }
            point.z = curr.value;
            return point;
        }
        function ensureHandle(entity) {
            if (!entity)
                throw new TypeError('entity cannot be undefined or null');
            if (!entity.handle)
                entity.handle = lastHandle++;
        }
        parseAll();
        return dxf;
    }
    _calculateDistance(x, y, x2, y2) {
        var a = x - x2;
        var b = y - y2;
        var c = Math.sqrt(a * a + b * b);
        return c;
    }
    getTasks(source, entitiesIds) {
        let sourceJSON = null;
        let idsJSON = null;
        try {
            idsJSON = JSON.parse(entitiesIds);
        }
        catch (error) {
            console.log(error);
            idsJSON = entitiesIds;
        }
        try {
            sourceJSON = JSON.parse(source);
        }
        catch (error) {
            console.log(error);
            sourceJSON = source;
        }
        let objects = [];
        idsJSON.data.objects.forEach((model) => {
            model.objects.forEach((itemBlock) => {
                itemBlock.objects.forEach((item) => {
                    if (item.objects && item.objects.length > 0) {
                        item.objects.forEach((item2) => {
                            objects.push({ ...item2, type: itemBlock.name });
                        });
                    }
                    else {
                        objects.push({ ...item, type: itemBlock.name });
                    }
                });
            });
        });
        let hldLayers = [];
        let vfyLayers = [];
        let elcLayers = [];
        let rfiLayers = [];
        let dimensions = [];
        let elcdimensions = [];
        sourceJSON.entities.forEach((block) => {
            if (block.layer.indexOf('-ELC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers.push(block);
                }
                else {
                    elcdimensions.push(block);
                }
            }
            if (block.layer.indexOf('-ELEC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers.push(block);
                }
            }
            if (block.layer.indexOf('-RFI') >= 0) {
                rfiLayers.push(block);
            }
            if (block.layer.indexOf('-VFY') >= 0) {
                vfyLayers.push(block);
            }
            if (block.layer.indexOf('-HLD') >= 0) {
                hldLayers.push(block);
            }
            if (block.type === 'DIMENSION') {
                if (block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1) {
                    dimensions.push(block);
                }
            }
        });
        rfiLayers = rfiLayers.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        elcLayers = elcLayers.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        vfyLayers = vfyLayers.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        hldLayers = hldLayers.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        dimensions = dimensions.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        elcdimensions = elcdimensions.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        const elcUpdatedDimensions = [];
        elcdimensions.forEach((dimension) => {
            let entityPoint1 = null;
            let entityPoint2 = null;
            sourceJSON.entities.forEach((elc) => {
                if (elc.type === 'INSERT') {
                    let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                    let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                    console.log(distancePoint1, distancePoint2);
                    if (distancePoint1 <= 1) {
                        entityPoint1 = elc;
                    }
                    if (distancePoint2 <= 1) {
                        entityPoint2 = elc;
                    }
                }
            });
            elcUpdatedDimensions.push({
                dimension,
                entityPoint1,
                entityPoint2
            });
        });
        elcLayers.forEach((elc) => {
            let elcIndex = elcLayers.findIndex((item) => item.handle === elc.handle);
            let distance = 10000000;
            let dimensionSelected = [];
            dimensions.forEach((dimension) => {
                let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                let newDistance = distancePoint1;
                if (newDistance > distancePoint2) {
                    newDistance = distancePoint2;
                }
                if (distance > newDistance) {
                    distance = newDistance;
                }
                if (newDistance <= 1) {
                    dimensionSelected.push({ ...dimension, distance: newDistance });
                }
            });
            elcLayers[elcIndex] = {
                ...elc,
                dimensions: dimensionSelected
            };
        });
        elcUpdatedDimensions.forEach((elc) => {
            if (elc.entityPoint1) {
                let elcIndex = elcLayers.findIndex((item) => item.handle === elc.entityPoint1.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers[elcIndex] = { ...elcLayers[elcIndex], dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers.push({
                        ...elc.entityPoint1,
                        dimensions: [elc.dimension]
                    });
                }
            }
            if (elc.entityPoint2) {
                let elcIndex = elcLayers.findIndex((item) => item.handle === elc.entityPoint2.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers[elcIndex] = { ...elcLayers[elcIndex], dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers.push({
                        ...elc.entityPoint2,
                        dimensions: [elc.dimension]
                    });
                }
            }
        });
        return {
            hld: hldLayers,
            rfi: rfiLayers,
            vfy: vfyLayers,
            elc: elcLayers,
        };
    }
    getDXFDiff2(source, source2, entitiesIds) {
        let sourceJSON = {};
        let source2JSON = {};
        let idsJSON = [];
        try {
            idsJSON = JSON.parse(entitiesIds);
        }
        catch (error) {
            console.log(error);
            idsJSON = entitiesIds;
        }
        try {
            sourceJSON = JSON.parse(source);
        }
        catch (error) {
            console.log(error);
            sourceJSON = source;
        }
        try {
            source2JSON = JSON.parse(source2);
        }
        catch (error) {
            console.log(error);
            source2JSON = source2;
        }
        let objects = [];
        idsJSON.data.objects.forEach((model) => {
            model.objects.forEach((itemBlock) => {
                itemBlock.objects.forEach((item) => {
                    if (item.objects && item.objects.length > 0) {
                        item.objects.forEach((item2) => {
                            objects.push({ ...item2, type: itemBlock.name });
                        });
                    }
                    else {
                        objects.push({ ...item, type: itemBlock.name });
                    }
                });
            });
        });
        let hldLayers = [];
        let vfyLayers = [];
        let elcLayers = [];
        let rfiLayers = [];
        let dimensions = [];
        let elcdimensions = [];
        sourceJSON.entities.forEach((block) => {
            if (block.layer.indexOf('-ELC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers.push(block);
                }
                else {
                    elcdimensions.push(block);
                }
            }
            if (block.layer.indexOf('-ELEC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers.push(block);
                }
            }
            if (block.layer.indexOf('-RFI') >= 0) {
                rfiLayers.push(block);
            }
            if (block.layer.indexOf('-VFY') >= 0) {
                vfyLayers.push(block);
            }
            if (block.layer.indexOf('-HLD') >= 0) {
                hldLayers.push(block);
            }
            if (block.type === 'DIMENSION') {
                if (block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1) {
                    dimensions.push(block);
                }
            }
        });
        rfiLayers = rfiLayers.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        elcLayers = elcLayers.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        vfyLayers = vfyLayers.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        hldLayers = hldLayers.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        dimensions = dimensions.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        elcdimensions = elcdimensions.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        const elcUpdatedDimensions = [];
        elcdimensions.forEach((dimension) => {
            let entityPoint1 = null;
            let entityPoint2 = null;
            sourceJSON.entities.forEach((elc) => {
                if (elc.type === 'INSERT') {
                    let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                    let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                    console.log(distancePoint1, distancePoint2);
                    if (distancePoint1 <= 1) {
                        entityPoint1 = elc;
                    }
                    if (distancePoint2 <= 1) {
                        entityPoint2 = elc;
                    }
                }
            });
            elcUpdatedDimensions.push({
                dimension,
                entityPoint1,
                entityPoint2
            });
        });
        elcLayers.forEach((elc) => {
            let elcIndex = elcLayers.findIndex((item) => item.handle === elc.handle);
            let distance = 10000000;
            let dimensionSelected = [];
            dimensions.forEach((dimension) => {
                let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                let newDistance = distancePoint1;
                if (newDistance > distancePoint2) {
                    newDistance = distancePoint2;
                }
                if (distance > newDistance) {
                    distance = newDistance;
                }
                if (newDistance <= 1) {
                    dimensionSelected.push({ ...dimension, distance: newDistance });
                }
            });
            elcLayers[elcIndex] = {
                ...elc,
                dimensions: dimensionSelected
            };
        });
        elcUpdatedDimensions.forEach((elc) => {
            if (elc.entityPoint1) {
                let elcIndex = elcLayers.findIndex((item) => item.handle === elc.entityPoint1.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers[elcIndex] = { ...elcLayers[elcIndex], dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers.push({
                        ...elc.entityPoint1,
                        dimensions: [elc.dimension]
                    });
                }
            }
            if (elc.entityPoint2) {
                let elcIndex = elcLayers.findIndex((item) => item.handle === elc.entityPoint2.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers[elcIndex] = { ...elcLayers[elcIndex], dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers.push({
                        ...elc.entityPoint2,
                        dimensions: [elc.dimension]
                    });
                }
            }
        });
        let hldLayers2 = [];
        let vfyLayers2 = [];
        let elcLayers2 = [];
        let rfiLayers2 = [];
        let dimensions2 = [];
        let elcdimensions2 = [];
        source2JSON.entities.forEach((block) => {
            if (block.layer.indexOf('-ELC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers2.push(block);
                }
                else {
                    elcdimensions2.push(block);
                }
            }
            if (block.layer.indexOf('-ELEC') >= 0) {
                if (block.type !== 'DIMENSION') {
                    elcLayers2.push(block);
                }
            }
            if (block.layer.indexOf('-RFI') >= 0) {
                rfiLayers2.push(block);
            }
            if (block.layer.indexOf('-VFY') >= 0) {
                vfyLayers2.push(block);
            }
            if (block.layer.indexOf('-HLD') >= 0) {
                hldLayers2.push(block);
            }
            if (block.type === 'DIMENSION') {
                if (block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1) {
                    dimensions2.push(block);
                }
            }
        });
        rfiLayers2 = rfiLayers2.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        elcLayers2 = elcLayers2.map((item) => {
            let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
            if (entity) {
                return { ...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type };
            }
            return item;
        });
        vfyLayers2 = vfyLayers2.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        hldLayers2 = hldLayers2.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        dimensions2 = dimensions2.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        elcdimensions2 = elcdimensions2.map((item) => {
            let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
            if (linearEntity) {
                return { ...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type };
            }
            return item;
        });
        const elcUpdatedDimensions2 = [];
        elcdimensions2.forEach((dimension) => {
            let entityPoint1 = null;
            let entityPoint2 = null;
            sourceJSON.entities.forEach((elc) => {
                if (elc.type === 'INSERT') {
                    let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                    let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                    console.log(distancePoint1, distancePoint2);
                    if (distancePoint1 <= 1) {
                        entityPoint1 = elc;
                    }
                    if (distancePoint2 <= 1) {
                        entityPoint2 = elc;
                    }
                }
            });
            elcUpdatedDimensions2.push({
                dimension,
                entityPoint1,
                entityPoint2
            });
        });
        elcLayers2.forEach((elc) => {
            let elcIndex = elcLayers2.findIndex((item) => item.handle === elc.handle);
            let distance = 10000000;
            let dimensionSelected = [];
            dimensions.forEach((dimension) => {
                let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
                let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
                let newDistance = distancePoint1;
                if (newDistance > distancePoint2) {
                    newDistance = distancePoint2;
                }
                if (distance > newDistance) {
                    distance = newDistance;
                }
                if (newDistance <= 1) {
                    dimensionSelected.push({ ...dimension, distance: newDistance });
                }
            });
            elcLayers2[elcIndex] = {
                ...elc,
                dimensions: dimensionSelected
            };
        });
        elcUpdatedDimensions2.forEach((elc) => {
            if (elc.entityPoint1) {
                let elcIndex = elcLayers2.findIndex((item) => item.handle === elc.entityPoint1.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers2[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers2[elcIndex] = { ...elcLayers2[elcIndex], dimensions: [...elcLayers2[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers.push({
                        ...elc.entityPoint1,
                        dimensions: [elc.dimension]
                    });
                }
            }
            if (elc.entityPoint2) {
                let elcIndex = elcLayers2.findIndex((item) => item.handle === elc.entityPoint2.handle);
                if (elcIndex >= 0) {
                    let dimIndex = elcLayers2[elcIndex].dimensions.findIndex((item) => item.handle === elc.dimension.handle);
                    if (dimIndex === -1) {
                        elcLayers2[elcIndex] = { ...elcLayers2[elcIndex], dimensions: [...elcLayers2[elcIndex].dimensions, elc.dimension] };
                    }
                }
                else {
                    elcLayers2.push({
                        ...elc.entityPoint2,
                        dimensions: [elc.dimension]
                    });
                }
            }
        });
        const returnArray1 = {
            hld: hldLayers,
            rfi: rfiLayers,
            vfy: vfyLayers,
            elc: elcLayers,
            dimensions: dimensions,
        };
        const returnArray2 = {
            hld: hldLayers2,
            rfi: rfiLayers2,
            vfy: vfyLayers2,
            elc: elcLayers2,
            dimensions: dimensions2,
        };
        return {
            hld: this.getComaprison(returnArray1.hld, returnArray2.hld),
            elc: this.getComaprison(returnArray1.elc, returnArray2.elc),
            vfy: this.getComaprison(returnArray1.vfy, returnArray2.vfy),
            rfi: this.getComaprison(returnArray1.rfi, returnArray2.rfi),
            dimensions: this.getComaprison(returnArray1.dimensions, returnArray2.dimensions),
        };
    }
    getComaprison(array1, array2) {
        const removed = [];
        const added = [];
        const modified = [];
        forEach(array2, (item) => {
            if (findIndex(array1, { handle: item.handle }) == -1) {
                added.push(item);
            }
        });
        forEach(array1, entityOriginal => {
            let index = findIndex(array2, { handle: entityOriginal.handle });
            if (index >= 0) {
                if (array2[index].type !== 'DIMENSION') {
                    if (!isEqual(entityOriginal.position, array2[index].position)) {
                        let oldPosition = {
                            x: ceil(entityOriginal.position.x, 10),
                            y: ceil(entityOriginal.position.y, 10)
                        };
                        let newPosition = {
                            x: ceil(array2[index].position.x, 10),
                            y: ceil(array2[index].position.y, 10)
                        };
                        if (!isEqual(oldPosition, newPosition)) {
                            modified.push({ ...entityOriginal, newPosition: array2[index].position, type: 'change_position' });
                        }
                    }
                    if (entityOriginal.rotation !== array2[index].rotation) {
                        modified.push({ entityOriginal, newRotation: array2[index].rotation, type: 'change_rotation' });
                    }
                    if (array2[index].dimensions && array2[index].dimensions.lenght > 0) {
                        let dimensionChanges = this.getComaprison(array1[index].dimensions, array2[index].dimensions);
                        if (dimensionChanges.added.length > 0) {
                            modified.push({ entityOriginal, addedDimension: dimensionChanges.added, type: 'add_dimension' });
                        }
                        if (dimensionChanges.removed.length > 0) {
                            modified.push({ entityOriginal, removedDimension: dimensionChanges.removed, type: 'removed_dimension' });
                        }
                        if (dimensionChanges.modified.length > 0) {
                            modified.push({ entityOriginal, modifiedDimension: dimensionChanges.modified, type: 'modified_dimension' });
                        }
                    }
                }
                else {
                    if (!isEqual(entityOriginal.linearOrAngularPoint1, array2[index].linearOrAngularPoint1)) {
                        let oldPosition = {
                            x: ceil(entityOriginal.linearOrAngularPoint1.x, 10),
                            y: ceil(entityOriginal.linearOrAngularPoint1.y, 10)
                        };
                        let newPosition = {
                            x: ceil(array2[index].linearOrAngularPoint1.x, 10),
                            y: ceil(array2[index].linearOrAngularPoint1.y, 10)
                        };
                        if (!isEqual(oldPosition, newPosition)) {
                            modified.push({ ...entityOriginal, newPoint1: array2[index].linearOrAngularPoint1, type: 'change_position' });
                        }
                    }
                    if (!isEqual(entityOriginal.linearOrAngularPoint2, array2[index].linearOrAngularPoint2)) {
                        let oldPosition = {
                            x: ceil(entityOriginal.linearOrAngularPoint2.x, 10),
                            y: ceil(entityOriginal.linearOrAngularPoint2.y, 10)
                        };
                        let newPosition = {
                            x: ceil(array2[index].linearOrAngularPoint2.x, 10),
                            y: ceil(array2[index].linearOrAngularPoint2.y, 10)
                        };
                        if (!isEqual(oldPosition, newPosition)) {
                            modified.push({ ...entityOriginal, newPoint2: array2[index].linearOrAngularPoint2, type: 'change_position' });
                        }
                    }
                    if (!isEqual(entityOriginal.actualMeasurement, array2[index].actualMeasurement)) {
                        let oldMeasuremnt = ceil(entityOriginal.actualMeasurement, 10);
                        let newMeasuremnt = ceil(array2[index].actualMeasurement, 10);
                        if (!isEqual(oldMeasuremnt, newMeasuremnt)) {
                            modified.push({ ...entityOriginal, newMeasuremnt: array2[index].actualMeasurement, type: 'change_measurement' });
                        }
                    }
                }
            }
            else {
                removed.push(entityOriginal);
            }
        });
        return {
            removed,
            added,
            modified,
        };
    }
    cleanDxf(source) {
        if (typeof source === 'string') {
            let dxfData = this._parse(source);
            const blocks = [];
            forEach(dxfData.fullblocks, (item) => {
                if (item.type >= 3) {
                    if (item.name[0] === '*') {
                        blocks.push(item.name);
                    }
                }
            });
            const dxfLinesArray = source.split(/\r\n|\r|\n/g);
            let dxfStr = '';
            let entity = '';
            for (var i = 0; i < dxfLinesArray.length; i++) {
                let lineVal = dxfLinesArray[i];
                let indexVal = findIndex(blocks, (item) => item == dxfLinesArray[i]);
                if (indexVal >= 0) {
                    entity = lineVal;
                    console.log(lineVal);
                    lineVal = lineVal.substring(1);
                }
                if (i > 2) {
                    let prevVal = dxfLinesArray[i - 1];
                    let entityVal = dxfLinesArray[i - 2];
                    let block = dxfLinesArray[i - 4];
                    if (prevVal.trim() === '70' && entityVal === entity && block == 'AcDbBlockBegin') {
                        console.log('Hail Lord', entity);
                        lineVal = replace(lineVal, '3', '2');
                    }
                }
                dxfStr = dxfStr + lineVal + '\r\n';
            }
            return dxfStr;
        }
        else {
            console.error('Cannot read dxf source of type `' + typeof (source));
            return null;
        }
    }
}
function groupIs(group, code, value) {
    return group.code === code && group.value === value;
}
function logUnhandledGroup(curr) {
    log.debug('unhandled group ' + debugCode(curr));
}
function debugCode(curr) {
    return curr.code + ':' + curr.value;
}
/**
 * Returns the truecolor value of the given AutoCad color index value
 * @return {Number} truecolor value as a number
 */
function getAcadColor(index) {
    return AUTO_CAD_COLOR_INDEX[index];
}
// const BLOCK_ANONYMOUS_FLAG = 1;
// const BLOCK_NON_CONSTANT_FLAG = 2;
// const BLOCK_XREF_FLAG = 4;
// const BLOCK_XREF_OVERLAY_FLAG = 8;
// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;
// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;
// const BLOCK_REFERENCED_XREF = 64;
/* Notes */
// Code 6 of an entity indicates inheritance of properties (eg. color).
//   BYBLOCK means inherits from block
//   BYLAYER (default) mean inherits from layer
