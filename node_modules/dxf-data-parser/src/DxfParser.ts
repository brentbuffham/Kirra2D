import { Readable } from 'stream';
import DxfArrayScanner, { IGroup } from './DxfArrayScanner';
import AUTO_CAD_COLOR_INDEX from './AutoCadColorIndex';
import {sortBy, forEach, findIndex, isEqual, ceil, replace} from 'lodash';

import Face from './entities/3dface';
import Arc from './entities/arc';
import AttDef from './entities/attdef';
import Circle from './entities/circle';
import Dimension from './entities/dimension';
import Ellipse from './entities/ellipse';
import Insert from './entities/insert';
import Line from './entities/line';
import LWPolyline from './entities/lwpolyline';
import MText from './entities/mtext';
import Point from './entities/point';
import Polyline from './entities/polyline';
import Solid from './entities/solid';
import Spline from './entities/spline';
import Text from './entities/text';
import Multileader from './entities/multileader';
//import Vertex from './entities/';

import log from 'loglevel';
import IGeometry, { EntityName, IEntity, IPoint } from './entities/geomtry';

//log.setLevel('trace');
//log.setLevel('debug');
//log.setLevel('info');
// log.setLevel('warn');
log.setLevel('error');
//log.setLevel('silent');

export interface IBlock {
	entities: IEntity[];
	type: number;
	ownerHandle: string;
	// entities: any[];
	xrefPath: string;
	name: string;
	name2: string;
	handle: string;
	layer: string;
	position: IPoint;
	paperSpace: boolean;
}

export interface IViewPort {
	name: string;
	lowerLeftCorner: IPoint;
	upperRightCorner: IPoint;
	center: IPoint;
	snapBasePoint: IPoint;
	snapSpacing: IPoint;
	gridSpacing: IPoint;
	viewDirectionFromTarget: IPoint;
	viewTarget: IPoint;
	lensLength: number;
	frontClippingPlane: string | number | boolean;
	backClippingPlane: string | number | boolean;
	viewHeight: number;
	snapRotationAngle: number;
	viewTwistAngle: number;
	orthographicType: string;
	ucsOrigin: IPoint;
	ucsXAxis: IPoint;
	ucsYAxis: IPoint;
	renderMode: string;
	defaultLightingType: string;
	defaultLightingOn: string;
	ownerHandle: string;
	ambientColor: number;
}

export interface IViewPortTableDefinition {
	tableRecordsProperty: 'viewPorts';
	tableName: 'viewPort';
	dxfSymbolName: 'VPORT';
	parseTableRecords(): IViewPort[];
}

export interface ILineType {
	name: string;
	description: string;
	pattern: string[];
	patternLength: number;
}

export interface ILineTypeTableDefinition {
	tableRecordsProperty: 'lineTypes';
	tableName: 'lineType';
	dxfSymbolName: 'LTYPE';
	parseTableRecords(): Record<string, ILineType>;
}

export interface ILayer {
	name: string;
	visible: boolean;
	colorIndex: number;
	color: number;
	frozen: boolean;
}

export interface ILayerTableDefinition {
	tableRecordsProperty: 'layers';
	tableName: 'layer';
	dxfSymbolName: 'LAYER';
	parseTableRecords(): Record<string, ILayer>;
}

export interface ITableDefinitions {
	VPORT: IViewPortTableDefinition;
	LTYPE: ILineTypeTableDefinition;
	LAYER: ILayerTableDefinition;
}

export interface IBaseTable {
	handle: string;
	ownerHandle: string;
}

export interface IViewPortTable extends IBaseTable {
	viewPorts: IViewPort[];
}

export interface ILayerTypesTable extends IBaseTable {
	lineTypes: Record<string, ILineType>;
}

export interface ILayersTable extends IBaseTable {
	layers: Record<string, ILayer>;
}

export interface ITables {
	viewPort: IViewPortTable;
	lineType: ILayerTypesTable;
	layer: ILayersTable;
}

export type ITable = IViewPortTable | ILayerTypesTable | ILayersTable;

export interface IDxf {
	header: Record<string, IPoint | number>;
	entities: IEntity[];
	blocks: Record<string, IBlock>;
	fullblocks: Record<string, IBlock>;
	tables: ITables;
	objects: {};
}

function registerDefaultEntityHandlers(dxfParser: DxfParser) {
	// Supported entities here (some entity code is still being refactored into this flow)
	dxfParser.registerEntityHandler(Face);
	dxfParser.registerEntityHandler(Arc);
	dxfParser.registerEntityHandler(AttDef);
	dxfParser.registerEntityHandler(Circle);
	dxfParser.registerEntityHandler(Dimension);
	dxfParser.registerEntityHandler(Ellipse);
	dxfParser.registerEntityHandler(Insert);
	dxfParser.registerEntityHandler(Line);
	dxfParser.registerEntityHandler(LWPolyline);
	dxfParser.registerEntityHandler(MText);
	dxfParser.registerEntityHandler(Point);
	dxfParser.registerEntityHandler(Polyline);
	dxfParser.registerEntityHandler(Solid);
	dxfParser.registerEntityHandler(Spline);
	dxfParser.registerEntityHandler(Text);
	dxfParser.registerEntityHandler(Multileader);
	//dxfParser.registerEntityHandler(require('./entities/vertex'));
}

export default class DxfParser {
	private _entityHandlers = {} as Record<EntityName, IGeometry>;
	constructor() {
		registerDefaultEntityHandlers(this);
	}

	public parse(source: string) {
		if (typeof source === 'string') {
			return this._parse(source);
		} else {
			console.error('Cannot read dxf source of type `' + typeof (source));
			return null;
		}
	}

	public registerEntityHandler(handlerType: new () => IGeometry) {
		const instance = new handlerType();
		this._entityHandlers[instance.ForEntityName] = instance;
	}

	public parseSync(source: string) {
		return this.parse(source);
	}

	public parseStream(stream: Readable) {

		let dxfString = "";
		const self = this;
		return new Promise<IDxf>((res, rej) => {

			stream.on('data', (chunk) => {
				dxfString += chunk;
			});
			stream.on('end', () => {
				try {
					res(self._parse(dxfString));
				} catch (err) {
					rej(err);
				}
			});
			stream.on('error', (err) => {
				rej(err);
			});
		});
	}


	public getEntities(source: any, entitiesIds: any) {
		let sourceJSON = null;
		let idsJSON = null;
		try {
			idsJSON = JSON.parse(entitiesIds);
		} catch (error) {
			console.log(error);
			idsJSON = entitiesIds;
		}

		try {
			sourceJSON = JSON.parse(source);
		} catch (error) {
			console.log(error);
			sourceJSON = source;
		}
		let objects:any[] = [];
		idsJSON.data.objects.forEach((model:any) => {
			model.objects.forEach((itemBlock:any) => {
				itemBlock.objects.forEach((item:any) => {
					if(item.objects && item.objects.length > 0){
						item.objects.forEach((item2:any) => {
							objects.push({...item2,type: itemBlock.name});
						});
					}else{
						objects.push({...item,type: itemBlock.name});
					}
				});
			});
		});
		
		let retValue = sourceJSON.entities;
		let entities = retValue.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});
		
		let dimension = retValue.filter((item: any) => item.type == 'DIMENSION');
		dimension = dimension.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});
		return {
			entities: entities.filter((item: any) => item.dbId),
			dimension: dimension
		};
	}


	public getDXFDiff(source: any, source2: any, entitiesIds: any) {
    let sourceJSON: any = {};
    let source2JSON: any = {};
		let idsJSON = [];
		try {
			idsJSON = JSON.parse(entitiesIds);
		} catch (error) {
			console.log(error);
			idsJSON = entitiesIds;
		}

		try {
			sourceJSON = JSON.parse(source);
		} catch (error) {
			console.log(error);
			sourceJSON = source;
		}
    try {
			source2JSON = JSON.parse(source2);
		} catch (error) {
			console.log(error);
			source2JSON = source2;
		}

		let objects:any[] = [];
		idsJSON.data.objects.forEach((model:any) => {
			model.objects.forEach((itemBlock:any) => {
				itemBlock.objects.forEach((item:any) => {
					if(item.objects && item.objects.length > 0){
						item.objects.forEach((item2:any) => {
							objects.push({...item2,type: itemBlock.name});
						});
					}else{
						objects.push({...item,type: itemBlock.name});
					}
				});
			});
		});
    let sortedJSON = sortBy( sourceJSON.entities.filter((item: any) => item.name), ['handle', 'name']);
    let sorted2JSON = sortBy(source2JSON.entities.filter((item: any) => item.name), ['handle', 'name']);

    let dimensionJSON = sortBy( sourceJSON.entities.filter((item: any) => item.type == 'DIMENSION'), ['handle']);
    let dimension2JSON = sortBy(source2JSON.entities.filter((item: any) => item.type == 'DIMENSION'), ['handle']);

    let changePoint1Dimension: any[] = [];
    let changePoint2Dimension: any[] = [];
    let changeMeasurementDimension: any[] = [];
    let newDimension: any[] = [];
    let removedDimension: any[] = [];
    

    dimensionJSON = dimensionJSON.map((item: any) => {
      let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
      if(linearEntity){
        return {...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type}
      }

      let angularEntity = objects.find(itemVal => itemVal.name == `Angular [${item.handle}]`);
      if(angularEntity){
        return {...item, entity_name: 'angular', dbId: angularEntity.objectid, blockType: angularEntity.type}
      }
      return item;
    });

    dimension2JSON = dimension2JSON.map((item: any) => {
      let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
      if(linearEntity){
        return {...item, entity_name: 'linear', dbId: linearEntity.objectid, blockType: linearEntity.type}
      }

      let angularEntity = objects.find(itemVal => itemVal.name == `Angular [${item.handle}]`);
      if(angularEntity){
        return {...item, entity_name: 'angular', dbId: angularEntity.objectid, blockType: angularEntity.type}
      }
      return item;
    });

    forEach(dimension2JSON, dimentionNew=> {
      if(findIndex(dimensionJSON, {handle: dimentionNew.handle}) == -1 ){
        newDimension.push(dimentionNew);
      }
    });

    forEach(dimensionJSON, dimentionOriginal=> {
      let index = findIndex(dimension2JSON,(item)=>item.handle==dimentionOriginal.handle);
      if(index >= 0 ){
        if(!isEqual(dimentionOriginal.linearOrAngularPoint1,dimension2JSON[index].linearOrAngularPoint1)){
          let oldPosition = {
            x: ceil(dimentionOriginal.linearOrAngularPoint1.x, 10),
            y: ceil(dimentionOriginal.linearOrAngularPoint1.y, 10)
          }
          let newPosition = {
            x: ceil(dimension2JSON[index].linearOrAngularPoint1.x, 10),
            y: ceil(dimension2JSON[index].linearOrAngularPoint1.y, 10)
          }
          if(!isEqual(oldPosition,newPosition)){
            changePoint1Dimension.push({...dimentionOriginal, newPoint1: dimension2JSON[index].linearOrAngularPoint1});
          }
        }
        if(!isEqual(dimentionOriginal.linearOrAngularPoint2,dimension2JSON[index].linearOrAngularPoint2)){
          let oldPosition = {
            x: ceil(dimentionOriginal.linearOrAngularPoint2.x, 10),
            y: ceil(dimentionOriginal.linearOrAngularPoint2.y, 10)
          }
          let newPosition = {
            x: ceil(dimension2JSON[index].linearOrAngularPoint2.x, 10),
            y: ceil(dimension2JSON[index].linearOrAngularPoint2.y, 10)
          }
          if(!isEqual(oldPosition,newPosition)){
            changePoint2Dimension.push({...dimentionOriginal, newPoint2: dimension2JSON[index].linearOrAngularPoint2});
          }
        }
        if(!isEqual(dimentionOriginal.actualMeasurement,dimension2JSON[index].actualMeasurement)){
          let oldMeasuremnt = ceil(dimentionOriginal.actualMeasurement, 10);
          let newMeasuremnt = ceil(dimension2JSON[index].actualMeasurement, 10)
          if(!isEqual(oldMeasuremnt,newMeasuremnt)){
            changeMeasurementDimension.push({...dimentionOriginal, newMeasuremnt: dimension2JSON[index].actualMeasurement});
          }
        }
      }else{
        removedDimension.push(dimentionOriginal);
      }
    });


    let removedEntity: any[] = [];
    let newEntity: any[] = [];
    let changePositionEntity: any[] = [];
    let changeRotationEntity: any[] = [];

    forEach(sortedJSON, entityOriginal=> {
      let index = findIndex(sorted2JSON, {handle: entityOriginal.handle});
      if(index >= 0 ){
        if(!isEqual(entityOriginal.position,sorted2JSON[index].position)){
          let oldPosition = {
            x: ceil(entityOriginal.position.x, 10),
            y: ceil(entityOriginal.position.y, 10)
          }
          let newPosition = {
            x: ceil(sorted2JSON[index].position.x, 10),
            y: ceil(sorted2JSON[index].position.y, 10)
          }
          if(!isEqual(oldPosition,newPosition)){
            changePositionEntity.push({...entityOriginal, newPosition: sorted2JSON[index].position});
          }
        }
        if(entityOriginal.rotation !== sorted2JSON[index].rotation){
          changeRotationEntity.push({entityOriginal, newRotation: sorted2JSON[index].rotation});
        }
      }else{
        removedEntity.push(entityOriginal);
      }
    });

    forEach(sorted2JSON, entityNew=> {
      if(findIndex(sortedJSON, {handle: entityNew.handle}) == -1 ){
        newEntity.push(entityNew);
      }
    });

    removedEntity = removedEntity.map((item: any) => {
      let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
      if(entity){
        return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
      }
      return item;
    });

    newEntity = newEntity.map((item: any) => {
      let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
      if(entity){
        return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
      }
      return item;
    });

    changeRotationEntity = changeRotationEntity.map((item: any) => {
      let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
      if(entity){
        return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
      }
      return item;
    });

    changePositionEntity = changePositionEntity.map((item: any) => {
      let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
      if(entity){
        return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
      }
      return item;
    });    

    return {
      entities: {
        removedEntity: removedEntity.filter((item: any) => item.dbId),
        newEntity: newEntity.filter((item: any) => item.dbId),
        changeRotationEntity: changeRotationEntity.filter((item: any) => item.dbId),
        changePositionEntity: changePositionEntity.filter((item: any) => item.dbId),
        changePoint1Dimension: changePoint1Dimension.filter((item: any) => item.dbId),
        changePoint2Dimension: changePoint2Dimension.filter((item: any) => item.dbId),
        changeMeasurementDimension: changeMeasurementDimension.filter((item: any) => item.dbId),
        newDimension: newDimension.filter((item: any) => item.dbId),
        removedDimension: removedDimension.filter((item: any) => item.dbId),
      }
    }
  }
	private _parse(dxfString: string) {
		const dxf = {} as IDxf;
		let lastHandle = 0;
		const dxfLinesArray = dxfString.split(/\r\n|\r|\n/g);

		const scanner = new DxfArrayScanner(dxfLinesArray);
		if (!scanner.hasNext()) throw Error('Empty file');

		const self = this;
		let curr: IGroup;

		function parseAll() {
			curr = scanner.next();
			while (!scanner.isEOF()) {
				if (curr.code === 0 && curr.value === 'SECTION') {
					curr = scanner.next();

					// // Be sure we are reading a section code
					if (curr.code !== 2) {
						console.error('Unexpected code %s after 0:SECTION', debugCode(curr));
						curr = scanner.next();
						continue;
					}

					if (curr.value === 'HEADER') {
						log.debug('> HEADER');
						dxf.header = parseHeader();
						log.debug('<');
					} else if (curr.value === 'BLOCKS') {
						log.debug('> BLOCKS');
						const parseBlock = parseBlocks();
						dxf.blocks = parseBlock.blocks;
						dxf.fullblocks = parseBlock.fullblocks;
						log.debug('<');
					} 
					else if (curr.value === 'ENTITIES') {
						log.debug('> ENTITIES');
						dxf.entities = parseEntities(false);
						log.debug('<');
					} 
					else 
					if (curr.value === 'TABLES') {
						log.debug('> TABLES');
						dxf.tables = parseTables();
						log.debug('<');
					}
					else 
					if (curr.value === 'OBJECTS') {
						log.debug('EOF');
						dxf.objects = parseLayerStates();
					} else if (curr.value === 'EOF') {
						log.debug('EOF');
					}else {
						log.warn('Skipping section \'%s\'', curr.value);
					}
				} else {
					curr = scanner.next();
				}
				// If is a new section
			}
		}


		function parseLayerStates() {
			curr = scanner.next();
			let layersStates: any = [];
			let layersStatesValue: any = {};
			let item:any = {};
			while (true) {
				if (groupIs(curr, 0, 'ENDSEC')) {
					break;
				} else {
					if(curr.code == 5){
						item.name = curr.value
						item.isLayer = false;
					}else{
						if(item.name == "18F"){
							if(curr.code == 3){
								item.key = curr.value;
							}
							if(curr.code == 350){
								item.value = curr.value;
								layersStates = [...layersStates,{key: item.key, value: item.value}];

							}
						}

						if(curr.code == 330 && curr.value == "18F"){
							item.isLayer = true;
						}

						if(item.isLayer){
							if(curr.code == 8){
								item.currentLayer = curr.value;
							}else{
								if(!layersStatesValue[item.name]){
									layersStatesValue[item.name] = {};
								}
								if(!layersStatesValue[item.name][item.currentLayer] && item.currentLayer && item.currentLayer !== "0"){
									layersStatesValue[item.name][item.currentLayer] = {}
								}
								if(item.currentLayer && item.currentLayer !== "0"){
									switch (curr.code) {
										case 62: // color, visibility
											let visible = curr.value >= 0;
											let colorIndex = Math.abs(curr.value as number);
											let color = getAcadColor(colorIndex as number);
											layersStatesValue[item.name][item.currentLayer]["colorIndex"] = colorIndex;
											layersStatesValue[item.name][item.currentLayer]["visible"] = visible;
											layersStatesValue[item.name][item.currentLayer]["color"] = color;
											break;
										case 70: // frozen layer
											let frozen = (((curr.value as number) & 1) != 0 || ((curr.value as number) & 2) != 0);
											layersStatesValue[item.name][item.currentLayer]["frozen"] = frozen;
											break;
										default:
											layersStatesValue[item.name][item.currentLayer][curr.code] = curr.value;
											break;
									}
								}
							}
						}
						
					}
					// log.warn('OBJECT VALUE \'%s\'', curr);
					// layersStates.push(curr)
				}
				curr = scanner.next();
			}
			return {layersStates: layersStates, layersStatesValue};
		}

		/**
		 *
		 * @return {object} header
		 */
		function parseHeader() {
			// interesting variables:
			//  $ACADVER, $VIEWDIR, $VIEWSIZE, $VIEWCTR, $TDCREATE, $TDUPDATE
			// http://www.autodesk.com/techpubs/autocad/acadr14/dxf/header_section_al_u05_c.htm
			// Also see VPORT table entries
			let currVarName = null as null | string;
			let currVarValue = null as null | IPoint | number;
			const header = {} as Record<string, IPoint | number>;
			// loop through header variables
			curr = scanner.next();

			while (true) {
				if (groupIs(curr, 0, 'ENDSEC')) {
					if (currVarName) header[currVarName as string] = currVarValue!;
					break;
				} else if (curr.code === 9) {
					if (currVarName) header[currVarName as string] = currVarValue!;
					currVarName = curr.value as string;
					// Filter here for particular variables we are interested in
				} else {
					if (curr.code === 10) {
						currVarValue = { x: curr.value as number } as IPoint;
					} else if (curr.code === 20) {
						(currVarValue as IPoint).y = curr.value as number;
					} else if (curr.code === 30) {
						(currVarValue as IPoint).z = curr.value as number;
					} else {
						currVarValue = curr.value as number;
					}
				}
				curr = scanner.next();
			}
			// console.log(util.inspect(header, { colors: true, depth: null }));
			curr = scanner.next(); // swallow up ENDSEC
			return header;
		}


		/**
		 *
		 */
		function parseBlocks() {
			const blocks = {} as Record<string, IBlock>;
			const fullblocks = {} as Record<string, IBlock>;

			curr = scanner.next();

			while (curr.value !== 'EOF') {
				if (groupIs(curr, 0, 'ENDSEC')) {
					break;
				}

				if (groupIs(curr, 0, 'BLOCK')) {
					log.debug('block {');
					const block = parseBlock();
					log.debug('}');
					ensureHandle(block);
					if (!block.name)
						log.error('block with handle "' + block.handle + '" is missing a name.');
					else{
						if(block.type >= 2){
							blocks[block.name] = block;
						}
						if(block.type == 3){
							fullblocks[block.name] = block;
						}
					}
				} else {
					logUnhandledGroup(curr);
					curr = scanner.next();
				}
			}
			return {blocks: blocks, fullblocks: fullblocks};
		}

		function parseBlock() {
			const block = {} as IBlock;
			curr = scanner.next();
			
			while (curr.value !== 'EOF') {
				switch (curr.code) {
					case 1:
						block.xrefPath = curr.value as string;
						curr = scanner.next();
						break;
					case 2:
						block.name = curr.value as string;
						curr = scanner.next();
						break;
					case 3:
						block.name2 = curr.value as string;
						curr = scanner.next();
						break;
					case 5:
						block.handle = curr.value as string;
						curr = scanner.next();
						break;
					case 8:
						block.layer = curr.value as string;
						curr = scanner.next();
						break;
					case 10:
						block.position = parsePoint(curr);
						curr = scanner.next();
						break;
					case 67:
						block.paperSpace = (curr.value && curr.value == 1) ? true : false;
						curr = scanner.next();
						break;
					case 70:
						if (curr.value != 0) {
							//if(curr.value & BLOCK_ANONYMOUS_FLAG) console.log('  Anonymous block');
							//if(curr.value & BLOCK_NON_CONSTANT_FLAG) console.log('  Non-constant attributes');
							//if(curr.value & BLOCK_XREF_FLAG) console.log('  Is xref');
							//if(curr.value & BLOCK_XREF_OVERLAY_FLAG) console.log('  Is xref overlay');
							//if(curr.value & BLOCK_EXTERNALLY_DEPENDENT_FLAG) console.log('  Is externally dependent');
							//if(curr.value & BLOCK_RESOLVED_OR_DEPENDENT_FLAG) console.log('  Is resolved xref or dependent of an xref');
							//if(curr.value & BLOCK_REFERENCED_XREF) console.log('  This definition is a referenced xref');
							block.type = curr.value as number;
						}
						curr = scanner.next();
						break;
					case 100:
						// ignore class markers
						curr = scanner.next();
						break;
					case 330:
						block.ownerHandle = curr.value as string;
						curr = scanner.next();
						break;
					case 0:
						if (curr.value == 'ENDBLK')
							break;
						block.entities = parseEntities(true);
						break;
					default:
						logUnhandledGroup(curr);
						curr = scanner.next();
				}

				if (groupIs(curr, 0, 'ENDBLK')) {
					curr = scanner.next();
					break;
				}
			}
			return block;
		}

		/**
		 * parseTables
		 * @return {Object} Object representing tables
		 */
		function parseTables() {
			const tables = {} as ITables;
			curr = scanner.next();
			while (curr.value !== 'EOF') {
				if (groupIs(curr, 0, 'ENDSEC'))
					break;

				if (groupIs(curr, 0, 'TABLE')) {
					curr = scanner.next();

					const tableDefinition = tableDefinitions[curr.value as keyof ITableDefinitions];
					if (tableDefinition) {
						log.debug(curr.value + ' Table {');
						tables[tableDefinitions[curr.value as keyof ITableDefinitions].tableName] = parseTable(curr);
						log.debug('}');
					} else {
						log.debug('Unhandled Table ' + curr.value);
					}
				} else {
					// else ignored
					curr = scanner.next();
				}
			}

			curr = scanner.next();
			return tables;
		}

		const END_OF_TABLE_VALUE = 'ENDTAB';

		function parseTable<T extends IBaseTable = ITable>(group: IGroup) {
			const tableDefinition = tableDefinitions[group.value as keyof ITableDefinitions];
			const table = {} as T;
			let expectedCount = 0;

			curr = scanner.next();
			while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {

				switch (curr.code) {
					case 5:
						table.handle = curr.value as string;
						curr = scanner.next();
						break;
					case 330:
						table.ownerHandle = curr.value as string;
						curr = scanner.next();
						break;
					case 100:
						if (curr.value === 'AcDbSymbolTable') {
							// ignore
							curr = scanner.next();
						} else {
							logUnhandledGroup(curr);
							curr = scanner.next();
						}
						break;
					case 70:
						expectedCount = curr.value as number;
						curr = scanner.next();
						break;
					case 0:
						if (curr.value === tableDefinition.dxfSymbolName) {
							table[tableDefinition.tableRecordsProperty] = tableDefinition.parseTableRecords();
						} else {
							logUnhandledGroup(curr);
							curr = scanner.next();
						}
						break;
					default:
						logUnhandledGroup(curr);
						console.log(curr);
						curr = scanner.next();
				}
			}
			const tableRecords = table[tableDefinition.tableRecordsProperty];
			if (tableRecords) {
				let actualCount = (() => {
					if (tableRecords.constructor === Array) {
						return tableRecords.length;
					} else if (typeof (tableRecords) === 'object') {
						return Object.keys(tableRecords).length;
					}
					return undefined;
				})();
				if (expectedCount !== actualCount) console.log('Parsed ' + actualCount + ' ' + tableDefinition.dxfSymbolName + '\'s but expected ' + expectedCount);
			}
			curr = scanner.next();
			return table;
		}

		function parseViewPortRecords() {
			const viewPorts = [] as IViewPort[]; // Multiple table entries may have the same name indicating a multiple viewport configuration
			let viewPort = {} as IViewPort;

			log.debug('ViewPort {');
			curr = scanner.next();
			while (!groupIs(curr, 0, END_OF_TABLE_VALUE)) {

				switch (curr.code) {
					case 2: // layer name
						viewPort.name = curr.value as string;
						curr = scanner.next();
						break;
					case 10:
						viewPort.lowerLeftCorner = parsePoint(curr);
						curr = scanner.next();
						break;
					case 11:
						viewPort.upperRightCorner = parsePoint(curr);
						curr = scanner.next();
						break;
					case 12:
						viewPort.center = parsePoint(curr);
						curr = scanner.next();
						break;
					case 13:
						viewPort.snapBasePoint = parsePoint(curr);
						curr = scanner.next();
						break;
					case 14:
						viewPort.snapSpacing = parsePoint(curr);
						curr = scanner.next();
						break;
					case 15:
						viewPort.gridSpacing = parsePoint(curr);
						curr = scanner.next();
						break;
					case 16:
						viewPort.viewDirectionFromTarget = parsePoint(curr);
						curr = scanner.next();
						break;
					case 17:
						viewPort.viewTarget = parsePoint(curr);
						curr = scanner.next();
						break;
					case 42:
						viewPort.lensLength = curr.value as number;
						curr = scanner.next();
						break;
					case 43:
						viewPort.frontClippingPlane = curr.value;
						curr = scanner.next();
						break;
					case 44:
						viewPort.backClippingPlane = curr.value;
						curr = scanner.next();
						break;
					case 45:
						viewPort.viewHeight = curr.value as number;
						curr = scanner.next();
						break;
					case 50:
						viewPort.snapRotationAngle = curr.value as number;
						curr = scanner.next();
						break;
					case 51:
						viewPort.viewTwistAngle = curr.value as number;
						curr = scanner.next();
						break;
					case 79:
						viewPort.orthographicType = curr.value as string;
						curr = scanner.next();
						break;
					case 110:
						viewPort.ucsOrigin = parsePoint(curr);
						curr = scanner.next();
						break;
					case 111:
						viewPort.ucsXAxis = parsePoint(curr);
						curr = scanner.next();
						break;
					case 112:
						viewPort.ucsYAxis = parsePoint(curr);
						curr = scanner.next();
						break;
					case 110:
						viewPort.ucsOrigin = parsePoint(curr);
						curr = scanner.next();
						break;
					case 281:
						viewPort.renderMode = curr.value as string;
						curr = scanner.next();
						break;
					case 281:
						// 0 is one distant light, 1 is two distant lights
						viewPort.defaultLightingType = curr.value as string;
						curr = scanner.next();
						break;
					case 292:
						viewPort.defaultLightingOn = curr.value as string;
						curr = scanner.next();
						break;
					case 330:
						viewPort.ownerHandle = curr.value as string;
						curr = scanner.next();
						break;
					case 63: // These are all ambient color. Perhaps should be a gradient when multiple are set.
					case 421:
					case 431:
						viewPort.ambientColor = curr.value as number;
						curr = scanner.next();
						break;
					case 0:
						// New ViewPort
						if (curr.value === 'VPORT') {
							log.debug('}');
							viewPorts.push(viewPort);
							log.debug('ViewPort {');
							viewPort = {} as IViewPort;
							curr = scanner.next();
						}
						break;
					default:
						logUnhandledGroup(curr);
						curr = scanner.next();
						break;
				}
			}
			// Note: do not call scanner.next() here,
			//  parseTable() needs the current group
			log.debug('}');
			viewPorts.push(viewPort);

			return viewPorts;
		}

		function parseLineTypes() {
			const ltypes = {} as Record<string, ILineType>;
			let ltype = {} as ILineType;
			let length = 0;
			let ltypeName: string;

			log.debug('LType {');
			curr = scanner.next();
			while (!groupIs(curr, 0, 'ENDTAB')) {

				switch (curr.code) {
					case 2:
						ltype.name = curr.value as string;
						ltypeName = curr.value as string;
						curr = scanner.next();
						break;
					case 3:
						ltype.description = curr.value as string;
						curr = scanner.next();
						break;
					case 73: // Number of elements for this line type (dots, dashes, spaces);
						length = curr.value as number;
						if (length > 0) ltype.pattern = [];
						curr = scanner.next();
						break;
					case 40: // total pattern length
						ltype.patternLength = curr.value as number;
						curr = scanner.next();
						break;
					case 49:
						ltype.pattern.push(curr.value as string);
						curr = scanner.next();
						break;
					case 0:
						log.debug('}');
						if (length > 0 && length !== ltype.pattern.length) log.warn('lengths do not match on LTYPE pattern');
						ltypes[ltypeName!] = ltype;
						ltype = {} as ILineType;
						log.debug('LType {');
						curr = scanner.next();
						break;
					default:
						curr = scanner.next();
				}
			}

			log.debug('}');
			ltypes[ltypeName!] = ltype;
			return ltypes;
		}

		function parseLayers() {
			const layers = {} as Record<string, ILayer>;
			let layer = {} as ILayer;
			let layerName: string | undefined;

			log.debug('Layer {');
			curr = scanner.next();
			while (!groupIs(curr, 0, 'ENDTAB')) {

				switch (curr.code) {
					case 2: // layer name
						layer.name = curr.value as string;
						layerName = curr.value as string;
						curr = scanner.next();
						break;
					case 62: // color, visibility
						layer.visible = curr.value >= 0;
						// TODO 0 and 256 are BYBLOCK and BYLAYER respectively. Need to handle these values for layers?.
						layer.colorIndex = Math.abs(curr.value as number);
						layer.color = getAcadColor(layer.colorIndex as number);
						curr = scanner.next();
						break;
					case 70: // frozen layer
						layer.frozen = (((curr.value as number) & 1) != 0 || ((curr.value as number) & 2) != 0);
						curr = scanner.next();
						break;
					case 0:
						// New Layer
						if (curr.value === 'LAYER') {
							log.debug('}');
							layers[layerName!] = layer;
							log.debug('Layer {');
							layer = {} as ILayer;
							layerName = undefined;
							curr = scanner.next();
						}
						break;
					default:
						logUnhandledGroup(curr);
						curr = scanner.next();
						break;
				}
			}
			// Note: do not call scanner.next() here,
			//  parseLayerTable() needs the current group
			log.debug('}');
			layers[layerName!] = layer;

			return layers;
		}

		const tableDefinitions = {
			VPORT: {
				tableRecordsProperty: 'viewPorts',
				tableName: 'viewPort',
				dxfSymbolName: 'VPORT',
				parseTableRecords: parseViewPortRecords
			},
			LTYPE: {
				tableRecordsProperty: 'lineTypes',
				tableName: 'lineType',
				dxfSymbolName: 'LTYPE',
				parseTableRecords: parseLineTypes
			},
			LAYER: {
				tableRecordsProperty: 'layers',
				tableName: 'layer',
				dxfSymbolName: 'LAYER',
				parseTableRecords: parseLayers
			}
		} as ITableDefinitions;

		/**
		 * Is called after the parser first reads the 0:ENTITIES group. The scanner
		 * should be on the start of the first entity already.
		 * @return {Array} the resulting entities
		 */
		function parseEntities(forBlock: boolean) {
			const entities = [] as IEntity[];

			const endingOnValue = forBlock ? 'ENDBLK' : 'ENDSEC';

			if (!forBlock) {
				curr = scanner.next();
			}
			while (true) {

				if (curr.code === 0) {
					if (curr.value === endingOnValue) {
						break;
					}

					const handler = self._entityHandlers[curr.value as EntityName];
					if (handler != null) {
						log.debug(curr.value + ' {');
						const entity = handler.parseEntity(scanner, curr);
						curr = scanner.lastReadGroup!;
						log.debug('}');
						ensureHandle(entity);
						//Only fetch the Attributes Def
						if(forBlock && entity.type == "ATTDEF"){
							entities.push(entity);
						}

						if(!forBlock){
							entities.push(entity);
						}
					} else {
						// log.warn('Unhandled entity ' + curr.value);
						curr = scanner.next();
						continue;
					}
				} else {
					// ignored lines from unsupported entity
					curr = scanner.next();
				}
			}
			if (endingOnValue == 'ENDSEC') curr = scanner.next(); // swallow up ENDSEC, but not ENDBLK
			return entities;
		}

		/**
		 * Parses a 2D or 3D point, returning it as an object with x, y, and
		 * (sometimes) z property if it is 3D. It is assumed the current group
		 * is x of the point being read in, and scanner.next() will return the
		 * y. The parser will determine if there is a z point automatically.
		 * @return {Object} The 2D or 3D point as an object with x, y[, z]
		 */
		function parsePoint(curr: IGroup) {
			const point = {} as IPoint;
			let code = curr.code;

			point.x = curr.value as number;

			code += 10;
			curr = scanner.next();
			if (curr.code != code)
				throw new Error('Expected code for point value to be ' + code +
					' but got ' + curr.code + '.');
			point.y = curr.value as number;

			code += 10;
			curr = scanner.next();
			if (curr.code != code) {
				scanner.rewind();
				return point;
			}
			point.z = curr.value as number;

			return point;
		}

		function ensureHandle(entity: IEntity | IBlock) {
			if (!entity) throw new TypeError('entity cannot be undefined or null');

			if (!entity.handle) entity.handle = lastHandle++;
		}

		parseAll();
		return dxf;
	}

  private _calculateDistance(x: number, y: number, x2: number, y2: number) {
    var a = x - x2;
    var b = y - y2;
    
    var c = Math.sqrt( a*a + b*b );
    return c;
  }
	public getTasks(source: any,  entitiesIds: any) {
		let sourceJSON: any = null;
		let idsJSON = null;
		try {
			idsJSON = JSON.parse(entitiesIds);
		} catch (error) {
			console.log(error);
			idsJSON = entitiesIds;
		}
    try {
			sourceJSON = JSON.parse(source);
		} catch (error) {
			console.log(error);
			sourceJSON = source;
		}

    let objects:any[] = [];
		idsJSON.data.objects.forEach((model:any) => {
			model.objects.forEach((itemBlock:any) => {
				itemBlock.objects.forEach((item:any) => {
					if(item.objects && item.objects.length > 0){
						item.objects.forEach((item2:any) => {
							objects.push({...item2,type: itemBlock.name});
						});
					}else{
						objects.push({...item,type: itemBlock.name});
					}
				});
			});
		});
		

    let hldLayers: any = [];
    let vfyLayers: any = [];
    let elcLayers: any = [];
    let rfiLayers: any = [];
    let dimensions: any = [];
    let elcdimensions: any = [];
    sourceJSON.entities.forEach((block: any) => {
      if(block.layer.indexOf('-ELC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers.push(block);
        }else {
          elcdimensions.push(block);
        }
      }
      if(block.layer.indexOf('-ELEC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers.push(block);
        }

      }
      if(block.layer.indexOf('-RFI') >= 0){
        rfiLayers.push(block);
      }
      if(block.layer.indexOf('-VFY') >= 0){
        vfyLayers.push(block);
      }
      if(block.layer.indexOf('-HLD') >= 0){
        hldLayers.push(block);
      }
      if(block.type === 'DIMENSION'){
        if(block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1){
          dimensions.push(block);
        }
      }
    });
    

    rfiLayers = rfiLayers.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});

    elcLayers = elcLayers.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});

    vfyLayers = vfyLayers.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    hldLayers = hldLayers.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});


    dimensions = dimensions.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    elcdimensions = elcdimensions.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    const elcUpdatedDimensions: any = [];
    elcdimensions.forEach((dimension: any) => {
      let entityPoint1 = null
      let entityPoint2 = null
      sourceJSON.entities.forEach((elc: any) => {
        if(elc.type === 'INSERT'){
          let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
          let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
          console.log(distancePoint1, distancePoint2);
          if(distancePoint1 <= 1){
            entityPoint1 = elc;
          }
          if(distancePoint2 <= 1){
            entityPoint2 = elc;
          }
        }
      });
      elcUpdatedDimensions.push({
        dimension,
        entityPoint1,
        entityPoint2
      });

    });


    elcLayers.forEach((elc: any) => {
      let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.handle);
      let distance = 10000000;
      let dimensionSelected: any[] = [];
      dimensions.forEach((dimension: any) => { 
        let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
        let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
        let newDistance = distancePoint1;
        if(newDistance > distancePoint2){
          newDistance = distancePoint2;
        }

        if(distance > newDistance){
          distance = newDistance;
        }
        if(newDistance <= 1){
          dimensionSelected.push({...dimension, distance: newDistance});
        }
      });
      
      elcLayers[elcIndex] = {
        ...elc,
        dimensions: dimensionSelected
      }
    });

    elcUpdatedDimensions.forEach((elc: any) => {
      if(elc.entityPoint1){
        let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.entityPoint1.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers[elcIndex] = {...elcLayers[elcIndex],dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers.push({
            ...elc.entityPoint1,
            dimensions: [elc.dimension]
          });
        }
      }
      if(elc.entityPoint2){
        let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.entityPoint2.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers[elcIndex] = {...elcLayers[elcIndex],dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers.push({
            ...elc.entityPoint2,
            dimensions: [elc.dimension]
          });
        }
      }
    });

    return {
      hld: hldLayers,
      rfi: rfiLayers,
      vfy: vfyLayers,
      elc: elcLayers,
    }
	}

  public getDXFDiff2(source: any, source2: any, entitiesIds: any) {
    let sourceJSON: any = {};
    let source2JSON: any = {};
		let idsJSON = [];
		try {
			idsJSON = JSON.parse(entitiesIds);
		} catch (error) {
			console.log(error);
			idsJSON = entitiesIds;
		}

		try {
			sourceJSON = JSON.parse(source);
		} catch (error) {
			console.log(error);
			sourceJSON = source;
		}
    try {
			source2JSON = JSON.parse(source2);
		} catch (error) {
			console.log(error);
			source2JSON = source2;
		}

		let objects:any[] = [];
		idsJSON.data.objects.forEach((model:any) => {
			model.objects.forEach((itemBlock:any) => {
				itemBlock.objects.forEach((item:any) => {
					if(item.objects && item.objects.length > 0){
						item.objects.forEach((item2:any) => {
							objects.push({...item2,type: itemBlock.name});
						});
					}else{
						objects.push({...item,type: itemBlock.name});
					}
				});
			});
		});

    let hldLayers: any = [];
    let vfyLayers: any = [];
    let elcLayers: any = [];
    let rfiLayers: any = [];
    let dimensions: any = [];
    let elcdimensions: any = [];
    sourceJSON.entities.forEach((block: any) => {
      if(block.layer.indexOf('-ELC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers.push(block);
        }else {
          elcdimensions.push(block);
        }
      }
      if(block.layer.indexOf('-ELEC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers.push(block);
        }
      }
      if(block.layer.indexOf('-RFI') >= 0){
        rfiLayers.push(block);
      }
      if(block.layer.indexOf('-VFY') >= 0){
        vfyLayers.push(block);
      }
      if(block.layer.indexOf('-HLD') >= 0){
        hldLayers.push(block);
      }
      if(block.type === 'DIMENSION'){
        if(block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1){
          dimensions.push(block);
        }
      }
    });

    rfiLayers = rfiLayers.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});


    elcLayers = elcLayers.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});

    vfyLayers = vfyLayers.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    hldLayers = hldLayers.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    dimensions = dimensions.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    elcdimensions = elcdimensions.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    const elcUpdatedDimensions: any = [];
    elcdimensions.forEach((dimension: any) => {
      let entityPoint1 = null
      let entityPoint2 = null
      sourceJSON.entities.forEach((elc: any) => {
        if(elc.type === 'INSERT'){
          let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
          let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
          console.log(distancePoint1, distancePoint2);
          if(distancePoint1 <= 1){
            entityPoint1 = elc;
          }
          if(distancePoint2 <= 1){
            entityPoint2 = elc;
          }
        }
      });
      elcUpdatedDimensions.push({
        dimension,
        entityPoint1,
        entityPoint2
      });

    });

    elcLayers.forEach((elc: any) => {
      let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.handle);
      let distance = 10000000;
      let dimensionSelected: any[] = [];
      dimensions.forEach((dimension: any) => { 
        let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
        let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
        let newDistance = distancePoint1;
        if(newDistance > distancePoint2){
          newDistance = distancePoint2;
        }

        if(distance > newDistance){
          distance = newDistance;
        }
        if(newDistance <= 1){
          dimensionSelected.push({...dimension, distance: newDistance});
        }
      });
      
      elcLayers[elcIndex] = {
        ...elc,
        dimensions: dimensionSelected
      }
    });

    elcUpdatedDimensions.forEach((elc: any) => {
      if(elc.entityPoint1){
        let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.entityPoint1.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers[elcIndex] = {...elcLayers[elcIndex],dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers.push({
            ...elc.entityPoint1,
            dimensions: [elc.dimension]
          });
        }
      }
      if(elc.entityPoint2){
        let elcIndex = elcLayers.findIndex((item: any) => item.handle === elc.entityPoint2.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers[elcIndex] = {...elcLayers[elcIndex],dimensions: [...elcLayers[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers.push({
            ...elc.entityPoint2,
            dimensions: [elc.dimension]
          });
        }
      }
    });

    let hldLayers2: any = [];
    let vfyLayers2: any = [];
    let elcLayers2: any = [];
    let rfiLayers2: any = [];
    let dimensions2: any = [];
    let elcdimensions2: any = [];
    source2JSON.entities.forEach((block: any) => {
      if(block.layer.indexOf('-ELC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers2.push(block);
        }else {
          elcdimensions2.push(block);
        }
      }
      if(block.layer.indexOf('-ELEC') >= 0){
        if(block.type !== 'DIMENSION'){
          elcLayers2.push(block);
        }
      }
      if(block.layer.indexOf('-RFI') >= 0){
        rfiLayers2.push(block);
      }
      if(block.layer.indexOf('-VFY') >= 0){
        vfyLayers2.push(block);
      }
      if(block.layer.indexOf('-HLD') >= 0){
        hldLayers2.push(block);
      }
      if(block.type === 'DIMENSION'){
        if(block.layer.indexOf('-VFY') == -1 && block.layer.indexOf('-HLD') == -1){
          dimensions2.push(block);
        }
      }
    });

    rfiLayers2 = rfiLayers2.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `Multi-leader [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});


    elcLayers2 = elcLayers2.map((item: any) => {
			let entity = objects.find(itemVal => itemVal.name == `${item.name} [${item.handle}]`);
			if(entity){
				return {...item, entity_name: entity.name, dbId: entity.objectid, blockType: entity.type}
			}
			return item;
		});

    vfyLayers2 = vfyLayers2.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    hldLayers2 = hldLayers2.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    dimensions2 = dimensions2.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    elcdimensions2 = elcdimensions2.map((item: any) => {
			let linearEntity = objects.find(itemVal => itemVal.name == `Linear [${item.handle}]`);
			if(linearEntity){
				return {...item, entity_name: 'dimension', dbId: linearEntity.objectid, blockType: linearEntity.type}
			}
			return item;
		});

    const elcUpdatedDimensions2: any = [];
    elcdimensions2.forEach((dimension: any) => {
      let entityPoint1 = null
      let entityPoint2 = null
      sourceJSON.entities.forEach((elc: any) => {
        if(elc.type === 'INSERT'){
          let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
          let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
          console.log(distancePoint1, distancePoint2);
          if(distancePoint1 <= 1){
            entityPoint1 = elc;
          }
          if(distancePoint2 <= 1){
            entityPoint2 = elc;
          }
        }
      });
      elcUpdatedDimensions2.push({
        dimension,
        entityPoint1,
        entityPoint2
      });

    });

    elcLayers2.forEach((elc: any) => {
      let elcIndex = elcLayers2.findIndex((item: any) => item.handle === elc.handle);
      let distance = 10000000;
      let dimensionSelected: any[] = [];
      dimensions.forEach((dimension: any) => { 
        let distancePoint1 = this._calculateDistance(dimension.linearOrAngularPoint1.x, dimension.linearOrAngularPoint1.y, elc.position.x, elc.position.y);
        let distancePoint2 = this._calculateDistance(dimension.linearOrAngularPoint2.x, dimension.linearOrAngularPoint2.y, elc.position.x, elc.position.y);
        let newDistance = distancePoint1;
        if(newDistance > distancePoint2){
          newDistance = distancePoint2;
        }

        if(distance > newDistance){
          distance = newDistance;
        }
        if(newDistance <= 1){
          dimensionSelected.push({...dimension, distance: newDistance});
        }
      });
      
      elcLayers2[elcIndex] = {
        ...elc,
        dimensions: dimensionSelected
      }
    });

    elcUpdatedDimensions2.forEach((elc: any) => {
      if(elc.entityPoint1){
        let elcIndex = elcLayers2.findIndex((item: any) => item.handle === elc.entityPoint1.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers2[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers2[elcIndex] = {...elcLayers2[elcIndex],dimensions: [...elcLayers2[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers.push({
            ...elc.entityPoint1,
            dimensions: [elc.dimension]
          });
        }
      }
      if(elc.entityPoint2){
        let elcIndex = elcLayers2.findIndex((item: any) => item.handle === elc.entityPoint2.handle);
        if(elcIndex >= 0){
          let dimIndex = elcLayers2[elcIndex].dimensions.findIndex((item: any) => item.handle === elc.dimension.handle);
          if(dimIndex === -1){
            elcLayers2[elcIndex] = {...elcLayers2[elcIndex],dimensions: [...elcLayers2[elcIndex].dimensions, elc.dimension]}
          }
        }else {
          elcLayers2.push({
            ...elc.entityPoint2,
            dimensions: [elc.dimension]
          });
        }
      }
    });



    const returnArray1 = {
      hld: hldLayers,
      rfi: rfiLayers,
      vfy: vfyLayers,
      elc: elcLayers,
      dimensions: dimensions,
    }
    const returnArray2 = {
      hld: hldLayers2,
      rfi: rfiLayers2,
      vfy: vfyLayers2,
      elc: elcLayers2,
      dimensions: dimensions2,
    }


    return {
      hld: this.getComaprison(returnArray1.hld,returnArray2.hld),
      elc: this.getComaprison(returnArray1.elc,returnArray2.elc),
      vfy: this.getComaprison(returnArray1.vfy,returnArray2.vfy),
      rfi: this.getComaprison(returnArray1.rfi,returnArray2.rfi),
      dimensions: this.getComaprison(returnArray1.dimensions,returnArray2.dimensions),
    }
  }

  private getComaprison(array1: any[], array2: any[]) {
    const removed: any[] = [];
    const added: any = [];
    const modified: any = [];
    
    forEach(array2, (item: any) => {
      if(findIndex(array1, {handle: item.handle}) == -1 ){
        added.push(item);
      }
    });
    
    forEach(array1, entityOriginal=> {
      let index = findIndex(array2, {handle: entityOriginal.handle});
      if(index >= 0 ){
        if(array2[index].type !== 'DIMENSION'){
          if(!isEqual(entityOriginal.position,array2[index].position)){
            let oldPosition = {
              x: ceil(entityOriginal.position.x, 10),
              y: ceil(entityOriginal.position.y, 10)
            }
            let newPosition = {
              x: ceil(array2[index].position.x, 10),
              y: ceil(array2[index].position.y, 10)
            }
            if(!isEqual(oldPosition,newPosition)){
              modified.push({...entityOriginal, newPosition: array2[index].position, type: 'change_position'});
            }
          }
          if(entityOriginal.rotation !== array2[index].rotation){
            modified.push({entityOriginal, newRotation: array2[index].rotation, type: 'change_rotation'});
          }
        
          if(array2[index].dimensions && array2[index].dimensions.lenght > 0){
            let dimensionChanges = this.getComaprison(array1[index].dimensions, array2[index].dimensions);
            if(dimensionChanges.added.length > 0){
              modified.push({entityOriginal, addedDimension: dimensionChanges.added, type: 'add_dimension'});
            }
            if(dimensionChanges.removed.length > 0){
              modified.push({entityOriginal, removedDimension: dimensionChanges.removed, type: 'removed_dimension'});
            }
            if(dimensionChanges.modified.length > 0){
              modified.push({entityOriginal, modifiedDimension: dimensionChanges.modified, type: 'modified_dimension'});
            }
          }
        }else {
          if(!isEqual(entityOriginal.linearOrAngularPoint1,array2[index].linearOrAngularPoint1)){
            let oldPosition = {
              x: ceil(entityOriginal.linearOrAngularPoint1.x, 10),
              y: ceil(entityOriginal.linearOrAngularPoint1.y, 10)
            }
            let newPosition = {
              x: ceil(array2[index].linearOrAngularPoint1.x, 10),
              y: ceil(array2[index].linearOrAngularPoint1.y, 10)
            }
            if(!isEqual(oldPosition,newPosition)){
              modified.push({...entityOriginal, newPoint1: array2[index].linearOrAngularPoint1, type: 'change_position'});
            }
          }
          if(!isEqual(entityOriginal.linearOrAngularPoint2,array2[index].linearOrAngularPoint2)){
            let oldPosition = {
              x: ceil(entityOriginal.linearOrAngularPoint2.x, 10),
              y: ceil(entityOriginal.linearOrAngularPoint2.y, 10)
            }
            let newPosition = {
              x: ceil(array2[index].linearOrAngularPoint2.x, 10),
              y: ceil(array2[index].linearOrAngularPoint2.y, 10)
            }
            if(!isEqual(oldPosition,newPosition)){
              modified.push({...entityOriginal, newPoint2: array2[index].linearOrAngularPoint2, type: 'change_position'});
            }
          }
          if(!isEqual(entityOriginal.actualMeasurement,array2[index].actualMeasurement)){
            let oldMeasuremnt = ceil(entityOriginal.actualMeasurement, 10);
            let newMeasuremnt = ceil(array2[index].actualMeasurement, 10)
            if(!isEqual(oldMeasuremnt,newMeasuremnt)){
              modified.push({...entityOriginal, newMeasuremnt: array2[index].actualMeasurement, type: 'change_measurement'});
            }
          }
        }
      }else{
        removed.push(entityOriginal);
      }
    });

    return {
      removed,
      added,
      modified,
    };
  }

  public cleanDxf(source: string) {
    if (typeof source === 'string') {
      let dxfData = this._parse(source);
      const blocks:string[] = [];
      forEach(dxfData.fullblocks, (item) => {
        if(item.type >= 3){
          if(item.name[0] === '*'){
            blocks.push(item.name);
          }
        }
      });
	  const dxfLinesArray = source.split(/\r\n|\r|\n/g);
      let dxfStr = '';
      let entity = ''
      for(var i=0; i< dxfLinesArray.length; i++){
        let lineVal = dxfLinesArray[i];
        let indexVal = findIndex(blocks, (item)=>item == dxfLinesArray[i]);
        if(indexVal >= 0){
			entity = lineVal;
			console.log(lineVal);
			lineVal = lineVal.substring(1);
        }
        
        if(i > 2){
          let prevVal = dxfLinesArray[i - 1];
          let entityVal = dxfLinesArray[i - 2];
          let block = dxfLinesArray[i - 4];

          if(prevVal.trim() === '70' && entityVal === entity && block == 'AcDbBlockBegin'){
            console.log('Hail Lord', entity);
            lineVal = replace(lineVal, '3', '2');
          }
        }
        dxfStr = dxfStr + lineVal +'\r\n';
      }

      return dxfStr;
    } else {
      console.error('Cannot read dxf source of type `' + typeof (source));
      return null;
    }
  }

  
}



function groupIs(group: IGroup, code: number, value: string | number | boolean) {
	return group.code === code && group.value === value;
}

function logUnhandledGroup(curr: IGroup) {
	log.debug('unhandled group ' + debugCode(curr));
}


function debugCode(curr: IGroup) {
	return curr.code + ':' + curr.value;
}

/**
 * Returns the truecolor value of the given AutoCad color index value
 * @return {Number} truecolor value as a number
 */
function getAcadColor(index: number) {
	return AUTO_CAD_COLOR_INDEX[index];
}

// const BLOCK_ANONYMOUS_FLAG = 1;
// const BLOCK_NON_CONSTANT_FLAG = 2;
// const BLOCK_XREF_FLAG = 4;
// const BLOCK_XREF_OVERLAY_FLAG = 8;
// const BLOCK_EXTERNALLY_DEPENDENT_FLAG = 16;
// const BLOCK_RESOLVED_OR_DEPENDENT_FLAG = 32;
// const BLOCK_REFERENCED_XREF = 64;


/* Notes */
// Code 6 of an entity indicates inheritance of properties (eg. color).
//   BYBLOCK means inherits from block
//   BYLAYER (default) mean inherits from layer
